{
    "cpp": {
        "python": [
            "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # for (int i = 0; i < numbers.size(); i++) {\n    for i in range(len(numbers)):\n        # for (int j = i + 1; j < numbers.size(); j++) {\n        for j in range(i + 1, len(numbers)):\n            # if (abs(numbers[i] - numbers[j]) < threshold) {\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true;\n                return True\n    # return false;\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # vector<string> groups;\n    groups = []\n    # vector<char> stk;\n    stk = []\n    # string current_group = \"\";\n    current_group = \"\"\n    # string parens = paren_string;\n    parens = paren_string\n    # erase(parens, ' ');\n    parens = parens.replace(\" \", \"\")\n    # for (char ch : parens) {\n    for ch in parens:\n        # if (ch == '(') {\n        if ch == '(':\n            # stk.push_back(ch);\n            stk.append(ch)\n            # current_group += ch;\n            current_group += ch\n        # } else if (ch == ')') {\n        elif ch == ')':\n            # stk.pop_back();\n            stk.pop()\n            # current_group += ch;\n            current_group += ch\n            # if (stk.empty()) {\n            if not stk:\n                # groups.push_back(current_group);\n                groups.append(current_group)\n                # current_group = \"\";\n                current_group = \"\"\n    # return groups;\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return num - floor(num);\n    return num - int(num)\n",
            "def below_zero(operations: List[int]) -> bool:\n    # int balance = 0;\n    balance = 0\n    # for (int op : operations) {\n    for op in operations:\n        # balance += op;\n        balance += op\n        # if (balance < 0) {\n        if balance < 0:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # double mean = accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();\n    mean = sum(numbers) / len(numbers)\n    # double deviation = accumulate(numbers.begin(), numbers.end(), 0.0, [&](double acc, double x) {\n    #     return acc + abs(x - mean);\n    # });\n    deviation = reduce(lambda acc, x: acc + abs(x - mean), numbers, 0.0)\n    # return deviation / numbers.size();\n    return deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # vector<int> result;\n    result = []\n    # for (int i = 0; i < numbers.size(); i++) {\n    for i in range(len(numbers)):\n        # if (i != 0) {\n        if i != 0:\n            # result.push_back(delimiter);\n            result.append(delimiter)\n        # result.push_back(numbers[i]);\n        result.append(numbers[i])\n    # return result;\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # vector<int> result;\n    result = []\n    # istringstream buf(paren_string);\n    buf = islice(paren_string, 0, None)\n    # vector<string> paren_groups = {istream_iterator<string>(buf), {}};\n    paren_groups = list(buf)\n    # for (const string& group : paren_groups) {\n    for group in paren_groups:\n        # int max_depth = 0;\n        max_depth = 0\n        # int depth = 0;\n        depth = 0\n        # for (char ch : group) {\n        for ch in group:\n            # if (ch == '(') {\n            if ch == '(':\n                # depth += 1;\n                depth += 1\n                # max_depth = max(max_depth, depth);\n                max_depth = max(max_depth, depth)\n            # } else if (ch == ')') {\n            elif ch == ')':\n                # depth -= 1;\n                depth -= 1\n        # result.push_back(max_depth);\n        result.append(max_depth)\n    # return result;\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # vector<string> result;\n    result = []\n    # copy_if(strs.begin(), strs.end(), back_inserter(result), [&](const string& s) {\n    #     return s.find(substring) != string::npos;\n    # });\n    result.extend(filterfalse(lambda s: substring not in s, strs))\n    # return result;\n    return result\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # int n_sum = accumulate(numbers.begin(), numbers.end(), 0);\n    n_sum = reduce(lambda x, y: x + y, numbers)\n    # int n_product = accumulate(numbers.begin(), numbers.end(), 1, multiplies<int>());\n    n_product = reduce(lambda x, y: x * y, numbers, 1)\n    # return {n_sum, n_product};\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # int max_so_far = numeric_limits<int>::min();\n    max_so_far = float('-inf')\n    # vector<int> result;\n    result = []\n    # for (int num : numbers) {\n    for num in numbers:\n        # max_so_far = max(max_so_far, num);\n        max_so_far = max(max_so_far, num)\n        # result.push_back(max_so_far);\n        result.append(max_so_far)\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == string(s.rbegin(), s.rend());\n    return s == s[::-1]\ndef make_palindrome(s: str) -> str:\n    # if (isPalindrome(s)) {\n    if is_palindrome(s):\n        # return s;\n        return s\n    # for (int i = 0; i < s.length(); i++) {\n    for i in range(len(s)):\n        # if (isPalindrome(s.substr(i))) {\n        if is_palindrome(s[i:]):\n            # return s + string(s.rbegin() + 1, s.rbegin() + i + 1);\n            return s + s[i:][::-1]\n    # return \"\";\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # return accumulate(a.begin(), a.end(), string(), [&](string&& res, char c) {\n    #     return move(res += (c == b[res.size()] ? '0' : '1'));\n    # });\n    return ''.join([c if c == b[len(res)] else '1' for res, c in zip(a, b)])\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if (strs.empty()) {\n    if not strs:\n        # return nullopt;\n        return None\n    # string longest_s = strs[0];\n    longest_s = strs[0]\n    # for (const string& s : strs) {\n    for s in strs:\n        # if (s.length() > longest_s.length()) {\n        if len(s) > len(longest_s):\n            # longest_s = s;\n            longest_s = s\n    # return longest_s;\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if (b == 0) {\n    if b == 0:\n        # return a;\n        return a\n    # else {\n    else:\n        # return greatestCommonDivisor(b, a % b);\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # vector<string> prefixes;\n    prefixes = []\n    # for (int i = 0; i < s.length(); i++) {\n    for i in range(len(s)):\n        # prefixes.push_back(s.substr(0, i + 1));\n        prefixes.append(s[:i + 1])\n    # return prefixes;\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # vector<int> a(n + 1);\n    a = [0] * (n + 1)\n    # iota(a.begin(), a.end(), 0);\n    for i in range(n + 1):\n        a[i] = i\n    # return accumulate(a.begin(), a.end(), string(), [](string&& s, int i) {\n    #     return move(s += (s.length() ? \" \" : \"\") + to_string(i));\n    # });\n    return accumulate(a, \"\", lambda s, i: s + (\" \" if s else \"\") + str(i))\n",
            "def count_distinct_characters(s: str) -> int:\n    # unordered_set<char> dc;\n    dc = set()\n    # transform(s.begin(), s.end(), inserter(dc, dc.begin()), ::tolower);\n    for c in s:\n        dc.add(c.lower())\n    # return dc.size();\n    return len(dc)\n",
            "def parse_music(music_string: str) -> List[int]:\n    # unordered_map<string, int> durations = {{\"o\", 4}, {\"o|\", 2}, {\".|\", 1}};\n    durations = defaultdict(int, {\"o\": 4, \"o|\": 2, \".|\": 1})\n    # istringstream buf(music_string);\n    buf = music_string.split()\n    # vector<string> notes = {istream_iterator<string>(buf), {}};\n    notes = [note for note in buf]\n    # vector<int> result;\n    result = []\n    # for (string& note : notes) {\n    for note in notes:\n        # result.push_back(durations[note]);\n        result.append(durations[note])\n    # return result;\n    return result\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # int times = 0;\n    times = 0\n    # for (int i = 0; i + substring.length() <= s.length(); i++) {\n    for i in range(len(s) - len(substring) + 1):\n        # if (s.substr(i, substring.length()) == substring) {\n        #     times += 1;\n        # }\n        if s[i:i + len(substring)] == substring:\n            times += 1\n    # return times;\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # unordered_map<string, int> num_dict = {\n    #     {\"zero\", 0},\n    #     {\"one\", 1},\n    #     {\"two\", 2},\n    #     {\"three\", 3},\n    #     {\"four\", 4},\n    #     {\"five\", 5},\n    #     {\"six\", 6},\n    #     {\"seven\", 7},\n    #     {\"eight\", 8},\n    #     {\"nine\", 9},\n    # };\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    # istringstream buf(numbers);\n    buf = StringIO(numbers)\n    # vector<string> num_list = {istream_iterator<string>(buf), {}};\n    num_list = [x for x in buf]\n    # erase_if(num_list, [&](const string& x) {\n    #     return num_dict.find(x) == num_dict.end();\n    # });\n    num_list = [x for x in num_list if x in num_dict]\n    # sort(num_list.begin(), num_list.end(), [&](const string& a, const string& b) {\n    #     return num_dict[a] < num_dict[b];\n    # });\n    num_list.sort(key=lambda x: num_dict[x])\n    # return accumulate(num_list.begin(), num_list.end(), string(), [](string&& a, const string& b) {\n    #     return move(a += a.empty() ? b : \" \" + b);\n    # });\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[float]) -> List[float]:\n    # vector<double> sorted_numbers(numbers);\n    sorted_numbers = sorted(numbers)\n    # sort(sorted_numbers.begin(), sorted_numbers.end());\n    # double min_diff = numeric_limits<double>::infinity();\n    min_diff = inf\n    # vector<double> closest_pair;\n    closest_pair = []\n    # for (int i = 1; i < sorted_numbers.size(); ++i) {\n    for i in range(1, len(sorted_numbers)):\n        # double diff = sorted_numbers[i] - sorted_numbers[i - 1];\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if (diff < min_diff) {\n        if diff < min_diff:\n            # min_diff = diff;\n            min_diff = diff\n            # closest_pair = {sorted_numbers[i - 1], sorted_numbers[i]};\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return closest_pair;\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # double min_num = *min_element(numbers.begin(), numbers.end());\n    try:\n        min_num = min(numbers)\n    except StatisticsError:\n        return [0.0] * len(numbers)\n    # double max_num = *max_element(numbers.begin(), numbers.end());\n    try:\n        max_num = max(numbers)\n    except StatisticsError:\n        return [0.0] * len(numbers)\n    # if (min_num == max_num) {\n    if min_num == max_num:\n        # return vector<double>(numbers.size(), 0.0);\n        return [0.0] * len(numbers)\n    # else {\n    else:\n        # vector<double> res;\n        res = []\n        # for (double num : numbers) {\n        for num in numbers:\n            # res.push_back((num - min_num) / (max_num - min_num));\n            res.append((num - min_num) / (max_num - min_num))\n        # return res;\n        return res\n",
            "def filter_integers(values: List[Any]) -> List[int]:\n    # vector<int> filtered_values;\n    filtered_values = []\n    # for (const auto& value : values) {\n    for value in values:\n        # try {\n        try:\n            # auto intValue = any_cast<int>(value);\n            intValue = cast(int, value)\n            # filtered_values.push_back(intValue);\n            filtered_values.append(intValue)\n        # } catch (const bad_any_cast&) {\n        except ValueError:\n            # continue;\n            pass\n    # return filtered_values;\n    return filtered_values\n",
            "def str_length(s: str) -> int:\n    # return s.length();\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for (int i = 2; i < n; i++) {\n    for i in range(2, n):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return n / i;\n            return n / i\n    # return 1;\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # vector<int> factors;\n    factors = []\n    # int divisor = 2;\n    divisor = 2\n    # while (divisor <= n) {\n    while divisor <= n:\n        # if (n % divisor == 0) {\n        if n % divisor == 0:\n            # factors.push_back(divisor);\n            factors.append(divisor)\n            # n /= divisor;\n            n //= divisor\n        else:\n            # divisor++;\n            divisor += 1\n    # return factors;\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # unordered_map<int, int> counts;\n    counts = Counter()\n    # for (int num : numbers) {\n    for num in numbers:\n        # counts[num]++;\n        counts[num] += 1\n    # vector<int> res;\n    res = []\n    # copy_if(numbers.begin(), numbers.end(), back_inserter(res), [&](int num) {\n    #     return counts[num] == 1;\n    # });\n    for num in numbers:\n        if counts[num] == 1:\n            res.append(num)\n    # return res;\n    return res\n",
            "def flip_case(s: str) -> str:\n    # string flipped = \"\";\n    flipped = \"\"\n    # for (char ch : s) {\n    for ch in s:\n        # if (!isalpha(ch)) {\n        if not ch.isalpha():\n            # flipped += ch;\n            flipped += ch\n        # } else if (islower(ch)) {\n        elif ch.islower():\n            # flipped += toupper(ch);\n            flipped += ch.upper()\n        # } else if (isupper(ch)) {\n        elif ch.isupper():\n            # flipped += tolower(ch);\n            flipped += ch.lower()\n    # return flipped;\n    return flipped\n",
            "def concatenate(strs: List[str]) -> str:\n    # return accumulate(strs.begin(), strs.end(), string());\n    return reduce(lambda x, y: x + y, strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # vector<string> filtered;\n    filtered = []\n    # copy_if(strs.begin(), strs.end(), back_inserter(filtered), [&](const string& str) {\n    #     return str.starts_with(prefix_str);\n    # });\n    filtered.extend(filterfalse(lambda str: not str.startswith(prefix_str), strs))\n    # return filtered;\n    return filtered\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # vector<int> result;\n    result = []\n    # copy_if(l.begin(), l.end(), back_inserter(result), [](int x) {\n    #     return x > 0;\n    # });\n    result.extend(filterfalse(lambda x: x <= 0, l))\n    # return result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= floor(sqrt(n)); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def poly(xs: List[int], x: float) -> float:\n    # double res = 0;\n    res = 0\n    # for (int i = 0; i < xs.size(); i++) {\n    for i in range(len(xs)):\n        # res += xs[i] * pow(x, i);\n        res += xs[i] * pow(x, i)\n    # return res;\n    return res\ndef find_zero(xs: List[int]) -> float:\n    # double x1 = 1.0, x2 = -1.0;\n    x1 = 1.0\n    x2 = -1.0\n    # while (poly(xs, x1) * poly(xs, x2) > 0) {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2;\n        x1 *= 2\n        # x2 *= 2;\n        x2 *= 2\n    # while (abs(x1 - x2) > 1e-10) {\n    while abs(x1 - x2) > 1e-10:\n        # double mid = (x1 + x2) / 2;\n        mid = (x1 + x2) / 2\n        # if (poly(xs, mid) == 0) {\n        if poly(xs, mid) == 0:\n            # return mid;\n            return mid\n        # else if (poly(xs, mid) * poly(xs, x1) < 0) {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid;\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid;\n            x1 = mid\n    # return (x1 + x2) / 2;\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # vector<int> sorted_third;\n    sorted_third = []\n    # for (int i = 0; i < l.size(); i += 3) {\n    for i in range(0, len(l), 3):\n        # sorted_third.push_back(l[i]);\n        sorted_third.append(l[i])\n    # sort(sorted_third.begin(), sorted_third.end());\n    sorted_third.sort()\n    # vector<int> result;\n    result = []\n    # for (int i = 0; i < l.size(); i++) {\n    for i in range(len(l)):\n        # if (i % 3 == 0) {\n        if i % 3 == 0:\n            # result.push_back(sorted_third[i / 3]);\n            result.append(sorted_third[i // 3])\n        else:\n            # result.push_back(l[i]);\n            result.append(l[i])\n    # return result;\n    return result\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # vector<int> result(l);\n    result = l.copy()\n    # sort(result.begin(), result.end());\n    result.sort()\n    # result.erase(unique(result.begin(), result.end()), result.end());\n    result = list(set(result))\n    # return result;\n    return result\n",
            "def max_element(l: List[int]) -> int:\n    # if (l.empty()) {\n    if not l:\n        # return 0;\n        return 0\n    # return *max_element(l.begin(), l.end());\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # if (i % 11 == 0 || i % 13 == 0) {\n        if i % 11 == 0 or i % 13 == 0:\n            # string str_i = to_string(i);\n            str_i = str(i)\n            # cnt += count(str_i.begin(), str_i.end(), '7');\n            cnt += str_i.count('7')\n    # return cnt;\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # vector<int> sorted_even;\n    sorted_even = []\n    # for (int i = 0; i < l.size(); i += 2) {\n    for i in range(0, len(l), 2):\n        # sorted_even.push_back(l[i]);\n        sorted_even.append(l[i])\n    # sort(sorted_even.begin(), sorted_even.end());\n    sorted_even.sort()\n    # vector<int> result;\n    result = []\n    # for (int i = 0; i < l.size(); i++) {\n    for i in range(len(l)):\n        # if (i % 2 == 0) {\n        if i % 2 == 0:\n            # result.push_back(sorted_even[i / 2]);\n            result.append(sorted_even[i // 2])\n        else:\n            # result.push_back(l[i]);\n            result.append(l[i])\n    # return result;\n    return result\n",
            "def encode_cyclic(s: str) -> str:\n    # string result;\n    result = ''\n    # for (int i = 0; i < s.size(); i += 3) {\n    for i in range(0, len(s), 3):\n        # if (i + 3 > s.size()) {\n        if i + 3 > len(s):\n            # result += s.substr(i);\n            result += s[i:]\n        # } else {\n        else:\n            # result += s.substr(i + 1, 2);\n            # result += s[i];\n            result += s[i + 1:i + 3]\n            result += s[i]\n    # return result;\n    return result\ndef decode_cyclic(s: str) -> str:\n    # return encodeCyclic(encodeCyclic(s));\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= floor(sqrt(n)); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        #     return false;\n        # }\n        if n % i == 0:\n            return False\n    # return true;\n    return True\ndef prime_fib(n: int) -> int:\n    # vector<int> f = {0, 1};\n    f = [0, 1]\n    # int cnt = 0;\n    cnt = 0\n    # while (cnt < n) {\n    while cnt < n:\n        # f = {f[1], f[0] + f[1]};\n        f = [f[1], f[0] + f[1]]\n        # if (isPrime(f[1])) {\n        if is_prime(f[1]):\n            # cnt++;\n            cnt += 1\n    # return f[1];\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for (int i = 0; i < l.size(); i++) {\n    for i in range(len(l)):\n        # for (int j = i + 1; j < l.size(); j++) {\n        for j in range(i + 1, len(l)):\n            # for (int k = j + 1; k < l.size(); k++) {\n            for k in range(j + 1, len(l)):\n                # if (l[i] + l[j] + l[k] == 0) {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true;\n                    return True\n    # return false;\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return pow(n, 2);\n    return n ** 2\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # vector<int> result;\n    result = []\n    # transform(l.begin(), l.end(), back_inserter(result), [](int i) { return i + 1; });\n    result.extend([i + 1 for i in l])\n    # return result;\n    return result\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # unordered_set<int> seen;\n    seen = set()\n    # for (int num : l) {\n    for num in l:\n        # if (seen.count(-num)) {\n        if -num in seen:\n            # return true;\n            return True\n        # seen.insert(num);\n        seen.add(num)\n    # return false;\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if (x == 0) {\n    if x == 0:\n        # return \"0\";\n        return \"0\"\n    # vector<string> digits;\n    digits = []\n    # while (x > 0) {\n    while x > 0:\n        # digits.push_back(to_string(x % bas));\n        digits.append(str(x % bas))\n        # x /= bas;\n        x //= bas\n    # return accumulate(digits.rbegin(), digits.rend(), string());\n    return reduce(lambda a, b: b + a, digits)\n",
            "def triangle_area(a: int, h: int) -> float:\n    # return static_cast<double>(a * h) / 2;\n    return a * h / 2\n",
            "def fib4(n: int) -> int:\n    # vector<int> fib = {0, 0, 2, 0};\n    fib = [0, 0, 2, 0]\n    # for (int i = 4; i <= n; i++) {\n    for i in range(4, n + 1):\n        # fib[i % 4] = accumulate(fib.begin(), fib.end(), 0);\n        fib[i % 4] = reduce(lambda x, y: x + y, fib)\n    # return fib[n % 4];\n    return fib[n % 4]\n",
            "def median(l: List[float]) -> float:\n    # vector<double> sl = l;\n    sl = l\n    # sort(sl.begin(), sl.end());\n    sl.sort()\n    # if (l.size() % 2 != 0) {\n    if len(l) % 2 != 0:\n        # return sl[l.size() / 2];\n        return sl[len(l) // 2]\n    # } else {\n    else:\n        # return (sl[l.size() / 2] + sl[l.size() / 2 - 1]) / 2;\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt == string(txt.rbegin(), txt.rend());\n    return txt == ''.join(reversed(txt))\n",
            "def modp(n: int, p: int) -> int:\n    # int ret = 1;\n    ret = 1\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # ret = (ret * 2) % p;\n        ret = (ret * 2) % p\n    # return ret;\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # string result;\n    result = ''\n    # transform(s.begin(), s.end(), back_inserter(result), [](char ch) {\n    #     return ((ch - 97 + 5) % 26) + 97;\n    # });\n    result = ''.join([chr((ord(ch) - 97 + 5) % 26 + 97) for ch in s])\n    # return result;\n    return result\ndef decode_shift(s: str) -> str:\n    # string result;\n    result = ''\n    # transform(s.begin(), s.end(), back_inserter(result), [](char ch) {\n    #     return ((ch - 97 + 21) % 26) + 97;\n    # });\n    result = ''.join([chr((ord(ch) - 97 + 21) % 26 + 97) for ch in s])\n    # return result;\n    return result\n",
            "def remove_vowels(txt: str) -> str:\n    # string vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # string result;\n    result = \"\"\n    # copy_if(txt.begin(), txt.end(), back_inserter(result), [&vowels](char ch) {\n    #     return vowels.find(ch) == string::npos;\n    # });\n    for ch in txt:\n        if vowels.find(ch) == -1:\n            result += ch\n    # return result;\n    return result\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # return all_of(l.begin(), l.end(), [t](int x) { return x < t; });\n    return all(x < t for x in l)\n",
            "def add(x: int, y: int) -> int:\n    # return x + y;\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # return unordered_set<char>(s0.begin(), s0.end()) == unordered_set<char>(s1.begin(), s1.end());\n    return set(s0) == set(s1)\n",
            "def fib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return n;\n        return n\n    # } else {\n    else:\n        # return fib(n - 1) + fib(n - 2);\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # for (char b : brackets) {\n    for b in brackets:\n        # if (b == '<') {\n        if b == '<':\n            # depth += 1;\n            depth += 1\n        # } else if (b == '>') {\n        elif b == '>':\n            # depth -= 1;\n            depth -= 1\n        # }\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n        # }\n    # return depth == 0;\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # vector<int> diff;\n    # transform(l.begin(), l.end() - 1, l.begin() + 1, back_inserter(diff), [](int x, int y) { return y - x; });\n    diff = list(starmap(lambda x, y: y - x, zip(l, l[1:])))\n    # return all_of(diff.begin(), diff.end(), [](int x) { return x <= 0; }) ||\n    #        all_of(diff.begin(), diff.end(), [](int x) { return x >= 0; });\n    return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # set<int> s1(l1.begin(), l1.end()), s2(l2.begin(), l2.end());\n    s1 = set(l1)\n    s2 = set(l2)\n    # vector<int> result;\n    result = []\n    # set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(result));\n    result.extend(chain(s1, s2))\n    # return result;\n    return result\n",
            "def largest_prime_factor(n: int) -> int:\n    # int i = 2;\n    i = 2\n    # while (i * i <= n) {\n    while i * i <= n:\n        # if (n % i) {\n        #     i += 1;\n        # } else {\n        #     n /= i;\n        # }\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    # return n;\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # int sum = 0;\n    sum = 0\n    # for (int i = 0; i <= n; i++) {\n    for i in range(n + 1):\n        # sum += i;\n        sum += i\n    # return sum;\n    return sum\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # for (char b : brackets) {\n    for b in brackets:\n        # if (b == '(') {\n        #     depth += 1;\n        # } else if (b == ')') {\n        #     depth -= 1;\n        # }\n        if b == '(':\n            depth += 1\n        elif b == ')':\n            depth -= 1\n        # if (depth < 0) {\n        #     return false;\n        # }\n        if depth < 0:\n            return False\n    # return depth == 0;\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # vector<int> result;\n    result = []\n    # for (int i = 1; i < xs.size(); i++) {\n    for i in range(1, len(xs)):\n        # result.push_back(xs[i] * i);\n        result.append(xs[i] * i)\n    # return result;\n    return result\n",
            "def fibfib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return 0;\n        return 0\n    # int a = 0, b = 0, c = 1;\n    a, b, c = 0, 0, 1\n    # while (n > 2) {\n    while n > 2:\n        # tie(a, b, c) = tuple(b, c, a + b + c);\n        a, b, c = b, c, a + b + c\n        # n -= 1;\n        n -= 1\n    # return c;    \n    return c\n",
            "def vowels_count(s: str) -> int:\n    # string vowels = \"aeiou\";\n    vowels = \"aeiou\"\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 0; i < s.size(); i++) {\n    for i in range(len(s)):\n        # if (vowels.find(tolower(s[i])) != string::npos || (i == s.size() - 1 && tolower(s[i]) == 'y')) {\n        if vowels.find(s[i].lower()) != -1 or (i == len(s) - 1 and s[i].lower() == 'y'):\n            # cnt += 1;\n            cnt += 1\n    # return cnt;\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # string x_str = to_string(x);\n    x_str = str(x)\n    # if (shift > x_str.size()) {\n    if shift > len(x_str):\n        # reverse(x_str.begin(), x_str.end());\n        x_str = x_str[::-1]\n        # return x_str;\n        return x_str\n    # } else {\n    #     return x_str.substr(x_str.size() - shift) + x_str.substr(0, x_str.size() - shift);\n    # }\n    return x_str[len(x_str) - shift:] + x_str[:len(x_str) - shift]\n",
            "def digit_sum(s: str) -> int:\n    # return accumulate(s.begin(), s.end(), 0, [](int a, char c) {\n    #     return a + (isupper(c) ? c : 0);\n    # });\n    return reduce(lambda a, c: a + (1 if c.isupper() else 0), s, 0)\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # istringstream buf(s);\n    buf = s.split()\n    # vector<string> words = {istream_iterator<string>(buf), {}};\n    words = list(islice(buf, 0, None))\n    # int apples = stoi(*(find(words.begin(), words.end(), \"apples\") - 1));\n    apples = int(words[words.index(\"apples\") - 1])\n    # int oranges = stoi(*(find(words.begin(), words.end(), \"oranges\") - 1));\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # return n - apples - oranges;    \n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> Optional[Tuple[int, int]]:\n    # vector<int> evens;\n    evens = []\n    # copy_if(arr.begin(), arr.end(), back_inserter(evens), [](int n) {\n    #     return n % 2 == 0;\n    # });\n    for n in arr:\n        if n % 2 == 0:\n            evens.append(n)\n    # if (evens.size() == 0) {\n    if len(evens) == 0:\n        # return {};\n        return None\n    # int minEven = *min_element(evens.begin(), evens.end());\n    minEven = min(evens)\n    # return {minEven, static_cast<int>(find(arr.begin(), arr.end(), minEven) - arr.begin())};\n    return minEven, evens.index(minEven)\n",
            "def search(lst: List[int]) -> int:\n    # unordered_map<int, int> freqs;\n    freqs = Counter()\n    # for (int n : lst) {\n    for n in lst:\n        # freqs[n]++;\n        freqs[n] += 1\n    # vector<int> good_vals;\n    good_vals = []\n    # for (auto& p : freqs) {\n    for p in freqs.items():\n        # if (p.second >= p.first) {\n        #     good_vals.push_back(p.first);\n        # }\n        if p[1] >= p[0]:\n            good_vals.append(p[0])\n    # return good_vals.empty() ? -1 : *max_element(good_vals.begin(), good_vals.end());\n    return -1 if not good_vals else max(good_vals)\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # vector<int> sl = lst;\n    sl = lst[:]\n    # sort(sl.begin(), sl.end());\n    sl.sort()\n    # vector<int> result;\n    result = []\n    # int left = 0, right = sl.size() - 1;\n    left = 0\n    right = len(sl) - 1\n    # while (left <= right) {\n    while left <= right:\n        # result.push_back(sl[left]);\n        result.append(sl[left])\n        # left += 1;\n        left += 1\n        # if (left <= right) {\n        if left <= right:\n            # result.push_back(sl[right]);\n            result.append(sl[right])\n            # right -= 1;\n            right -= 1\n    # return result;\n    return result\n",
            "def triangle_area(a: int, b: int, c: int) -> float:\n    # if (a + b > c && a + c > b && b + c > a) {\n    if a + b > c and a + c > b and b + c > a:\n        # double s = (a + b + c) / 2.0;\n        s = (a + b + c) / 2.0\n        # return sqrt(s * (s - a) * (s - b) * (s - c));\n        return sqrt(s * (s - a) * (s - b) * (s - c))\n    # } else {\n    else:\n        # return -1.0;\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if (q.size() == 0) {\n    if len(q) == 0:\n        # return false;\n        return False\n    # vector<int> idxs(q.size());\n    idxs = list(range(len(q)))\n    # iota(idxs.begin(), idxs.end(), 0);\n    # bool isPalin = all_of(idxs.begin(), idxs.end(), [&](int i) { return q[i] == q[q.size() - i - 1]; });\n    isPalin = all(q[i] == q[len(q) - i - 1] for i in idxs)\n    # int total = accumulate(q.begin(), q.end(), 0);\n    total = sum(q)\n    # return isPalin && total <= w;\n    return isPalin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # int ans = 0;\n    ans = 0\n    # for (int i = 0; i < arr.size() / 2; i++) {\n    for i in range(len(arr) // 2):\n        # if (arr[i] != arr[arr.size() - i - 1]) {\n        #     ans += 1;\n        # }\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    # return ans;\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # int cnt1 = accumulate(lst1.begin(), lst1.end(), 0, [](int acc, const string& s) { return acc + s.length(); });\n    cnt1 = reduce(lambda acc, s: acc + len(s), lst1, 0)\n    # int cnt2 = accumulate(lst2.begin(), lst2.end(), 0, [](int acc, const string& s) { return acc + s.length(); });\n    cnt2 = reduce(lambda acc, s: acc + len(s), lst2, 0)\n    # return cnt1 <= cnt2 ? lst1 : lst2;\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    #     return false;\n    # }\n    if n < 2:\n        return False\n    # for (int i = 2; i <= floor(sqrt(n)); i++) {\n    #     if (n % i == 0) {\n    #         return false;\n    #     }\n    # }\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    # return true;\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 2; i <= a; i++) {\n    #     if (isPrime(i)) {\n    #         while (a % i == 0) {\n    #             cnt++;\n    #             a /= i;\n    #         }\n    #     }\n    # }\n    for i in range(2, a + 1):\n        if is_prime(i):\n            while a % i == 0:\n                cnt += 1\n                a //= i\n    # return cnt == 3;\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return x == n;\n        return x == n\n    # int tmp = 1;\n    tmp = 1\n    # while (tmp < x) {\n    while tmp < x:\n        # tmp *= n;\n        tmp *= n\n    # return tmp == x;\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # a = abs(a);\n    a = abs(a)\n    # int root = round(pow(a, 1.0 / 3));\n    root = round(pow(a, 1.0 / 3))\n    # return root * root * root == a;\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # return count_if(num.begin(), num.end(), [](char c) {\n    #     return string(\"2357BD\").find(c) != string::npos;\n    # });\n    return sum(1 for c in num if c in \"2357BD\")\n",
            "def decimal_to_binary(dec: int) -> str:\n    # string binary = bitset<32>(dec).to_string();\n    binary = BitArray(uint=dec, length=32).bin\n    # binary.erase(0, min(binary.find_first_not_of('0'), binary.size()-1));\n    binary = binary.lstrip('0')\n    # return format(\"db{}db\", binary);\n    return f\"db{binary}db\"\n",
            "def is_happy(s: str) -> bool:\n    # if (s.length() < 3) {\n    if len(s) < 3:\n        # return false;\n        return False\n    # for (int i = 0; i < s.length() - 2; i++) {\n    for i in range(len(s) - 2):\n        # if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # vector<string> result;\n    result = []\n    # for (double grade : grades) {\n    for grade in grades:\n        # if (grade == 4.0) {\n        if grade == 4.0:\n            # result.push_back(\"A+\");\n            result.append(\"A+\")\n        # } else if (grade > 3.7) {\n        elif grade > 3.7:\n            # result.push_back(\"A\");\n            result.append(\"A\")\n        # } else if (grade > 3.3) {\n        elif grade > 3.3:\n            # result.push_back(\"A-\");\n            result.append(\"A-\")\n        # } else if (grade > 3.0) {\n        elif grade > 3.0:\n            # result.push_back(\"B+\");\n            result.append(\"B+\")\n        # } else if (grade > 2.7) {\n        elif grade > 2.7:\n            # result.push_back(\"B\");\n            result.append(\"B\")\n        # } else if (grade > 2.3) {\n        elif grade > 2.3:\n            # result.push_back(\"B-\");\n            result.append(\"B-\")\n        # } else if (grade > 2.0) {\n        elif grade > 2.0:\n            # result.push_back(\"C+\");\n            result.append(\"C+\")\n        # } else if (grade > 1.7) {\n        elif grade > 1.7:\n            # result.push_back(\"C\");\n            result.append(\"C\")\n        # } else if (grade > 1.3) {\n        elif grade > 1.3:\n            # result.push_back(\"C-\");\n            result.append(\"C-\")\n        # } else if (grade > 1.0) {\n        elif grade > 1.0:\n            # result.push_back(\"D+\");\n            result.append(\"D+\")\n        # } else if (grade > 0.7) {\n        elif grade > 0.7:\n            # result.push_back(\"D\");\n            result.append(\"D\")\n        # } else if (grade > 0.0) {\n        elif grade > 0.0:\n            # result.push_back(\"D-\");\n            result.append(\"D-\")\n        # } else {\n        else:\n            # result.push_back(\"E\");\n            result.append(\"E\")\n    # return result;\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # int length = s.length();\n    length = len(s)\n    # if (length < 2) {\n    if length < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= floor(sqrt(length)); i++) {\n    for i in range(2, floor(sqrt(length)) + 1):\n        # if (length % i == 0) {\n        #     return false;\n        # }\n        if length % i == 0:\n            return False\n    # return true;\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if (n == 1) {\n    if n == 1:\n        # return 1;\n        return 1\n    # return 2 * 9 * pow(10, n - 2);\n    return 2 * 9 * pow(10, n - 2)\n",
            "def solve(n: int) -> str:\n    # string n_str = to_string(n);\n    n_str = str(n)\n    # int digits_sum = accumulate(n_str.begin(), n_str.end(), 0, [](int acc, char d) {\n    #     return acc + stoi(string(1,d));\n    # });\n    digits_sum = reduce(lambda acc, d: acc + int(d), n_str, 0)\n    # string binary = bitset<32>(digits_sum).to_string();\n    binary = bin(digits_sum)[2:]\n    # binary.erase(0, min(binary.find_first_not_of('0'), binary.size()-1));\n    binary = binary.lstrip('0')\n    # return binary;\n    return binary\n",
            "def add(lst: List[int]) -> int:\n    # int result = 0;\n    result = 0\n    # for (int i = 0; i < lst.size(); i++) {\n    for i in range(len(lst)):\n        # if (i % 2 == 1 && lst[i] % 2 == 0) {\n        if i % 2 == 1 and lst[i] % 2 == 0:\n            # result += lst[i];\n            result += lst[i]\n    # return result;\n    return result\n",
            "def anti_shuffle(s: str) -> str:\n    # istringstream buf(s);\n    buf = StringIO(s)\n    # vector<string> words(istream_iterator<string>(buf), {});\n    words = list(map(str.strip, buf.readlines()))\n    # for_each(words.begin(), words.end(), [](string& word) {\n    #     sort(word.begin(), word.end());\n    # });\n    for word in words:\n        word.sort()\n    # return accumulate(words.begin(), words.end(), string(), [](string&& a, const string& b) {\n    #     return move(a += a.empty() ? b : \" \" + b);\n    # });\n    return ' '.join(accumulate(words, []))\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # vector<vector<int>> coords;\n    coords = []\n    # for (int i = 0; i < lst.size(); i++) {\n    for i in range(len(lst)):\n        # for (int j = 0; j < lst[i].size(); j++) {\n        for j in range(len(lst[i])):\n            # if (lst[i][j] == x) {\n            if lst[i][j] == x:\n                # coords.push_back({i, j});\n                coords.append([i, j])\n    # sort(coords.begin(), coords.end(), [](const vector<int>& a, const vector<int>& b) {\n    #     return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n    # });\n    coords.sort(key=lambda a: a[0] == b[0] and a[1] > b[1] or a[0] < b[0])\n    # return coords;\n    return coords\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if (arr.size() == 0) {\n    if len(arr) == 0:\n        # return {};\n        return []\n    # vector<int> result(arr);\n    result = arr.copy()\n    # if ((arr[0] + arr[arr.size() - 1]) % 2 == 0) {\n    if (arr[0] + arr[-1]) % 2 == 0:\n        # sort(result.begin(), result.end(), greater<int>());\n        result.sort(reverse=True)\n    else:\n        # sort(result.begin(), result.end());\n        result.sort()\n    # return result;\n    return result\n",
            "def encrypt(s: str) -> str:\n    # string result;\n    result = ''\n    # for (char ch : s) {\n    for ch in s:\n        # char shifted = ch + 4;\n        shifted = ch + 4\n        # if (shifted > 'z') {\n        if shifted > 'z':\n            # shifted -= 26;\n            shifted -= 26\n        # result += shifted;\n        result += shifted\n    # return result;\n    return result\n",
            "def next_smallest(lst: List[int]) -> Optional[int]:\n    # vector<int> sl(lst);\n    sl = lst.copy()\n    # sort(sl.begin(), sl.end());\n    sl.sort()\n    # sl.erase(unique(sl.begin(), sl.end()), sl.end());\n    sl = list(set(sl))\n    # if (sl.size() < 2) {\n    if len(sl) < 2:\n        # return nullopt;\n        return None\n    # return sl[1];\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # regex re(\"[.!?]\\\\s*\");\n    re = compile(\"[.!?]\\\\s*\", IGNORECASE)\n    # vector<string> sentences(sregex_token_iterator(s.begin(), s.end(), re, -1), sregex_token_iterator());\n    sentences = list(re.findall(s))\n    # return count_if(sentences.begin(), sentences.end(), [](const string& sentence) {\n    #     return sentence.size() >= 2 && sentence.substr(0, 2) == \"I \";\n    # });\n    return sum(1 for sentence in sentences if sentence.startswith(\"I \"))\n",
            "def any_int(x: Any, y: Any, z: Any) -> bool:\n    # if (x.type() == typeid(int) && y.type() == typeid(int) && z.type() == typeid(int)) {\n    if type(x) == int and type(y) == int and type(z) == int:\n        # int int_x = any_cast<int>(x);\n        # int int_y = any_cast<int>(y);\n        # int int_z = any_cast<int>(z);\n        int_x = x\n        int_y = y\n        int_z = z\n        # if ((int_x + int_y == int_z) || (int_x + int_z == int_y) || (int_y + int_z == int_x)) {\n        if int_x + int_y == int_z or int_x + int_z == int_y or int_y + int_z == int_x:\n            # return true;\n            return True\n    # }\n    # return false;\n    return False\n",
            "def encode(message: str) -> str:\n    # string vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # string result = \"\";\n    result = \"\"\n    # for (char ch : message) {\n    for ch in message:\n        # if (isalpha(ch)) {\n        if ch.isalpha():\n            # char ch1 = islower(ch) ? toupper(ch) : tolower(ch);\n            ch1 = ch.upper() if ch.islower() else ch.lower()\n            # if (vowels.find(ch1) != string::npos) {\n            if ch1 in vowels:\n                # ch1 = ch1 + 2;\n                ch1 = chr(ord(ch1) + 2)\n            # result += ch1;\n            result += ch1\n        # } else {\n        else:\n            # result += ch;\n            result += ch\n    # return result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= floor(sqrt(n)); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # vector<int> primes;\n    primes = []\n    # copy_if(lst.begin(), lst.end(), back_inserter(primes), isPrime);\n    primes = list(filter(is_prime, lst))\n    # if (primes.size() == 0) {\n    if len(primes) == 0:\n        # return 0;\n        return 0\n    # string largest = to_string(*max_element(primes.begin(), primes.end()));\n    largest = str(max(primes))\n    # return accumulate(largest.begin(), largest.end(), 0, [](int acc, char d) { return acc + (d - '0'); });\n    return sum(map(lambda d: ord(d) - ord('0'), largest))\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if (d.empty()) {\n    if not d:\n        # return false;\n        return False\n    # return all_of(d.begin(), d.end(), [](const auto& p) { \n    #     return all_of(p.first.begin(), p.first.end(), [](char c) { return islower(c); });\n    # }) || all_of(d.begin(), d.end(), [](const auto& p) { \n    #     return all_of(p.first.begin(), p.first.end(), [](char c) { return isupper(c); });\n    # });\n    return all(all(c.islower() for c in k) for k, v in d.items()) or all(all(c.isupper() for c in k) for k, v in d.items())\n",
            "def count_up_to(n: int) -> List[int]:\n    # vector<int> primes;\n    primes = []\n    # for (int num = 2; num < n; num++) {\n    for num in range(2, n):\n        # if (all_of(primes.begin(), primes.end(), [num](int p) { return num % p != 0; })) {\n        if all(num % p != 0 for p in primes):\n            # primes.push_back(num);\n            primes.append(num)\n    # return primes;\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # return (abs(a) % 10) * (abs(b) % 10);\n    return abs(a) % 10 * abs(b) % 10\n",
            "def count_upper(s: str) -> int:\n    # string vowels = \"AEIOU\";\n    vowels = \"AEIOU\"\n    # int count = 0;\n    count = 0\n    # for (int i = 0; i < s.size(); i++) {\n    for i in range(len(s)):\n        # if (i % 2 == 0 && vowels.find(s[i]) != string::npos) {\n        if i % 2 == 0 and s[i] in vowels:\n            # count++;\n            count += 1\n    # return count;\n    return count\n",
            "def closest_integer(value: str) -> int:\n    # double num = stod(value);\n    num = float(value)\n    # if (num >= 0) {\n    if num >= 0:\n        # return static_cast<int>(num + 0.5);\n        return int(num + 0.5)\n    # } else {\n    else:\n        # return static_cast<int>(num - 0.5);\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # vector<int> pile;\n    pile = []\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # pile.push_back(n + 2 * i);\n        pile.append(n + 2 * i)\n    # return pile;\n    return pile\n",
            "def words_string(s: str) -> List[str]:\n    # regex re(\"[, ]\");\n    re_ = re.compile(r\"[, ]\")\n    # vector<string> words(sregex_token_iterator(s.begin(), s.end(), re, -1), sregex_token_iterator());\n    words = list(re_.findall(s))\n    # erase_if(words, [](const string& word) {\n    #     return word.size() == 0;\n    # });\n    words = [word for word in words if len(word) > 0]\n    # return words;\n    return words\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    if x > y:\n        # return -1;\n        return -1\n    # if (y % 2 == 0) {\n    if y % 2 == 0:\n        # return y;\n        return y\n    # return y != x ? y - 1 : -1;\n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> Optional[str]:\n    # if (n > m) {\n    if n > m:\n        # return nullopt;\n        return None\n    # int r_avg = (n + m) / 2.0 + 0.5;\n    r_avg = (n + m) // 2 + 1\n    # string result = bitset<32>(r_avg).to_string();\n    result = BitArray(uint=r_avg, length=32).bin\n    # result.erase(0, min(result.find_first_not_of('0'), result.size()-1));\n    result = result.lstrip('0')\n    # return result;\n    return result\n",
            "def all_digits_odd(s: str) -> bool:\n    # return all_of(s.begin(), s.end(), [](char digit) {\n    #     return digit % 2 != 0;\n    # });\n    return all(digit % 2 != 0 for digit in s)\ndef unique_digits(x: List[int]) -> List[int]:\n    # vector<int> result;\n    result = []\n    # copy_if(x.begin(), x.end(), back_inserter(result), [](int num) {\n    #     return allDigitsOdd(to_string(num));\n    # });\n    result.extend(num for num in x if all_digits_odd(str(num)))\n    # sort(result.begin(), result.end());\n    result.sort()\n    # return result;\n    return result\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # vector<string> digit_names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # vector<int> sorted_arr;\n    sorted_arr = []\n    # copy_if(arr.begin(), arr.end(), back_inserter(sorted_arr), [](int x) {\n    #     return 1 <= x && x <= 9;\n    # });\n    for x in arr:\n        if 1 <= x <= 9:\n            sorted_arr.append(x)\n    # sort(sorted_arr.begin(), sorted_arr.end(), greater<int>());\n    sorted_arr.sort(reverse=True)\n    # vector<string> result;\n    result = []\n    # transform(sorted_arr.begin(), sorted_arr.end(), back_inserter(result), [&digit_names](int x) {\n    #     return digit_names[x-1];\n    # });\n    for x in sorted_arr:\n        result.append(digit_names[x-1])\n    # return result;\n    return result\n",
            "def f(n: int) -> List[int]:\n    # vector<int> nums(n);\n    nums = [0] * n\n    # iota(nums.begin(), nums.end(), 1);\n    for i in range(n):\n        nums[i] = i + 1\n    # vector<int> result;\n    result = []\n    # transform(nums.begin(), nums.end(), back_inserter(result), [&nums](int i) {\n    #     return i % 2 != 0 ? accumulate(nums.begin(), nums.begin() + i, 0) : accumulate(nums.begin(), nums.begin() + i, 1, multiplies<int>());\n    # });\n    for i in nums:\n        result.append(accumulate(nums[:i]) if i % 2 != 0 else accumulate(nums[:i], 1, mul))\n    # return result;\n    return result\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt == string(txt.rbegin(), txt.rend());\n    return txt == txt[::-1]\ndef even_odd_palindrome(n: int) -> List[int]:\n    # vector<int> cnt(2);\n    cnt = [0, 0]\n    # for (int i = 1; i <= n; ++i) {\n    for i in range(1, n + 1):\n        # if (isPalindrome(to_string(i))) {\n        if is_palindrome(str(i)):\n            # cnt[i % 2]++;\n            cnt[i % 2] += 1\n    # return cnt;\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # string n_str = to_string(n);\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return accumulate(n_str.begin(), n_str.end(), 0, [](int acc, char d) {\n        #     return acc + stoi(string(1,d));\n        # });\n        return reduce(lambda acc, d: acc + int(d), n_str, 0)\n    # } else {\n    else:\n        # return stoi(n_str.substr(0, 2)) * 2 + digitsSum(abs(n));\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# int countNums(const vector<int>& arr) {\ndef count_nums(arr: List[int]) -> int:\n    # return count_if(arr.begin(), arr.end(), [](int n) {\n    #     return digitsSum(n) > 0;\n    # });\n    return sum(1 for n in arr if digits_sum(n) > 0)\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if (arr.size() == 0) {\n    if len(arr) == 0:\n        # return true;\n        return True\n    # vector<int> sorted_arr = arr;\n    sorted_arr = sorted(arr)\n    # for (int i = 0; i < arr.size(); i++) {\n    for i in range(len(arr)):\n        # if (equal(arr.begin() + i, arr.end(), sorted_arr.begin(), sorted_arr.end() - i) &&\n        #     equal(arr.begin(), arr.begin() + i, sorted_arr.end() - i, sorted_arr.end())) {\n        if all(a == b for a, b in zip_longest(arr[i:], sorted_arr[:-i])) and \\\n           all(a == b for a, b in zip_longest(arr[:i], sorted_arr[-i:])):\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # int odd_cnt = count_if(lst1.begin(), lst1.end(), [](int n) {\n    #     return n % 2 != 0;\n    # });\n    odd_cnt = sum(1 for n in lst1 if n % 2 != 0)\n    # int even_cnt = count_if(lst2.begin(), lst2.end(), [](int n) {\n    #     return n % 2 == 0;\n    # });\n    even_cnt = sum(1 for n in lst2 if n % 2 == 0)\n    # return even_cnt >= odd_cnt ? \"YES\" : \"NO\";\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # unordered_map<string, int> freq;\n    freq = Counter()\n    # istringstream buf(test);\n    buf = test.split()\n    # vector<string> words(istream_iterator<string>(buf), {});\n    words = buf\n    # for (const string& w : words) {\n    for w in words:\n        # freq[w]++;\n        freq[w] += 1\n    # unordered_map<string, int> result;\n    result = {}\n    # if (freq.size() > 0) {\n    if freq:\n        # int max_freq = max_element(freq.begin(), freq.end(), [](const auto& p1, const auto& p2) { return p1.second < p2.second; })->second;\n        max_freq = max(freq.values())\n        # for (const auto& [k, v] : freq) {\n        #     if (v == max_freq) {\n        #         result[k] = v;\n        #     }\n        # }\n        for k, v in freq.items():\n            if v == max_freq:\n                result[k] = v\n    # return result;   \n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == string(s.rbegin(), s.rend());\n    return s == s[::-1]\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # string s1 = s;\n    s1 = s\n    # erase_if(s1, [&c](char ch) { return c.find(ch) != string::npos; });\n    s1 = ''.join(ch for ch in s1 if ch not in c)\n    # return {s1, isPalindrome(s1) ? \"yes\" : \"no\"};\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # vector<string> result;\n    result = []\n    # for (const string& num : lst) {\n    for num in lst:\n        # int n = accumulate(num.begin(), num.end(), 0, [](int a, char b) { return a + (b % 2 == 1); });\n        n = sum(1 if c % 2 == 1 else 0 for c in num)\n        # string rs = \"the number of odd elements in the string i of the input.\";\n        rs = \"the number of odd elements in the string i of the input.\"\n        # replace(rs.begin(), rs.end(), 'i', to_string(n)[0]);\n        rs = rs.replace('i', str(n)[0])\n        # result.push_back(rs);\n        result.append(rs)\n    # return result;\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # int min_sum = 0;\n    min_sum = 0\n    # int cur_sum = 0;\n    cur_sum = 0\n    # for (int n : nums) {\n    for n in nums:\n        # cur_sum = min(cur_sum + n, 0);\n        cur_sum = min(cur_sum + n, 0)\n        # min_sum = min(cur_sum, min_sum);\n        min_sum = min(cur_sum, min_sum)\n    # if (min_sum == 0) {\n    if min_sum == 0:\n        # min_sum = *min_element(nums.begin(), nums.end());\n        min_sum = min(nums)\n    # return min_sum;\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # return accumulate(grid.begin(), grid.end(), 0, [&](int a, const vector<int>& b) {\n    #     return a + ceil(accumulate(b.begin(), b.end(), 0) / static_cast<double>(capacity));\n    # });\n    return sum(a + ceil(sum(b) / capacity) for a, b in grid)\n",
            "def count_ones(num: int) -> int:\n    # return bitset<32>(num).count();\n    return BitArray(uint=num, length=32).count('1')\ndef sort_array(arr: List[int]) -> List[int]:\n    # vector<int> result(arr);\n    result = list(arr)\n    # sort(result.begin(), result.end(), [](int a, int b) {\n    #     return countOnes(a) == countOnes(b) ? a < b : countOnes(a) < countOnes(b);\n    # });\n    result.sort(key=lambda a: (count_ones(a), a))\n    # return result;\n    return result\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # istringstream buf(s);\n    buf = s.split()\n    # vector<string> words(istream_iterator<string>(buf), {});\n    words = list(islice(buf, 0, None))\n    # vector<string> result;\n    result = []\n    # copy_if(words.begin(), words.end(), back_inserter(result), [&](const string& w) {\n    for w in words:\n        # return count_if(w.begin(), w.end(), [&](char c) {\n        #     return consonants.find(tolower(c)) != string::npos;\n        # }) == n;\n        if sum(1 for c in w if c.lower() in consonants) == n:\n            # pq.pop();\n            result.append(w)\n    # return result;\n    return result\n",
            "def get_closest_vowel(word: str) -> str:\n    # string vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # for (int i = word.size() - 2; i > 0; --i) {\n    for i in range(word.size() - 2, 0, -1):\n        # if (vowels.find(word[i]) != string::npos && vowels.find(word[i - 1]) == string::npos && vowels.find(word[i + 1]) == string::npos) {\n        if vowels.find(word[i]) != -1 and vowels.find(word[i - 1]) == -1 and vowels.find(word[i + 1]) == -1:\n            # return string(1, word[i]);\n            return word[i]\n    # return \"\";\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # for (char ch : s) {\n    for ch in s:\n        # if (ch == '(') {\n        if ch == '(':\n            # depth++;\n            depth += 1\n        # } else {\n        else:\n            # depth--;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth == 0;\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # string s1 = lst[0] + lst[1];\n    s1 = lst[0] + lst[1]\n    # string s2 = lst[1] + lst[0];\n    s2 = lst[1] + lst[0]\n    # return check(s1) || check(s2) ? \"Yes\" : \"No\";\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if (k == 0) {\n    if k == 0:\n        # return {};\n        return []\n    # vector<int> sorted_arr = arr;\n    sorted_arr = arr.copy()\n    # sort(sorted_arr.begin(), sorted_arr.end());\n    sorted_arr.sort()\n    # vector<int> ans(sorted_arr.end() - k, sorted_arr.end());\n    ans = sorted_arr[-k:]\n    # return ans;\n    return ans\n",
            "def solution(lst: List[int]) -> int:\n    # int result = 0;\n    result = 0\n    # for (int i = 0; i < lst.size(); i++) {\n    for i in range(len(lst)):\n        # if (i % 2 == 0 && lst[i] % 2 != 0) {\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            # result += lst[i];\n            result += lst[i]\n    # return result;\n    return result\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # return accumulate(arr.begin(), arr.begin() + k, 0, [&](int a, int b) {\n    #     return a + (to_string(b).size() <= 2 ? b : 0);\n    # });\n    return reduce(lambda a, b: a + (len(str(b)) <= 2 and b or 0), arr[:k], 0)\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # vector<int> collatz = {1};\n    collatz = [1]\n    # while (n != 1) {\n    while n != 1:\n        # if (n % 2 != 0) {\n        if n % 2 != 0:\n            # collatz.push_back(n);\n            collatz.append(n)\n            # n = 3 * n + 1;\n            n = 3 * n + 1\n        else:\n            # n = n / 2;\n            n = n / 2\n    # sort(collatz.begin(), collatz.end());\n    collatz.sort()\n    # return collatz;\n    return collatz\n",
            "def valid_date(date: str) -> bool:\n    # if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        # return false;\n        return False\n    # int m = stoi(date.substr(0, 2));\n    m = int(date[0:2])\n    # int d = stoi(date.substr(3, 2));\n    d = int(date[3:5])\n    # if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 ||\n    #     m == 12) {\n    if m == 1 or m == 3 or m == 5 or m == 7 or m == 8 or m == 10 or m == 12:\n        # return d >= 1 && d <= 31;\n        return d >= 1 and d <= 31\n    # if (m == 4 || m == 6 || m == 9 || m == 11) {\n    if m == 4 or m == 6 or m == 9 or m == 11:\n        # return d >= 1 && d <= 30;\n        return d >= 1 and d <= 30\n    # if (m == 2) {\n    if m == 2:\n        # return d >= 1 && d <= 29;\n        return d >= 1 and d <= 29\n    # return false;\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # istringstream iss(txt);\n    iss = istringstream(txt)\n    # if (txt.find(\" \") != string::npos) {\n    if \" \" in txt:\n        # return vector<string>(istream_iterator<string>(iss), {});\n        return list(islice(iss, 0, None))\n    # else if (txt.find(\",\") != string::npos) {\n    elif \",\" in txt:\n        # vector<string> result;\n        result = []\n        # for (auto [iss, token] = pair{istringstream(txt), string()}; getline(iss, token, ','); result.push_back(token));\n        for [iss, token] in [pair{istringstream(txt), \"\"}]:\n            getline(iss, token, ',')\n            result.append(token)\n        # return result;\n        return result\n    # else {\n    else:\n        # return {to_string(count_if(txt.begin(), txt.end(), [&](char c) {\n        #     return islower(c) && c % 2 == 0;\n        # }))};\n        return [to_string(count_if(txt.begin(), txt.end(), lambda c: islower(c) and c % 2 == 0))]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if (!is_sorted(lst.begin(), lst.end())) {\n    if not sorted(lst):\n        # return false;\n        return False\n    # unordered_map<int, int> freq;\n    freq = Counter()\n    # for (int i : lst) {\n    for i in lst:\n        # freq[i]++;\n        freq[i] += 1\n    # return lst.size() == 0 || max_element(freq.begin(), freq.end(), [](const auto& a, const auto& b) { return a.second < b.second; })->second <= 2;\n    return len(lst) == 0 or max(freq.values()) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= floor(sqrt(n)); i++) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        #     return false;\n        # }\n        if n % i == 0:\n            return False\n    # return true;\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # int l = max(interval1[0], interval2[0]);\n    l = max(interval1[0], interval2[0])\n    # int r = min(interval1[1], interval2[1]);\n    r = min(interval1[1], interval2[1])\n    # int length = r - l;\n    length = r - l\n    # return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if (arr.empty()) {\n    if not arr:\n        # return nullopt;\n        return None\n    # if (find(arr.begin(), arr.end(), 0) != arr.end()) {\n    if 0 in arr:\n        # return 0;\n        return 0\n    # int sign = count_if(arr.begin(), arr.end(), [](int n) { return n < 0; }) % 2 == 1 ? -1 : 1;\n    sign = -1 if sum(1 for n in arr if n < 0) % 2 == 1 else 1\n    # return sign * accumulate(arr.begin(), arr.end(), 0, [](int a, int b) { return a + abs(b); });\n    return sign * reduce(lambda a, b: a + abs(b), arr, 0)\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # int n = grid.size();\n    n = len(grid)\n    # int min_val = n * n + 1;\n    min_val = n * n + 1\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # for (int j = 0; j < n; j++) {\n        for j in range(n):\n            # if (grid[i][j] == 1) {\n            if grid[i][j] == 1:\n                # vector<int> temp;\n                temp = []\n                # if (i != 0) {\n                if i != 0:\n                    # temp.push_back(grid[i - 1][j]);\n                    temp.append(grid[i - 1][j])\n                # if (j != 0) {\n                if j != 0:\n                    # temp.push_back(grid[i][j - 1]);\n                    temp.append(grid[i][j - 1])\n                # if (i != n - 1) {\n                if i != n - 1:\n                    # temp.push_back(grid[i + 1][j]);\n                    temp.append(grid[i + 1][j])\n                # if (j != n - 1) {\n                if j != n - 1:\n                    # temp.push_back(grid[i][j + 1]);\n                    temp.append(grid[i][j + 1])\n                # min_val = *min_element(temp.begin(), temp.end());\n                min_val = min(temp)\n    # vector<int> result;\n    result = []\n    # for (int i = 0; i < k; i++) {\n    for i in range(k):\n        # result.push_back(i % 2 == 0 ? 1 : min_val);\n        result.append(1 if i % 2 == 0 else min_val)\n    # return result;\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if (n == 0) {\n    if n == 0:\n        # return {1};\n        return [1]\n    # vector<int> seq = {1, 3};\n    seq = [1, 3]\n    # for (int i = 2; i <= n; i++) {\n    for i in range(2, n + 1):\n        # if (i % 2 == 0) {\n        if i % 2 == 0:\n            # seq.push_back(i / 2 + 1);\n            seq.append(i // 2 + 1)\n        # else {\n        else:\n            # seq.push_back(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) // 2)\n    # return seq;\n    return seq\n",
            "def digits(n: int) -> int:\n    # vector<int> odds;\n    odds = []\n    # for (char c : to_string(n)) {\n    for c in str(n):\n        # int d = c - '0';\n        d = ord(c) - ord('0')\n        # if (d % 2 == 1) {\n        if d % 2 == 1:\n            # odds.push_back(d);\n            odds.append(d)\n    # return odds.empty() ? 0 : accumulate(odds.begin(), odds.end(), 1, multiplies<int>());\n    return 0 if odds == [] else reduce(lambda x, y: x * y, odds, 1)\n",
            "def is_nested(s: str) -> bool:\n    # vector<int> open_idx;\n    open_idx = []\n    # vector<int> close_idx;\n    close_idx = []\n    # for (int i = 0; i < s.length(); i++) {\n    for i in range(len(s)):\n        # switch (s[i]) {\n        #     case '[':\n        #         open_idx.push_back(i); break;\n        #     case ']':\n        #         close_idx.push_back(i); break;\n        # }\n        if s[i] == '[':\n            open_idx.append(i)\n        elif s[i] == ']':\n            close_idx.append(i)\n    # reverse(close_idx.begin(), close_idx.end());\n    close_idx.reverse()\n    # int cnt = 0;\n    cnt = 0\n    # int i = 0;\n    i = 0\n    # int l = close_idx.size();\n    l = len(close_idx)\n    # for (int idx : open_idx) {\n    #     if (i < l && idx < close_idx[i]) {\n    #         cnt += 1;\n    #         i += 1;\n    #     }\n    # }\n    for idx in open_idx:\n        if i < l and idx < close_idx[i]:\n            cnt += 1\n            i += 1\n    # return cnt >= 2;\n    return cnt >= 2\n",
            "def sum_squares(lst: List[float]) -> int:\n    # return accumulate(lst.begin(), lst.end(), 0, [](int acc, double n) { return acc + pow(ceil(n), 2); });\n    return sum([pow(ceil(n), 2) for n in lst])\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if (txt.empty()) {\n    if not txt:\n        # return false;\n        return False\n    # string last = txt.substr(txt.find_last_of(\" \") + 1);\n    last = txt[txt.rfind(\" \") + 1:]\n    # return last.length() == 1 && isalpha(last[0]);\n    return len(last) == 1 and last[0].isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if (arr.size() <= 1) {\n    if len(arr) <= 1:\n        # return -1;\n        return -1\n    # vector<int> idx;\n    idx = []\n    # for (int i = 1; i < arr.size(); i++) {\n    for i in range(1, len(arr)):\n        # if (arr[i] < arr[i - 1]) {\n        if arr[i] < arr[i - 1]:\n            # idx.push_back(i);\n            idx.append(i)\n    # return idx.empty() ? -1 : *max_element(idx.begin(), idx.end());\n    return -1 if not idx else max(idx)\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # vector<int> neg;\n    neg = []\n    # vector<int> pos;\n    pos = []\n    # copy_if(lst.begin(), lst.end(), back_inserter(neg), [](int i) { return i < 0; });\n    neg = list(filterfalse(lambda i: i >= 0, lst))\n    # copy_if(lst.begin(), lst.end(), back_inserter(pos), [](int i) { return i > 0; });\n    pos = list(filterfalse(lambda i: i <= 0, lst))\n    # optional<int> max_neg = neg.size() > 0 ? make_optional(*max_element(neg.begin(), neg.end())) : nullopt;\n    max_neg = max(neg) if len(neg) > 0 else None\n    # optional<int> min_pos = pos.size() > 0 ? make_optional(*min_element(pos.begin(), pos.end())) : nullopt;\n    min_pos = min(pos) if len(pos) > 0 else None\n    # return {max_neg, min_pos};\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if (o.type() == typeid(string)) {\n    if type(o) == str:\n        # string o_str = any_cast<string>(o);\n        o_str = o\n        # replace(o_str.begin(), o_str.end(), ',', '.');\n        o_str = o_str.replace(',', '.')\n        # return stod(o_str);\n        return float(o_str)\n    # else if (o.type() == typeid(int)) {\n    elif type(o) == int:\n        # return static_cast<double>(any_cast<int>(o));\n        return float(o)\n    # else if (o.type() == typeid(double)) {\n    elif type(o) == float:\n        # return any_cast<double>(o);\n        return o\n    # throw runtime_error(\"Type Error\");  \n    else:\n        raise RuntimeError(\"Type Error\")\ndef compare_one(a: Any, b: Any) -> Optional[float]:\n    # double a1 = anyToReal(a);\n    a1 = any_to_real(a)\n    # double b1 = anyToReal(b);\n    b1 = any_to_real(b)\n    # if (a1 == b1) {\n    if a1 == b1:\n        # return nullopt;\n        return None\n    # else if (a1 > b1) {\n    elif a1 > b1:\n        # return a1;\n        return a1\n    # else {\n    else:\n        # return b1;\n        return b1\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return n % 2 == 0 && n >= 8;\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # int fact = 1;\n    fact = 1\n    # int result = 1;\n    result = 1\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # fact *= i;\n        fact *= i\n        # result *= fact;\n        result *= fact\n    # return result;\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # string result = txt;\n    result = txt\n    # result = regex_replace(result, regex(\"\\\\s{3,}\"), \"-\");\n    result = re.sub(r\"\\s{3,}\", \"-\", result)\n    # replace(result.begin(), result.end(), ' ', '_');\n    result = result.replace(\" \", \"_\")\n    # return result;\n    return result\n",
            "def file_name_check(file_name: str) -> str:\n    # vector<string> suf = {\"txt\", \"exe\", \"dll\"};\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # vector<string> lst;\n    lst = []\n    # for (auto [iss, token] = pair{istringstream(file_name), string()}; getline(iss, token, '.'); lst.push_back(token));\n    for token in file_name.split(\".\"):\n        lst.append(token)\n    # if (lst.size() != 2 || !count(suf.begin(), suf.end(), lst[1]) || lst[0].size() == 0 || !isalpha(lst[0][0]) || count_if(lst[0].begin(), lst[0].end(), [](char c) { return isdigit(c); }) > 3) {\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or lst[0].count(lambda c: c.isdigit()) > 3:\n        # return \"No\";\n        return \"No\"\n    # return \"Yes\";\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # int result = 0;\n    result = 0\n    # for (int i = 0; i < lst.size(); i++) {\n    for i in range(len(lst)):\n        # if (i % 3 == 0) {\n        if i % 3 == 0:\n            # result += pow(lst[i], 2);\n            result += pow(lst[i], 2)\n        # } else if (i % 4 == 0) {\n        elif i % 4 == 0:\n            # result += pow(lst[i], 3);\n            result += pow(lst[i], 3)\n        # } else {\n        else:\n            # result += lst[i];\n            result += lst[i]\n    # return result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= floor(sqrt(n)); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # istringstream ss(sentence);\n    ss = sentence.split()\n    # vector<string> words(istream_iterator<string>(ss), {});\n    words = list(ss)\n    # erase_if(words, [](const string& w) { return !isPrime(w.length()); });\n    words = [w for w in words if is_prime(len(w))]\n    # return accumulate(words.begin(), words.end(), string(), [](string&& a, const string& b) { return move(a += a.empty() ? b : \" \" + b); });\n    return ' '.join(words)\n",
            "def simplify(x: str, n: str) -> bool:\n    # vector<string> xs;\n    xs = []\n    # vector<string> ns;\n    ns = []\n    # for (auto [iss, token] = pair{istringstream(x), string()}; getline(iss, token, '/'); xs.push_back(token));\n    for token in x.split('/'):\n        xs.append(token)\n    # for (auto [iss, token] = pair{istringstream(n), string()}; getline(iss, token, '/'); ns.push_back(token));\n    for token in n.split('/'):\n        ns.append(token)\n    # int num = stoi(xs[0]) * stoi(ns[0]);\n    num = int(xs[0]) * int(ns[0])\n    # int den = stoi(xs[1]) * stoi(ns[1]);\n    den = int(xs[1]) * int(ns[1])\n    # return num % den == 0;\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # string n_str = to_string(n);\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return accumulate(n_str.begin(), n_str.end(), 0, [](int acc, char d) {\n        #     return acc + stoi(string(1,d));\n        # });\n        return reduce(lambda acc, d: acc + int(d), n_str, 0)\n    # } else {\n    else:\n        # return stoi(n_str.substr(0, 2)) * 2 + digitsSum(abs(n));\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# }\ndef order_by_points(nums: List[int]) -> List[int]:\n    # vector<int> result(nums);\n    result = nums.copy()\n    # stable_sort(result.begin(), result.end(), [](int a, int b) {\n    #     return digitsSum(a) < digitsSum(b);\n    # });\n    result.sort(key=digits_sum)\n    # return result;\n    return result\n",
            "def special_filter(nums: List[int]) -> int:\n    # string odds = \"13579\";\n    odds = \"13579\"\n    # return count_if(nums.begin(), nums.end(), [&](int n) { return n > 10 && n % 2 == 1 && odds.find(to_string(n)[0]) != string::npos; });\n    return sum(1 for n in nums if n > 10 and n % 2 == 1 and odds.find(str(n)[0]) != -1)\n",
            "def get_max_triples(n: int) -> int:\n    # int c[3] = {0, 0, 0};\n    c = [0, 0, 0]\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # int a = i * i - i + 1;\n        a = i * i - i + 1\n        # c[a % 3]++;\n        c[a % 3] += 1\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6;\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # vector<string> names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if (find(names.begin(), names.end(), planet1) == names.end() || find(names.begin(), names.end(), planet2) == names.end()) {\n    if planet1 not in names or planet2 not in names:\n        # return {};\n        return []\n    # int l = find(names.begin(), names.end(), planet1) - names.begin();\n    l = names.index(planet1)\n    # int r = find(names.begin(), names.end(), planet2) - names.begin();\n    r = names.index(planet2)\n    # if (l > r) {\n    if l > r:\n        # tie(l, r) = tuple(r, l);\n        l, r = r, l\n    # if (l == r) {\n    if l == r:\n        # return {};\n        return []\n    # return vector<string>(names.begin() + l + 1, names.begin() + r);  \n    return names[l + 1: r + 1]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # vector<string> result;\n    result = []\n    # copy_if(lst.begin(), lst.end(), back_inserter(result), [](const string& s) { return s.length() % 2 == 0; });\n    result.extend(filterfalse(lambda s: s.length() % 2 != 0, lst))\n    # sort(result.begin(), result.end(), [](const string& a, const string& b) {\n    #     if (a.length() == b.length()) {\n    #         return a < b;\n    #     }\n    #     return a.length() < b.length();\n    # });\n    result.sort(key=lambda s: (s.length(), s))\n    # return result;\n    return result\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if (n < 2) {\n    if n < 2:\n        # return y;\n        return y\n    # for (int i = 2; i <= floor(sqrt(n)); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return y;\n            return y\n    # return x;\n    return x\n",
            "def double_the_difference(lst: List[float]) -> int:\n    # return accumulate(lst.begin(), lst.end(), 0, [](double acc, double n) { return acc + (n >= 0 && fmod(n, 2) == 1 ? static_cast<int>(n * n) : 0); });\n    return reduce(lambda acc, n: acc + (n >= 0 and fmod(n, 2) == 1) * int(n * n), lst, 0)\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # vector<int> result;\n    result = []\n    # transform(game.begin(), game.end(), guess.begin(), back_inserter(result), [](int x, int y) { return abs(x - y); });\n    result.extend(starmap(abs, zip(game, guess)))\n    # return result;\n    return result\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # int max_s = numeric_limits<int>::min();\n    max_s = -float('inf')\n    # string max_ext;\n    max_ext = ''\n    # for (const string& ext : extensions) {\n    for ext in extensions:\n        # int upper = count_if(ext.begin(), ext.end(), [](char c) { return isupper(c); });\n        upper = sum(1 for c in ext if c in ascii_uppercase)\n        # int lower = count_if(ext.begin(), ext.end(), [](char c) { return islower(c); });\n        lower = sum(1 for c in ext if c in ascii_lowercase)\n        # int s = upper - lower;\n        s = upper - lower\n        # if (s > max_s) {\n        if s > max_s:\n            # max_s = s;\n            max_s = s\n            # max_ext = ext;\n            max_ext = ext\n    # return format(\"{0}.{1}\", class_name, max_ext);\n    return '{0}.{1}'.format(class_name, max_ext)\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if (a.length() < b.length()) {\n    if len(a) < len(b):\n        # return false;\n        return False\n    # for (int i = 0; i < b.length(); i++) {\n    for i in range(len(b)):\n        # if (a.find(b.substr(i) + b.substr(0, i)) != string::npos) {\n        if a.find(b[i:] + b[:i]) != -1:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # string ds = to_string(abs(num));\n    ds = str(abs(num))\n    # int even = count_if(ds.begin(), ds.end(), [](char d) { return d % 2 == 0; });\n    even = sum(1 for d in ds if d % 2 == 0)\n    # return {even, static_cast<int>(ds.size()) - even};\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 ,5, 4, 1};\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 ,5, 4, 1]\n    # vector<string> numerals = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # string res = \"\";\n    res = \"\"\n    # for (int i = 0; i < values.size(); i++) {\n    for i in range(len(values)):\n        # while (num >= values[i]) {\n        while num >= values[i]:\n            # res += numerals[i];\n            # num -= values[i];\n            res += numerals[i]\n            num -= values[i]\n    # return res;\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # vector<int> s = {a, b, c};\n    s = [a, b, c]\n    # sort(s.begin(), s.end());\n    s.sort()\n    # return s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # int max_cnt = 0;\n    max_cnt = 0\n    # string max_w = \"\";\n    max_w = \"\"\n    # for (const string& w : words) {\n    for w in words:\n        # int cnt = unordered_set<char>(w.begin(), w.end()).size();\n        cnt = len(set(w))\n        # if (cnt > max_cnt) {\n        if cnt > max_cnt:\n            # max_cnt = cnt;\n            max_cnt = cnt\n            # max_w = w;\n            max_w = w\n        # else if (cnt == max_cnt) {\n        elif cnt == max_cnt:\n            # max_w = min(max_w, w);\n            max_w = min(max_w, w)\n    # return max_w;\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if (need <= remaining) {\n    if need <= remaining:\n        # return {num + need, remaining - need};\n        return [num + need, remaining - need]\n    # } else {\n    else:\n        # return {num + remaining, 0};\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # vector<string> ops = operators;\n    ops = operators.copy()\n    # vector<int> nums = operands;\n    nums = operands.copy()\n    # int i = ops.size() - 1;\n    i = len(ops) - 1\n    # while (i >= 0) {\n    while i >= 0:\n        # if (ops[i] == \"**\") {\n        if ops[i] == \"**\":\n            # nums[i] = pow(nums[i], nums[i + 1]);\n            nums[i] = pow(nums[i], nums[i + 1])\n            # nums.erase(nums.begin() + i + 1);\n            nums.pop(i + 1)\n            # ops.erase(ops.begin() + i);\n            ops.pop(i)\n        # i--;\n        i -= 1\n    # i = 0;\n    i = 0\n    # while (i < ops.size()) {\n    while i < len(ops):\n        # if (ops[i] == \"*\") {\n        if ops[i] == \"*\":\n            # nums[i] = nums[i] * nums[i + 1];\n            nums[i] = nums[i] * nums[i + 1]\n            # nums.erase(nums.begin() + i + 1);\n            nums.pop(i + 1)\n            # ops.erase(ops.begin() + i);\n            ops.pop(i)\n            # i--;\n            i -= 1\n        # } else if (ops[i] == \"//\") {\n        elif ops[i] == \"//\":\n            # nums[i] = nums[i] / nums[i + 1];\n            nums[i] = nums[i] / nums[i + 1]\n            # nums.erase(nums.begin() + i + 1);\n            nums.pop(i + 1)\n            # ops.erase(ops.begin() + i);\n            ops.pop(i)\n            # i--;\n            i -= 1\n        # i++;\n        i += 1\n    # i = 0;\n    i = 0\n    # while (i < ops.size()) {\n    while i < len(ops):\n        # if (ops[i] == \"+\") {\n        if ops[i] == \"+\":\n            # nums[i] = nums[i] + nums[i + 1];\n            nums[i] = nums[i] + nums[i + 1]\n            # nums.erase(nums.begin() + i + 1);\n            nums.pop(i + 1)\n            # ops.erase(ops.begin() + i);\n            ops.pop(i)\n            # i--;\n            i -= 1\n        # } else if (ops[i] == \"-\") {\n        elif ops[i] == \"-\":\n            # nums[i] = nums[i] - nums[i + 1];\n            nums[i] = nums[i] - nums[i + 1]\n            # nums.erase(nums.begin() + i + 1);\n            nums.pop(i + 1)\n            # ops.erase(ops.begin() + i);\n            ops.pop(i)\n            # i--;\n            i -= 1\n        # i++;\n        i += 1\n    # return nums[0];\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if (!any_of(s.begin(), s.end(), [](char ch) { return isalpha(ch); })) {\n    if not any(ch.isalpha() for ch in s):\n        # return string(s.rbegin(), s.rend());\n        return ''.join(reversed(s))\n    # string result;\n    result = ''\n    # for (char ch : s) {\n    for ch in s:\n        # if (!isalpha(ch)) {\n        if not ch.isalpha():\n            # result.push_back(ch);\n            result += ch\n        # } else if (isupper(ch)) {\n        elif ch.isupper():\n            # result.push_back(tolower(ch));\n            result += ch.lower()\n        # } else if (islower(ch)) {\n        elif ch.islower():\n            # result.push_back(toupper(ch));\n            result += ch.upper()\n    # return result;\n    return result\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if (txt.empty()) {\n    if not txt:\n        # return nullopt;\n        return None\n    # MD5_CTX md5_context;\n    # MD5_Init(&md5_context);\n    # MD5_Update(&md5_context, txt.c_str(), txt.length());\n    md5_context = md5()\n    md5_context.update(txt.encode())\n    # unsigned char hash_bytes[MD5_DIGEST_LENGTH];\n    # MD5_Final(hash_bytes, &md5_context);\n    hash_bytes = md5_context.digest()\n    # string md5_encoded;\n    md5_encoded = \"\"\n    # for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n    for i in range(MD5_DIGEST_LENGTH):\n        # md5_encoded += format(\"{:02x}\", static_cast<int>(hash_bytes[i]));\n        md5_encoded += format(\"{:02x}\", hash_bytes[i])\n    # return md5_encoded;\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # int lower = max(2, min(a, b));\n    lower = max(2, min(a, b))\n    # int upper = min(8, max(a, b));\n    upper = min(8, max(a, b))\n    # vector<int> numbers;\n    numbers = []\n    # for (int n = lower; n <= upper; n++) {\n    for n in range(lower, upper + 1):\n        # if (n % 2 == 0) {\n        if n % 2 == 0:\n            # numbers.push_back(n);\n            numbers.append(n)\n    # return numbers;\n    return numbers\n"
        ]
    },
    "csharp": {
        "python": [
            "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # for (int i = 0; i < numbers.Count; i++) {\n    for i in range(len(numbers)):\n        # for (int j = i + 1; j < numbers.Count; j++) {\n        for j in range(i + 1, len(numbers)):\n            # if (Math.Abs(numbers[i] - numbers[j]) < threshold) {\n            if math.fabs(numbers[i] - numbers[j]) < threshold:\n                # return true;\n                return True\n    # return false;\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # List<string> groups = new List<string>();\n    groups = []\n    # List<char> stk = new List<char>();\n    stk = []\n    # string currentGroup = \"\";\n    current_group = \"\"\n    # string parens = parenString.Replace(\" \", \"\");\n    parens = paren_string.replace(\" \", \"\")\n    # foreach (char ch in parens) {\n    for ch in parens:\n        # if (ch == '(') {\n        if ch == '(':\n            # stk.Add(ch);\n            stk.append(ch)\n            # currentGroup += ch;\n            current_group += ch\n        # }\n        # else if (ch == ')') {\n        elif ch == ')':\n            # stk.RemoveAt(stk.Count - 1);\n            stk.pop()\n            # currentGroup += ch;\n            current_group += ch\n            # if (stk.Count == 0) {\n            if not stk:\n                # groups.Add(currentGroup);\n                groups.append(current_group)\n                # currentGroup = \"\";\n                current_group = \"\"\n        # }\n    # return groups;\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return num - Math.Floor(num);\n    return num - floor(num)\n",
            "def below_zero(operations: List[int]) -> bool:\n    # int balance = 0;\n    balance = 0\n    # foreach (int op in operations) {\n    for op in operations:\n        # balance += op;\n        balance += op\n        # if (balance < 0) {\n        if balance < 0:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # double mean = numbers.Sum() / numbers.Count;\n    mean = sum(numbers) / len(numbers)\n    # double deviation = numbers.Select(x => Math.Abs(x - mean)).Sum();\n    deviation = sum(map(lambda x: fabs(x - mean), numbers))\n    # return deviation / numbers.Count;\n    return deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # List<int> result = new List<int>();\n    result = []\n    # for (int i = 0; i < numbers.Count; i++) {\n    for i in range(len(numbers)):\n        # if (i != 0) {\n        if i != 0:\n            # result.Add(delimiter);\n            result.append(delimiter)\n        # result.Add(numbers[i]);\n        result.append(numbers[i])\n    # return result;\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # List<int> result = new List<int>();\n    result = []\n    # List<string> parenGroups = parenString.Split(\" \").Where(s => s.Length > 0).ToList();\n    paren_groups = paren_string.split(\" \")\n    # foreach (string group in parenGroups) {\n    for group in paren_groups:\n        # int maxDepth = 0;\n        max_depth = 0\n        # int depth = 0;\n        depth = 0\n        # foreach (char ch in group) {\n        for ch in group:\n            # if (ch == '(') {\n            if ch == \"(\":\n                # depth += 1;\n                depth += 1\n                # maxDepth = Math.Max(maxDepth, depth);\n                max_depth = max(max_depth, depth)\n            # } else if (ch == ')') {\n            elif ch == \")\":\n                # depth -= 1;\n                depth -= 1\n        # result.Add(maxDepth);\n        result.append(max_depth)\n    # return result;\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # return strs.Where(s => s.Contains(substring)).ToList();\n    return [s for s in strs if substring in s]\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # int nSum = numbers.Sum();\n    n_sum = sum(numbers)\n    # int nProduct = numbers.Aggregate(1, (a, b) => a * b);\n    n_product = reduce(lambda a, b: a * b, numbers)\n    # return new List<int> { nSum, nProduct };\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # int maxSoFar = int.MinValue;\n    max_so_far = float('-inf')\n    # List<int> result = new List<int>();\n    result = []\n    # foreach (int num in numbers) {\n    for num in numbers:\n        # maxSoFar = Math.Max(maxSoFar, num);\n        max_so_far = max(max_so_far, num)\n        # result.Add(maxSoFar);\n        result.append(max_so_far)\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == new string(s.Reverse().ToArray());\n    return s == ''.join(reversed(s))\ndef make_palindrome(s: str) -> str:\n    # if (IsPalindrome(s)) {\n    if is_palindrome(s):\n        # return s;\n        return s\n    # for (int i = 0; i < s.Length; i++) {\n    for i in range(len(s)):\n        # if (IsPalindrome(s.Substring(i))) {\n        if is_palindrome(s[i:]):\n            # return s + new string(s.Substring(0, i).Reverse().ToArray());\n            return s + ''.join(reversed(s[:i]))\n    # return \"\";\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # return new string(a.Zip(b, (x, y) => x == y ? '0' : '1').ToArray());\n    return ''.join('0' if x == y else '1' for x, y in zip(a, b))\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if (strs.Count == 0) {\n    if not strs:\n        # return null;\n        return None\n    # string longestS = strs[0];\n    longest_s = strs[0]\n    # foreach (string s in strs) {\n    for s in strs:\n        # if (s.Length > longestS.Length) {\n        if len(s) > len(longest_s):\n            # longestS = s;\n            longest_s = s\n    # return longestS;\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if (b == 0) {\n    if b == 0:\n        # return a;\n        return a\n    # else {\n    else:\n        # return GreatestCommonDivisor(b, a % b);\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # List<string> prefixes = new List<string>();\n    prefixes = []\n    # for (int i = 0; i < s.Length; i++) {\n    for i in range(len(s)):\n        # prefixes.Add(s.Substring(0, i + 1));\n        prefixes.append(s[:i + 1])\n    # return prefixes;\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # return string.Join(\" \", Enumerable.Range(0, n + 1).Select(i => i.ToString()));\n    return \" \".join(str(i) for i in range(n + 1))\n",
            "def count_distinct_characters(s: str) -> int:\n    # return s.ToLower().Distinct().Count();\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # Dictionary<string, int> durations = new Dictionary<string, int> {{\"o\", 4}, {\"o|\", 2}, {\".|\", 1}};\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    # List<string> notes = musicString.Split(\" \").Where(s => s.Length > 0).ToList();\n    notes = [s for s in music_string.split(\" \") if len(s) > 0]\n    # return notes.Select(note => durations[note]).ToList();\n    return [durations[note] for note in notes]\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # int times = 0;\n    times = 0\n    # for (int i = 0; i <= s.Length - substring.Length; i++) {\n    for i in range(len(s) - len(substring) + 1):\n        # if (s.Substring(i, substring.Length) == substring) {\n        #     times += 1;\n        # }\n        if s[i:i + len(substring)] == substring:\n            times += 1\n    # return times;\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # Dictionary<string, int> numDict = new Dictionary<string, int>() {\n    #     {\"zero\", 0},\n    #     {\"one\", 1},\n    #     {\"two\", 2},\n    #     {\"three\", 3},\n    #     {\"four\", 4},\n    #     {\"five\", 5},\n    #     {\"six\", 6},\n    #     {\"seven\", 7},\n    #     {\"eight\", 8},\n    #     {\"nine\", 9}\n    # };\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    # List<string> numList = numbers.Split(\" \").Where(x => numDict.ContainsKey(x)).ToList();\n    num_list = [x for x in numbers.split(\" \") if x in num_dict]\n    # numList.Sort((x, y) => numDict[x] - numDict[y]);\n    num_list.sort(key=lambda x: num_dict[x])\n    # return string.Join(\" \", numList);\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[float]) -> List[float]:\n    # List<double> sortedNumbers = numbers.OrderBy(x => x).ToList();\n    sorted_numbers = sorted(numbers)\n    # double minDiff = double.MaxValue;\n    min_diff = float('inf')\n    # List<double> closestPair = new List<double>();\n    closest_pair = []\n    # for (int i = 1; i < sortedNumbers.Count; i++) {\n    for i in range(1, len(sorted_numbers)):\n        # double diff = sortedNumbers[i] - sortedNumbers[i - 1];\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if (diff < minDiff) {\n        if diff < min_diff:\n            # minDiff = diff;\n            min_diff = diff\n            # closestPair = new List<double>() {sortedNumbers[i - 1], sortedNumbers[i]};\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return closestPair;\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # double minNum = numbers.Min();\n    min_num = min(numbers)\n    # double maxNum = numbers.Max();\n    max_num = max(numbers)\n    # if (minNum == maxNum) {\n    if min_num == max_num:\n        # return new List<double>(new double[numbers.Count]);\n        return [0.0] * len(numbers)\n    # } else {\n    else:\n        # return numbers.Select(num => (num - minNum) / (maxNum - minNum)).ToList();\n        return [(num - min_num) / (max_num - min_num) for num in numbers]\n",
            "def filter_integers(values: List[object]) -> List[int]:\n    # return values.OfType<int>().ToList();\n    return [v for v in values if isinstance(v, int)]\n",
            "def str_length(s: str) -> int:\n    # return s.Length;\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for (int i = 2; i < n; i++) {\n    for i in range(2, n):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return n / i;\n            return n / i\n    # return 1;\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # List<int> factors = new List<int>();\n    factors = []\n    # int divisor = 2;\n    divisor = 2\n    # while (divisor <= n) {\n    while divisor <= n:\n        # if (n % divisor == 0) {\n        if n % divisor == 0:\n            # factors.Add(divisor);\n            factors.append(divisor)\n            # n /= divisor;\n            n //= divisor\n        # else {\n        else:\n            # divisor += 1;\n            divisor += 1\n    # return factors;\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # Dictionary<int, int> counts = new Dictionary<int, int>();\n    counts = {}\n    # foreach (int num in numbers) {\n    for num in numbers:\n        # counts[num] = counts.GetValueOrDefault(num, 0) + 1;\n        counts[num] = counts.get(num, 0) + 1\n    # List<int> res = numbers.Where(num => counts[num] == 1).ToList();\n    res = [num for num in numbers if counts[num] == 1]\n    # return res;\n    return res\n",
            "def flip_case(s: str) -> str:\n    # StringBuilder flipped = new StringBuilder();\n    flipped = []\n    # foreach (char ch in s) {\n    for ch in s:\n        # if (!char.IsLetter(ch)) {\n        if not ch.isalpha():\n            # flipped.Append(ch);\n            flipped.append(ch)\n        # else if (char.IsLower(ch)) {\n        elif ch.islower():\n            # flipped.Append(char.ToUpper(ch));\n            flipped.append(ch.upper())\n        # else if (char.IsUpper(ch)) {\n        elif ch.isupper():\n            # flipped.Append(char.ToLower(ch));\n            flipped.append(ch.lower())\n    # return flipped.ToString();\n    return ''.join(flipped)\n",
            "def concatenate(strs: List[str]) -> str:\n    # return string.Join(\"\", strs);\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # return strs.Where(s => s.StartsWith(prefixStr)).ToList();\n    return [s for s in strs if s.startswith(prefix_str)]\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # return l.Where(num => num > 0).ToList();\n    return [num for num in l if num > 0]\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.Floor(Math.Sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def poly(xs: List[int], x: float) -> float:\n    # double res = 0;\n    res = 0\n    # for (int i = 0; i < xs.Count; i++) {\n    for i in range(len(xs)):\n        # res += xs[i] * Math.Pow(x, i);\n        res += xs[i] * math.pow(x, i)\n    # return res;\n    return res\ndef find_zero(xs: List[int]) -> float:\n    # double x1 = 1.0, x2 = -1.0;\n    x1 = 1.0\n    x2 = -1.0\n    # while (Poly(xs, x1) * Poly(xs, x2) > 0) {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2;\n        x1 *= 2\n        # x2 *= 2;\n        x2 *= 2\n    # while (Math.Abs(x1 - x2) > 1e-10) {\n    while math.fabs(x1 - x2) > 1e-10:\n        # double mid = (x1 + x2) / 2;\n        mid = (x1 + x2) / 2\n        # if (Poly(xs, mid) == 0) {\n        if poly(xs, mid) == 0:\n            # return mid;\n            return mid\n        # else if (Poly(xs, mid) * Poly(xs, x1) < 0) {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid;\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid;\n            x1 = mid\n    # return (x1 + x2) / 2;\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # var sortedThird = l.Where((x, i) => i % 3 == 0).OrderBy(x => x).ToList();\n    sorted_third = [x for i, x in enumerate(l) if i % 3 == 0]\n    sorted_third.sort()\n    # return l.Select((x, i) => i % 3 == 0 ? sortedThird[i / 3] : x).ToList();\n    return [sorted_third[i // 3] if i % 3 == 0 else x for i, x in enumerate(l)]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # return l.Distinct().OrderBy(x => x).ToList();\n    return sorted(set(l))\n",
            "def max_element(l: List[int]) -> int:\n    # if (l.Count == 0) {\n    if len(l) == 0:\n        # return 0;\n        return 0\n    # return l.Max();\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # if (i % 11 == 0 || i % 13 == 0) {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += i.ToString().Count(x => x == '7');\n            cnt += i.count('7')\n    # return cnt;\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # var sortedEven = l.Where((x, i) => i % 2 == 0).OrderBy(x => x).ToList();\n    sorted_even = [x for i, x in enumerate(l) if i % 2 == 0]\n    sorted_even.sort()\n    # return l.Select((x, i) => i % 2 == 0 ? sortedEven[i / 2] : x).ToList();\n    return [sorted_even[i // 2] if i % 2 == 0 else x for i, x in enumerate(l)]\n",
            "def encode_cyclic(s: str) -> str:\n    # var result = new StringBuilder();\n    result = ''\n    # for (int i = 0; i < s.Length; i += 3) {\n    for i in range(0, len(s), 3):\n        # if (i + 3 > s.Length) {\n        if i + 3 > len(s):\n            # result.Append(s.Substring(i));\n            result += s[i:]\n        # } else {\n        else:\n            # result.Append(s.Substring(i + 1, 2));\n            # result.Append(s[i]);\n            result += s[i + 1:i + 3] + s[i]\n    # return result.ToString();\n    return result\ndef decode_cyclic(s: str) -> str:\n    # return EncodeCyclic(EncodeCyclic(s));\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.Floor(Math.Sqrt(n)); i++) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        #     return false;\n        # }\n        if n % i == 0:\n            return False\n    # return true;\n    return True\ndef prime_fib(n: int) -> int:\n    # int[] f = new int[] {0, 1};\n    f = [0, 1]\n    # int cnt = 0;\n    cnt = 0\n    # while (cnt < n) {\n    while cnt < n:\n        # f = new int[] {f[1], f[0] + f[1]};\n        f = [f[1], f[0] + f[1]]\n        # if (IsPrime(f[1])) {\n        #     cnt++;\n        # }\n        if is_prime(f[1]):\n            cnt += 1\n    # return f[1];\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for (int i = 0; i < l.Count; i++) {\n    for i in range(len(l)):\n        # for (int j = i + 1; j < l.Count; j++) {\n        for j in range(i + 1, len(l)):\n            # for (int k = j + 1; k < l.Count; k++) {\n            for k in range(j + 1, len(l)):\n                # if (l[i] + l[j] + l[k] == 0) {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true;\n                    return True\n    # return false;\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return (int)Math.Pow(n, 2);\n    return int(pow(n, 2))\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # return l.Select(i => i + 1).ToList();\n    return [i + 1 for i in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # HashSet<int> seen = new HashSet<int>();\n    seen = set()\n    # foreach (int num in l) {\n    for num in l:\n        # if (seen.Contains(-num)) {\n        if -num in seen:\n            # return true;\n            return True\n        # seen.Add(num);\n        seen.add(num)\n    # return false;\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if (x == 0) {\n    if x == 0:\n        # return \"0\";\n        return \"0\"\n    # List<string> digits = new List<string>();\n    digits = []\n    # while (x > 0) {\n    while x > 0:\n        # digits.Add((x % bas).ToString());\n        digits.append(str(x % bas))\n        # x /= bas;\n        x //= bas\n    # digits.Reverse();\n    digits.reverse()\n    # return string.Join(\"\", digits);\n    return \"\".join(digits)\n",
            "def triangle_area(a: int, h: int) -> float:\n    # return (double)(a * h) / 2;\n    return (a * h) / 2\n",
            "def fib4(n: int) -> int:\n    # int[] fib = new int[] {0, 0, 2, 0};\n    fib = [0, 0, 2, 0]\n    # for (int i = 4; i <= n; i++) {\n    for i in range(4, n + 1):\n        # fib[i % 4] = fib.Sum();\n        fib[i % 4] = sum(fib)\n    # return fib[n % 4];\n    return fib[n % 4]\n",
            "def median(l: List[float]) -> float:\n    # var sl = l.OrderBy(i => i).ToList();\n    sl = sorted(l)\n    # if (l.Count % 2 != 0) {\n    if len(l) % 2 != 0:\n        # return sl[l.Count / 2];\n        return sl[len(l) // 2]\n    # } else {\n    else:\n        # return (sl[l.Count / 2] + sl[l.Count / 2 - 1]) / 2;\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt == new string(txt.Reverse().ToArray());\n    return txt == txt[::-1]\n",
            "def modp(n: int, p: int) -> int:\n    # int ret = 1;\n    ret = 1\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # ret = (ret * 2) % p;\n        ret = (ret * 2) % p\n    # return ret;\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # var result = s.Select(ch => (char)(((ch - 97 + 5) % 26) + 97));\n    result = [((ord(ch) - 97 + 5) % 26) + 97 for ch in s]\n    # return string.Join(\"\", result);\n    return \"\".join(chr(ch) for ch in result)\ndef decode_shift(s: str) -> str:\n    # var result = s.Select(ch => (char)(((ch - 97 + 21) % 26) + 97));\n    result = [((ord(ch) - 97 + 21) % 26) + 97 for ch in s]\n    # return string.Join(\"\", result);\n    return \"\".join(chr(ch) for ch in result)\n",
            "def remove_vowels(txt: str) -> str:\n    # string vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # return String.Join(\"\", txt.Where(c => !vowels.Contains(c)));\n    return \"\".join(c for c in txt if c not in vowels)\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # return l.All(x => x < t);\n    return all(x < t for x in l)\n",
            "def add(x: int, y: int) -> int:\n    # return x + y;\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # return (new HashSet<char>(s0)).SetEquals(new HashSet<char>(s1));\n    return set(s0) == set(s1)\n",
            "def fib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return n;\n        return n\n    # else {\n    else:\n        # return Fib(n - 1) + Fib(n - 2);\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # foreach (char b in brackets) {\n    for b in brackets:\n        # if (b == '<') {\n        if b == '<':\n            # depth += 1;\n            depth += 1\n        # } else if (b == '>') {\n        elif b == '>':\n            # depth -= 1;\n            depth -= 1\n        # }\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n        # }\n    # return depth == 0;\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # var diff = l.Zip(l.Skip(1), (x, y) => y - x);\n    diff = [y - x for x, y in zip(l, l[1:])]\n    # return diff.All(x => x <= 0) || diff.All(x => x >= 0);\n    return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # return l1.Intersect(l2).Distinct().OrderBy(x => x).ToList();\n    return sorted(set(l1).intersection(l2))\n",
            "def largest_prime_factor(n: int) -> int:\n    # int i = 2;\n    i = 2\n    # while (i * i <= n) {\n    while i * i <= n:\n        # if (n % i != 0) {\n        if n % i != 0:\n            # i += 1;\n            i += 1\n        # else {\n        else:\n            # n /= i;\n            n //= i\n    # return n;\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # return Enumerable.Range(0, n + 1).Sum();\n    return sum(range(n + 1))\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # foreach (char b in brackets) {\n    for b in brackets:\n        # if (b == '(') {\n        if b == '(':\n            # depth += 1;\n            depth += 1\n        # } else if (b == ')') {\n        elif b == ')':\n            # depth -= 1;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth == 0;\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # return xs.Select((x, i) => x * i).Skip(1).ToList();\n    return [x * i for i, x in enumerate(xs)][1:]\n",
            "def fibfib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return 0;\n        return 0\n    # int a = 0, b = 0, c = 1;\n    a = 0\n    b = 0\n    c = 1\n    # while (n > 2) {\n    while n > 2:\n        # (a, b, c) = (b, c, a + b + c);\n        a, b, c = b, c, a + b + c\n        # n -= 1;\n        n -= 1\n    # return c;\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # string vowels = \"aeiou\";\n    vowels = \"aeiou\"\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 0; i < s.Length; i++) {\n    for i in range(len(s)):\n        # if (vowels.Contains(char.ToLower(s[i])) || (i == s.Length - 1 && char.ToLower(s[i]) == 'y')) {\n        if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == 'y'):\n            # cnt += 1;\n            cnt += 1\n    # return cnt;\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # string xStr = x.ToString();\n    x_str = str(x)\n    # if (shift > xStr.Length) {\n    if shift > len(x_str):\n        # return new string(xStr.Reverse().ToArray());\n        return ''.join(reversed(x_str))\n    # } else {\n    #     return xStr.Substring(xStr.Length - shift) + xStr.Substring(0, xStr.Length - shift);\n    # }\n    return x_str[len(x_str) - shift:] + x_str[:len(x_str) - shift]\n",
            "def digit_sum(s: str) -> int:\n    # return s.Where(c => char.IsUpper(c)).Sum(c => (int)c);\n    return sum(map(lambda c: ord(c), filter(lambda c: c.isupper(), s)))\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # string[] words = s.Split(\" \");\n    words = s.split(\" \")\n    # int apples = int.Parse(words[words.ToList().IndexOf(\"apples\") - 1]);\n    apples = int(words[words.index(\"apples\") - 1])\n    # int oranges = int.Parse(words[words.ToList().IndexOf(\"oranges\") - 1]);\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # return n - apples - oranges;\n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # var evens = arr.Where(n => n % 2 == 0).ToList();\n    evens = [n for n in arr if n % 2 == 0]\n    # if (evens.Count == 0) {\n    if len(evens) == 0:\n        # return new List<int>();\n        return []\n    # var minEven = evens.Min();\n    min_even = min(evens)\n    # return new List<int> { minEven, arr.IndexOf(minEven) };\n    return [min_even, arr.index(min_even)]\n",
            "def search(lst: List[int]) -> int:\n    # Dictionary<int, int> freqs = new Dictionary<int, int>();\n    freqs = {}\n    # foreach (int n in lst) {\n    for n in lst:\n        # freqs[n] = freqs.GetValueOrDefault(n, 0) + 1;\n        freqs[n] = freqs.get(n, 0) + 1\n    # List<int> goodVals = freqs.Where(p => p.Value >= p.Key).Select(p => p.Key).ToList();\n    good_vals = [k for k, v in freqs.items() if v >= k]\n    # return goodVals.DefaultIfEmpty(-1).Max();\n    return max(good_vals) if good_vals else -1\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # List<int> sl = lst.OrderBy(x => x).ToList();\n    sl = sorted(lst)\n    # List<int> result = new List<int>();\n    result = []\n    # int left = 0, right = sl.Count - 1;\n    left = 0\n    right = len(sl) - 1\n    # while (left <= right) {\n    while left <= right:\n        # result.Add(sl[left]);\n        result.append(sl[left])\n        # left += 1;\n        left += 1\n        # if (left <= right) {\n        if left <= right:\n            # result.Add(sl[right]);\n            result.append(sl[right])\n            # right -= 1;\n            right -= 1\n    # return result;\n    return result\n",
            "def triangle_area(a: int, b: int, c: int) -> float:\n    # if (a + b > c && a + c > b && b + c > a) {\n    if a + b > c and a + c > b and b + c > a:\n        # double s = (a + b + c) / 2.0;\n        s = (a + b + c) / 2.0\n        # return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # } else {\n    else:\n        # return -1.0;\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if (q.Count == 0) {\n    if not q:\n        # return false;\n        return False\n    # bool isPalin = Enumerable.Range(0, q.Count).All(i => q[i] == q[q.Count - i - 1]);\n    is_palin = all(q[i] == q[q.Count - i - 1] for i in range(q.Count))\n    # int total = q.Sum();\n    total = sum(q)\n    # return isPalin && total <= w;\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # int ans = 0;\n    ans = 0\n    # for (int i = 0; i < arr.Count / 2; i++) {\n    for i in range(len(arr) // 2):\n        # if (arr[i] != arr[arr.Count - i - 1]) {\n        #     ans += 1;\n        # }\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    # return ans;\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # int cnt1 = lst1.Sum(x => x.Length);\n    cnt1 = sum(len(x) for x in lst1)\n    # int cnt2 = lst2.Sum(x => x.Length);\n    cnt2 = sum(len(x) for x in lst2)\n    # return cnt1 <= cnt2 ? lst1 : lst2;\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.Floor(Math.Sqrt(n)); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 2; i <= a; i++) {\n    for i in range(2, a + 1):\n        # if (IsPrime(i)) {\n        if is_prime(i):\n            # while (a % i == 0) {\n            #     cnt++;\n            #     a /= i;\n            # }\n            while a % i == 0:\n                cnt += 1\n                a //= i\n    # return cnt == 3;\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return x == n;\n        return x == n\n    # int tmp = 1;\n    tmp = 1\n    # while (tmp < x) {\n    while tmp < x:\n        # tmp *= n;\n        tmp *= n\n    # return tmp == x;\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # a = Math.Abs(a);\n    a = abs(a)\n    # int root = (int)Math.Round(Math.Pow(a, 1.0 / 3.0));\n    root = int(round(math.pow(a, 1.0 / 3.0)))\n    # return root * root * root == a;\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # return num.Count(x => \"2357BD\".Contains(x));\n    return sum(1 for x in num if x in \"2357BD\")\n",
            "def decimal_to_binary(dec: int) -> str:\n    # string binary = Convert.ToString(dec, 2);\n    binary = bin(dec)\n    # return $\"db{binary}db\";\n    return f\"db{binary}db\"\n",
            "def is_happy(s: str) -> bool:\n    # if (s.Length < 3) {\n    if len(s) < 3:\n        # return false;\n        return False\n    # for (int i = 0; i < s.Length - 2; i++) {\n    for i in range(len(s) - 2):\n        # if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # List<string> result = new List<string>();\n    result = []\n    # foreach (double g in grades) {\n    for g in grades:\n        # switch (true) {\n        # case true when g == 4.0:\n        #     result.Add(\"A+\"); break;\n        if g == 4.0:\n            result.append(\"A+\")\n        # case true when g > 3.7:\n        #     result.Add(\"A\"); break;\n        elif g > 3.7:\n            result.append(\"A\")\n        # case true when g > 3.3:\n        #     result.Add(\"A-\"); break;\n        elif g > 3.3:\n            result.append(\"A-\")\n        # case true when g > 3.0:\n        #     result.Add(\"B+\"); break;\n        elif g > 3.0:\n            result.append(\"B+\")\n        # case true when g > 2.7:\n        #     result.Add(\"B\"); break;\n        elif g > 2.7:\n            result.append(\"B\")\n        # case true when g > 2.3:\n        #     result.Add(\"B-\"); break;\n        elif g > 2.3:\n            result.append(\"B-\")\n        # case true when g > 2.0:\n        #     result.Add(\"C+\"); break;\n        elif g > 2.0:\n            result.append(\"C+\")\n        # case true when g > 1.7:\n        #     result.Add(\"C\"); break;\n        elif g > 1.7:\n            result.append(\"C\")\n        # case true when g > 1.3:\n        #     result.Add(\"C-\"); break;\n        elif g > 1.3:\n            result.append(\"C-\")\n        # case true when g > 1.0:\n        #     result.Add(\"D+\"); break;\n        elif g > 1.0:\n            result.append(\"D+\")\n        # case true when g > 0.7:\n        #     result.Add(\"D\"); break;\n        elif g > 0.7:\n            result.append(\"D\")\n        # case true when g > 0.0:\n        #     result.Add(\"D-\"); break;\n        elif g > 0.0:\n            result.append(\"D-\")\n        # default:\n        #     result.Add(\"E\"); break;\n        else:\n            result.append(\"E\")\n    # return result;\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # int length = s.Length;\n    length = len(s)\n    # if (length < 2) {\n    if length < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.Floor(Math.Sqrt(length)); i++) {\n    for i in range(2, int(length ** 0.5) + 1):\n        # if (length % i == 0) {\n        if length % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if (n == 1) {\n    if n == 1:\n        # return 1;\n        return 1\n    # return 2 * 9 * (int)Math.Pow(10, n - 2);\n    return 2 * 9 * (int)(pow(10, n - 2))\n",
            "def solve(n: int) -> str:\n    # int digitsSum = n.ToString().Select(d => int.Parse(d.ToString())).Sum();\n    digitsSum = sum(map(int, str(n)))\n    # return Convert.ToString(digitsSum, 2);\n    return bin(digitsSum)[2:]\n",
            "def add(lst: List[int]) -> int:\n    # return lst.Where((x, i) => i % 2 == 1 && x % 2 == 0).Sum();\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)\n",
            "def anti_shuffle(s: str) -> str:\n    # var words = s.Split(' ').Select(word => new string(word.OrderBy(c => c).ToArray())).ToList();\n    words = [word for word in s.split(' ') if word]\n    # return string.Join(' ', words);\n    return ' '.join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # List<IList<int>> coords = new List<IList<int>>();\n    coords = []\n    # for (int i = 0; i < lst.Count; i++) {\n    for i in range(len(lst)):\n        # for (int j = 0; j < lst[i].Count; j++) {\n        for j in range(len(lst[i])):\n            # if (lst[i][j] == x) {\n            if lst[i][j] == x:\n                # coords.Add(new List<int> { i, j });\n                coords.append([i, j])\n    # return coords.OrderByDescending((a) => a[1]).OrderBy((a) => a[0]).ToList();\n    return sorted(coords, key=lambda a: a[1], reverse=True)\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if (arr.Count == 0) {\n    if len(arr) == 0:\n        # return new List<int>();\n        return []\n    # if ((arr[0] + arr[arr.Count - 1]) % 2 == 0) {\n    if (arr[0] + arr[-1]) % 2 == 0:\n        # return arr.OrderByDescending((a) => a).ToList();\n        return sorted(arr, reverse=True)\n    # else {\n    else:\n        # return arr.OrderBy((a) => a).ToList();\n        return sorted(arr)\n",
            "def encrypt(s: str) -> str:\n    # StringBuilder result = new StringBuilder();\n    result = []\n    # foreach (char ch in s) {\n    for ch in s:\n        # int shifted = ch + 4;\n        shifted = ord(ch) + 4\n        # if (shifted > 'z') {\n        if shifted > ord('z'):\n            # shifted -= 26;\n            shifted -= 26\n        # result.Append((char)shifted);\n        result.append(chr(shifted))\n    # return result.ToString();\n    return ''.join(result)\n",
            "def next_smallest(lst: List[int]) -> int:\n    # List<int> sl = lst.Distinct().OrderBy((a) => a).ToList();\n    sl = list(set(lst))\n    sl.sort()\n    # if (sl.Count < 2) {\n    if len(sl) < 2:\n        # return null;\n        return None\n    # return sl[1];\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # string[] sentences = Regex.Split(s, @\"[.!?]\\s*\");\n    sentences = re.split(r'[.!?]\\s*', s)\n    # return sentences.Where((sentence) => sentence.Length >= 2 && sentence.Substring(0, 2) == \"I \").Count();\n    return sum(1 for sentence in sentences if len(sentence) >= 2 and sentence[:2] == 'I ')\n",
            "def any_int(x, y, z):\n    # if (x is int && y is int && z is int) {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # int intX = (int)x;\n        intX = x\n        # int intY = (int)y;\n        intY = y\n        # int intZ = (int)z;\n        intZ = z\n        # if ((intX + intY == intZ) || (intX + intZ == intY) || (intY + intZ == intX)) {\n        if intX + intY == intZ or intX + intZ == intY or intY + intZ == intX:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def encode(message: str) -> str:\n    # string vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # StringBuilder result = new StringBuilder();\n    result = \"\"\n    # foreach (char ch in message) {\n    for ch in message:\n        # if (char.IsLetter(ch)) {\n        if ch.isalpha():\n            # char ch1 = char.IsLower(ch) ? char.ToUpper(ch) : char.ToLower(ch);\n            ch1 = ch.upper() if ch.islower() else ch.lower()\n            # if (vowels.Contains(ch1)) {\n            if ch1 in vowels:\n                # ch1 = (char)(ch1 + 2);\n                ch1 = chr(ord(ch1) + 2)\n            # result.Append(ch1);\n            result += ch1\n        else:\n            # result.Append(ch);\n            result += ch\n    # return result.ToString();\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.Floor(Math.Sqrt(n)); i++) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        #     return false;\n        # }\n        if n % i == 0:\n            return False\n    # return true;\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # var primes = lst.Where(n => IsPrime(n)).ToList();\n    primes = [n for n in lst if is_prime(n)]\n    # if (primes.Count == 0) {\n    if len(primes) == 0:\n        # return 0;\n        return 0\n    # string largest = primes.Max().ToString();\n    largest = str(max(primes))\n    # return largest.Select(d => (int)char.GetNumericValue(d)).Sum();\n    return sum(int(d) for d in largest)\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if (d.Count == 0) {\n    if len(d) == 0:\n        # return false;\n        return False\n    # return d.Keys.All(k => k.All(c => char.IsLower(c))) || d.Keys.All(k => k.All(c => char.IsUpper(c)));\n    return all(k.islower() for k in d.keys()) or all(k.isupper() for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # List<int> primes = new List<int>();\n    primes = []\n    # for (int num = 2; num < n; num++) {\n    for num in range(2, n):\n        # if (primes.All(p => num % p != 0)) {\n        if all(num % p != 0 for p in primes):\n            # primes.Add(num);\n            primes.append(num)\n    # return primes;\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # return (Math.Abs(a) % 10) * (Math.Abs(b) % 10);\n    return math.fabs(a) % 10 * math.fabs(b) % 10\n",
            "def count_upper(s: str) -> int:\n    # string vowels = \"AEIOU\";\n    vowels = \"AEIOU\"\n    # return s.Where((c, i) => i % 2 == 0 && vowels.Contains(c)).Count();\n    return sum(1 for i, c in enumerate(s) if i % 2 == 0 and c in vowels)\n",
            "def closest_integer(value: str) -> int:\n    # double num = double.Parse(value);\n    num = float(value)\n    # if (num >= 0) {\n    if num >= 0:\n        # return (int)(num + 0.5);\n        return int(num + 0.5)\n    # else {\n    else:\n        # return (int)(num - 0.5);\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # return Enumerable.Range(0, n).Select(i => n + 2 * i).ToList();\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # return Regex.Split(s, \"[, ]\").Where(w => w.Length > 0).ToList();\n    return list(filter(lambda w: len(w) > 0, re.split(r'[, ]', s)))\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    if x > y:\n        # return -1;\n        return -1\n    # if (y % 2 == 0) {\n    if y % 2 == 0:\n        # return y;\n        return y\n    # return y != x ? y - 1 : -1;\n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> str:\n    # if (n > m) {\n    if n > m:\n        # return null;\n        return None\n    # int rAvg = (int)((m + n) / 2.0 + 0.5);\n    r_avg = int((m + n) / 2.0 + 0.5)\n    # return Convert.ToString(rAvg, 2);\n    return bin(r_avg)\n",
            "def all_digits_odd(s: str) -> bool:\n    # return s.All(digit => digit % 2 != 0);\n    return all(digit % 2 != 0 for digit in s)\ndef unique_digits(x: List[int]) -> List[int]:\n    # return x.Where(num => AllDigitsOdd(Convert.ToString(num))).OrderBy(num => num).ToList();\n    return sorted(filter(lambda num: all_digits_odd(str(num)), x))\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # string[] digitNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # List<int> sortedArr = arr.Where(x => 1 <= x && x <= 9).OrderByDescending(x => x).ToList();\n    sorted_arr = sorted(filter(lambda x: 1 <= x <= 9, arr), reverse=True)\n    # return sortedArr.Select(x => digitNames[x - 1]).ToList();\n    return [digit_names[x - 1] for x in sorted_arr]\n",
            "def f(n: int) -> List[int]:\n    # List<int> nums = Enumerable.Range(1, n).ToList();\n    nums = list(range(1, n + 1))\n    # return nums.Select(i => i % 2 != 0 ? nums.Take(i).Sum() : nums.Take(i).Aggregate(1, (x, y) => x * y)).ToList();\n    return [sum(takewhile(lambda x: x <= i, nums)) if i % 2 != 0 else reduce(lambda x, y: x * y, takewhile(lambda x: x <= i, nums)) for i in nums]\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt == new string(txt.Reverse().ToArray());\n    return txt == txt[::-1]\ndef even_odd_palindrome(n: int) -> List[int]:\n    # var cnt = new List<int> { 0, 0 };\n    cnt = [0, 0]\n    # for (var i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # if (IsPalindrome(i.ToString())) {\n        if is_palindrome(str(i)):\n            # cnt[i % 2]++;\n            cnt[i % 2] += 1\n    # return cnt;\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # string nStr = n.ToString();\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return nStr.Select(d => int.Parse(d.ToString())).Sum();\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return int.Parse(nStr.Substring(0, 2)) * 2 + DigitsSum(Math.Abs(n));\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# }\ndef count_nums(arr: List[int]) -> int:\n    # return arr.Count(n => DigitsSum(n) > 0);\n    return len(list(filter(lambda n: digits_sum(n) > 0, arr)))\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if (arr.Count == 0) {\n    if len(arr) == 0:\n        # return true;\n        return True\n    # List<int> sortedArr = arr.OrderBy(n => n).ToList();\n    sorted_arr = sorted(arr)\n    # for (int i = 0; i < arr.Count; i++) {\n    for i in range(len(arr)):\n        # if (arr.Skip(i).SequenceEqual(sortedArr.Take(arr.Count - i)) && arr.Take(i).SequenceEqual(sortedArr.Skip(arr.Count - i))) {\n        if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # int oddCnt = lst1.Count(n => n % 2 != 0);\n    odd_cnt = sum(1 for n in lst1 if n % 2 != 0)\n    # int evenCnt = lst2.Count(n => n % 2 == 0);\n    even_cnt = sum(1 for n in lst2 if n % 2 == 0)\n    # return evenCnt >= oddCnt ? \"YES\" : \"NO\";\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # var freq = new Dictionary<string, int>();\n    freq = {}\n    # var words = test.Split(\" \").Where(w => w.Length > 0).ToList();\n    words = [w for w in test.split(\" \") if len(w) > 0]\n    # foreach (var w in words) {\n    for w in words:\n        # freq[w] = freq.ContainsKey(w) ? freq[w] + 1 : 1;\n        freq[w] = freq.get(w, 0) + 1\n    # var result = new Dictionary<string, int>();\n    result = {}\n    # if (freq.Count > 0) {\n    if freq:\n        # var maxFreq = freq.Values.Max();\n        max_freq = max(freq.values())\n        # foreach (var kv in freq) {\n        #     if (kv.Value == maxFreq) {\n        #         result[kv.Key] = kv.Value;\n        #     }\n        # }\n        for k, v in freq.items():\n            if v == max_freq:\n                result[k] = v\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == new string(s.Reverse().ToArray());\n    return s == ''.join(reversed(s))\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # var s1 = new string(s.Where(ch => !c.Contains(ch)).ToArray());\n    s1 = ''.join(ch for ch in s if ch not in c)\n    # return new List<string> { s1, IsPalindrome(s1) ? \"yes\" : \"no\" };\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # var result = new List<string>();\n    result = []\n    # foreach (var num in lst) {\n    for num in lst:\n        # var n = num.Count(d => d % 2 == 1);\n        n = sum(1 for d in num if d % 2 == 1)\n        # var rs = \"the number of odd elements in the string i of the input.\";\n        rs = \"the number of odd elements in the string {} of the input.\".format(n)\n        # result.Add(rs.Replace(\"i\", n.ToString()));\n        result.append(rs.replace(\"i\", str(n)))\n    # return result;\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # int minSum = 0;\n    min_sum = 0\n    # int curSum = 0;\n    cur_sum = 0\n    # foreach (var n in nums) {\n    for n in nums:\n        # curSum = Math.Min(curSum + n, 0);\n        cur_sum = min(cur_sum + n, 0)\n        # minSum = Math.Min(curSum, minSum);\n        min_sum = min(cur_sum, min_sum)\n    # if (minSum == 0) {\n    if min_sum == 0:\n        # minSum = nums.Min();\n        min_sum = min(nums)\n    # return minSum;\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # return grid.Sum(arr => (int)Math.Ceiling(arr.Sum() / (double)capacity));\n    return sum(int(math.ceil(sum(arr) / capacity)) for arr in grid)\n",
            "def count_ones(num: int) -> int:\n    # return Convert.ToString(num, 2).Count(ch => ch == '1');\n    return bin(num).count('1')\ndef sort_array(arr: List[int]) -> List[int]:\n    # return arr.OrderBy(x => CountOnes(x)).ThenBy(x => x).ToList();\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # string[] words = s.Split(' ').Where(w => w.Length > 0).ToArray();\n    words = [w for w in s.split(' ') if len(w) > 0]\n    # return words.Where(w => w.Count(c => consonants.Contains(char.ToLower(c))) == n).ToList();\n    return [w for w in words if w.count(c => consonants.contains(c.lower())) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # string vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # for (int i = word.Length - 2; i > 0; i--) {\n    for i in range(len(word) - 2, 0, -1):\n        # if (vowels.Contains(word[i]) && !vowels.Contains(word[i - 1]) && !vowels.Contains(word[i + 1])) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return word[i].ToString();\n            return word[i]\n    # return \"\";\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # foreach (char ch in s) {\n    for ch in s:\n        # if (ch == '(') {\n        if ch == '(':\n            # depth++;\n            depth += 1\n        # else {\n        else:\n            # depth--;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth == 0;\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # string s1 = lst[0] + lst[1];\n    s1 = lst[0] + lst[1]\n    # string s2 = lst[1] + lst[0];\n    s2 = lst[1] + lst[0]\n    # return Check(s1) || Check(s2) ? \"Yes\" : \"No\";\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if (k == 0) {\n    if k == 0:\n        # return new List<int>();\n        return []\n    # return arr.OrderBy(x => x).Skip(arr.Count - k).ToList();\n    return sorted(arr)[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # return lst.Where((x, i) => i % 2 == 0 && x % 2 != 0).Sum();\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # return arr.Take(k).Where(n => n.ToString().Length <= 2).Sum();\n    return sum(n for n in arr[:k] if len(str(n)) <= 2)\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # var collatz = new List<int>{1};\n    collatz = [1]\n    # while (n != 1) {\n    while n != 1:\n        # if (n % 2 != 0) {\n        if n % 2 != 0:\n            # collatz.Add(n);\n            collatz.append(n)\n            # n = 3 * n + 1;\n            n = 3 * n + 1\n        else:\n            # n = n / 2;\n            n = n / 2\n    # return collatz.OrderBy(x => x).ToList();\n    return sorted(collatz)\n",
            "def valid_date(date: str) -> bool:\n    # if (date.Length != 10 || date[2] != '-' || date[5] != '-') {\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        # return false;\n        return False\n    # int m = int.Parse(date.Substring(0, 2));\n    m = int(date[0:2])\n    # int d = int.Parse(date.Substring(3, 2));\n    d = int(date[3:5])\n    # if (new List<int>{1, 3, 5, 7, 8, 10, 12}.Contains(m) && d >= 1 && d <= 31) {\n    if m in [1, 3, 5, 7, 8, 10, 12] and 1 <= d <= 31:\n        # return true;\n        return True\n    # if (new List<int>{4, 6, 9, 11}.Contains(m) && d >= 1 && d <= 30) {\n    if m in [4, 6, 9, 11] and 1 <= d <= 30:\n        # return true;\n        return True\n    # if (m == 2 && d >= 1 && d <= 29) {\n    if m == 2 and 1 <= d <= 29:\n        # return true;\n        return True\n    # return false;\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if (txt.Contains(\" \")) {\n    if \" \" in txt:\n        # return txt.Split(\" \").ToList();\n        return txt.split(\" \")\n    # } else if (txt.Contains(\",\")) {\n    elif \",\" in txt:\n        # return txt.Split(\",\").ToList();\n        return txt.split(\",\")\n    # } else {\n    else:\n        # return new List<string>{txt.Where(c => char.IsLower(c) && (int)c % 2 == 0).Count().ToString()};\n        return [str(len(list(filter(lambda c: c.islower() and (ord(c) % 2 == 0), txt))))]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if (!lst.Skip(1).Select((n, i) => lst[i] <= n).All(a => a)) {\n    #     return false;\n    # }\n    if not all(lst[i] <= n for i, n in enumerate(islice(lst, 1, None))):\n        return False\n    # var freq = new Dictionary<int, int>();\n    freq = {}\n    # foreach (var i in lst) {\n    #     freq[i] = freq.GetValueOrDefault(i, 0) + 1;\n    # }\n    for i in lst:\n        freq[i] = freq.get(i, 0) + 1\n    # return freq.Values.DefaultIfEmpty(0).Max() <= 2;\n    return max(freq.values(), default=0) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.Floor(Math.Sqrt(n)); i++) {\n    for i in range(2, math.floor(math.sqrt(n)) + 1):\n        # if (n % i == 0) {\n        #     return false;\n        # }\n        if n % i == 0:\n            return False\n    # return true;\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # var l = Math.Max(interval1[0], interval2[0]);\n    l = max(interval1[0], interval2[0])\n    # var r = Math.Min(interval1[1], interval2[1]);\n    r = min(interval1[1], interval2[1])\n    # var length = r - l;\n    length = r - l\n    # return length > 0 && IsPrime(length) ? \"YES\" : \"NO\";\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if (arr.Count == 0) {\n    if len(arr) == 0:\n        # return null;\n        return None\n    # if (arr.Contains(0)) {\n    if 0 in arr:\n        # return 0;\n        return 0\n    # int sign = arr.Where(n => n < 0).Count() % 2 == 1 ? -1 : 1;\n    sign = -1 if arr.count(n => n < 0) % 2 == 1 else 1\n    # return sign * arr.Select(n => Math.Abs(n)).Sum();\n    return sign * sum(map(abs, arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # int n = grid.Count;\n    n = len(grid)\n    # int minVal = n * n + 1;\n    min_val = n * n + 1\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # for (int j = 0; j < n; j++) {\n        for j in range(n):\n            # if (grid[i][j] == 1) {\n            if grid[i][j] == 1:\n                # List<int> temp = new List<int>();\n                temp = []\n                # if (i != 0) {\n                if i != 0:\n                    # temp.Add(grid[i - 1][j]);\n                    temp.append(grid[i - 1][j])\n                # if (j != 0) {\n                if j != 0:\n                    # temp.Add(grid[i][j - 1]);\n                    temp.append(grid[i][j - 1])\n                # if (i != n - 1) {\n                if i != n - 1:\n                    # temp.Add(grid[i + 1][j]);\n                    temp.append(grid[i + 1][j])\n                # if (j != n - 1) {\n                if j != n - 1:\n                    # temp.Add(grid[i][j + 1]);\n                    temp.append(grid[i][j + 1])\n                # minVal = temp.Min();\n                min_val = min(temp)\n    # List<int> result = new List<int>();\n    result = []\n    # for (int i = 0; i < k; i++) {\n    for i in range(k):\n        # result.Add(i % 2 == 0 ? 1 : minVal);\n        result.append(1 if i % 2 == 0 else min_val)\n    # return result;\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if (n == 0) {\n    if n == 0:\n        # return new List<int> { 1 };\n        return [1]\n    # List<int> seq = new List<int> { 1, 3 };\n    seq = [1, 3]\n    # for (int i = 2; i <= n; i++) {\n    for i in range(2, n + 1):\n        # if (i % 2 == 0) {\n        if i % 2 == 0:\n            # seq.Add(i / 2 + 1);\n            seq.append(i // 2 + 1)\n        # else {\n        else:\n            # seq.Add(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) // 2)\n    # return seq;\n    return seq\n",
            "def digits(n: int) -> int:\n    # var odds = n.ToString().Where(d => char.GetNumericValue(d) % 2 == 1).Select(d => (int)char.GetNumericValue(d)).ToList();\n    odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    # return odds.Count > 0 ? odds.Aggregate((x, y) => x * y) : 0;\n    return 0 if len(odds) == 0 else reduce(lambda x, y: x * y, odds)\n",
            "def is_nested(s: str) -> bool:\n    # List<int> openIdx = new List<int>();\n    open_idx = []\n    # List<int> closeIdx = new List<int>();\n    close_idx = []\n    # for (int i = 0; i < s.Length; i++) {\n    for i in range(len(s)):\n        # switch (s[i]) {\n        #     case '[':\n        #         openIdx.Add(i); break;\n        #     case ']':\n        #         closeIdx.Add(i); break;\n        # }\n        if s[i] == '[':\n            open_idx.append(i)\n        elif s[i] == ']':\n            close_idx.append(i)\n    # closeIdx.Reverse();\n    close_idx.reverse()\n    # int cnt = 0;\n    cnt = 0\n    # int i0 = 0;\n    i0 = 0\n    # int l = closeIdx.Count;\n    l = len(close_idx)\n    # foreach (int idx in openIdx) {\n    #     if (i0 < l && idx < closeIdx[i0]) {\n    #         cnt++;\n    #         i0++;\n    #     }\n    # }\n    for idx in open_idx:\n        if i0 < l and idx < close_idx[i0]:\n            cnt += 1\n            i0 += 1\n    # return cnt >= 2;\n    return cnt >= 2\n",
            "def sum_squares(lst: List[float]) -> int:\n    # return lst.Select(n => (int)Math.Pow(Math.Ceiling(n), 2)).Sum();\n    return sum(int(pow(ceil(n), 2)) for n in lst)\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if (string.IsNullOrEmpty(txt)) {\n    if not txt:\n        # return false;\n        return False\n    # string last = txt.Substring(txt.LastIndexOf(' ') + 1);\n    last = txt.split(' ')[-1]\n    # return last.Length == 1 && char.IsLetter(last[0]);\n    return len(last) == 1 and last[0].isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if (arr.Count <= 1) {\n    if len(arr) <= 1:\n        # return -1;\n        return -1\n    # var idx = Enumerable.Range(1, arr.Count - 1).Where(i => arr[i] < arr[i - 1]);\n    idx = chain.from_iterable(range(1, len(arr) - 1), filter(lambda i: arr[i] < arr[i - 1]))\n    # return idx.DefaultIfEmpty(-1).Max();\n    return max(idx, default=-1)\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # var neg = lst.Where(i => i < 0).ToList();\n    neg = [i for i in lst if i < 0]\n    # var pos = lst.Where(i => i > 0).ToList();\n    pos = [i for i in lst if i > 0]\n    # int? maxNeg =  neg.Count > 0 ? neg.Max() : null;\n    max_neg = max(neg) if neg else None\n    # int? minPos = pos.Count > 0 ? pos.Min() : null;\n    min_pos = min(pos) if pos else None\n    # return new List<int?> { maxNeg, minPos };\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: object) -> float:\n    # if (o is string) {\n    if isinstance(o, str):\n        # return double.Parse(((string)o).Replace(\",\", \".\"));\n        return float(o.replace(\",\", \".\"))\n    # }\n    # else if (o is int) {\n    elif isinstance(o, int):\n        # return (double)(int)o;\n        return float(o)\n    # }\n    # else if (o is double) {\n    elif isinstance(o, float):\n        # return (double)o;\n        return o\n    # }\n    # throw new Exception(\"Type Error\");\n    raise Exception(\"Type Error\")\ndef compare_one(a: object, b: object) -> Optional[float]:\n    # double a1 = AnyToReal(a);\n    a1 = any_to_real(a)\n    # double b1 = AnyToReal(b);\n    b1 = any_to_real(b)\n    # if (a1 == b1) {\n    if a1 == b1:\n        # return null;\n        return None\n    # }\n    # else if (a1 > b1) {\n    elif a1 > b1:\n        # return a1;\n        return a1\n    # }\n    # else {\n    else:\n        # return b1;\n        return b1\n    # }\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return n % 2 == 0 && n >= 8;\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # int fact = 1;\n    fact = 1\n    # int result = 1;\n    result = 1\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # fact *= i;\n        fact *= i\n        # result *= fact;\n        result *= fact\n    # return result;\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return Regex.Replace(txt, @\"\\s{3,}\", \"-\").Replace(\" \", \"_\");\n    return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n",
            "def file_name_check(file_name: str) -> str:\n    # var suf = new List<string> { \"txt\", \"exe\", \"dll\" };\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # var lst = fileName.Split('.');\n    lst = file_name.split('.')\n    # if (lst.Length != 2 || !suf.Contains(lst[1]) || lst[0].Length == 0 || !char.IsLetter(lst[0][0]) || lst[0].Count(x => char.IsDigit(x)) > 3) {\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or lst[0].count(lambda x: x.isdigit()) > 3:\n        # return \"No\";\n        return \"No\"\n    # return \"Yes\";\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # int result = 0;\n    result = 0\n    # for (int i = 0; i < lst.Count; i++) {\n    for i in range(len(lst)):\n        # if (i % 3 == 0) {\n        if i % 3 == 0:\n            # result += (int)Math.Pow(lst[i], 2);\n            result += int(math.pow(lst[i], 2))\n        # else if (i % 4 == 0) {\n        elif i % 4 == 0:\n            # result += (int)Math.Pow(lst[i], 3);\n            result += int(math.pow(lst[i], 3))\n        # else {\n        else:\n            # result += lst[i];\n            result += lst[i]\n    # return result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.Floor(Math.Sqrt(n)); i++) {\n    for i in range(2, math.floor(math.sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # var words = sentence.Split(\" \");\n    words = sentence.split(\" \")\n    # return string.Join(\" \", words.Where(w => IsPrime(w.Length)));\n    return \" \".join(w for w in words if is_prime(len(w)))\n",
            "def simplify(x: str, n: str) -> bool:\n    # var xs = x.Split('/');\n    xs = x.split('/')\n    # var ns = n.Split('/');\n    ns = n.split('/')\n    # var num = int.Parse(xs[0]) * int.Parse(ns[0]);\n    num = int(xs[0]) * int(ns[0])\n    # var den = int.Parse(xs[1]) * int.Parse(ns[1]);\n    den = int(xs[1]) * int(ns[1])\n    # return num % den == 0;\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # string nStr = n.ToString();\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return nStr.Select(d => int.Parse(d.ToString())).Sum();\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return int.Parse(nStr.Substring(0, 2)) * 2 + DigitsSum(Math.Abs(n));\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# }\ndef order_by_points(nums: List[int]) -> List[int]:\n    # return nums.OrderBy(n => DigitsSum(n)).ToList();\n    return sorted(nums, key=digits_sum)\n",
            "def special_filter(nums: List[int]) -> int:\n    # string odds = \"13579\";\n    odds = \"13579\"\n    # return nums.Where(n => n > 10 && n % 2 == 1 && odds.Contains(n.ToString()[0])).Count();\n    return len([n for n in nums if n > 10 and n % 2 == 1 and odds[0] in str(n)])\n",
            "def get_max_triples(n: int) -> int:\n    # int[] c = {0, 0, 0};\n    c = [0, 0, 0]\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # int a = i * i - i + 1;\n        a = i * i - i + 1\n        # c[a % 3] += 1;\n        c[a % 3] += 1\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6;\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # List<string> names = new List<string>() {\n    #     \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    # };\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if (!names.Contains(planet1) || !names.Contains(planet2)) {\n    if planet1 not in names or planet2 not in names:\n        # return new List<string>();\n        return []\n    # int l = names.IndexOf(planet1);\n    l = names.index(planet1)\n    # int r = names.IndexOf(planet2);\n    r = names.index(planet2)\n    # if (l > r) {\n    if l > r:\n        # (l, r) = (r, l);\n        l, r = r, l\n    # if (l == r) {\n    if l == r:\n        # return new List<string>();\n        return []\n    # return names.GetRange(l + 1, r - l - 1);\n    return names[l + 1:r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # var result = lst.Where(s => s.Length % 2 == 0).ToList();\n    result = [s for s in lst if len(s) % 2 == 0]\n    # return result.OrderBy(s => s.Length).ThenBy(s => s, StringComparer.Ordinal).ToList();\n    return sorted(result, key=lambda s: (len(s), s))\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if (n < 2) {\n    if n < 2:\n        # return y;\n        return y\n    # for (int i = 2; i <= Math.Floor(Math.Sqrt(n)); i++) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return y;\n            return y\n    # return x;\n    return x\n",
            "def double_the_difference(lst: List[float]) -> int:\n    # return lst.Where(n => n >= 0 && n % 2 == 1).Select(n => (int)(n * n)).Sum();\n    return sum(int(n * n) for n in lst if n >= 0 and n % 2 == 1)\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # return game.Zip(guess, (x, y) => Math.Abs(x - y)).ToList();\n    return [fabs(x - y) for x, y in zip(game, guess)]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # int maxS = int.MinValue;\n    max_s = -1\n    # string maxExt = \"\";\n    max_ext = \"\"\n    # foreach (string ext in extensions) {\n    for ext in extensions:\n        # int upper = ext.Count(c => char.IsUpper(c));\n        upper = sum(1 for c in ext if c.isupper())\n        # int lower = ext.Count(c => char.IsLower(c));\n        lower = sum(1 for c in ext if c.islower())\n        # int s = upper - lower;\n        s = upper - lower\n        # if (s > maxS) {\n        if s > max_s:\n            # maxS = s;\n            max_s = s\n            # maxExt = ext;\n            max_ext = ext\n    # return $\"{className}.{maxExt}\";\n    return f\"{class_name}.{max_ext}\"\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if (a.Length < b.Length) {\n    if len(a) < len(b):\n        # return false;\n        return False\n    # for (int i = 0; i < b.Length; i++) {\n    for i in range(len(b)):\n        # if (a.Contains(b.Substring(i) + b.Substring(0, i))) {\n        if b[i:] + b[:i] in a:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # string ds = Math.Abs(num).ToString();\n    ds = str(abs(num))\n    # int even = ds.Count(d => d % 2 == 0);\n    even = sum(1 for d in ds if d % 2 == 0)\n    # return new List<int> { even, ds.Length - even };\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, \n    #                                  10, 9, 5, 4, 1};\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, \n                                  10, 9, 5, 4, 1]\n    # string[] numerals = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \n    #                                          \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \n                                          \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # StringBuilder res = new StringBuilder();\n    res = \"\"\n    # for (int i = 0; i < values.Length; i++) {\n    for i in range(len(values)):\n        # while (num >= values[i]) {\n        while num >= values[i]:\n            # res.Append(numerals[i]);\n            res += numerals[i]\n            # num -= values[i];\n            num -= values[i]\n    # return res.ToString();\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # int[] s = {a, b, c};\n    s = [a, b, c]\n    # Array.Sort(s);\n    s.sort()\n    # return s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # int maxCnt = 0;\n    max_cnt = 0\n    # string maxW = \"\";\n    max_w = \"\"\n    # foreach (string w in words) {\n    for w in words:\n        # int cnt = w.Distinct().Count();\n        cnt = len(set(w))\n        # if (cnt > maxCnt) {\n        if cnt > max_cnt:\n            # maxCnt = cnt;\n            max_cnt = cnt\n            # maxW = w;\n            max_w = w\n        # else if (cnt == maxCnt) {\n        elif cnt == max_cnt:\n            # maxW = string.CompareOrdinal(maxW, w) < 0 ? maxW : w;\n            max_w = max_w if max_w < w else w\n    # return maxW;\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if (need <= remaining) {\n    if need <= remaining:\n        # return new List<int> { num + need, remaining - need };\n        return [num + need, remaining - need]\n    # else {\n    else:\n        # return new List<int> { num + remaining, 0 };\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # List<string> ops = new List<string>(operators);\n    ops = list(operators)\n    # List<int> nums = new List<int>(operands);\n    nums = list(operands)\n    # int i = ops.Count - 1;\n    i = len(ops) - 1\n    # while (i >= 0) {\n    while i >= 0:\n        # if (ops[i] == \"**\") {\n        if ops[i] == \"**\":\n            # nums[i] = (int) Math.Pow(nums[i], nums[i + 1]);\n            nums[i] = int(nums[i] ** nums[i + 1])\n            # nums.RemoveAt(i + 1);\n            nums.pop(i + 1)\n            # ops.RemoveAt(i);\n            ops.pop(i)\n        # i -= 1;\n        i -= 1\n    # i = 0;\n    i = 0\n    # while (i < ops.Count) {\n    while i < len(ops):\n        # if (ops[i] == \"*\") {\n        if ops[i] == \"*\":\n            # nums[i] = nums[i] * nums[i + 1];\n            nums[i] = nums[i] * nums[i + 1]\n            # nums.RemoveAt(i + 1);\n            nums.pop(i + 1)\n            # ops.RemoveAt(i);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if (ops[i] == \"//\") {\n        elif ops[i] == \"//\":\n            # nums[i] = nums[i] / nums[i + 1];\n            nums[i] = nums[i] / nums[i + 1]\n            # nums.RemoveAt(i + 1);\n            nums.pop(i + 1)\n            # ops.RemoveAt(i);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # i = 0;\n    i = 0\n    # while (i < ops.Count) {\n    while i < len(ops):\n        # if (ops[i] == \"+\") {\n        if ops[i] == \"+\":\n            # nums[i] = nums[i] + nums[i + 1];\n            nums[i] = nums[i] + nums[i + 1]\n            # nums.RemoveAt(i + 1);\n            nums.pop(i + 1)\n            # ops.RemoveAt(i);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if (ops[i] == \"-\") {\n        elif ops[i] == \"-\":\n            # nums[i] = nums[i] - nums[i + 1];\n            nums[i] = nums[i] - nums[i + 1]\n            # nums.RemoveAt(i + 1);\n            nums.pop(i + 1)\n            # ops.RemoveAt(i);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # return nums[0];\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if (!s.Any(char.IsLetter) ) {\n    if not any(char.isalpha(ch) for ch in s):\n        # return new string(s.Reverse().ToArray());\n        return ''.join(reversed(s))\n    # StringBuilder result = new StringBuilder();\n    result = []\n    # foreach (char ch in s) {\n    for ch in s:\n        # if (!char.IsLetter(ch) ) {\n        if not char.isalpha(ch):\n            # result.Append(ch);\n            result.append(ch)\n        # else if (char.IsUpper(ch) ) {\n        elif char.isupper(ch):\n            # result.Append(char.ToLower(ch) );\n            result.append(ch.lower() )\n        # else if (char.IsLower(ch) ) {\n        elif char.islower(ch):\n            # result.Append(char.ToUpper(ch) );\n            result.append(ch.upper() )\n    # return result.ToString();\n    return ''.join(result)\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if (string.IsNullOrEmpty(txt)) {\n    if not txt:\n        # return null;\n        return None\n    # using (MD5 md5Hash = MD5.Create()) {\n    md5 = hashlib.md5()\n    # byte[] txtBytes = Encoding.UTF8.GetBytes(txt);\n    txt_bytes = txt.encode('utf-8')\n    # byte[] hashBytes = md5Hash.ComputeHash(txtBytes);\n    hash_bytes = md5.update(txt_bytes)\n    # String md5Encoded = string.Join(\"\", hashBytes.Select(b => b.ToString(\"x2\")).ToList());\n    md5_encoded = ''.join([\"{:02x}\".format(b) for b in hash_bytes])\n    # return md5Encoded;\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # int lower = Math.Max(2, Math.Min(a, b));\n    lower = max(2, min(a, b))\n    # int upper = Math.Min(8, Math.Max(a, b));\n    upper = min(8, max(a, b))\n    # if (lower > upper) {\n    if lower > upper:\n        # return new List<int>();\n        return []\n    # return Enumerable.Range(lower, upper - lower + 1).Where(n => n % 2 == 0).ToList();\n    return [n for n in range(lower, upper + 1) if n % 2 == 0]\n"
        ]
    },
    "dart": {
        "python": [
            "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # for (int i = 0; i < numbers.length; i++) {\n    for i in range(len(numbers)):\n        # for (int j = i + 1; j < numbers.length; j++) {\n        for j in range(i + 1, len(numbers)):\n            # if ((numbers[i] - numbers[j]).abs() < threshold) {\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true;\n                return True\n    # return false;\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # List<String> groups = [];\n    groups = []\n    # List<String> stk = [];\n    stk = []\n    # String currentGroup = \"\";\n    current_group = \"\"\n    # String parens = parenString.replaceAll(\" \", \"\");\n    parens = paren_string.replace(\" \", \"\")\n    # for (var ch in parens.split(\"\")) {\n    for ch in parens.split(\"\"):\n        # if (ch == \"(\") {\n        if ch == \"(\":\n            # stk.add(ch);\n            stk.append(ch)\n            # currentGroup += ch;\n            current_group += ch\n        # } else if (ch == \")\") {\n        elif ch == \")\":\n            # stk.removeLast();\n            stk.pop()\n            # currentGroup += ch;\n            current_group += ch\n            # if (stk.isEmpty) {\n            if not stk:\n                # groups.add(currentGroup);\n                groups.append(current_group)\n                # currentGroup = \"\";\n                current_group = \"\"\n    # return groups;\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return num - num.floor();\n    return num - num.floor()\n",
            "def below_zero(operations: List[int]) -> bool:\n    # int balance = 0;\n    balance = 0\n    # for (int op in operations) {\n    for op in operations:\n        # balance += op;\n        balance += op\n        # if (balance < 0) {\n        if balance < 0:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # double mean = numbers.reduce((a, b) => a + b) / numbers.length;\n    mean = sum(numbers) / len(numbers)\n    # double deviation = numbers.map((x) => (x - mean).abs()).reduce((a, b) => a + b);\n    deviation = sum(abs(x - mean) for x in numbers)\n    # return deviation / numbers.length;\n    return deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # List<int> result = [];\n    result = []\n    # for (int i = 0; i < numbers.length; i++) {\n    for i in range(len(numbers)):\n        # if (i != 0) {\n        if i != 0:\n            # result.add(delimiter);\n            result.append(delimiter)\n        # result.add(numbers[i]);\n        result.append(numbers[i])\n    # return result;\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # List<int> result = [];\n    result = []\n    # List<String> parenGroups = parenString.split(\" \").where((s) => s.isNotEmpty).toList();\n    paren_groups = paren_string.split(\" \")\n    paren_groups = [g for g in paren_groups if g]\n    # for (String group in parenGroups) {\n    for group in paren_groups:\n        # int maxDepth = 0;\n        max_depth = 0\n        # int depth = 0;\n        depth = 0\n        # for (var ch in group.split(\"\")) {\n        for ch in group.split(\"\"):\n            # if (ch == \"(\") {\n            if ch == \"(\":\n                # depth += 1;\n                depth += 1\n                # maxDepth = max(maxDepth, depth);\n                max_depth = max(max_depth, depth)\n            # } else if (ch == \")\") {\n            elif ch == \")\":\n                # depth -= 1;\n                depth -= 1\n        # result.add(maxDepth);\n        result.append(max_depth)\n    # return result;\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # return strs.where((s) => s.contains(substring)).toList();\n    return [s for s in strs if substring in s]\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # int nSum = numbers.fold(0, (a, b) => a + b);\n    n_sum = sum(numbers)\n    # int nProduct = numbers.fold(1, (a, b) => a * b);\n    n_product = 1\n    for n in numbers:\n        n_product *= n\n    # return [nSum, nProduct];\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # int maxSoFar = -double.maxFinite.toInt();\n    max_so_far = -float('inf')\n    # List<int> result = [];\n    result = []\n    # for (int num in numbers) {\n    for num in numbers:\n        # maxSoFar = max(maxSoFar, num);\n        max_so_far = max(max_so_far, num)\n        # result.add(maxSoFar);\n        result.append(max_so_far)\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == s.split('').reversed.join('');\n    return s == ''.join(reversed(s.split('')))\ndef make_palindrome(s: str) -> str:\n    # if (isPalindrome(s)) {\n    if is_palindrome(s):\n        # return s;\n        return s\n    # for (int i = 0; i < s.length; i++) {\n    for i in range(len(s)):\n        # if (isPalindrome(s.substring(i))) {\n        if is_palindrome(s[i:]):\n            # return s + s.substring(0, i).split('').reversed.join('');\n            return s + ''.join(reversed(s[:i].split('')))\n    # return \"\";\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # return IterableZip([a.split(\"\"), b.split(\"\")]).map((x) => x[0] == x[1] ? \"0\" : \"1\").join(\"\");\n    return \"\".join([\"0\" if x[0] == x[1] else \"1\" for x in zip(a.split(\"\"), b.split(\"\"))])\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if (strs.isEmpty) {\n    if not strs:\n        # return null;\n        return None\n    # String longestS = strs[0];\n    longest_s = strs[0]\n    # for (String s in strs) {\n    for s in strs:\n        # if (s.length > longestS.length) {\n        if len(s) > len(longest_s):\n            # longestS = s;\n            longest_s = s\n    # return longestS;\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if (b == 0) {\n    if b == 0:\n        # return a;\n        return a\n    # else {\n    else:\n        # return greatestCommonDivisor(b, a % b);\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # List<String> prefixes = [];\n    prefixes = []\n    # for (int i = 0; i < s.length; i++) {\n    for i in range(len(s)):\n        # prefixes.add(s.substring(0, i + 1));\n        prefixes.append(s[:i + 1])\n    # return prefixes;\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # return List.generate(n + 1, (i) => i.toString()).join(\" \");\n    return \" \".join(str(i) for i in range(n + 1))\n",
            "def count_distinct_characters(s: str) -> int:\n    # return s.toLowerCase().split('').toSet().length;\n    return len(set(s.lower().split('')))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # Map<String, int> durations = {\"o\": 4, \"o|\": 2, \".|\": 1};\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    # List<String> notes = musicString.split(\" \").where((s) => s.isNotEmpty).toList();\n    notes = [s for s in music_string.split(\" \") if s]\n    # return notes.map((note) => durations[note]!).toList();\n    return [durations[note] for note in notes]\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # int times = 0;\n    times = 0\n    # for (int i = 0; i <= s.length - substring.length; i++) {\n    for i in range(s.length - substring.length + 1):\n        # if (s.substring(i, min(i + substring.length, s.length)) == substring) {\n        if s[i:min(i + substring.length, s.length)] == substring:\n            # times += 1;\n            times += 1\n    # return times;\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # Map<String, int> numDict = {\n    num_dict = {\n        # \"zero\": 0,\n        \"zero\": 0,\n        # \"one\": 1,\n        \"one\": 1,\n        # \"two\": 2,\n        \"two\": 2,\n        # \"three\": 3,\n        \"three\": 3,\n        # \"four\": 4,\n        \"four\": 4,\n        # \"five\": 5,\n        \"five\": 5,\n        # \"six\": 6,\n        \"six\": 6,\n        # \"seven\": 7,\n        \"seven\": 7,\n        # \"eight\": 8,\n        \"eight\": 8,\n        # \"nine\": 9,\n        \"nine\": 9,\n    }\n    # List<String> numList = numbers.split(\" \").where((x) => numDict.containsKey(x)).toList();\n    num_list = [x for x in numbers.split(\" \") if x in num_dict]\n    # numList.sort((a, b) => numDict[a]! - numDict[b]!);\n    num_list.sort(key=lambda x: num_dict[x])\n    # return numList.join(\" \");\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[float]) -> List[float]:\n    # List<double> sortedNumbers = numbers.toList()..sort();\n    sorted_numbers = sorted(numbers)\n    # double minDiff = double.infinity;\n    min_diff = float('inf')\n    # List<double> closestPair = [];\n    closest_pair = []\n    # for (int i = 1; i < sortedNumbers.length; i++) {\n    for i in range(1, len(sorted_numbers)):\n        # double diff = sortedNumbers[i] - sortedNumbers[i - 1];\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if (diff < minDiff) {\n        if diff < min_diff:\n            # minDiff = diff;\n            min_diff = diff\n            # closestPair = [sortedNumbers[i - 1], sortedNumbers[i]];\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return closestPair;\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # double minNum = numbers.reduce(min);\n    min_num = min(numbers)\n    # double maxNum = numbers.reduce(max);\n    max_num = max(numbers)\n    # if (minNum == maxNum) {\n    if min_num == max_num:\n        # return List<double>.filled(numbers.length, 0.0);\n        return [0.0] * len(numbers)\n    # } else {\n    else:\n        # return numbers.map((num) => (num - minNum) / (maxNum - minNum)).toList();\n        return [(num - min_num) / (max_num - min_num) for num in numbers]\n",
            "def filter_integers(values: List[object]) -> List[int]:\n    # return values.whereType<int>().toList();\n    return [v for v in values if isinstance(v, int)]\n",
            "def str_length(s: str) -> int:\n    # return s.length;\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for (int i = 2; i < n; i++) {\n    for i in range(2, n):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return n ~/ i;\n            return n // i\n    # return 1;\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # List<int> factors = [];\n    factors = []\n    # int divisor = 2;\n    divisor = 2\n    # while (divisor <= n) {\n    while divisor <= n:\n        # if (n % divisor == 0) {\n        if n % divisor == 0:\n            # factors.add(divisor);\n            factors.append(divisor)\n            # n ~/= divisor;\n            n //= divisor\n        else:\n            # divisor += 1;\n            divisor += 1\n    # return factors;\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # Map<int, int> counts = {};\n    counts = {}\n    # for (int num in numbers) {\n    for num in numbers:\n        # counts[num] = (counts[num] ?? 0) + 1;\n        counts[num] = counts.get(num, 0) + 1\n    # List<int> res = numbers.where((num) => counts[num] == 1).toList();\n    res = [num for num in numbers if counts[num] == 1]\n    # return res;\n    return res\n",
            "def flip_case(s: str) -> str:\n    # StringBuffer flipped = StringBuffer();\n    flipped = \"\"\n    # for (var ch in s.split(\"\")) {\n    for ch in s.split(\"\"):\n        # if (!ch.contains(RegExp(r'[a-zA-Z]'))) {\n        if not ch.isalpha():\n            # flipped.write(ch);\n            flipped += ch\n        # } else if (ch.contains(RegExp(r'[a-z]'))) {\n        elif ch.islower():\n            # flipped.write(ch.toUpperCase());\n            flipped += ch.upper()\n        # } else if (ch.contains(RegExp(r'[A-Z]'))) {\n        elif ch.isupper():\n            # flipped.write(ch.toLowerCase());\n            flipped += ch.lower()\n    # return flipped.toString();\n    return flipped\n",
            "def concatenate(strs: List[str]) -> str:\n    # return strs.join(\"\");\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # return strs.where((s) => s.startsWith(prefixStr)).toList();\n    return [s for s in strs if s.startswith(prefix_str)]\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # return l.where((num) => num > 0).toList();\n    return [num for num in l if num > 0]\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= sqrt(n).floor(); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def poly(xs: List[int], x: float) -> float:\n    # double res = 0;\n    res = 0\n    # for (int i = 0; i < xs.length; i++) {\n    for i in range(len(xs)):\n        # res += xs[i] * pow(x, i);\n        res += xs[i] * pow(x, i)\n    # return res;\n    return res\ndef find_zero(xs: List[int]) -> float:\n    # double x1 = 1.0, x2 = -1.0;\n    x1 = 1.0\n    x2 = -1.0\n    # while (poly(xs, x1) * poly(xs, x2) > 0) {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2;\n        x1 *= 2\n        # x2 *= 2;\n        x2 *= 2\n    # while ((x1 - x2).abs() > 1e-10) {\n    while (x1 - x2).abs() > 1e-10:\n        # double mid = (x1 + x2) / 2;\n        mid = (x1 + x2) / 2\n        # if (poly(xs, mid) == 0) {\n        if poly(xs, mid) == 0:\n            # return mid;\n            return mid\n        # else if (poly(xs, mid) * poly(xs, x1) < 0) {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid;\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid;\n            x1 = mid\n    # return (x1 + x2) / 2;\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # var sortedThird = l.whereIndexed((i, x) => i % 3 == 0).toList()..sort();\n    sorted_third = sorted([x for i, x in enumerate(l) if i % 3 == 0])\n    # return l.mapIndexed((i, x) => (i % 3 == 0) ? sortedThird[i ~/ 3] : x).toList();\n    return [sorted_third[i // 3] if i % 3 == 0 else x for i, x in enumerate(l)]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # return l.toSet().toList()..sort();\n    return sorted(set(l))\n",
            "def max_element(l: List[int]) -> int:\n    # if (l.isEmpty) {\n    if not l:\n        # return 0;\n        return 0\n    # return l.reduce(max);\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # if (i % 11 == 0 || i % 13 == 0) {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += \"7\".allMatches(i.toString()).length;\n            cnt += len(\"7\".join(str(i)))\n    # return cnt;\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # var sortedEven = l.whereIndexed((i, x) => i % 2 == 0).toList()..sort();\n    sorted_even = sorted([x for i, x in enumerate(l) if i % 2 == 0])\n    # return l.mapIndexed((i, x) => (i % 2 == 0) ? sortedEven[i ~/ 2] : x).toList();\n    return [sorted_even[i // 2] if i % 2 == 0 else x for i, x in enumerate(l)]\n",
            "def encode_cyclic(s: str) -> str:\n    # var result = StringBuffer();\n    result = ''\n    # for (int i = 0; i < s.length; i += 3) {\n    for i in range(0, len(s), 3):\n        # if (i + 3 > s.length) {\n        if i + 3 > len(s):\n            # result.write(s.substring(i));\n            result += s[i:]\n        else:\n            # result.write(s.substring(i + 1, i + 3));\n            result += s[i + 1:i + 3]\n            # result.write(s[i]);\n            result += s[i]\n    # return result.toString();\n    return result\ndef decode_cyclic(s: str) -> str:\n    # return encodeCyclic(encodeCyclic(s));\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= sqrt(n).floor(); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef prime_fib(n: int) -> int:\n    # List<int> f = [0, 1];\n    f = [0, 1]\n    # int cnt = 0;\n    cnt = 0\n    # while (cnt < n) {\n    while cnt < n:\n        # f = [f[1], f[0] + f[1]];\n        f = [f[1], f[0] + f[1]]\n        # if (isPrime(f[1])) {\n        if is_prime(f[1]):\n            # cnt++;\n            cnt += 1\n    # return f[1];\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for (int i = 0; i < l.length; i++) {\n    for i in range(len(l)):\n        # for (int j = i + 1; j < l.length; j++) {\n        for j in range(i + 1, len(l)):\n            # for (int k = j + 1; k < l.length; k++) {\n            for k in range(j + 1, len(l)):\n                # if (l[i] + l[j] + l[k] == 0) {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true;\n                    return True\n    # return false;\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return pow(n, 2).toInt();\n    return int(pow(n, 2))\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # return l.map((i) => i + 1).toList();\n    return [i + 1 for i in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # Set<int> seen = {};\n    seen = set()\n    # for (int num in l) {\n    for num in l:\n        # if (seen.contains(-num)) {\n        if -num in seen:\n            # return true;\n            return True\n        # seen.add(num);\n        seen.add(num)\n    # return false;\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if (x == 0) {\n    if x == 0:\n        # return \"0\";\n        return \"0\"\n    # List<String> digits = [];\n    digits = []\n    # while (x > 0) {\n    while x > 0:\n        # digits.add((x % bas).toString());\n        digits.append(str(x % bas))\n        # x ~/= bas;\n        x //= bas\n    # return digits.reversed.join();\n    return \"\".join(reversed(digits))\n",
            "def triangle_area(a: int, h: int) -> float:\n    # return a * h / 2;\n    return a * h / 2\n",
            "def fib4(n: int) -> int:\n    # List<int> fib = [0, 0, 2, 0];\n    fib = [0, 0, 2, 0]\n    # for (int i = 4; i <= n; i++) {\n    for i in range(4, n + 1):\n        # fib[i % 4] = fib.reduce((a, b) => a + b);\n        fib[i % 4] = sum(fib)\n    # return fib[n % 4];\n    return fib[n % 4]\n",
            "def median(l: List[float]) -> float:\n    # List<double> sl = [...l]..sort();\n    sl = sorted(l)\n    # if (l.length % 2 != 0) {\n    if len(l) % 2 != 0:\n        # return sl[l.length ~/ 2];\n        return sl[len(l) // 2]\n    # } else {\n    else:\n        # return (sl[l.length ~/ 2] + sl[l.length ~/ 2 - 1]) / 2;\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt == txt.split('').reversed.join('');\n    return txt == txt[::-1]\n",
            "def modp(n: int, p: int) -> int:\n    # int ret = 1;\n    ret = 1\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # ret = (ret * 2) % p;\n        ret = (ret * 2) % p\n    # return ret;\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # var result = s.runes.map((ch) => ((ch - 97 + 5) % 26) + 97);\n    result = [((ch - 97 + 5) % 26) + 97 for ch in s]\n    # return String.fromCharCodes(result);\n    return ''.join(chr(ch) for ch in result)\ndef decode_shift(s: str) -> str:\n    # var result = s.runes.map((ch) => ((ch - 97 - 5) % 26) + 97);\n    result = [((ch - 97 - 5) % 26) + 97 for ch in s]\n    # return String.fromCharCodes(result);\n    return ''.join(chr(ch) for ch in result)\n",
            "def remove_vowels(txt: str) -> str:\n    # String vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # return txt.split('').where((char) => !vowels.contains(char)).join('');\n    return ''.join([char for char in txt if char not in vowels])\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # return l.every((x) => x < t);\n    return all(x < t for x in l)\n",
            "def add(x: int, y: int) -> int:\n    # return x + y;\n    return x + y\n",
            "",
            "def fib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return n;\n        return n\n    # } else {\n    else:\n        # return fib(n - 1) + fib(n - 2);\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # for (String b in brackets.split(\"\")) {\n    for b in brackets.split(\"\"):\n        # if (b == \"<\") {\n        if b == \"<\":\n            # depth += 1;\n            depth += 1\n        # } else if (b == \">\") {\n        elif b == \">\":\n            # depth -= 1;\n            depth -= 1\n        # }\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n        # }\n    # return depth == 0;\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # var diff = IterableZip([l, l.skip(1)]).map((x) => x[1] - x[0]);\n    diff = [x[1] - x[0] for x in zip_longest(l, l[1:])]\n    # return diff.every((x) => x <= 0) || diff.every((x) => x >= 0);\n    return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # return l1.toSet().intersection(l2.toSet()).toList()..sort();\n    return sorted(set(l1).intersection(set(l2)))\n",
            "def largest_prime_factor(n: int) -> int:\n    # int i = 2;\n    i = 2\n    # while (i * i <= n) {\n    while i * i <= n:\n        # if (n % i != 0) {\n        if n % i != 0:\n            # i += 1;\n            i += 1\n        else:\n            # n ~/= i;\n            n //= i\n    # return n;\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # return List.generate(n + 1, (i) => i).reduce((a, b) => a + b);\n    return sum(range(n + 1))\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # for (String b in brackets.split(\"\")) {\n    for b in brackets.split(\"\"):\n        # if (b == \"(\") {\n        if b == \"(\":\n            # depth += 1;\n            depth += 1\n        # } else if (b == \")\") {\n        elif b == \")\":\n            # depth -= 1;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth == 0;\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # return xs.mapIndexed((i, x) => x * i).skip(1).toList();\n    return [x * i for i, x in enumerate(xs)][1:]\n",
            "def fibfib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return 0;\n        return 0\n    # int a = 0, b = 0, c = 1;\n    a = 0\n    b = 0\n    c = 1\n    # while (n > 2) {\n    while n > 2:\n        # (a, b, c) = (b, c, a + b + c);\n        a, b, c = b, c, a + b + c\n        # n -= 1;\n        n -= 1\n    # return c;\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # String vowels = \"aeiou\";\n    vowels = \"aeiou\"\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 0; i < s.length; i++) {\n    for i in range(len(s)):\n        # if (vowels.contains(s[i].toLowerCase()) || (i == s.length - 1 && s[i].toLowerCase() == \"y\")) {\n        if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n            # cnt += 1;\n            cnt += 1\n    # return cnt;\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # String xStr = x.toString();\n    x_str = str(x)\n    # if (shift > xStr.length) {\n    if shift > len(x_str):\n        # return xStr.split('').reversed.join('');\n        return ''.join(reversed(x_str))\n    # } else {\n    #     return xStr.substring(xStr.length - shift) + xStr.substring(0, xStr.length - shift);\n    # }\n    return x_str[len(x_str) - shift:] + x_str[:len(x_str) - shift]\n",
            "def digit_sum(s: str) -> int:\n    # return s.split('').where((e) => e.contains(RegExp(r'[A-Z]'))).map((e) => e.codeUnitAt(0)).fold(0, (a, b) => a + b);\n    return sum(map(lambda e: ord(e), filter(lambda e: e.isupper(), s.split(''))))\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # List<String> words = s.split(' ');\n    words = s.split(' ')\n    # int apples = int.parse(words[words.indexOf(\"apples\") - 1]);\n    apples = int(words[words.index(\"apples\") - 1])\n    # int oranges = int.parse(words[words.indexOf(\"oranges\") - 1]);\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # return n - apples - oranges;\n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # var evens = arr.where((n) => n % 2 == 0).toList();\n    evens = [n for n in arr if n % 2 == 0]\n    # if (evens.length == 0) {\n    if len(evens) == 0:\n        # return [];\n        return []\n    # var minEven = evens.reduce((a, b) => a < b ? a : b);\n    min_even = min(evens)\n    # return [minEven, arr.indexOf(minEven)];\n    return [min_even, arr.index(min_even)]\n",
            "def search(lst: List[int]) -> int:\n    # Map<int, int> freqs = {};\n    freqs = {}\n    # for (int n in lst) {\n    for n in lst:\n        # freqs[n] = (freqs[n] ?? 0) + 1;\n        freqs[n] = freqs.get(n, 0) + 1\n    # var goodVals = freqs.entries.where((p) => p.value >= p.key).map((p) => p.key).toList();\n    good_vals = [p.key for p in freqs.items() if p.value >= p.key]\n    # return goodVals.fold(-1, max);\n    return max(good_vals, default=-1)\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # List<int> sl = List.from(lst)..sort();\n    sl = sorted(lst)\n    # List<int> result = [];\n    result = []\n    # int left = 0, right = sl.length - 1;\n    left = 0\n    right = len(sl) - 1\n    # while (left <= right) {\n    while left <= right:\n        # result.add(sl[left]);\n        result.append(sl[left])\n        # left += 1;\n        left += 1\n        # if (left <= right) {\n        if left <= right:\n            # result.add(sl[right]);\n            result.append(sl[right])\n            # right -= 1;\n            right -= 1\n    # return result;\n    return result\n",
            "def triangle_area(a: int, b: int, c: int) -> float:\n    # if (a + b > c && a + c > b && b + c > a) {\n    if a + b > c and a + c > b and b + c > a:\n        # double s = (a + b + c) / 2.0;\n        s = (a + b + c) / 2.0\n        # return sqrt(s * (s - a) * (s - b) * (s - c));\n        return sqrt(s * (s - a) * (s - b) * (s - c))\n    # } else {\n    else:\n        # return -1.0;\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if (q.length == 0) {\n    if len(q) == 0:\n        # return false;\n        return False\n    # bool isPalin = Iterable<int>.generate(q.length).every((i) => q[i] == q[q.length - i - 1]);\n    is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    # int total = q.reduce((a, b) => a + b);\n    total = sum(q)\n    # return isPalin && total <= w;\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # int ans = 0;\n    ans = 0\n    # for (int i = 0; i < arr.length ~/ 2; i++) {\n    for i in range(len(arr) // 2):\n        # if (arr[i] != arr[arr.length - i - 1]) {\n        if arr[i] != arr[len(arr) - i - 1]:\n            # ans += 1;\n            ans += 1\n    # return ans;\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # int cnt1 = lst1.fold(0, (a, b) => a + b.length);\n    cnt1 = sum(map(len, lst1))\n    # int cnt2 = lst2.fold(0, (a, b) => a + b.length);\n    cnt2 = sum(map(len, lst2))\n    # return cnt1 <= cnt2 ? lst1 : lst2;\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= sqrt(n).floor(); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 2; i <= a; i++) {\n    for i in range(2, a + 1):\n        # if (isPrime(i)) {\n        if is_prime(i):\n            # while (a % i == 0) {\n            while a % i == 0:\n                # cnt += 1;\n                cnt += 1\n                # a ~/= i;\n                a //= i\n    # return cnt == 3;\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return x == n;\n        return x == n\n    # int tmp = 1;\n    tmp = 1\n    # while (tmp < x) {\n    while tmp < x:\n        # tmp *= n;\n        tmp *= n\n    # return tmp == x;\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # a = a.abs();\n    a = abs(a)\n    # int root = pow(a, 1.0 / 3.0).round();\n    root = int(pow(a, 1.0 / 3.0))\n    # return root * root * root == a;\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # return num.split('').where((x) => \"2357BD\".contains(x)).length;\n    return len(list(filter(lambda x: x in \"2357BD\", num.split(''))))\n",
            "def decimal_to_binary(dec: int) -> str:\n    # String binary = dec.toRadixString(2);\n    binary = bin(dec)\n    # return \"db${binary}db\";\n    return \"db\" + binary + \"db\"\n",
            "def is_happy(s: str) -> bool:\n    # if (s.length < 3) {\n    if len(s) < 3:\n        # return false;\n        return False\n    # for (int i = 0; i < s.length - 2; i++) {\n    for i in range(len(s) - 2):\n        # if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # List<String> result = [];\n    result = []\n    # for (double g in grades) {\n    for g in grades:\n        # switch (g) {\n        #     case 4.0:\n        #         result.add(\"A+\");\n        if g == 4.0:\n            result.append(\"A+\")\n        #     case > 3.7:\n        #         result.add(\"A\");\n        elif g > 3.7:\n            result.append(\"A\")\n        #     case > 3.3:\n        #         result.add(\"A-\");\n        elif g > 3.3:\n            result.append(\"A-\")\n        #     case > 3.0:\n        #         result.add(\"B+\");\n        elif g > 3.0:\n            result.append(\"B+\")\n        #     case > 2.7:\n        #         result.add(\"B\");\n        elif g > 2.7:\n            result.append(\"B\")\n        #     case > 2.3:\n        #         result.add(\"B-\");\n        elif g > 2.3:\n            result.append(\"B-\")\n        #     case > 2.0:\n        #         result.add(\"C+\");\n        elif g > 2.0:\n            result.append(\"C+\")\n        #     case > 1.7:\n        #         result.add(\"C\");\n        elif g > 1.7:\n            result.append(\"C\")\n        #     case > 1.3:\n        #         result.add(\"C-\");\n        elif g > 1.3:\n            result.append(\"C-\")\n        #     case > 1.0:\n        #         result.add(\"D+\");\n        elif g > 1.0:\n            result.append(\"D+\")\n        #     case > 0.7:\n        #         result.add(\"D\");\n        elif g > 0.7:\n            result.append(\"D\")\n        #     case > 0.0:\n        #         result.add(\"D-\");\n        elif g > 0.0:\n            result.append(\"D-\")\n        #     default:\n        #         result.add(\"E\");\n        else:\n            result.append(\"E\")\n    # return result;\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # int length = s.length;\n    length = len(s)\n    # if (length < 2) {\n    if length < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= sqrt(length).floor(); i++) {\n    for i in range(2, int(sqrt(length)) + 1):\n        # if (length % i == 0) {\n        if length % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if (n == 1) {\n    if n == 1:\n        # return 1;\n        return 1\n    # return 2 * 9 * pow(10, n - 2).toInt();\n    return 2 * 9 * pow(10, n - 2)\n",
            "def solve(n: int) -> str:\n    # int digitsSum = n.toString().split('').map((d) => int.parse(d)).reduce((a, b) => a + b);\n    digits_sum = sum(map(int, str(n)))\n    # return digitsSum.toRadixString(2);\n    return bin(digits_sum)[2:]\n",
            "def add(lst: List[int]) -> int:\n    # return lst.whereIndexed((i, x) => i % 2 == 1 && x % 2 == 0).fold(0, (a, b) => a + b);\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)\n",
            "def anti_shuffle(s: str) -> str:\n    # var words = s.split(' ').map((word) => String.fromCharCodes(word.runes.toList()..sort())).toList();\n    words = [String.fromCharCodes(word.runes.toList().sort()) for word in s.split(' ')]\n    # return words.join(' ');\n    return ' '.join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # List<List<int>> coords = [];\n    coords = []\n    # for (int i = 0; i < lst.length; i++) {\n    for i in range(len(lst)):\n        # for (int j = 0; j < lst[i].length; j++) {\n        for j in range(len(lst[i])):\n            # if (lst[i][j] == x) {\n            if lst[i][j] == x:\n                # coords.add([i, j]);\n                coords.append([i, j])\n    # return coords..sort((a, b) => a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n    return sorted(coords, key=lambda a, b: a[0] == b[0] and b[1] - a[1] or a[0] - b[0])\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if (arr.length == 0) {\n    if len(arr) == 0:\n        # return [];\n        return []\n    # if ((arr[0] + arr[arr.length - 1]) % 2 == 0) {\n    if (arr[0] + arr[len(arr) - 1]) % 2 == 0:\n        # return [...arr]..sort((a, b) => b - a);\n        return sorted(arr, key=lambda a, b: b - a)\n    # } else {\n    else:\n        # return [...arr]..sort();\n        return sorted(arr)\n",
            "def encrypt(s: str) -> str:\n    # StringBuffer result = StringBuffer();\n    result = \"\"\n    # for (String ch in s.split(\"\")) {\n    for ch in s.split(\"\"):\n        # int shifted = ch.codeUnitAt(0) + 4;\n        shifted = ord(ch) + 4\n        # if (shifted > 'z'.codeUnitAt(0)) {\n        if shifted > ord('z'):\n            # shifted -= 26;\n            shifted -= 26\n        # result.writeCharCode(shifted);\n        result += chr(shifted)\n    # return result.toString();\n    return result\n",
            "def next_smallest(lst: List[int]) -> Optional[int]:\n    # List<int> sl = lst.toSet().toList()..sort();\n    sl = sorted(set(lst))\n    # if (sl.length < 2) {\n    if len(sl) < 2:\n        # return null;\n        return None\n    # return sl[1];\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # var sentences = s.split(RegExp(r\"[.!?]\\s*\"));\n    sentences = s.split(r\"[.!?]\\s*\")\n    # return sentences.where((sentence) => sentence.length >= 2 && sentence.substring(0, 2) == \"I \").length;\n    return len([sentence for sentence in sentences if len(sentence) >= 2 and sentence[:2] == \"I \"])\n",
            "def any_int(x: object, y: object, z: object) -> bool:\n    # if (x is int && y is int && z is int) {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # if ((x + y == z) || (x + z == y) || (y + z == x)) {\n        if x + y == z or x + z == y or y + z == x:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def encode(message: str) -> str:\n    # String vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # StringBuffer result = new StringBuffer();\n    result = \"\"\n    # for (String ch in message.split(\"\")) {\n    for ch in message.split(\"\"):\n        # if (ch.contains(RegExp(r'[a-zA-Z]'))) {\n        if ch.isalpha():\n            # String ch1 = ch.toUpperCase() == ch ? ch.toLowerCase() : ch.toUpperCase();\n            ch1 = ch.lower() if ch.isupper() else ch.upper()\n            # if (vowels.contains(ch1)) {\n            if ch1 in vowels:\n                # ch1 = String.fromCharCode(ch1.codeUnitAt(0) + 2);\n                ch1 = chr(ord(ch1) + 2)\n            # result.write(ch1);\n            result += ch1\n        else:\n            # result.write(ch);\n            result += ch\n    # return result.toString();\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= sqrt(n).floor(); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # List<int> primes = lst.where((n) => isPrime(n)).toList();\n    primes = [n for n in lst if is_prime(n)]\n    # if (primes.length == 0) {\n    if len(primes) == 0:\n        # return 0;\n        return 0\n    # String largest = primes.reduce((a, b) => a > b ? a : b).toString();\n    largest = max(primes)\n    # return largest.split('').map((d) => int.parse(d)).reduce((a, b) => a + b);\n    return sum([int(d) for d in largest])\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if (d.isEmpty) {\n    if not d:\n        # return false;\n        return False\n    # return d.keys.every((k) => RegExp(r'^[A-Z]+$').hasMatch(k)) || d.keys.every((k) => RegExp(r'^[a-z]+$').hasMatch(k));\n    return all(re.match(r'^[A-Z]+$', k) for k in d.keys()) or all(re.match(r'^[a-z]+$', k) for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # List<int> primes = [];\n    primes = []\n    # for (int num = 2; num < n; num++) {\n    for num in range(2, n):\n        # if (primes.every((p) => num % p != 0)) {\n        if all(num % p != 0 for p in primes):\n            # primes.add(num);\n            primes.append(num)\n    # return primes;\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # return (a.abs() % 10) * (b.abs() % 10);\n    return (abs(a) % 10) * (abs(b) % 10)\n",
            "def count_upper(s: str) -> int:\n    # String vowels = \"AEIOU\";\n    vowels = \"AEIOU\"\n    # return s.split('').whereIndexed((i, c) => i % 2 == 0 && vowels.contains(c)).length;\n    return sum(1 for i, c in enumerate(s) if i % 2 == 0 and c in vowels)\n",
            "def closest_integer(value: str) -> int:\n    # double num = double.parse(value);\n    num = float(value)\n    # if (num >= 0) {\n    if num >= 0:\n        # return (num + 0.5).toInt();\n        return int(num + 0.5)\n    # } else {\n    else:\n        # return (num - 0.5).toInt();\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # return List.generate(n, (i) => n + 2 * i);\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # return s.split(RegExp(r\"[, ]\")).where((w) => w.length > 0).toList();\n    return [w for w in s.split(\", \") if len(w) > 0]\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    if x > y:\n        # return -1;\n        return -1\n    # if (y % 2 == 0) {\n    if y % 2 == 0:\n        # return y;\n        return y\n    # return y != x ? y - 1 : -1;\n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> Optional[str]:\n    # if (n > m) {\n    if n > m:\n        # return null;\n        return None\n    # int rAvg = ((m + n) / 2.0 + 0.5).toInt();\n    r_avg = (m + n) // 2 + 1\n    # return rAvg.toRadixString(2);\n    return f'{r_avg:b}'\n",
            "def all_digits_odd(s: str) -> bool:\n    # return s.split('').every((digit) => digit.codeUnitAt(0) % 2 != 0);\n    return all(digit.encode().hex() % 2 != 0 for digit in s.split(''))\ndef unique_digits(x: List[int]) -> List[int]:\n    # return x.where((num) => allDigitsOdd(num.toString())).toList()..sort();\n    return sorted(filter(lambda num: all_digits_odd(str(num)), x))\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # List<String> digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # List<int> sortedArr = arr.where((x) => 1 <= x && x <= 9).toList()..sort((x, y) => y - x);\n    sorted_arr = sorted(filter(lambda x: 1 <= x and x <= 9, arr), reverse=True)\n    # return sortedArr.map((x) => digitNames[x - 1]).toList();\n    return [digit_names[x - 1] for x in sorted_arr]\n",
            "def f(n: int) -> List[int]:\n    # List<int> nums = List.generate(n, (i) => i + 1);\n    nums = [i + 1 for i in range(n)]\n    # return nums.map((i) => i % 2 != 0 ? nums.take(i).reduce((x, y) => x + y) : nums.take(i).reduce((x, y) => x * y)).toList();\n    return [i % 2 != 0 ? sum(nums[:i]) : reduce(lambda x, y: x * y, nums[:i]) for i in nums]\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt == txt.split('').reversed.join('');\n    return txt == txt[::-1]\ndef even_odd_palindrome(n: int) -> List[int]:\n    # List<int> cnt = [0, 0];\n    cnt = [0, 0]\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # if (isPalindrome(i.toString())) {\n        if is_palindrome(str(i)):\n            # cnt[i % 2] += 1;\n            cnt[i % 2] += 1\n    # return cnt;    \n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # String nStr = n.toString();\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return nStr.split('').map((d) => int.parse(d)).reduce((a, b) => a + b);\n        return sum(map(int, n_str.split('')))\n    # } else {\n    else:\n        # return int.parse(nStr.substring(0, 2)) * 2 + digitsSum(n.abs());\n        return int(n_str[0:2]) * 2 + digits_sum(abs(n))\n# int countNums(List<int> arr) {\ndef count_nums(arr: List[int]) -> int:\n    # return arr.where((n) => digitsSum(n) > 0).length;\n    return len(list(filter(lambda n: digits_sum(n) > 0, arr)))\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if (arr.length == 0) {\n    if len(arr) == 0:\n        # return true;\n        return True\n    # List<int> sortedArr = List.from(arr)..sort();\n    sorted_arr = sorted(arr)\n    # for (int i = 0; i < arr.length; i++) {\n    for i in range(len(arr)):\n        # if (ListEquality().equals(arr.sublist(i), sortedArr.sublist(0, arr.length - i)) && ListEquality().equals(arr.sublist(0, i), sortedArr.sublist(arr.length - i))) {\n        if ListEquality().equals(arr[i:], sorted_arr[:len(arr) - i]) and ListEquality().equals(arr[:i], sorted_arr[len(arr) - i:]):\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # int oddCnt = lst1.where((num) => num % 2 != 0).length;\n    odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    # int evenCnt = lst2.where((num) => num % 2 == 0).length;\n    even_cnt = len([num for num in lst2 if num % 2 == 0])\n    # return evenCnt >= oddCnt ? \"YES\" : \"NO\";\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # Map<String, int> freq = {};\n    freq = {}\n    # var words = test.split(\" \").where((w) => w.length > 0).toList();\n    words = [w for w in test.split(\" \") if len(w) > 0]\n    # for (var w in words) {\n    for w in words:\n        # freq[w] = (freq[w] ?? 0) + 1;\n        freq[w] = freq.get(w, 0) + 1\n    # Map<String, int> result = {};\n    result = {}\n    # if (freq.length > 0) {\n    if freq:\n        # var maxFreq = freq.values.reduce((a, b) => a > b ? a : b);\n        max_freq = max(freq.values())\n        # for (var k in freq.keys) {\n        for k in freq.keys():\n            # if (freq[k] == maxFreq) {\n            if freq[k] == max_freq:\n                # result[k] = freq[k]!;\n                result[k] = freq[k]\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == s.split('').reversed.join('');\n    return s == s[::-1]\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # String s1 = s.split('').where((ch) => !c.contains(ch)).join('');\n    s1 = ''.join(ch for ch in s if ch not in c)\n    # return [s1, isPalindrome(s1) ? \"yes\" : \"no\"];\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # List<String> result = [];\n    result = []\n    # for (String num in lst) {\n    for num in lst:\n        # int n = num.split('').where((d) => d.codeUnitAt(0) % 2 == 1).length;\n        n = len([d for d in num.split('') if d.encode('utf-8')[0] % 2 == 1])\n        # String rs = \"the number of odd elements in the string i of the input.\";\n        rs = \"the number of odd elements in the string i of the input.\"\n        # result.add(rs.replaceAll(\"i\", n.toString()));\n        result.append(rs.replace(\"i\", str(n)))\n    # return result;\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # int minSum = 0;\n    min_sum = 0\n    # int curSum = 0;\n    cur_sum = 0\n    # for (int n in nums) {\n    for n in nums:\n        # curSum = min(curSum + n, 0);\n        cur_sum = min(cur_sum + n, 0)\n        # minSum = min(curSum, minSum);\n        min_sum = min(cur_sum, min_sum)\n    # if (minSum == 0) {\n    if min_sum == 0:\n        # minSum = nums.reduce(min);\n        min_sum = min(nums)\n    # return minSum;\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # return grid.map((arr) => (arr.reduce((a, b) => a + b) / capacity).ceil()).fold(0, (a, b) => a + b);\n    return sum(map(lambda arr: (sum(arr) / capacity).ceil(), grid))\n",
            "def count_ones(num: int) -> int:\n    # return \"1\".allMatches(num.toRadixString(2)).length;\n    return len(re.findall(r'1', bin(num)[2:]))\ndef sort_array(arr: List[int]) -> List[int]:\n    # return List.from(arr)..sort((a, b) {\n    #     return (countOnes(a) == countOnes(b)) ? a - b : countOnes(a) - countOnes(b);\n    # });\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # String consonants = \"bcdfghjklmnpqrstvwxyz\";\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # List<String> words = s.split(\" \").where((w) => w.length > 0).toList();\n    words = [w for w in s.split(\" \") if len(w) > 0]\n    # return words.where((w) => w.split('').where((c) => consonants.toLowerCase().contains(c.toLowerCase())).length == n).toList();\n    return [w for w in words if len([c for c in w.split('') if c.lower() in consonants]) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # String vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # for (int i = word.length - 2; i > 0; i--) {\n    for i in range(word.length - 2, 0, -1):\n        # if (vowels.contains(word[i]) && !vowels.contains(word[i - 1]) && !vowels.contains(word[i + 1])) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return word[i];\n            return word[i]\n    # return \"\";\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # for (String ch in s.split(\"\")) {\n    for ch in s.split(\"\"):\n        # if (ch == \"(\") {\n        if ch == \"(\":\n            # depth++;\n            depth += 1\n        # } else {\n        else:\n            # depth--;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth == 0;\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # String s1 = lst[0] + lst[1];\n    s1 = lst[0] + lst[1]\n    # String s2 = lst[1] + lst[0];\n    s2 = lst[1] + lst[0]\n    # return check(s1) || check(s2) ? \"Yes\" : \"No\";\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if (k == 0) {\n    if k == 0:\n        # return [];\n        return []\n    # List<int> result = List.from(arr)..sort();\n    result = sorted(arr)\n    # return result.sublist(arr.length - k);\n    return result[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # return lst.whereIndexed((i, x) => i % 2 == 0 && x % 2 != 0).fold(0, (a, b) => a + b);\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # return arr.take(k).where((n) => n.toString().length <= 2).fold(0, (a, b) => a + b);\n    return sum(filter(lambda n: len(str(n)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # List<int> collatz = [1];\n    collatz = [1]\n    # while (n != 1) {\n    while n != 1:\n        # if (n % 2 != 0) {\n        if n % 2 != 0:\n            # collatz.add(n);\n            collatz.append(n)\n            # n = 3 * n + 1;\n            n = 3 * n + 1\n        else:\n            # n = n ~/ 2;\n            n = n // 2\n    # return collatz..sort();\n    return sorted(collatz)\n",
            "def valid_date(date: str) -> bool:\n    # if (date.length != 10 || date[2] != \"-\" || date[5] != \"-\") {\n    if len(date) != 10 or date[2] != \"-\" or date[5] != \"-\":\n        # return false;\n        return False\n    # int m = int.parse(date.substring(0, 2));\n    m = int(date[0:2])\n    # int d = int.parse(date.substring(3, 5));\n    d = int(date[3:5])\n    # if ([1, 3, 5, 7, 8, 10, 12].contains(m) && d >= 1 && d <= 31) {\n    if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n        # return true;\n        return True\n    # if ([4, 6, 9, 11].contains(m) && d >= 1 && d <= 30) {\n    if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n        # return true;\n        return True\n    # if (m == 2 && d >= 1 && d <= 29) {\n    if m == 2 and d >= 1 and d <= 29:\n        # return true;\n        return True\n    # return false;\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if (txt.contains(\" \")) {\n    if \" \" in txt:\n        # return txt.split(\" \");\n        return txt.split(\" \")\n    # } else if (txt.contains(\",\")) {\n    elif \",\" in txt:\n        # return txt.split(\",\");\n        return txt.split(\",\")\n    # } else {\n    else:\n        # return [txt.split(\"\").where((c) => c.contains(RegExp(r\"[a-z]\")) && c.codeUnitAt(0) % 2 == 0).length.toString()];\n        return [txt.split(\"\").where(lambda c: c.isalpha() and c.encode(\"utf-8\")[0] % 2 == 0).__len__().__str__()]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if (!(lst.isSorted((a, b) => a - b))) {\n    if not lst.sort(key=lambda a, b: a - b):\n        # return false;\n        return False\n    # var freq = {};\n    freq = {}\n    # for (var i in lst) {\n    for i in lst:\n        # freq[i] = (freq[i] ?? 0) + 1;\n        freq[i] = freq.get(i, 0) + 1\n    # return freq.values.fold(0, (a, b) => a > b ? a : b) <= 2;\n    return max(freq.values()) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= sqrt(n).floor(); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # int l = max(interval1[0], interval2[0]);\n    l = max(interval1[0], interval2[0])\n    # int r = min(interval1[1], interval2[1]);\n    r = min(interval1[1], interval2[1])\n    # int length = r - l;\n    length = r - l\n    # return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if (arr.length == 0) {\n    if len(arr) == 0:\n        # return null;\n        return None\n    # if (arr.contains(0)) {\n    if 0 in arr:\n        # return 0;\n        return 0\n    # int sign = arr.where((n) => n < 0).length % 2 == 1 ? -1 : 1;\n    sign = 1 if arr.count(lambda n: n < 0) % 2 == 1 else -1\n    # return sign * arr.map((n) => n.abs()).reduce((a, b) => a + b);\n    return sign * sum(map(lambda n: abs(n), arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # int n = grid.length;\n    n = len(grid)\n    # int minVal = n * n + 1;\n    min_val = n * n + 1\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # for (int j = 0; j < n; j++) {\n        for j in range(n):\n            # if (grid[i][j] == 1) {\n            if grid[i][j] == 1:\n                # List<int> temp = [];\n                temp = []\n                # if (i != 0) {\n                if i != 0:\n                    # temp.add(grid[i - 1][j]);\n                    temp.append(grid[i - 1][j])\n                # if (j != 0) {\n                if j != 0:\n                    # temp.add(grid[i][j - 1]);\n                    temp.append(grid[i][j - 1])\n                # if (i != n - 1) {\n                if i != n - 1:\n                    # temp.add(grid[i + 1][j]);\n                    temp.append(grid[i + 1][j])\n                # if (j != n - 1) {\n                if j != n - 1:\n                    # temp.add(grid[i][j + 1]);\n                    temp.append(grid[i][j + 1])\n                # minVal = temp.reduce(min);\n                min_val = min(temp)\n    # List<int> result = [];\n    result = []\n    # for (int i = 0; i < k; i++) {\n    for i in range(k):\n        # result.add(i % 2 == 0 ? 1 : minVal);\n        result.append(1 if i % 2 == 0 else min_val)\n    # return result;\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if (n == 0) {\n    if n == 0:\n        # return [1];\n        return [1]\n    # List<int> seq = [1, 3];\n    seq = [1, 3]\n    # for (int i = 2; i <= n; i++) {\n    for i in range(2, n + 1):\n        # if (i % 2 == 0) {\n        if i % 2 == 0:\n            # seq.add((i / 2 + 1).toInt());\n            seq.append((i / 2 + 1))\n        # else {\n        else:\n            # seq.add(seq[i - 1] + seq[i - 2] + ((i + 3) / 2).toInt());\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n    # return seq;\n    return seq\n",
            "def digits(n: int) -> int:\n    # var odds = n.toString().split('').where((d) => int.parse(d) % 2 == 1).map((d) => int.parse(d));\n    odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    # return odds.length > 0 ? odds.reduce((x, y) => x * y) : 0;\n    return reduce(lambda x, y: x * y, odds) if odds else 0\n",
            "def is_nested(s: str) -> bool:\n    # List<int> openIdx = [];\n    open_idx = []\n    # List<int> closeIdx = [];\n    close_idx = []\n    # for (final (i, ch) in s.split(\"\").indexed) {\n    for i, ch in enumerate(s.split(\"\")):\n        # switch (ch) {\n        #     case '[':\n        #         openIdx.add(i);\n        #     case ']':\n        #         closeIdx.add(i);\n        # }\n        if ch == \"[\":\n            open_idx.append(i)\n        elif ch == \"]\":\n            close_idx.append(i)\n    # closeIdx = closeIdx.reversed.toList();\n    close_idx = close_idx[::-1]\n    # int cnt = 0;\n    cnt = 0\n    # int i = 0;\n    i = 0\n    # int l = closeIdx.length;\n    l = len(close_idx)\n    # for (int idx in openIdx) {\n    for idx in open_idx:\n        # if (i < l && idx < closeIdx[i]) {\n        #     cnt += 1;\n        #     i += 1;\n        # }\n        if i < l and idx < close_idx[i]:\n            cnt += 1\n            i += 1\n    # return cnt >= 2;\n    return cnt >= 2\n",
            "def sum_squares(lst: List[float]) -> int:\n    # return lst.map((n) => pow(n.ceil(), 2).toInt()).fold(0, (a, b) => a + b);\n    return sum(pow(ceil(n), 2) for n in lst)\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if (txt.isEmpty) {\n    if not txt:\n        # return false;\n        return False\n    # String last = txt.substring(txt.lastIndexOf(' ') + 1);\n    last = txt.split()[-1]\n    # return last.length == 1 && RegExp(r'[a-z]', caseSensitive: false).hasMatch(last[0]);\n    return len(last) == 1 and bool(re.match(r'[a-z]', last[0], flags=re.IGNORECASE))\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if (arr.length <= 1) {\n    if len(arr) <= 1:\n        # return -1;\n        return -1\n    # var idx = List.generate(arr.length - 1, (i) => i + 1).where((i) => arr[i] < arr[i - 1]);\n    idx = [i + 1 for i in range(len(arr) - 1) if arr[i] < arr[i - 1]]\n    # return idx.fold(-1, max);\n    return max(idx, default=-1)\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # var neg = lst.where((i) => i < 0);\n    neg = [i for i in lst if i < 0]\n    # var pos = lst.where((i) => i > 0);\n    pos = [i for i in lst if i > 0]\n    # int? maxNeg = neg.isNotEmpty ? neg.reduce(max) : null;\n    max_neg = max(neg) if neg else None\n    # int? minPos = pos.isNotEmpty ? pos.reduce(min) : null;\n    min_pos = min(pos) if pos else None\n    # return [maxNeg, minPos];\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: object) -> float:\n    # if (o is String) {\n    if isinstance(o, str):\n        # return double.parse((o as String).replaceAll(',', '.'));\n        return float(o.replace(',', '.'))\n    # } else if (o is int) {\n    elif isinstance(o, int):\n        # return (o as int).toDouble();\n        return float(o)\n    # } else if (o is double) {\n    elif isinstance(o, float):\n        # return o as double;\n        return o\n    # }\n    # throw new Exception(\"Type Error\");\n    raise Exception(\"Type Error\")\ndef compare_one(a: object, b: object) -> Optional[float]:\n    # double a1 = anyToReal(a);\n    a1 = any_to_real(a)\n    # double b1 = anyToReal(b);\n    b1 = any_to_real(b)\n    # if (a1 == b1) {\n    if a1 == b1:\n        # return null;\n        return None\n    # } else if (a1 > b1) {\n    elif a1 > b1:\n        # return a1;\n        return a1\n    # } else {\n    else:\n        # return b1;\n        return b1\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return n % 2 == 0 && n >= 8;\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # int fact = 1;\n    fact = 1\n    # int result = 1;\n    result = 1\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # fact *= i;\n        fact *= i\n        # result *= fact;\n        result *= fact\n    # return result;\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return txt.replaceAll(RegExp(r\"\\s{3,}\"), \"-\").replaceAll(\" \", \"_\");\n    return txt.replace(r\"\\s{3,}\", \"-\").replace(\" \", \"_\")\n",
            "def file_name_check(file_name: str) -> str:\n    # var suf = [\"txt\", \"exe\", \"dll\"];\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # var lst = fileName.split(\".\");\n    lst = file_name.split(\".\")\n    # if (lst.length != 2 || !suf.contains(lst[1]) || lst[0].length == 0 || !lst[0][0].contains(RegExp(r'[a-z]', caseSensitive: false)) || lst[0].split(\"\").where((x) => x.contains(RegExp(r'\\d'))).length > 3) {\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or lst[0][0].find(r'[a-z]') == -1 or lst[0].split(\"\").where((x) => x.find(r'\\d') != -1).length > 3:\n        # return \"No\";\n        return \"No\"\n    # return \"Yes\";\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # int result = 0;\n    result = 0\n    # for (int i = 0; i < lst.length; i++) {\n    for i in range(len(lst)):\n        # if (i % 3 == 0) {\n        if i % 3 == 0:\n            # result += pow(lst[i], 2).toInt();\n            result += pow(lst[i], 2)\n        # } else if (i % 4 == 0) {\n        elif i % 4 == 0:\n            # result += pow(lst[i], 3).toInt();\n            result += pow(lst[i], 3)\n        # } else {\n        else:\n            # result += lst[i];\n            result += lst[i]\n    # return result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= sqrt(n).floor(); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # List<String> words = sentence.split(\" \");\n    words = sentence.split(\" \")\n    # return words.where((w) => isPrime(w.length)).join(\" \");\n    return \" \".join(w for w in words if is_prime(len(w)))\n",
            "def simplify(x: str, n: str) -> bool:\n    # var xs = x.split('/');\n    xs = x.split('/')\n    # var ns = n.split('/');\n    ns = n.split('/')\n    # var num = int.parse(xs[0]) * int.parse(ns[0]);\n    num = int(xs[0]) * int(ns[0])\n    # var den = int.parse(xs[1]) * int.parse(ns[1]);\n    den = int(xs[1]) * int(ns[1])\n    # return num % den == 0;\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # String nStr = n.toString();\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return nStr.split('').map((d) => int.parse(d)).reduce((a, b) => a + b);\n        return sum(map(int, n_str.split('')))\n    # } else {\n    else:\n        # return int.parse(nStr.substring(0, 2)) * 2 + digitsSum(n.abs());\n        return int(n_str[0:2]) * 2 + digits_sum(abs(n))\n# List<int> orderByPoints(List<int> nums) {\ndef order_by_points(nums: List[int]) -> List[int]:\n    # List<int> result = List.from(nums);\n    result = list(nums)\n    # mergeSort(result, compare: (a, b) => digitsSum(a)- digitsSum(b));\n    merge_sort(result, key=lambda a, b: digits_sum(a) - digits_sum(b))\n    # return result;\n    return result\n",
            "def special_filter(nums: List[int]) -> int:\n    # String odds = \"13579\";\n    odds = \"13579\"\n    # return nums.where((n) => n > 10 && n % 2 == 1 && odds.contains(n.toString()[0])).length;\n    return len([n for n in nums if n > 10 and n % 2 == 1 and odds[0] in str(n)])\n",
            "def get_max_triples(n: int) -> int:\n    # List<int> c = [0, 0, 0];\n    c = [0, 0, 0]\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # int a = i * i - i + 1;\n        a = i * i - i + 1\n        # c[a % 3] += 1;\n        c[a % 3] += 1\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) ~/ 6;\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # List<String> names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if (!names.contains(planet1) || !names.contains(planet2)) {\n    if planet1 not in names or planet2 not in names:\n        # return [];\n        return []\n    # int l = names.indexOf(planet1);\n    l = names.index(planet1)\n    # int r = names.indexOf(planet2);\n    r = names.index(planet2)\n    # if (l > r) {\n    if l > r:\n        # [l, r] = [r, l];\n        l, r = r, l\n    # if (l == r) {\n    if l == r:\n        # return [];\n        return []\n    # return names.sublist(l + 1, r);\n    return names[l + 1:r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # var result = lst.where((it) => it.length % 2 == 0).toList();\n    result = [it for it in lst if len(it) % 2 == 0]\n    # return result..sort((a, b) {\n    #     if (a.length == b.length) {\n    #         return a.compareTo(b);\n    #     }\n    #     return a.length - b.length;\n    # });\n    return sorted(result, key=lambda a, b: a.length - b.length if a.length == b.length else a.length - b.length)\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if (n < 2) {\n    if n < 2:\n        # return y;\n        return y\n    # for (int i = 2; i <= sqrt(n).floor(); i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return y;\n            return y\n    # return x;\n    return x\n",
            "def double_the_difference(lst: List[float]) -> int:\n    # return lst.where((n) => n >= 0 && n % 2 == 1).map((n) => (n * n).toInt()).fold(0, (a, b) => a + b);\n    return sum(map(lambda n: int(n * n), filter(lambda n: n >= 0 and n % 2 == 1, lst)))\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # return IterableZip([game, guess]).map((x) => (x[0] - x[1]).abs()).toList();\n    return [abs(x[0] - x[1]) for x in zip_longest(game, guess)]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # int maxS = -double.maxFinite.toInt();\n    max_s = -float('inf')\n    # String maxExt = \"\";\n    max_ext = \"\"\n    # for (String ext in extensions) {\n    for ext in extensions:\n        # int upper = ext.split(\"\").where((c) => c == c.toUpperCase()).length;\n        upper = sum(1 for c in ext if c.isupper())\n        # int lower = ext.split(\"\").where((c) => c == c.toLowerCase()).length;\n        lower = sum(1 for c in ext if c.islower())\n        # int s = upper - lower;\n        s = upper - lower\n        # if (s > maxS) {\n        if s > max_s:\n            # maxS = s;\n            max_s = s\n            # maxExt = ext;\n            max_ext = ext\n    # return \"${className}.${maxExt}\";\n    return f\"{class_name}.{max_ext}\"\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if (a.length < b.length) {\n    if len(a) < len(b):\n        # return false;\n        return False\n    # for (int i = 0; i < b.length; i++) {\n    for i in range(len(b)):\n        # if (a.contains(b.substring(i) + b.substring(0, i))) {\n        if a.find(b[i:] + b[:i]) != -1:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # String ds = num.abs().toString();\n    ds = str(abs(num))\n    # int even = ds.split(\"\").where((d) => d.codeUnitAt(0) % 2 == 0).length;\n    even = len([d for d in ds if d.encode(\"utf-8\")[0] % 2 == 0])\n    # return [even, ds.length - even];\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # List<int> values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1];\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1]\n    # List<String> numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # StringBuffer res = StringBuffer();\n    res = \"\"\n    # for (int i = 0; i < values.length; i++) {\n    for i in range(len(values)):\n        # while (num >= values[i]) {\n        while num >= values[i]:\n            # res.write(numerals[i]);\n            res += numerals[i]\n            # num -= values[i];\n            num -= values[i]\n    # return res.toString();\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # List<int> s = [a, b, c]..sort();\n    s = sorted([a, b, c])\n    # return s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # int maxCnt = 0;\n    max_cnt = 0\n    # String maxW = \"\";\n    max_w = \"\"\n    # for (String w in words) {\n    for w in words:\n        # int cnt = w.split(\"\").toSet().length;\n        cnt = len(set(w))\n        # if (cnt > maxCnt) {\n        if cnt > max_cnt:\n            # maxCnt = cnt;\n            max_cnt = cnt\n            # maxW = w;\n            max_w = w\n        # else if (cnt == maxCnt) {\n        elif cnt == max_cnt:\n            # maxW = maxW.compareTo(w) < 0 ? maxW : w;\n            max_w = max_w if max_w < w else w\n    # return maxW;\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if (need <= remaining) {\n    if need <= remaining:\n        # return [num + need, remaining - need];\n        return [num + need, remaining - need]\n    # } else {\n    else:\n        # return [num + remaining, 0];\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # List<String> ops = List.from(operators);\n    ops = list(operators)\n    # List<int> nums = List.from(operands);\n    nums = list(operands)\n    # int i = ops.length - 1;\n    i = len(ops) - 1\n    # while (i >= 0) {\n    while i >= 0:\n        # if (ops[i] == \"**\") {\n        if ops[i] == \"**\":\n            # nums[i] = pow(nums[i], nums[i + 1]).toInt();\n            nums[i] = int(pow(nums[i], nums[i + 1]))\n            # nums.removeAt(i + 1);\n            nums.pop(i + 1)\n            # ops.removeAt(i);\n            ops.pop(i)\n        # i -= 1;\n        i -= 1\n    # i = 0;\n    i = 0\n    # while (i < ops.length) {\n    while i < len(ops):\n        # if (ops[i] == \"*\") {\n        if ops[i] == \"*\":\n            # nums[i] = nums[i] * nums[i + 1];\n            nums[i] = nums[i] * nums[i + 1]\n            # nums.removeAt(i + 1);\n            nums.pop(i + 1)\n            # ops.removeAt(i);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if (ops[i] == \"//\") {\n        elif ops[i] == \"//\":\n            # nums[i] = nums[i] ~/ nums[i + 1];\n            nums[i] = nums[i] // nums[i + 1]\n            # nums.removeAt(i + 1);\n            nums.pop(i + 1)\n            # ops.removeAt(i);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # i = 0;\n    i = 0\n    # while (i < ops.length) {\n    while i < len(ops):\n        # if (ops[i] == \"+\") {\n        if ops[i] == \"+\":\n            # nums[i] = nums[i] + nums[i + 1];\n            nums[i] = nums[i] + nums[i + 1]\n            # nums.removeAt(i + 1);\n            nums.pop(i + 1)\n            # ops.removeAt(i);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if (ops[i] == \"-\") {\n        elif ops[i] == \"-\":\n            # nums[i] = nums[i] - nums[i + 1];\n            nums[i] = nums[i] - nums[i + 1]\n            # nums.removeAt(i + 1);\n            nums.pop(i + 1)\n            # ops.removeAt(i);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # return nums[0];\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if (!s.split(\"\").any((ch) => ch.contains(RegExp(r'[A-Za-z]')))) {\n    if not any(ch.isalpha() for ch in s.split(\"\")):\n        # return s.split('').reversed.join('');\n        return ''.join(reversed(s.split('')))\n    # StringBuffer result = StringBuffer();\n    result = []\n    # for (var ch in s.split(\"\")) {\n    for ch in s.split(\"\"):\n        # if (!ch.contains(RegExp(r'[A-Za-z]'))) {\n        if not ch.isalpha():\n            # result.write(ch);\n            result.append(ch)\n        # else if (ch.contains(RegExp(r'[A-Z]'))) {\n        elif ch.isupper():\n            # result.write(ch.toLowerCase());\n            result.append(ch.lower())\n        # else if (ch.contains(RegExp(r'[a-z]'))) {\n        elif ch.islower():\n            # result.write(ch.toUpperCase());\n            result.append(ch.upper())\n    # return result.toString();\n    return ''.join(result)\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if (txt.isEmpty) {\n    if not txt:\n        # return null;\n        return None\n    # var txtBytes = utf8.encode(txt);\n    txt_bytes = txt.encode('utf-8')\n    # var md5Encoded = md5.convert(txtBytes).toString();\n    md5_encoded = hashlib.md5(txt_bytes).hexdigest()\n    # return md5Encoded;\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # int lower = max(2, min(a, b));\n    lower = max(2, min(a, b))\n    # int upper = min(8, max(a, b));\n    upper = min(8, max(a, b))\n    # return [for(int i = lower; i <= upper; i++) i].where((i) => i % 2 == 0).toList();\n    return [i for i in range(lower, upper + 1) if i % 2 == 0]\n"
        ]
    },
    "go": {
        "python": [
            "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # for i := 0; i < len(numbers); i++ {\n    for i in range(len(numbers)):\n        # for j := i + 1; j < len(numbers); j++ {\n        for j in range(i + 1, len(numbers)):\n            # if math.Abs(numbers[i]-numbers[j]) < threshold {\n            #     return true\n            # }\n            if math.fabs(numbers[i] - numbers[j]) < threshold:\n                return True\n    # return false\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # groups := []string{}\n    groups = []\n    # stk := []rune{}\n    stk = []\n    # currentGroup := \"\"\n    current_group = \"\"\n    # parens := strings.ReplaceAll(parenString, \" \", \"\")\n    parens = paren_string.replace(\" \", \"\")\n    # for _, ch := range parens {\n    for ch in parens:\n        # if ch == '(' {\n        if ch == '(':\n            # stk = append(stk, ch)\n            stk.append(ch)\n            # currentGroup += string(ch)\n            current_group += ch\n        # } else if ch == ')' {\n        elif ch == ')':\n            # stk = stk[:len(stk)-1]\n            stk = stk[:len(stk)-1]\n            # currentGroup += string(ch)\n            current_group += ch\n            # if len(stk) == 0 {\n            if len(stk) == 0:\n                # groups = append(groups, currentGroup)\n                groups.append(current_group)\n                # currentGroup = \"\"\n                current_group = \"\"\n    # return groups\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return num - math.Floor(num)\n    return num - math.floor(num)\n",
            "def below_zero(operations: List[int]) -> bool:\n    # balance := 0\n    balance = 0\n    # for _, op := range operations {\n    for op in operations:\n        # balance += op\n        balance += op\n        # if balance < 0 {\n        if balance < 0:\n            # return true\n            return True\n    # return false\n    return False\n",
            "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # mean := 0.0\n    mean = 0.0\n    # for _, num := range numbers {\n    for num in numbers:\n        # mean += num\n        mean += num\n    # mean /= float64(len(numbers))\n    mean /= float(len(numbers))\n    # deviation := 0.0\n    deviation = 0.0\n    # for _, num := range numbers {\n    for num in numbers:\n        # deviation += math.Abs(num - mean)\n        deviation += math.fabs(num - mean)\n    # return deviation / float64(len(numbers))\n    return deviation / float(len(numbers))\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # result := []int{}\n    result = []\n    # for i := 0; i < len(numbers); i++ {\n    for i in range(len(numbers)):\n        # if i != 0 {\n        if i != 0:\n            # result = append(result, delimiter)\n            result.append(delimiter)\n        # result = append(result, numbers[i])\n        result.append(numbers[i])\n    # return result\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # result := []int{}\n    result = []\n    # parenGroups := []string{}\n    paren_groups = []\n    # for _, str := range strings.Split(parenString, \" \") {\n    for str in paren_string.split(\" \"):\n        # if str != \"\" {\n        if str != \"\":\n            # parenGroups = append(parenGroups, str)\n            paren_groups.append(str)\n    # for _, group := range parenGroups {\n    for group in paren_groups:\n        # maxDepth := 0\n        max_depth = 0\n        # depth := 0\n        depth = 0\n        # for _, ch := range group {\n        for ch in group:\n            # if ch == '(' {\n            #     depth++\n            #     maxDepth = max(maxDepth, depth)\n            if ch == \"(\":\n                depth += 1\n                max_depth = max(max_depth, depth)\n            # } else if ch == ')' {\n            #     depth--\n            # }\n            elif ch == \")\":\n                depth -= 1\n        # result = append(result, maxDepth)\n        result.append(max_depth)\n    # return result\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # result := []string{}\n    result = []\n    # for _, s := range strs {\n    for s in strs:\n        # if strings.Contains(s, substring) {\n        #     result = append(result, s)\n        # }\n        if substring in s:\n            result.append(s)\n    # return result\n    return result\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # nSum := 0\n    n_sum = 0\n    # nProduct := 1\n    n_product = 1\n    # for _, n := range numbers {\n    for n in numbers:\n        # nSum += n\n        n_sum += n\n        # nProduct *= n\n        n_product *= n\n    # return []int{nSum, nProduct}\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # maxSoFar := math.MinInt\n    max_so_far = float('-inf')\n    # result := []int{}\n    result = []\n    # for _, num := range numbers {\n    for num in numbers:\n        # maxSoFar = max(maxSoFar, num)\n        max_so_far = max(max_so_far, num)\n        # result = append(result, maxSoFar)\n        result.append(max_so_far)\n    # return result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # runes := []rune(s)\n    runes = list(s)\n    # for i := 0; i < len(runes)/2; i++ {\n    for i in range(len(runes) // 2):\n        # if runes[i] != runes[len(runes)-1-i] {\n        #     return false\n        # }\n        if runes[i] != runes[len(runes) - 1 - i]:\n            return False\n    # return true\n    return True\ndef make_palindrome(s: str) -> str:\n    # if IsPalindrome(s) {\n    #     return s\n    # }\n    if is_palindrome(s):\n        return s\n    # for i := 0; i < len(s); i++ {\n    for i in range(len(s)):\n        # if IsPalindrome(s[i:]) {\n        #     runes := []rune(s[:i])\n        #     for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        #         runes[i], runes[j] = runes[j], runes[i]\n        #     }\n        #     return s + string(runes)\n        # }\n        if is_palindrome(s[i:]):\n            runes = list(s[:i])\n            for i, j in zip(range(len(runes)), range(len(runes) - 1, -1, -1)):\n                runes[i], runes[j] = runes[j], runes[i]\n            return s + ''.join(runes)\n    # return \"\"\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # result := []string{}\n    result = []\n    # for i := 0; i < len(a); i++ {\n    for i in range(len(a)):\n        # if a[i] == b[i] {\n        #     result = append(result, \"0\")\n        # } else {\n        #     result = append(result, \"1\")\n        # }\n        result.append(\"0\" if a[i] == b[i] else \"1\")\n    # return strings.Join(result, \"\")\n    return \"\".join(result)\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if len(strs) == 0 {\n    #     return nil\n    # }\n    if not strs:\n        return None\n    # longestS := strs[0]\n    longest_s = strs[0]\n    # for _, s := range strs {\n    for s in strs:\n        # if len(s) > len(longestS) {\n        #     longestS = s\n        # }\n        if len(s) > len(longest_s):\n            longest_s = s\n    # return &longestS\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if b == 0 {\n    #     return a\n    # } else {\n    #     return GreatestCommonDivisor(b, a%b)\n    # }\n    return a if b == 0 else greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # prefixes := []string{}\n    prefixes = []\n    # for i := 0; i < len(s); i++ {\n    for i in range(len(s)):\n        # prefixes = append(prefixes, s[:i+1])\n        prefixes.append(s[:i+1])\n    # return prefixes\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # result := []string{}\n    result = []\n    # for i := 0; i <= n; i++ {\n    for i in range(n + 1):\n        # result = append(result, strconv.Itoa(i))\n        result.append(str(i))\n    # return strings.Join(result, \" \")\n    return string.join(result, \" \")\n",
            "def count_distinct_characters(s: str) -> int:\n    # dc := make(map[rune]bool)\n    dc = {}\n    # for _, ch := range strings.ToLower(s) {\n    for ch in s.lower():\n        # dc[ch] = true\n        dc[ch] = True\n    # return len(dc)\n    return len(dc)\n",
            "def parse_music(music_string: str) -> List[int]:\n    # durations := map[string]int{\n    #     \"o\": 4,\n    #     \"o|\": 2,\n    #     \".|\": 1,\n    # }\n    durations = {\n        \"o\": 4,\n        \"o|\": 2,\n        \".|\": 1,\n    }\n    # notes := []string{}\n    notes = []\n    # for _, str := range strings.Split(musicString, \" \") {\n    for str in music_string.split(\" \"):\n        # if str != \"\" {\n        #     notes = append(notes, str)\n        if str != \"\":\n            notes.append(str)\n    # result := []int{}\n    result = []\n    # for _, note := range notes {\n    for note in notes:\n        # result = append(result, durations[note])\n        result.append(durations[note])\n    # return result\n    return result\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # times := 0\n    times = 0\n    # for i := 0; i <= len(s) - len(substring); i++ {\n    for i in range(len(s) - len(substring) + 1):\n        # if s[i:i+len(substring)] == substring {\n        #     times += 1\n        # }\n        if s[i:i+len(substring)] == substring:\n            times += 1\n    # return times\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # numDict := map[string]int{\n    #     \"zero\": 0,\n    #     \"one\": 1,\n    #     \"two\": 2,\n    #     \"three\": 3,\n    #     \"four\": 4,\n    #     \"five\": 5,\n    #     \"six\": 6,\n    #     \"seven\": 7,\n    #     \"eight\": 8,\n    #     \"nine\": 9,\n    # }\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    # strs := strings.Split(numbers, \" \")\n    strs = numbers.split(\" \")\n    # numList := []string{}\n    num_list = []\n    # for _, str := range strs {\n    for str in strs:\n        # numList = append(numList, str)\n        num_list.append(str)\n    # sort.Slice(numList, func(i, j int) bool {\n    #     return numDict[numList[i]] < numDict[numList[j]]\n    # })\n    num_list.sort(key=lambda x: num_dict[x])\n    # return strings.Join(numList, \" \")\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[float]) -> List[float]:\n    # sortedNumbers := make([]float64, len(numbers))\n    # copy(sortedNumbers, numbers)\n    # sort.Float64s(sortedNumbers)\n    sorted_numbers = sorted(numbers)\n    # minDiff := math.Inf(1)\n    min_diff = math.inf\n    # closestPair := []float64{}\n    closest_pair = []\n    # for i := 1; i < len(sortedNumbers); i++ {\n    for i in range(1, len(sorted_numbers)):\n        # diff := sortedNumbers[i] - sortedNumbers[i - 1]\n        # if diff < minDiff {\n        #     minDiff = diff\n        #     closestPair = []float64{sortedNumbers[i - 1], sortedNumbers[i]}\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return closestPair\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # minNum := math.Inf(1)\n    min_num = math.inf\n    # maxNum := math.Inf(-1)\n    max_num = -math.inf\n    # for _, num := range numbers {\n    for num in numbers:\n        # if num < minNum {\n        #     minNum = num\n        # }\n        if num < min_num:\n            min_num = num\n        # if num > maxNum {\n        #     maxNum = num\n        # }\n        if num > max_num:\n            max_num = num\n    # res := make([]float64, len(numbers))\n    res = [0] * len(numbers)\n    # if minNum == maxNum {\n    if min_num == max_num:\n        # return res\n        return res\n    # else {\n    else:\n        # for i, num := range numbers {\n        #     res[i] = (num - minNum) / (maxNum - minNum)\n        # }\n        for i, num in enumerate(numbers):\n            res[i] = (num - min_num) / (max_num - min_num)\n        # return res\n        return res\n",
            "def filter_integers(values: List[object]) -> List[int]:\n    # integers := []int{}\n    integers = []\n    # for _, value := range values {\n    for value in values:\n        # if intValue, ok := value.(int); ok {\n        #     integers = append(integers, intValue)\n        # }\n        if isinstance(value, int):\n            integers.append(value)\n    # return integers\n    return integers\n",
            "def str_length(s: str) -> int:\n    # return len(s)\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for i := 2; i < n; i++ {\n    for i in range(2, n):\n        # if n % i == 0 {\n        #     return n / i\n        # }\n        if n % i == 0:\n            return n / i\n    # return 1\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # factors := []int{}\n    factors = []\n    # divisor := 2\n    divisor = 2\n    # for divisor <= n {\n    while divisor <= n:\n        # if n%divisor == 0 {\n        #     factors = append(factors, divisor)\n        #     n /= divisor\n        # } else {\n        #     divisor++\n        # }\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    # return factors\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # counts := make(map[int]int)\n    counts = {}\n    # for _, num := range numbers {\n    for num in numbers:\n        # counts[num]++\n        counts[num] = counts.get(num, 0) + 1\n    # res := make([]int, 0)\n    res = []\n    # for _, num := range numbers {\n    for num in numbers:\n        # if counts[num] == 1 {\n        #     res = append(res, num)\n        # }\n        if counts[num] == 1:\n            res.append(num)\n    # return res\n    return res\n",
            "def flip_case(s: str) -> str:\n    # var flipped strings.Builder\n    flipped = ''\n    # for _, ch := range s {\n    for ch in s:\n        # if !unicode.IsLetter(ch) {\n        #     flipped.WriteRune(ch)\n        # } else if unicode.IsLower(ch) {\n        #     flipped.WriteRune(unicode.ToUpper(ch))\n        # } else if unicode.IsUpper(ch) {\n        #     flipped.WriteRune(unicode.ToLower(ch))\n        # }\n        if ch not in string.ascii_letters:\n            flipped += ch\n        elif ch.islower():\n            flipped += ch.upper()\n        elif ch.isupper():\n            flipped += ch.lower()\n    # return flipped.String()\n    return flipped\n",
            "def concatenate(strs: List[str]) -> str:\n    # return strings.Join(strs, \"\")\n    return string.join(strs, \"\")\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # filtered := []string{}\n    filtered = []\n    # for _, str := range strs {\n    for str in strs:\n        # if strings.HasPrefix(str, prefixStr) {\n        #     filtered = append(filtered, str)\n        # }\n        if str.startswith(prefix_str):\n            filtered.append(str)\n    # return filtered\n    return filtered\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # result := []int{}\n    result = []\n    # for _, num := range l {\n    for num in l:\n        # if num > 0 {\n        #     result = append(result, num)\n        # }\n        if num > 0:\n            result.append(num)\n    # return result\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    #     return false\n    # }\n    if n < 2:\n        return False\n    # for i := 2; i <= int(math.Floor(math.Sqrt(float64(n)))); i++ {\n    for i in range(2, int(math.floor(math.sqrt(n))) + 1):\n        # if n % i == 0 {\n        #     return false\n        # }\n        if n % i == 0:\n            return False\n    # return true\n    return True\n",
            "def poly(xs: List[int], x: float) -> float:\n    # res := 0.0\n    res = 0.0\n    # for i := 0; i < len(xs); i++ {\n    for i in range(len(xs)):\n        # res += float64(xs[i]) * math.Pow(x, float64(i))\n        res += float(xs[i]) * math.pow(x, float(i))\n    # return res\n    return res\ndef find_zero(xs: List[int]) -> float:\n    # x1, x2 := 1.0, -1.0\n    x1, x2 = 1.0, -1.0\n    # for Poly(xs, x1) * Poly(xs, x2) > 0 {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2\n        x1 *= 2\n        # x2 *= 2\n        x2 *= 2\n    # for math.Abs(x1 - x2) > 1e-10 {\n    while math.fabs(x1 - x2) > 1e-10:\n        # mid := (x1 + x2) / 2\n        mid = (x1 + x2) / 2\n        # if Poly(xs, mid) == 0 {\n        if poly(xs, mid) == 0:\n            # return mid\n            return mid\n        # else if Poly(xs, mid) * Poly(xs, x1) < 0 {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid\n            x2 = mid\n        # } else {\n        else:\n            # x1 = mid\n            x1 = mid\n    # return (x1 + x2) / 2\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # sortedThird := make([]int, 0)\n    sorted_third = []\n    # for i, x := range l {\n    for i, x in enumerate(l):\n        # if i % 3 == 0 {\n        if i % 3 == 0:\n            # sortedThird = append(sortedThird, x)\n            sorted_third.append(x)\n    # result := make([]int, len(l))\n    result = [None] * len(l)\n    # sort.Ints(sortedThird)\n    sorted_third.sort()\n    # for i, x := range l {\n    for i, x in enumerate(l):\n        # if i % 3 == 0 {\n        if i % 3 == 0:\n            # result[i] = sortedThird[i / 3]\n            result[i] = sorted_third[i // 3]\n        else:\n            # result[i] = x\n            result[i] = x\n    # return result\n    return result\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # keys := make(map[int]bool)\n    keys = {}\n    # result := make([]int, 0)\n    result = []\n    # for _, x := range l {\n    for x in l:\n        # if _, value := keys[x]; !value {\n        #     keys[x] = true\n        #     result = append(result, x)\n        if x not in keys:\n            keys[x] = True\n            result.append(x)\n    # sort.Ints(result)\n    result.sort()\n    # return result\n    return result\n",
            "def max_element(l: List[int]) -> int:\n    # if len(l) == 0 {\n    #     return 0\n    # }\n    if not l:\n        return 0\n    # max := l[0]\n    max = l[0]\n    # for _, e := range l {\n    for e in l:\n        # if e > max {\n        #     max = e\n        # }\n        if e > max:\n            max = e\n    # return max\n    return max\n",
            "def fizz_buzz(n: int) -> int:\n    # cnt := 0\n    cnt = 0\n    # for i := 0; i < n; i++ {\n    for i in range(n):\n        # if i%11 == 0 || i%13 == 0 {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += strings.Count(strconv.Itoa(i), \"7\")\n            cnt += str(i).count(\"7\")\n    # return cnt\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # sortedEven := make([]int, 0)\n    sorted_even = []\n    # for i, x := range l {\n    for i, x in enumerate(l):\n        # if i % 2 == 0 {\n        if i % 2 == 0:\n            # sortedEven = append(sortedEven, x)\n            sorted_even.append(x)\n    # result := make([]int, len(l))\n    result = [None] * len(l)\n    # sort.Ints(sortedEven)\n    sorted_even.sort()\n    # for i, x := range l {\n    for i, x in enumerate(l):\n        # if i % 2 == 0 {\n        if i % 2 == 0:\n            # result[i] = sortedEven[i / 2]\n            result[i] = sorted_even[i // 2]\n        else:\n            # result[i] = x\n            result[i] = x\n    # return result\n    return result\n",
            "def encode_cyclic(s: str) -> str:\n    # var result strings.Builder\n    result = ''\n    # for i := 0; i < len(s); i += 3 {\n    for i in range(0, len(s), 3):\n        # if i + 3 > len(s) {\n        #     result.WriteString(s[i:])\n        # } else {\n        #     result.WriteString(s[i+1:i+3])\n        #     result.WriteByte(s[i])\n        # }\n        if i + 3 > len(s):\n            result += s[i:]\n        else:\n            result += s[i+1:i+3]\n            result += s[i]\n    # return result.String()\n    return result\ndef decode_cyclic(s: str) -> str:\n    # return EncodeCyclic(EncodeCyclic(s))\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    #     return false\n    # }\n    if n < 2:\n        return False\n    # for i := 2; i <= int(math.Floor(math.Sqrt(float64(n)))); i++ {\n    for i in range(2, int(math.floor(math.sqrt(n))) + 1):\n        # if n % i == 0 {\n        #     return false\n        # }\n        if n % i == 0:\n            return False\n    # return true\n    return True\ndef prime_fib(n: int) -> int:\n    # f := [2]int{0, 1}\n    f = [0, 1]\n    # cnt := 0\n    cnt = 0\n    # for cnt < n {\n    while cnt < n:\n        # f = [2]int{f[1], f[0] + f[1]}\n        f = [f[1], f[0] + f[1]]\n        # if IsPrime(f[1]) {\n        #     cnt++\n        # }\n        if is_prime(f[1]):\n            cnt += 1\n    # return f[1]\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for i := 0; i < len(l); i++ {\n    for i in range(len(l)):\n        # for j := i + 1; j < len(l); j++ {\n        for j in range(i + 1, len(l)):\n            # for k := j + 1; k < len(l); k++ {\n            for k in range(j + 1, len(l)):\n                # if l[i] + l[j] + l[k] == 0 {\n                #     return true\n                # }\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    # return false\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return int(math.Pow(float64(n), float64(2)))\n    return int(math.pow(n, 2))\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # result := make([]int, len(l))\n    result = [0] * len(l)\n    # for i := 0; i < len(l); i++ {\n    for i in range(len(l)):\n        # result[i] = l[i] + 1\n        result[i] = l[i] + 1\n    # return result\n    return result\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # seen := make(map[int]bool)\n    seen = {}\n    # for _, num := range l {\n    for num in l:\n        # if seen[-num] {\n        #     return true\n        # }\n        if -num in seen:\n            return True\n        # seen[num] = true\n        seen[num] = True\n    # return false\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if x == 0 {\n    #     return \"0\"\n    # }\n    if x == 0:\n        return \"0\"\n    # digits := []string{}\n    digits = []\n    # for x > 0 {\n    while x > 0:\n        # digits = append([]string{strconv.Itoa(x%bas)}, digits...)\n        digits.append(str(x % bas))\n        x //= bas\n    # return strings.Join(digits, \"\")\n    return \"\".join(digits)\n",
            "def triangle_area(a: int, h: int) -> float:\n    # return float64(a * h) / 2\n    return float(a * h) / 2\n",
            "def fib4(n: int) -> int:\n    # fib := [4]int{0, 0, 2, 0}\n    fib = [0, 0, 2, 0]\n    # for i := 4; i <= n; i++ {\n    for i in range(4, n + 1):\n        # fib[i % 4] = fib[0] + fib[1] + fib[2] + fib[3]\n        fib[i % 4] = fib[0] + fib[1] + fib[2] + fib[3]\n    # return fib[n % 4]\n    return fib[n % 4]\n",
            "def median(l: List[float]) -> float:\n    # sl := make([]float64, len(l))\n    sl = l[:]\n    # copy(sl, l)\n    # sort.Float64s(sl)\n    sl.sort()\n    # if len(l) % 2 != 0 {\n    #     return sl[len(l) / 2]\n    # } else {\n    #     return (sl[len(l) / 2] + sl[len(l) / 2 - 1]) / 2\n    # }\n    return statistics.median(sl)\n",
            "def is_palindrome(s: str) -> bool:\n    # runes := []rune(s)\n    runes = list(s)\n    # for i := 0; i < len(runes)/2; i++ {\n    for i in range(len(runes) // 2):\n        # if runes[i] != runes[len(runes)-1-i] {\n        #     return false\n        # }\n        if runes[i] != runes[len(runes) - 1 - i]:\n            return False\n    # return true\n    return True\n",
            "def modp(n: int, p: int) -> int:\n    # ret := 1\n    ret = 1\n    # for i := 0; i < n; i++ {\n    for i in range(n):\n        # ret = (ret * 2) % p\n        ret = (ret * 2) % p\n    # return ret\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # result := []rune{}\n    result = []\n    # for _, ch := range s {\n    for ch in s:\n        # result = append(result, (ch - 97 + 5) % 26 + 97)\n        result.append((ord(ch) - 97 + 5) % 26 + 97)\n    # return string(result)\n    return ''.join(chr(c) for c in result)\ndef decode_shift(s: str) -> str:\n    # result := []rune{}\n    result = []\n    # for _, ch := range s {\n    for ch in s:\n        # result = append(result, (ch - 97 + 21) % 26 + 97)\n        result.append((ord(ch) - 97 + 21) % 26 + 97)\n    # return string(result)\n    return ''.join(chr(c) for c in result)\n",
            "def remove_vowels(txt: str) -> str:\n    # vowels := \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # var result strings.Builder\n    result = \"\"\n    # for _, char := range txt {\n    for char in txt:\n        # if !strings.ContainsRune(vowels, char) {\n        #     result.WriteRune(char)\n        # }\n        if char not in vowels:\n            result += char\n    # return result.String()\n    return result\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # for _, x := range l {\n    for x in l:\n        # if x >= t {\n        #     return false\n        # }\n        if x >= t:\n            return False\n    # return true\n    return True\n",
            "def add(x: int, y: int) -> int:\n    # return x + y\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # set0 := make(map[rune]bool)\n    set0 = {}\n    # set1 := make(map[rune]bool)\n    set1 = {}\n    # for _, char := range s0 {\n    for char in s0:\n        # set0[char] = true\n        set0[char] = True\n    # for _, char := range s1 {\n    for char in s1:\n        # set1[char] = true\n        set1[char] = True\n    # return reflect.DeepEqual(set0, set1)\n    return set0 == set1\n",
            "def fib(n: int) -> int:\n    # if n <= 1 {\n    #     return n\n    # } else {\n    #     return Fib(n-1) + Fib(n-2)\n    # }\n    return n if n <= 1 else fib(n-1) + fib(n-2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # depth := 0\n    depth = 0\n    # for _, b := range brackets {\n    for b in brackets:\n        # if b == '<' {\n        #     depth += 1\n        # } else if b == '>' {\n        #     depth -= 1\n        # }\n        if b == '<':\n            depth += 1\n        elif b == '>':\n            depth -= 1\n        # if depth < 0 {\n        #     return false\n        # }\n        if depth < 0:\n            return False\n    # return depth == 0\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # diff := make([]int, len(l) - 1)\n    diff = [0] * (len(l) - 1)\n    # for i := 0; i < len(l) - 1; i++ {\n    for i in range(len(l) - 1):\n        # diff[i] = l[i + 1] - l[i]\n        diff[i] = l[i + 1] - l[i]\n    # allNeg := true\n    all_neg = True\n    # allPos := true\n    all_pos = True\n    # for _, x := range diff {\n    for x in diff:\n        # if x > 0 {\n        #     allNeg = false\n        # }\n        if x > 0:\n            all_neg = False\n        # if x < 0 {\n        #     allPos = false\n        # }\n        if x < 0:\n            all_pos = False\n    # return allNeg || allPos\n    return all_neg or all_pos\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # result := make([]int, 0)\n    result = []\n    # s1 := make(map[int]bool)\n    s1 = {}\n    # for _, num := range l1 {\n    for num in l1:\n        # s1[num] = true\n        s1[num] = True\n    # for _, num := range l2 {\n    for num in l2:\n        # if s1[num] {\n        #     result = append(result, num)\n        #     s1[num] = false\n        # }\n        if s1.get(num, False):\n            result.append(num)\n            s1[num] = False\n    # sort.Ints(result)\n    result.sort()\n    # return result\n    return result\n",
            "def largest_prime_factor(n: int) -> int:\n    # i := 2\n    i = 2\n    # for i*i <= n {\n    while i*i <= n:\n        # if n%i != 0 {\n        #     i++\n        # } else {\n        #     n /= i\n        # }\n        if n % i != 0:\n            i += 1\n        else:\n            n //= i\n    # return n\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # sum := 0\n    sum = 0\n    # for i := 0; i <= n; i++ {\n    for i in range(n + 1):\n        # sum += i\n        sum += i\n    # return sum\n    return sum\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # depth := 0\n    depth = 0\n    # for _, b := range brackets {\n    for b in brackets:\n        # if b == '(' {\n        #     depth += 1\n        # } else if b == ')' {\n        #     depth -= 1\n        # }\n        if b == '(':\n            depth += 1\n        elif b == ')':\n            depth -= 1\n        # if depth < 0 {\n        #     return false\n        # }\n        if depth < 0:\n            return False\n    # return depth == 0\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # result := make([]int, len(xs) - 1)\n    result = [0] * (len(xs) - 1)\n    # for i := 1; i < len(xs); i++ {\n    for i in range(1, len(xs)):\n        # result[i - 1] = xs[i] * i\n        result[i - 1] = xs[i] * i\n    # return result\n    return result\n",
            "def fibfib(n: int) -> int:\n    # if n <= 1 {\n    #     return 0\n    # }\n    if n <= 1:\n        return 0\n    # a, b, c := 0, 0, 1\n    a, b, c = 0, 0, 1\n    # for n > 2 {\n    while n > 2:\n        # a, b, c = b, c, a + b + c\n        a, b, c = b, c, a + b + c\n        # n -= 1\n        n -= 1\n    # return c\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # vowels := \"aeiou\"\n    vowels = \"aeiou\"\n    # cnt := 0\n    cnt = 0\n    # for i := 0; i < len(s); i++ {\n    for i in range(len(s)):\n        # if strings.Contains(vowels, strings.ToLower(string(s[i]))) || (i == len(s) - 1 && strings.ToLower(string(s[i])) == \"y\") {\n        if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n            # cnt += 1\n            cnt += 1\n    # return cnt\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # xStr := strconv.Itoa(x)\n    x_str = str(x)\n    # if shift > len(xStr) {\n    if shift > len(x_str):\n        # runes := []rune(xStr)\n        runes = list(x_str)\n        # for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        #     runes[i], runes[j] = runes[j], runes[i]\n        # }\n        for i in range(0, len(runes)-1):\n            runes[i], runes[len(runes)-1-i] = runes[len(runes)-1-i], runes[i]\n        # return string(runes)\n        return ''.join(runes)\n    # } else {\n    #     return xStr[len(xStr) - shift:] + xStr[:len(xStr) - shift]\n    # }\n    return x_str[len(x_str) - shift:] + x_str[:len(x_str) - shift]\n",
            "def digit_sum(s: str) -> int:\n    # a := 0\n    a = 0\n    # for _, c := range s {\n    for c in s:\n        # if unicode.IsUpper(c) {\n        #     a += int(c)\n        # }\n        if c.isupper():\n            a += ord(c)\n    # return a\n    return a\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # words := strings.Split(s, \" \")\n    words = s.split(\" \")\n    # apples := 0\n    apples = 0\n    # oranges := 0\n    oranges = 0\n    # for i, word := range words {\n    for i, word in enumerate(words):\n        # if word == \"apples\" {\n        #     apples, _ = strconv.Atoi(words[i - 1])\n        # }\n        if word == \"apples\":\n            apples = int(words[i - 1])\n        # if word == \"oranges\" {\n        #     oranges, _ = strconv.Atoi(words[i - 1])\n        # }\n        if word == \"oranges\":\n            oranges = int(words[i - 1])\n    # return n - apples - oranges\n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # minEven := math.MaxInt\n    min_even = math.inf\n    # minIdx := -1\n    min_idx = -1\n    # for i, n := range arr {\n    for i, n in enumerate(arr):\n        # if n % 2 == 0 && n < minEven {\n        if n % 2 == 0 and n < min_even:\n            # minEven = n\n            min_even = n\n            # minIdx = i\n            min_idx = i\n    # if minIdx == -1 {\n    if min_idx == -1:\n        # return []int{}\n        return []\n    # return []int{minEven, minIdx}\n    return [min_even, min_idx]\n",
            "def search(lst: List[int]) -> int:\n    # freqs := make(map[int]int)\n    freqs = {}\n    # for _, n := range lst {\n    for n in lst:\n        # freqs[n] = freqs[n] + 1\n        freqs[n] = freqs.get(n, 0) + 1\n    # maxVal := math.MinInt\n    max_val = math.min\n    # for k, v := range freqs {\n    for k, v in freqs.items():\n        # if v >= k && k > maxVal {\n        #     maxVal = k\n        # }\n        if v >= k and k > max_val:\n            max_val = k\n    # if maxVal == math.MinInt {\n    #     return -1\n    # }\n    if max_val == math.min:\n        return -1\n    # return maxVal\n    return max_val\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # sl := make([]int, len(lst))\n    sl = [0] * len(lst)\n    # copy(sl, lst)\n    sl[:] = lst\n    # sort.Ints(sl)\n    sl.sort()\n    # result := make([]int, 0)\n    result = []\n    # left, right := 0, len(sl) - 1\n    left, right = 0, len(sl) - 1\n    # for left <= right {\n    while left <= right:\n        # result = append(result, sl[left])\n        result.append(sl[left])\n        left += 1\n        # if left <= right {\n        if left <= right:\n            # result = append(result, sl[right])\n            result.append(sl[right])\n            right -= 1\n    # return result\n    return result\n",
            "def triangle_area(a: int, b: int, c: int) -> float:\n    # if a + b > c && a + c > b && b + c > a {\n    if a + b > c and a + c > b and b + c > a:\n        # s := float64(a + b + c) / 2.0\n        s = (a + b + c) / 2.0\n        # return math.Sqrt(float64(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c))))\n        return math.sqrt(s * (s - float(a)) * (s - float(b)) * (s - float(c)))\n    # } else {\n    else:\n        # return -1.0\n        return -1.0\n    # }\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if len(q) == 0 {\n    #     return false\n    # }\n    if not q:\n        return False\n    # isPalin := true\n    is_palin = True\n    # for i := 0; i < len(q); i++ {\n    for i in range(len(q)):\n        # if q[i] != q[len(q) - i - 1] {\n        #     isPalin = false\n        #     break\n        # }\n        if q[i] != q[len(q) - i - 1]:\n            is_palin = False\n            break\n    # total := 0\n    total = 0\n    # for i := 0; i < len(q); i++ {\n    for i in range(len(q)):\n        # total += q[i]\n        total += q[i]\n    # return isPalin && total <= w\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # ans := 0\n    ans = 0\n    # for i := 0; i < len(arr) / 2; i++ {\n    for i in range(len(arr) // 2):\n        # if arr[i] != arr[len(arr) - i - 1] {\n        #     ans += 1\n        # }\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    # return ans\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # cnt1 := 0\n    cnt1 = 0\n    # for _, b := range lst1 {\n    for b in lst1:\n        # cnt1 += len(b)\n        cnt1 += len(b)\n    # cnt2 := 0\n    cnt2 = 0\n    # for _, b := range lst2 {\n    for b in lst2:\n        # cnt2 += len(b)\n        cnt2 += len(b)\n    # if cnt1 <= cnt2 {\n    if cnt1 <= cnt2:\n        # return lst1\n        return lst1\n    # } else {\n    else:\n        # return lst2\n        return lst2\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    #     return false\n    # }\n    if n < 2:\n        return False\n    # for i := 2; i <= int(math.Floor(math.Sqrt(float64(n)))); i++ {\n    for i in range(2, int(math.floor(math.sqrt(n))) + 1):\n        # if n % i == 0 {\n        #     return false\n        # }\n        if n % i == 0:\n            return False\n    # return true\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # cnt := 0\n    cnt = 0\n    # for i := 2; i <= a; i++ {\n    for i in range(2, a + 1):\n        # if IsPrime(i) {\n        #     for a % i == 0 {\n        #         cnt += 1\n        #         a /= i\n        #     }\n        # }\n        if is_prime(i):\n            while a % i == 0:\n                cnt += 1\n                a //= i\n    # return cnt == 3\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if n < 2 {\n    #     return x == n\n    # }\n    if n < 2:\n        return x == n\n    # tmp := 1\n    tmp = 1\n    # for tmp < x {\n    while tmp < x:\n        # tmp *= n\n        tmp *= n\n    # return tmp == x\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # a = int(math.Abs(float64(a)))\n    a = abs(a)\n    # root := int(math.Round(math.Pow(float64(a), 1.0 / 3.0)))\n    root = int(round(math.pow(a, 1.0 / 3.0)))\n    # return root * root * root == a\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # result := 0\n    result = 0\n    # for _, x := range num {\n    for x in num:\n        # if strings.ContainsRune(\"2357BD\", x) {\n        #     result += 1\n        # }\n        if x in \"2357BD\":\n            result += 1\n    # return result\n    return result\n",
            "def decimal_to_binary(dec: int) -> str:\n    # binary := strconv.FormatInt(int64(dec), 2)\n    binary = format(dec, 'b')\n    # return fmt.Sprintf(\"db%sdb\", binary)\n    return 'db' + binary + 'db'\n",
            "def is_happy(s: str) -> bool:\n    # if len(s) < 3 {\n    #     return false\n    # }\n    if len(s) < 3:\n        return False\n    # for i := 0; i < len(s)-2; i++ {\n    for i in range(len(s) - 2):\n        # if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n        #     return false\n        # }\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    # return true\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # result := []string{}\n    result = []\n    # for _, g := range grades {\n    for g in grades:\n        # switch {\n        # case g == 4.0:\n        #     result = append(result, \"A+\")\n        if g == 4.0:\n            result.append(\"A+\")\n        # case g > 3.7:\n        #     result = append(result, \"A\")\n        elif g > 3.7:\n            result.append(\"A\")\n        # case g > 3.3:\n        #     result = append(result, \"A-\")\n        elif g > 3.3:\n            result.append(\"A-\")\n        # case g > 3.0:\n        #     result = append(result, \"B+\")\n        elif g > 3.0:\n            result.append(\"B+\")\n        # case g > 2.7:\n        #     result = append(result, \"B\")\n        elif g > 2.7:\n            result.append(\"B\")\n        # case g > 2.3:\n        #     result = append(result, \"B-\")\n        elif g > 2.3:\n            result.append(\"B-\")\n        # case g > 2.0:\n        #     result = append(result, \"C+\")\n        elif g > 2.0:\n            result.append(\"C+\")\n        # case g > 1.7:\n        #     result = append(result, \"C\")\n        elif g > 1.7:\n            result.append(\"C\")\n        # case g > 1.3:\n        #     result = append(result, \"C-\")\n        elif g > 1.3:\n            result.append(\"C-\")\n        # case g > 1.0:\n        #     result = append(result, \"D+\")\n        elif g > 1.0:\n            result.append(\"D+\")\n        # case g > 0.7:\n        #     result = append(result, \"D\")\n        elif g > 0.7:\n            result.append(\"D\")\n        # case g > 0.0:\n        #     result = append(result, \"D-\")\n        elif g > 0.0:\n            result.append(\"D-\")\n        # default:\n        #     result = append(result, \"E\")\n        else:\n            result.append(\"E\")\n        # }\n    # return result\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # length := len(s)\n    length = len(s)\n    # if length < 2 {\n    #     return false\n    # }\n    if length < 2:\n        return False\n    # for i := 2; i <= int(math.Floor(math.Sqrt(float64(length)))); i++ {\n    for i in range(2, int(math.floor(math.sqrt(length))) + 1):\n        # if length % i == 0 {\n        #     return false\n        # }\n        if length % i == 0:\n            return False\n    # return true\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if n == 1 {\n    #     return 1\n    # }\n    # return 2 * 9 * int(math.Pow10(n-2))\n    return 1 if n == 1 else 2 * 9 * int(math.pow(10, n - 2))\n",
            "def solve(n: int) -> str:\n    # digitsSum := 0\n    digits_sum = 0\n    # for _, d := range strconv.Itoa(n) {\n    for d in str(n):\n        # digit, _ := strconv.Atoi(string(d))\n        digit = int(d)\n        # digitsSum += digit\n        digits_sum += digit\n    # return strconv.FormatInt(int64(digitsSum), 2)\n    return str(digits_sum)\n",
            "def add(lst: List[int]) -> int:\n    # result := 0\n    result = 0\n    # for i, x := range lst {\n    for i, x in enumerate(lst):\n        # if i % 2 == 1 && x % 2 == 0 {\n        if i % 2 == 1 and x % 2 == 0:\n            # result += x\n            result += x\n    # return result\n    return result\n",
            "def anti_shuffle(s: str) -> str:\n    # words := strings.Split(s, \" \")\n    words = re.split(r\"\\s+\", s)\n    # for i, word := range words {\n    for i, word in enumerate(words):\n        # chars := []rune(word)\n        chars = list(word)\n        # sort.Slice(chars, func(i, j int) bool {\n        #     return chars[i] < chars[j]\n        # })\n        chars.sort()\n        # words[i] = string(chars)\n        words[i] = \"\".join(chars)\n    # return strings.Join(words, \" \")\n    return \" \".join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # coords := [][]int{}\n    coords = []\n    # for i := 0; i < len(lst); i++ {\n    for i in range(len(lst)):\n        # for j := 0; j < len(lst[i]); j++ {\n        for j in range(len(lst[i])):\n            # if lst[i][j] == x {\n            #     coords = append(coords, []int{i, j})\n            if lst[i][j] == x:\n                coords.append([i, j])\n    # sort.Slice(coords, func(i, j int) bool {\n    #     if coords[i][0] == coords[j][0] {\n    #         return coords[i][1] > coords[j][1]\n    #     }\n    #     return coords[i][0] < coords[j][0]\n    # })\n    coords.sort(key=lambda x: (x[0], -x[1]))\n    # return coords\n    return coords\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if len(arr) == 0 {\n    #     return []int{}\n    # }\n    if len(arr) == 0:\n        return []\n    # result := make([]int, len(arr))\n    # copy(result, arr)\n    result = copy.copy(arr)\n    # if (arr[0] + arr[len(arr) - 1]) % 2 == 0 {\n    #     sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    # } else {\n    #     sort.Ints(result)\n    # }\n    if (arr[0] + arr[len(arr) - 1]) % 2 == 0:\n        heapq.heapify(result)\n        heapq.heapify(result[::-1])\n        result = heapq.merge(result, result[::-1])\n    else:\n        heapq.heapify(result)\n    return result\n",
            "def encrypt(s: str) -> str:\n    # var result strings.Builder\n    result = ''\n    # for _, ch := range s {\n    for ch in s:\n        # shifted := ch + 4\n        shifted = ord(ch) + 4\n        # if shifted > 'z' {\n        if shifted > ord('z'):\n            # shifted -= 26\n            shifted -= 26\n        # result.WriteRune(shifted)\n        result += chr(shifted)\n    # return result.String()\n    return result\n",
            "def next_smallest(lst: List[int]) -> Optional[int]:\n    # tmp := make([]int, len(lst))\n    tmp = [0] * len(lst)\n    # copy(tmp, lst)\n    tmp[:] = lst\n    # sort.Ints(tmp)\n    tmp.sort()\n    # sl := []int{}\n    sl = []\n    # for i := 0; i < len(tmp); i++ {\n    for i in range(len(tmp)):\n        # if i == 0 || tmp[i] != tmp[i - 1] {\n        if i == 0 or tmp[i] != tmp[i - 1]:\n            # sl = append(sl, tmp[i])\n            sl.append(tmp[i])\n    # if len(sl) < 2 {\n    if len(sl) < 2:\n        # return nil\n        return None\n    # return &sl[1]\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # sentences := regexp.MustCompile(`[.!?]\\s*`).Split(s, -1)\n    sentences = re.split(r'[.!?]\\s*', s)\n    # cnt := 0\n    cnt = 0\n    # for _, sentence := range sentences {\n    for sentence in sentences:\n        # if len(sentence) >= 2 && sentence[:2] == \"I \" {\n        #     cnt++\n        # }\n        if len(sentence) >= 2 and sentence[:2] == \"I \":\n            cnt += 1\n    # return cnt\n    return cnt\n",
            "def any_int(x: int, y: int, z: int) -> bool:\n    # if intX, ok := x.(int); ok {\n    #     if intY, ok := y.(int); ok {\n    #         if intZ, ok := z.(int); ok {\n    #             if (intX+intY == intZ) || (intX+intZ == intY) || (intY+intZ == intX) {\n    #                 return true\n    #             }\n    #         }\n    #     }\n    # }\n    # return false\n    return (x + y == z) or (x + z == y) or (y + z == x)\n",
            "def encode(message: str) -> str:\n    # vowels := \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # var result strings.Builder\n    result = \"\"\n    # for _, ch := range message {\n    for ch in message:\n        # if unicode.IsLetter(ch) {\n        if ch.isalpha():\n            # var ch1 rune\n            ch1 = \"\"\n            # if unicode.IsLower(ch) {\n            if ch.islower():\n                # ch1 = unicode.ToUpper(ch)\n                ch1 = ch.upper()\n            else:\n                # ch1 = unicode.ToLower(ch)\n                ch1 = ch.lower()\n            # if strings.ContainsRune(vowels, ch1) {\n            if ch1 in vowels:\n                # ch1 = rune(int(ch1) + 2)\n                ch1 = chr(ord(ch1) + 2)\n            # result.WriteRune(ch1)\n            result += ch1\n        else:\n            # result.WriteRune(ch)\n            result += ch\n    # return result.String()\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    #     return false\n    # }\n    if n < 2:\n        return False\n    # for i := 2; i <= int(math.Floor(math.Sqrt(float64(n)))); i++ {\n    for i in range(2, int(math.floor(math.sqrt(n))) + 1):\n        # if n % i == 0 {\n        #     return false\n        # }\n        if n % i == 0:\n            return False\n    # return true\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # maxPrime := 0\n    max_prime = 0\n    # for _, n := range lst {\n    for n in lst:\n        # if IsPrime(n) && n > maxPrime {\n        #     maxPrime = n\n        # }\n        if is_prime(n) and n > max_prime:\n            max_prime = n\n    # if maxPrime == 0 {\n    #     return 0\n    # }\n    if max_prime == 0:\n        return 0\n    # largest := strconv.Itoa(maxPrime)\n    largest = str(max_prime)\n    # result := 0\n    result = 0\n    # for _, d := range largest {\n    for d in largest:\n        # result += int(d - '0')\n        result += int(d) - ord('0')\n    # return result\n    return result\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if len(d) == 0 {\n    #     return false\n    # }\n    if not d:\n        return False\n    # lower, upper := true, true\n    lower, upper = True, True\n    # for k, _ := range d {\n    for k in d:\n        # for _, r := range k {\n        #     if !unicode.IsLower(r) {\n        #         lower = false\n        #     }\n        #     if !unicode.IsUpper(r) {\n        #         upper = false\n        #     }\n        # }\n        for r in k:\n            if not unicodedata.islower(r):\n                lower = False\n            if not unicodedata.isupper(r):\n                upper = False\n    # return lower || upper\n    return lower or upper\n",
            "def count_up_to(n: int) -> List[int]:\n    # primes := make([]int, 0)\n    primes = []\n    # for num := 2; num < n; num++ {\n    for num in range(2, n):\n        # flag := true\n        flag = True\n        # for _, p := range primes {\n        for p in primes:\n            # if num % p == 0 {\n            #     flag = false\n            #     break\n            # }\n            if num % p == 0:\n                flag = False\n                break\n        # if flag {\n        #     primes = append(primes, num)\n        # }\n        if flag:\n            primes.append(num)\n    # return primes\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # return (int(math.Abs(float64(a))) % 10) * (int(math.Abs(float64(b))) % 10)\n    return (int(abs(float(a))) % 10) * (int(abs(float(b))) % 10)\n",
            "def count_upper(s: str) -> int:\n    # vowels := \"AEIOU\"\n    vowels = \"AEIOU\"\n    # count := 0\n    count = 0\n    # for i, c := range s {\n    for i, c in enumerate(s):\n        # if i % 2 == 0 && strings.Contains(vowels, string(c)) {\n        if i % 2 == 0 and c in vowels:\n            # count++\n            count += 1\n    # return count\n    return count\n",
            "def closest_integer(value: str) -> int:\n    # num, _ := strconv.ParseFloat(value, 64)\n    num = float(value)\n    # if num >= 0 {\n    #     return int(num + 0.5)\n    # } else {\n    #     return int(num - 0.5)\n    # }\n    return int(num + 0.5) if num >= 0 else int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # result := make([]int, n)\n    result = [0] * n\n    # for i := 0; i < n; i++ {\n    for i in range(n):\n        # result[i] = n + 2 * i\n        result[i] = n + 2 * i\n    # return result\n    return result\n",
            "def words_string(s: str) -> List[str]:\n    # words := regexp.MustCompile(`[, ]`).Split(s, -1)\n    words = re.split(r'[, ]', s)\n    # result := make([]string, 0)\n    result = []\n    # for _, w := range words {\n    for w in words:\n        # if len(w) > 0 {\n        #     result = append(result, w)\n        if len(w) > 0:\n            result.append(w)\n    # return result\n    return result\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    #     return -1;\n    # }\n    if x > y:\n        return -1\n    # if (y % 2 == 0) {\n    #     return y;\n    # }\n    if y % 2 == 0:\n        return y\n    # if (y != x) {\n    #     return y - 1;\n    # }\n    if y != x:\n        return y - 1\n    # return -1;\n    return -1\n",
            "def rounded_avg(n: int, m: int) -> Optional[str]:\n    # if n > m {\n    #     return nil\n    # }\n    if n > m:\n        return None\n    # rAvg := int(float64((n + m)) / 2.0 + 0.5)\n    r_avg = int(float((n + m)) / 2.0 + 0.5)\n    # result := strconv.FormatInt(int64(rAvg), 2)\n    result = str(r_avg)\n    # return &result\n    return result\n",
            "def all_odd_digits(s: str) -> bool:\n    # for _, digit := range s {\n    for digit in s:\n        # if digit % 2 == 0 {\n        #     return false\n        # }\n        if digit % 2 == 0:\n            return False\n    # return true\n    return True\ndef unique_digits(x: List[int]) -> List[int]:\n    # var result []int\n    result = []\n    # for _, num := range x {\n    for num in x:\n        # if AllOddDigits(strconv.Itoa(num)) {\n        #     result = append(result, num)\n        # }\n        if all_odd_digits(str(num)):\n            result.append(num)\n    # sort.Ints(result)\n    result.sort()\n    # return result\n    return result\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # digitNames := []string{\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # var sortedArr []int\n    sorted_arr = []\n    # for _, x := range arr {\n    for x in arr:\n        # if 1 <= x && x <= 9 {\n        if 1 <= x <= 9:\n            # sortedArr = append(sortedArr, x)\n            sorted_arr.append(x)\n    # sort.Slice(sortedArr, func(i, j int) bool {\n    #     return sortedArr[i] > sortedArr[j]\n    # })\n    sorted_arr.sort(key=lambda x: x, reverse=True)\n    # var result []string\n    result = []\n    # for _, x := range sortedArr {\n    for x in sorted_arr:\n        # result = append(result, digitNames[x - 1])\n        result.append(digit_names[x - 1])\n    # return result\n    return result\n",
            "def f(n: int) -> List[int]:\n    # nums := make([]int, n)\n    nums = [0] * n\n    # for i := 0; i < n; i++ {\n    for i in range(n):\n        # nums[i] = i + 1\n        nums[i] = i + 1\n    # var result []int\n    result = []\n    # for _, i := range nums {\n    for i in nums:\n        # if i % 2 != 0 {\n        if i % 2 != 0:\n            # sum := 0\n            sum = 0\n            # for _, j := range nums[:i] {\n            for j in nums[:i]:\n                # sum += j\n                sum += j\n            # result = append(result, sum)\n            result.append(sum)\n        # } else {\n        else:\n            # product := 1\n            product = 1\n            # for _, j := range nums[:i] {\n            for j in nums[:i]:\n                # product *= j\n                product *= j\n            # result = append(result, product)\n            result.append(product)\n    # return result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # runes := []rune(s)\n    runes = list(s)\n    # for i := 0; i < len(runes)/2; i++ {\n    for i in range(len(runes) // 2):\n        # if runes[i] != runes[len(runes)-1-i] {\n        #     return false\n        # }\n        if runes[i] != runes[len(runes) - 1 - i]:\n            return False\n    # return true\n    return True\ndef even_odd_palindrome(n: int) -> List[int]:\n    # cnt := []int{0, 0}\n    cnt = [0, 0]\n    # for i := 1; i <= n; i++ {\n    for i in range(1, n + 1):\n        # if IsPalindrome(strconv.Itoa(i)) {\n        #     cnt[i % 2] += 1\n        # }\n        if is_palindrome(str(i)):\n            cnt[i % 2] += 1\n    # return cnt\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # nStr := strconv.Itoa(n)\n    n_str = str(n)\n    # if n >= 0 {\n    if n >= 0:\n        # acc := 0\n        acc = 0\n        # for _, d := range nStr {\n        for d in n_str:\n            # dInt, _ := strconv.Atoi(string(d))\n            # acc += dInt\n            acc += int(d)\n        # return acc\n        return acc\n    # } else {\n    else:\n        # neg, _ := strconv.Atoi(nStr[0:2])\n        neg = int(n_str[0:2])\n        # return neg * 2 + DigitsSum(int(math.Abs(float64(n))))\n        return neg * 2 + digits_sum(int(math.fabs(float(n))))\n    # }\n# }\ndef count_nums(arr: List[int]) -> int:\n    # cnt := 0\n    cnt = 0\n    # for _, n := range arr {\n    for n in arr:\n        # if DigitsSum(n) > 0 {\n        if digits_sum(n) > 0:\n            # cnt += 1\n            cnt += 1\n    # return cnt\n    return cnt\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if len(arr) == 0 {\n    #     return true\n    # }\n    if len(arr) == 0:\n        return True\n    # sortedArr := make([]int, len(arr))\n    # copy(sortedArr, arr)\n    # sort.Ints(sortedArr)\n    sorted_arr = copy.copy(arr)\n    sorted_arr.sort()\n    # for i := 0; i < len(arr); i++ {\n    for i in range(len(arr)):\n        # if reflect.DeepEqual(arr[i:], sortedArr[:len(arr) - i]) && reflect.DeepEqual(arr[:i], sortedArr[len(arr) - i:]) {\n        #     return true\n        # }\n        if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n            return True\n    # return false\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # oddCnt := 0\n    odd_cnt = 0\n    # evenCnt := 0\n    even_cnt = 0\n    # for _, num := range lst1 {\n    for num in lst1:\n        # if num % 2 != 0 {\n        #     oddCnt += 1\n        # }\n        if num % 2 != 0:\n            odd_cnt += 1\n    # for _, num := range lst2 {\n    for num in lst2:\n        # if num % 2 == 0 {\n        #     evenCnt += 1\n        # }\n        if num % 2 == 0:\n            even_cnt += 1\n    # if evenCnt >= oddCnt {\n    #     return \"YES\"\n    # } else {\n    #     return \"NO\"\n    # }\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # freq := make(map[string]int)\n    freq = {}\n    # words := strings.Split(test, \" \")\n    words = test.split(\" \")\n    # for _, w := range words {\n    for w in words:\n        # if len(w) > 0 {\n        if len(w) > 0:\n            # freq[w] += 1\n            freq[w] = freq.get(w, 0) + 1\n    # result := make(map[string]int)\n    result = {}\n    # if len(freq) > 0 {\n    if freq:\n        # maxFreq := 0\n        max_freq = 0\n        # for _, v := range freq {\n        for _, v in freq.items():\n            # if v > maxFreq {\n            if v > max_freq:\n                # maxFreq = v\n                max_freq = v\n        # for k, v := range freq {\n        for k, v in freq.items():\n            # if v == maxFreq {\n            if v == max_freq:\n                # result[k] = v\n                result[k] = v\n    # return result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # runes := []rune(s)\n    runes = list(s)\n    # for i := 0; i < len(runes)/2; i++ {\n    for i in range(len(runes) // 2):\n        # if runes[i] != runes[len(runes)-1-i] {\n        #     return false\n        # }\n        if runes[i] != runes[-1-i]:\n            return False\n    # return true\n    return True\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # var s1 strings.Builder\n    s1 = \"\"\n    # for _, ch := range s {\n    for ch in s:\n        # if !strings.Contains(c, string(ch)) {\n        #     s1.WriteRune(ch)\n        # }\n        if ch not in c:\n            s1 += ch\n    # check := \"no\"\n    check = \"no\"\n    # if IsPalindrome(s1.String()) {\n    if is_palindrome(s1):\n        # check = \"yes\"\n        check = \"yes\"\n    # return []string{s1.String(), check}\n    return [s1, check]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # var result []string\n    result = []\n    # for _, num := range lst {\n    for num in lst:\n        # n := 0\n        n = 0\n        # for _, d := range num {\n        for d in num:\n            # if int(d) % 2 == 1 {\n            #     n++\n            # }\n            if int(d) % 2 == 1:\n                n += 1\n        # rs := \"the number of odd elements in the string i of the input.\"\n        # result = append(result, strings.ReplaceAll(rs, \"i\", strconv.Itoa(n)))\n        result.append(string.replace(rs, \"i\", str(n)))\n    # return result\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # minSum := 0\n    min_sum = 0\n    # curSum := 0\n    cur_sum = 0\n    # for _, n := range nums {\n    for n in nums:\n        # if curSum + n > 0 {\n        #     curSum = 0\n        # } else {\n        #     curSum += n\n        # }\n        if cur_sum + n > 0:\n            cur_sum = 0\n        else:\n            cur_sum += n\n        # if curSum < minSum {\n        #     minSum = curSum\n        # }\n        if cur_sum < min_sum:\n            min_sum = cur_sum\n    # if minSum == 0 {\n    #     minSum = math.MaxInt\n    #     for _, n := range nums {\n    #         if n < minSum {\n    #             minSum = n\n    #         }\n    #     }\n    # }\n    if min_sum == 0:\n        min_sum = math.inf\n        for n in nums:\n            if n < min_sum:\n                min_sum = n\n    # return minSum\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # result := 0\n    result = 0\n    # for _, arr := range grid {\n    for arr in grid:\n        # sum := 0\n        sum = 0\n        # for _, n := range arr {\n        for n in arr:\n            # sum += n\n            sum += n\n        # result += int(math.Ceil(float64(sum) / float64(capacity)))\n        result += int(math.ceil(float(sum) / float(capacity)))\n    # return result\n    return result\n",
            "def count_ones(num: int) -> int:\n    # return strings.Count(strconv.FormatInt(int64(num), 2), \"1\")\n    return string.count(bin(num)[2:], \"1\")\ndef sort_array(arr: List[int]) -> List[int]:\n    # result := make([]int, len(arr))\n    result = [0] * len(arr)\n    # copy(result, arr)\n    result[:] = arr\n    # sort.Slice(result, func(i, j int) bool {\n    #     if CountOnes(result[i]) == CountOnes(result[j]) {\n    #         return result[i] < result[j]\n    #     }\n    #     return CountOnes(result[i]) < CountOnes(result[j])\n    # })\n    result.sort(key=lambda x: (count_ones(x), x))\n    # return result\n    return result\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # consonants := \"bcdfghjklmnpqrstvwxyz\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # strs := strings.Split(s, \" \")\n    strs = s.split(\" \")\n    # words := []string{}\n    words = []\n    # for _, w := range strs {\n    for w in strs:\n        # if len(w) > 0 {\n        #     words = append(words, w)\n        if len(w) > 0:\n            words.append(w)\n    # result := []string{}\n    result = []\n    # for _, w := range words {\n    for w in words:\n        # count := 0\n        count = 0\n        # for _, c := range w {\n        for c in w:\n            # if strings.ContainsRune(consonants, unicode.ToLower(c)) {\n            #     count++\n            # }\n            if c.lower() in consonants:\n                count += 1\n        # if count == n {\n        #     result = append(result, w)\n        # }\n        if count == n:\n            result.append(w)\n    # return result\n    return result\n",
            "def get_closest_vowel(word: str) -> str:\n    # vowels := \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # for i := len(word) - 2; i > 0; i-- {\n    for i in range(len(word) - 2, 0, -1):\n        # if strings.ContainsRune(vowels, rune(word[i])) && !strings.ContainsRune(vowels, rune(word[i - 1])) && !strings.ContainsRune(vowels, rune(word[i + 1])) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return string(word[i])\n            return word[i]\n    # return \"\"\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # depth := 0\n    depth = 0\n    # for _, ch := range s {\n    for ch in s:\n        # if ch == '(' {\n        #     depth++\n        # } else {\n        #     depth--\n        # }\n        if ch == '(':\n            depth += 1\n        else:\n            depth -= 1\n        # if depth < 0 {\n        #     return false\n        # }\n        if depth < 0:\n            return False\n    # return depth == 0\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # s1 := lst[0] + lst[1]\n    # s2 := lst[1] + lst[0]\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n    # if Check(s1) || Check(s2) {\n    #     return \"Yes\"\n    # }\n    # return \"No\"\n    if check(s1) or check(s2):\n        return \"Yes\"\n    return \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if k == 0 {\n    #     return []int{}\n    # }\n    if k == 0:\n        return []\n    # result := make([]int, len(arr))\n    # copy(result, arr)\n    result = copy.copy(arr)\n    # sort.Ints(result)\n    heapq.heapify(result)\n    # return result[len(arr)-k:]\n    return result[len(arr)-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # result := 0\n    result = 0\n    # for i, x := range lst {\n    for i, x in enumerate(lst):\n        # if i % 2 == 0 && x % 2 != 0 {\n        if i % 2 == 0 and x % 2 != 0:\n            # result += x\n            result += x\n    # return result\n    return result\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # result := 0\n    result = 0\n    # for i := 0; i < k; i++ {\n    for i in range(k):\n        # if len(strconv.Itoa(arr[i])) <= 2 {\n        #     result += arr[i]\n        # }\n        if len(str(arr[i])) <= 2:\n            result += arr[i]\n    # return result\n    return result\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # collatz := []int{1}\n    collatz = [1]\n    # for n != 1 {\n    while n != 1:\n        # if n % 2 != 0 {\n        if n % 2 != 0:\n            # collatz = append(collatz, n)\n            collatz.append(n)\n            # n = 3 * n + 1\n            n = 3 * n + 1\n        else:\n            # n = n / 2\n            n = n / 2\n    # sort.Ints(collatz)\n    collatz.sort()\n    # return collatz\n    return collatz\n",
            "def valid_date(date: str) -> bool:\n    # if len(date) != 10 || date[2] != '-' || date[5] != '-' {\n    #     return false\n    # }\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    # m, _ := strconv.Atoi(date[:2])\n    # d, _ := strconv.Atoi(date[3:5])\n    m = int(date[:2])\n    d = int(date[3:5])\n    # for _, i := range []int{1, 3, 5, 7, 8, 10, 12} {\n    #     if i == m && d >= 1 && d <= 31 {\n    #         return true\n    #     }\n    # }\n    for i in [1, 3, 5, 7, 8, 10, 12]:\n        if i == m and 1 <= d <= 31:\n            return True\n    # for _, i := range []int{4, 6, 9, 11} {\n    #     if i == m && d >= 1 && d <= 30 {\n    #         return true\n    #     }\n    # }\n    for i in [4, 6, 9, 11]:\n        if i == m and 1 <= d <= 30:\n            return True\n    # if m == 2 && d >= 1 && d <= 29 {\n    #     return true\n    # }\n    if m == 2 and 1 <= d <= 29:\n        return True\n    # return false\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if strings.Contains(txt, \" \") {\n    if re.search(r\"\\s\", txt):\n        # return strings.Split(txt, \" \")\n        return txt.split()\n    # } else if strings.Contains(txt, \",\") {\n    elif re.search(r\",\", txt):\n        # return strings.Split(txt, \",\")\n        return txt.split(\",\")\n    # } else {\n    else:\n        # cnt := 0\n        cnt = 0\n        # for _, c := range txt {\n        for c in txt:\n            # if unicode.IsLower(c) && int(c) % 2 == 0 {\n            if c.islower() and int(c) % 2 == 0:\n                # cnt++\n                cnt += 1\n        # return []string{strconv.Itoa(cnt)}\n        return [str(cnt)]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # for i := 1; i < len(lst); i++ {\n    for i in range(1, len(lst)):\n        # if lst[i] < lst[i - 1] {\n        #     return false\n        # }\n        if lst[i] < lst[i - 1]:\n            return False\n    # freq := make(map[int]int)\n    freq = {}\n    # for _, i := range lst {\n    for i in lst:\n        # freq[i] += 1\n        freq[i] = freq.get(i, 0) + 1\n    # maxFreq := 0\n    max_freq = 0\n    # for _, v := range freq {\n    for v in freq.values():\n        # if v > maxFreq {\n        #     maxFreq = v\n        # }\n        if v > max_freq:\n            max_freq = v\n    # return len(lst) == 0 || maxFreq <= 2\n    return len(lst) == 0 or max_freq <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    #     return false\n    # }\n    if n < 2:\n        return False\n    # for i := 2; i <= int(math.Floor(math.Sqrt(float64(n)))); i++ {\n    for i in range(2, int(math.floor(math.sqrt(n))) + 1):\n        # if n % i == 0 {\n        #     return false\n        # }\n        if n % i == 0:\n            return False\n    # return true\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # l := max(interval1[0], interval2[0])\n    l = max(interval1[0], interval2[0])\n    # r := min(interval1[1], interval2[1])\n    r = min(interval1[1], interval2[1])\n    # length := r - l\n    length = r - l\n    # if length > 0 && IsPrime(length) {\n    if length > 0 and is_prime(length):\n        # return \"YES\"\n        return \"YES\"\n    # return \"NO\"\n    return \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if len(arr) == 0 {\n    #     return nil\n    # }\n    if len(arr) == 0:\n        return None\n    # result := 0\n    result = 0\n    # for _, n := range arr {\n    for n in arr:\n        # if n == 0 {\n        #     return &result\n        # }\n        if n == 0:\n            return result\n    # sign := 1\n    sign = 1\n    # for _, n := range arr {\n    for n in arr:\n        # if n < 0 {\n        #     sign *= -1\n        # }\n        if n < 0:\n            sign *= -1\n        # result += int(math.Abs(float64(n)))\n        result += int(abs(float(n)))\n    # result = sign * result\n    result *= sign\n    # return &result\n    return result\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # n := len(grid)\n    n = len(grid)\n    # minVal := n * n + 1\n    min_val = n * n + 1\n    # for i := 0; i < n; i++ {\n    for i in range(n):\n        # for j := 0; j < n; j++ {\n        for j in range(n):\n            # if grid[i][j] == 1 {\n            if grid[i][j] == 1:\n                # temp := []int{}\n                temp = []\n                # if i != 0 {\n                if i != 0:\n                    # temp = append(temp, grid[i - 1][j])\n                    temp.append(grid[i - 1][j])\n                # if j != 0 {\n                if j != 0:\n                    # temp = append(temp, grid[i][j - 1])\n                    temp.append(grid[i][j - 1])\n                # if i != n - 1 {\n                if i != n - 1:\n                    # temp = append(temp, grid[i + 1][j])\n                    temp.append(grid[i + 1][j])\n                # if j != n - 1 {\n                if j != n - 1:\n                    # temp = append(temp, grid[i][j + 1])\n                    temp.append(grid[i][j + 1])\n                # minVal = temp[0]\n                # for _, v := range temp {\n                #     if v < minVal {\n                #         minVal = v\n                #     }\n                # }\n                min_val = temp[0]\n                for v in temp:\n                    if v < min_val:\n                        min_val = v\n    # result := []int{}\n    result = []\n    # for i := 0; i < k; i++ {\n    for i in range(k):\n        # if i % 2 == 0 {\n        if i % 2 == 0:\n            # result = append(result, 1)\n            result.append(1)\n        # else {\n        else:\n            # result = append(result, minVal)\n            result.append(min_val)\n    # return result\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if n == 0 {\n    #     return []int{1}\n    # }\n    if n == 0:\n        return [1]\n    # seq := []int{1, 3}\n    seq = [1, 3]\n    # for i := 2; i <= n; i++ {\n    for i in range(2, n + 1):\n        # if i % 2 == 0 {\n        #     seq = append(seq, i / 2 + 1)\n        # } else {\n        #     seq = append(seq, seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n        # }\n        if i % 2 == 0:\n            seq.append(i // 2 + 1)\n        else:\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) // 2)\n    # return seq\n    return seq\n",
            "def digits(n: int) -> int:\n    # odds := []int{}\n    odds = []\n    # for _, d := range strconv.Itoa(n) {\n    for d in str(n):\n        # if int(d - '0') % 2 == 1 {\n        #     odds = append(odds, int(d - '0'))\n        if int(d) % 2 == 1:\n            odds.append(int(d))\n    # if len(odds) == 0 {\n    if len(odds) == 0:\n        # return 0\n        return 0\n    # result := 1\n    result = 1\n    # for _, d := range odds {\n    for d in odds:\n        # result *= d\n        result *= d\n    # return result\n    return result\n",
            "def is_nested(s: str) -> bool:\n    # openIdx := []int{}\n    open_idx = []\n    # closeIdx := []int{}\n    close_idx = []\n    # for i, ch := range s {\n    for i, ch in enumerate(s):\n        # switch ch {\n        #     case '[':\n        #         openIdx = append(openIdx, i)\n        #     case ']':\n        #         closeIdx = append([]int{i}, closeIdx...)\n        # }\n        if ch == '[':\n            open_idx.append(i)\n        elif ch == ']':\n            close_idx.append(i)\n    # cnt := 0\n    cnt = 0\n    # i := 0\n    i = 0\n    # l := len(closeIdx)\n    l = len(close_idx)\n    # for _, idx := range openIdx {\n    for idx in open_idx:\n        # if i < l && idx < closeIdx[i] {\n        #     cnt++\n        #     i++\n        # }\n        if i < l and idx < close_idx[i]:\n            cnt += 1\n            i += 1\n    # return cnt >= 2\n    return cnt >= 2\n",
            "def sum_squares(lst: List[float]) -> int:\n    # result := 0\n    result = 0\n    # for _, n := range lst {\n    for n in lst:\n        # result += int(math.Pow(math.Ceil(n), 2))\n        result += int(math.pow(math.ceil(n), 2))\n    # return result\n    return result\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if len(txt) == 0 {\n    #     return false\n    # }\n    if len(txt) == 0:\n        return False\n    # last := txt[strings.LastIndex(txt, \" \")+1:]\n    last = txt[txt.rfind(\" \") + 1:]\n    # return len(last) == 1 && unicode.IsLetter(rune(last[0]))\n    return len(last) == 1 and last[0].isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if len(arr) <= 1 {\n    #     return -1\n    # }\n    if len(arr) <= 1:\n        return -1\n    # idx := []int{}\n    idx = []\n    # for i := 1; i < len(arr); i++ {\n    for i in range(1, len(arr)):\n        # if arr[i] < arr[i - 1] {\n        #     idx = append(idx, i)\n        # }\n        if arr[i] < arr[i - 1]:\n            idx.append(i)\n    # if len(idx) == 0 {\n    #     return -1\n    # }\n    if len(idx) == 0:\n        return -1\n    # maxIdx := idx[0]\n    # for _, i := range idx {\n    #     if i > maxIdx {\n    #         maxIdx = i\n    #     }\n    # }\n    max_idx = idx[0]\n    for i in idx:\n        if i > max_idx:\n            max_idx = i\n    # return maxIdx\n    return max_idx\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # var maxNeg *int = nil\n    max_neg: Optional[int] = None\n    # var minPos *int = nil\n    min_pos: Optional[int] = None\n    # for _, n := range lst {\n    for n in lst:\n        # if n < 0 {\n        if n < 0:\n            # if maxNeg == nil {\n            if max_neg is None:\n                # maxNeg = new(int)\n                # *maxNeg = n\n                max_neg = n\n            # else if n > *maxNeg {\n            elif n > max_neg:\n                # *maxNeg = n\n                max_neg = n\n        # }\n        if n > 0:\n            # if minPos == nil {\n            if min_pos is None:\n                # minPos = new(int)\n                # *minPos = n\n                min_pos = n\n            # else if n < *minPos {\n            elif n < min_pos:\n                # *minPos = n\n                min_pos = n\n    # return []*int{maxNeg, minPos}\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if oStr, ok := o.(string); ok {\n    if isinstance(o, str):\n        # oFloat, _ := strconv.ParseFloat(strings.ReplaceAll(oStr, \",\", \".\"), 64);\n        o_float = float(o.replace(\",\", \".\"))\n        return o_float\n    # } else if oInt, ok := o.(int); ok {\n    elif isinstance(o, int):\n        # return float64(oInt)\n        return float(o)\n    # } else if oFloat, ok := o.(float64); ok {\n    elif isinstance(o, float):\n        # return oFloat\n        return o\n    # }\n    # panic(\"Type Error\")\n    raise TypeError(\"Type Error\")\ndef compare_one(a: Any, b: Any) -> Optional[float]:\n    # a1 := AnyToReal(a)\n    a1 = any_to_real(a)\n    # b1 := AnyToReal(b)\n    b1 = any_to_real(b)\n    # ptr := new(float64)\n    ptr = 0.0\n    # if a1 == b1 {\n    if a1 == b1:\n        # return nil\n        return None\n    # } else if a1 > b1 {\n    elif a1 > b1:\n        # *ptr = a1\n        ptr = a1\n        # return ptr\n        return ptr\n    # } else {\n    else:\n        # *ptr = b1\n        ptr = b1\n        # return ptr\n        return ptr\n    # }\n    # return ptr\n    return ptr\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return n%2 == 0 && n >= 8\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # fact := 1\n    fact = 1\n    # result := 1\n    result = 1\n    # for i := 1; i <= n; i++ {\n    for i in range(1, n + 1):\n        # fact *= i\n        fact *= i\n        # result *= fact\n        result *= fact\n    # return result\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return strings.ReplaceAll(regexp.MustCompile(`\\s{3,}`).ReplaceAllString(txt, \"-\"), \" \", \"_\")\n    return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n",
            "def file_name_check(file_name: str) -> str:\n    # suf := []string{\"txt\", \"exe\", \"dll\"}\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # lst := strings.Split(fileName, \".\")\n    lst = file_name.split(\".\")\n    # if len(lst) != 2 || len(lst[0]) == 0 || !unicode.IsLetter(rune(lst[0][0])) {\n    if len(lst) != 2 or len(lst[0]) == 0 or not lst[0][0].isalpha():\n        return \"No\"\n    # found := false\n    found = False\n    # for _, s := range suf {\n    for s in suf:\n        # if s == lst[1] {\n        #     found = true\n        #     break\n        # }\n        if s == lst[1]:\n            found = True\n            break\n    # if !found {\n    if not found:\n        return \"No\"\n    # digitCnt := 0\n    digitCnt = 0\n    # for _, ch := range lst[0] {\n    for ch in lst[0]:\n        # if unicode.IsDigit(ch) {\n        #     digitCnt++\n        # }\n        if ch.isdigit():\n            digitCnt += 1\n    # if digitCnt > 3 {\n    if digitCnt > 3:\n        return \"No\"\n    # }\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # result := 0\n    result = 0\n    # for i := 0; i < len(lst); i++ {\n    for i in range(len(lst)):\n        # if i % 3 == 0 {\n        #     result += int(math.Pow(float64(lst[i]), 2))\n        # } else if i % 4 == 0 {\n        #     result += int(math.Pow(float64(lst[i]), 3))\n        # } else {\n        #     result += lst[i]\n        # }\n        if i % 3 == 0:\n            result += int(math.pow(lst[i], 2))\n        elif i % 4 == 0:\n            result += int(math.pow(lst[i], 3))\n        else:\n            result += lst[i]\n    # return result\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    #     return false\n    # }\n    if n < 2:\n        return False\n    # for i := 2; i <= int(math.Floor(math.Sqrt(float64(n)))); i++ {\n    for i in range(2, int(math.floor(math.sqrt(n))) + 1):\n        # if n % i == 0 {\n        #     return false\n        # }\n        if n % i == 0:\n            return False\n    # return true\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # strs := strings.Split(sentence, \" \")\n    strs = sentence.split(\" \")\n    # words := []string{}\n    words = []\n    # for _, word := range strs {\n    for word in strs:\n        # if IsPrime(len(word)) {\n        #     words = append(words, word)\n        # }\n        if is_prime(len(word)):\n            words.append(word)\n    # return strings.Join(words, \" \")\n    return \" \".join(words)\n",
            "def simplify(x: str, n: str) -> bool:\n    # xs := strings.Split(x, \"/\")\n    xs = re.split(r'/', x)\n    # ns := strings.Split(n, \"/\")\n    ns = re.split(r'/', n)\n    # num0, _ := strconv.Atoi(xs[0])\n    num0 = int(xs[0])\n    # den0, _ := strconv.Atoi(xs[1])\n    den0 = int(xs[1])\n    # num1, _ := strconv.Atoi(ns[0])\n    num1 = int(ns[0])\n    # den1, _ := strconv.Atoi(ns[1])\n    den1 = int(ns[1])\n    # return (num0 * num1) % (den0 * den1) == 0\n    return (num0 * num1) % (den0 * den1) == 0\n",
            "def digits_sum(n: int) -> int:\n    # nStr := strconv.Itoa(n)\n    n_str = str(n)\n    # if n >= 0 {\n    if n >= 0:\n        # acc := 0\n        acc = 0\n        # for _, d := range nStr {\n        for d in n_str:\n            # dInt, _ := strconv.Atoi(string(d))\n            # acc += dInt\n            acc += int(d)\n        # return acc\n        return acc\n    # } else {\n    else:\n        # neg, _ := strconv.Atoi(nStr[0:2])\n        neg = int(n_str[0:2])\n        # return neg * 2 + DigitsSum(int(math.Abs(float64(n))))\n        return neg * 2 + digits_sum(int(math.fabs(float(n))))\n    # }\n# }\ndef order_by_points(nums: List[int]) -> List[int]:\n    # result := make([]int, len(nums))\n    result = [0] * len(nums)\n    # copy(result, nums)\n    result[:] = nums\n    # sort.SliceStable(result, func(i, j int) bool {\n    #     return DigitsSum(result[i]) < DigitsSum(result[j])\n    # })\n    result.sort(key=lambda x: digits_sum(x))\n    # return result\n    return result\n",
            "def special_filter(nums: List[int]) -> int:\n    # odds := \"13579\"\n    odds = \"13579\"\n    # cnt := 0\n    cnt = 0\n    # for _, n := range nums {\n    for n in nums:\n        # if n > 10 && n % 2 == 1 && strings.Contains(odds, string(strconv.Itoa(n)[0])) {\n        if n > 10 and n % 2 == 1 and str(str(n)[0]) in odds:\n            # cnt += 1\n            cnt += 1\n    # return cnt\n    return cnt\n",
            "def get_max_triples(n: int) -> int:\n    # c := [3]int{0, 0, 0}\n    c = [0, 0, 0]\n    # for i := 1; i <= n; i++ {\n    for i in range(1, n + 1):\n        # a := i * i - i + 1\n        a = i * i - i + 1\n        # c[a % 3] += 1\n        c[a % 3] += 1\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # names := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # l, r := -1, -1\n    l, r = -1, -1\n    # for i, name := range names {\n    for i, name in enumerate(names):\n        # if name == planet1 {\n        #     l = i\n        # }\n        if name == planet1:\n            l = i\n        # if name == planet2 {\n        #     r = i\n        # }\n        if name == planet2:\n            r = i\n    # if l == -1 || r == -1 {\n    if l == -1 or r == -1:\n        # return []string{}\n        return []\n    # if l > r {\n    #     l, r = r, l\n    # }\n    if l > r:\n        l, r = r, l\n    # if l == r {\n    #     return []string{}\n    # }\n    if l == r:\n        return []\n    # return names[l + 1 : r]\n    return names[l + 1 : r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # result := []string{}\n    result = []\n    # for _, s := range lst {\n    for s in lst:\n        # if len(s) % 2 == 0 {\n        #     result = append(result, s)\n        # }\n        if len(s) % 2 == 0:\n            result.append(s)\n    # sort.Slice(result, func(i, j int) bool {\n    #     if len(result[i]) == len(result[j]) {\n    #         return result[i] < result[j]\n    #     }\n    #     return len(result[i]) < len(result[j])\n    # })\n    result.sort(key=lambda x: (len(x), x))\n    # return result\n    return result\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if n < 2 {\n    #     return y\n    # }\n    if n < 2:\n        return y\n    # for i := 2; i <= int(math.Floor(math.Sqrt(float64(n)))); i++ {\n    for i in range(2, int(math.floor(math.sqrt(n))) + 1):\n        # if n % i == 0 {\n        #     return y\n        # }\n        if n % i == 0:\n            return y\n    # return x\n    return x\n",
            "def double_the_difference(lst: List[float]) -> int:\n    # acc := 0\n    acc = 0\n    # for _, n := range lst {\n    for n in lst:\n        # if n >= 0 && int(n) % 2 == 1 {\n        if n >= 0 and int(n) % 2 == 1:\n            # acc += int(n * n)\n            acc += int(n * n)\n    # return acc\n    return acc\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # result := make([]int, len(game))\n    result = [0] * len(game)\n    # for x, i := range game {\n    for x, i in enumerate(game):\n        # result[x] = int(math.Abs(float64(i - guess[x])))\n        result[x] = int(math.fabs(i - guess[x]))\n    # return result\n    return result\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # maxS := math.MinInt\n    max_s = math.inf\n    # maxExt := \"\"\n    max_ext = \"\"\n    # for _, ext := range extensions {\n    for ext in extensions:\n        # upper := 0\n        upper = 0\n        # lower := 0\n        lower = 0\n        # for _, c := range ext {\n        for c in ext:\n            # if unicode.IsUpper(c) {\n            #     upper += 1\n            # } else if unicode.IsLower(c) {\n            #     lower += 1\n            # }\n            if c.isupper():\n                upper += 1\n            elif c.islower():\n                lower += 1\n        # s := upper - lower\n        s = upper - lower\n        # if s > maxS {\n        if s > max_s:\n            # maxS = s\n            max_s = s\n            # maxExt = ext\n            max_ext = ext\n    # return fmt.Sprintf(\"%s.%s\", className, maxExt)\n    return \"{}.{}\".format(class_name, max_ext)\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if len(a) < len(b) {\n    #     return false\n    # }\n    if len(a) < len(b):\n        return False\n    # for i := 0; i < len(b); i++ {\n    for i in range(len(b)):\n        # if strings.Contains(a, b[i:]+b[:i]) {\n        #     return true\n        # }\n        if b[i:] in a[:-i] + a[:i]:\n            return True\n    # return false\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # ds := strconv.Itoa(int(math.Abs(float64(num))))\n    ds = str(abs(num))\n    # even := 0\n    even = 0\n    # for _, d := range ds {\n    for d in ds:\n        # if int(d) % 2 == 0 {\n        #     even++\n        # }\n        if int(d) % 2 == 0:\n            even += 1\n    # return []int{even, len(ds) - even}\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 ,5, 4, 1}\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 ,5, 4, 1]\n    # numerals := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # var res strings.Builder\n    res = \"\"\n    # for i := 0; i < len(values); i++ {\n    for i in range(len(values)):\n        # for num >= values[i] {\n        #     res.WriteString(numerals[i])\n        #     num -= values[i]\n        # }\n        while num >= values[i]:\n            res += numerals[i]\n            num -= values[i]\n    # return res.String()\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # s := []int{a, b, c}\n    s = [a, b, c]\n    # sort.Ints(s)\n    s.sort()\n    # return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # maxCnt := 0\n    max_cnt = 0\n    # maxW := \"\"\n    max_w = \"\"\n    # for _, w := range words {\n    for w in words:\n        # cnt := 0\n        cnt = 0\n        # freq := make(map[rune]bool)\n        freq = {}\n        # for _, c := range w {\n        for c in w:\n            # if !freq[c] {\n            #     freq[c] = true\n            #     cnt++\n            # }\n            if c not in freq:\n                freq[c] = True\n                cnt += 1\n        # if cnt > maxCnt {\n        #     maxCnt = cnt\n        #     maxW = w\n        # } else if cnt == maxCnt {\n        #     maxW = min(maxW, w)\n        # }\n        if cnt > max_cnt:\n            max_cnt = cnt\n            max_w = w\n        elif cnt == max_cnt:\n            max_w = min(max_w, w)\n    # return maxW\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if need <= remaining {\n    #     return []int{num + need, remaining - need}\n    # } else {\n    #     return []int{num + remaining, 0}\n    # }\n    return [num + need, remaining - need] if need <= remaining else [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # ops := make([]string, len(operators))\n    # nums := make([]int, len(operands))\n    ops = list(operators)\n    nums = list(operands)\n    # copy(ops, operators)\n    # copy(nums, operands)\n    # i := len(ops) - 1\n    i = len(ops) - 1\n    # for i >= 0 {\n    while i >= 0:\n        # if ops[i] == \"**\" {\n        #     nums[i] = int(math.Pow(float64(nums[i]), float64(nums[i + 1])))\n        #     nums = append(nums[:i + 1], nums[i + 2:]...)\n        #     ops = append(ops[:i], ops[i + 1:]...)\n        if ops[i] == \"**\":\n            nums[i] = int(math.pow(nums[i], nums[i + 1]))\n            nums = nums[:i + 1] + nums[i + 2:]\n            ops = ops[:i] + ops[i + 1:]\n        # }\n        i -= 1\n    # i = 0\n    i = 0\n    # for i < len(ops) {\n    while i < len(ops):\n        # if ops[i] == \"*\" {\n        #     nums[i] = nums[i] * nums[i + 1]\n        #     nums = append(nums[:i + 1], nums[i + 2:]...)\n        #     ops = append(ops[:i], ops[i + 1:]...)\n        #     i -= 1\n        # } else if ops[i] == \"//\" {\n        #     nums[i] = nums[i] / nums[i + 1]\n        #     nums = append(nums[:i + 1], nums[i + 2:]...)\n        #     ops = append(ops[:i], ops[i + 1:]...)\n        #     i -= 1\n        # }\n        if ops[i] == \"*\":\n            nums[i] = nums[i] * nums[i + 1]\n            nums = nums[:i + 1] + nums[i + 2:]\n            ops = ops[:i] + ops[i + 1:]\n            i -= 1\n        elif ops[i] == \"//\":\n            nums[i] = nums[i] / nums[i + 1]\n            nums = nums[:i + 1] + nums[i + 2:]\n            ops = ops[:i] + ops[i + 1:]\n            i -= 1\n        # i += 1\n        i += 1\n    # i = 0\n    i = 0\n    # for i < len(ops) {\n    while i < len(ops):\n        # if ops[i] == \"+\" {\n        #     nums[i] = nums[i] + nums[i + 1]\n        #     nums = append(nums[:i + 1], nums[i + 2:]...)\n        #     ops = append(ops[:i], ops[i + 1:]...)\n        #     i -= 1\n        # } else if ops[i] == \"-\" {\n        #     nums[i] = nums[i] - nums[i + 1]\n        #     nums = append(nums[:i + 1], nums[i + 2:]...)\n        #     ops = append(ops[:i], ops[i + 1:]...)\n        #     i -= 1\n        # }\n        if ops[i] == \"+\":\n            nums[i] = nums[i] + nums[i + 1]\n            nums = nums[:i + 1] + nums[i + 2:]\n            ops = ops[:i] + ops[i + 1:]\n            i -= 1\n        elif ops[i] == \"-\":\n            nums[i] = nums[i] - nums[i + 1]\n            nums = nums[:i + 1] + nums[i + 2:]\n            ops = ops[:i] + ops[i + 1:]\n            i -= 1\n        # i += 1\n        i += 1\n    # return nums[0]\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # flag := false\n    flag = False\n    # for _, ch := range s {\n    for ch in s:\n        # if unicode.IsLetter(ch) {\n        #     flag = true\n        #     break\n        # }\n        if ch.isalpha():\n            flag = True\n            break\n    # if !flag {\n    if not flag:\n        # runes := []rune(s)\n        runes = list(s)\n        # for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        #     runes[i], runes[j] = runes[j], runes[i]\n        # }\n        for i in range(len(runes) // 2):\n            runes[i], runes[-i-1] = runes[-i-1], runes[i]\n        # return string(runes)\n        return ''.join(runes)\n    # var result strings.Builder\n    result = []\n    # for _, ch := range s {\n    for ch in s:\n        # if !unicode.IsLetter(ch) {\n        #     result.WriteRune(ch)\n        # } else if unicode.IsUpper(ch) {\n        #     result.WriteRune(unicode.ToLower(ch))\n        # } else if unicode.IsLower(ch) {\n        #     result.WriteRune(unicode.ToUpper(ch))\n        # }\n        if not ch.isalpha():\n            result.append(ch)\n        elif ch.isupper():\n            result.append(ch.lower())\n        elif ch.islower():\n            result.append(ch.upper())\n    # return result.String()\n    return ''.join(result)\n",
            "def string_to_md5(txt: str) -> str:\n    # if txt == \"\" {\n    #     return nil\n    # }\n    if txt == \"\":\n        return None\n    # md5Hash := md5.New()\n    md5_hash = hashlib.md5()\n    # txtBytes := []byte(txt)\n    txt_bytes = txt.encode()\n    # md5Hash.Write(txtBytes)\n    md5_hash.update(txt_bytes)\n    # md5Encoded := hex.EncodeToString(md5Hash.Sum(nil))\n    md5_encoded = md5_hash.hexdigest()\n    # return &md5Encoded\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # lower := int(max(2.0, min(float64(a), float64(b))))\n    lower = int(max(2.0, min(float(a), float(b))))\n    # upper := int(min(8.0, max(float64(a), float64(b))))\n    upper = int(min(8.0, max(float(a), float(b))))\n    # numbers := []int{}\n    numbers = []\n    # for i := lower; i <= upper; i++ {\n    for i in range(lower, upper + 1):\n        # if i % 2 == 0 {\n        #     numbers = append(numbers, i)\n        # }\n        if i % 2 == 0:\n            numbers.append(i)\n    # return numbers\n    return numbers\n"
        ]
    },
    "java": {
        "python": [
            "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # for (int i = 0; i < numbers.size(); i++) {\n    for i in range(len(numbers)):\n        # for (int j = i + 1; j < numbers.size(); j++) {\n        for j in range(i + 1, len(numbers)):\n            # if (Math.abs(numbers.get(i) - numbers.get(j)) < threshold) {\n            if math.abs(numbers[i] - numbers[j]) < threshold:\n                # return true;\n                return True\n    # return false;\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # List<String> groups = new ArrayList<>();\n    groups = []\n    # List<Character> stk = new ArrayList<>();\n    stk = []\n    # String currentGroup = \"\";\n    current_group = \"\"\n    # String parens = parenString.replace(\" \", \"\");\n    parens = paren_string.replace(\" \", \"\")\n    # for (char ch : parens.toCharArray()) {\n    for ch in parens:\n        # if (ch == '(') {\n        if ch == '(':\n            # stk.add(ch);\n            stk.append(ch)\n            # currentGroup += ch;\n            current_group += ch\n        # } else if (ch == ')') {\n        elif ch == ')':\n            # stk.remove(stk.size() - 1);\n            stk.pop()\n            # currentGroup += ch;\n            current_group += ch\n            # if (stk.isEmpty()) {\n            if not stk:\n                # groups.add(currentGroup);\n                groups.append(current_group)\n                # currentGroup = \"\";\n                current_group = \"\"\n    # return groups;\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return num - Math.floor(num);\n    return num - math.floor(num)\n",
            "def below_zero(operations: List[int]) -> bool:\n    # int balance = 0;\n    balance = 0\n    # for (int op : operations) {\n    for op in operations:\n        # balance += op;\n        balance += op\n        # if (balance < 0) {\n        if balance < 0:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # double mean = numbers.stream().mapToDouble(x -> x).sum() / numbers.size();\n    mean = sum(numbers) / len(numbers)\n    # double deviation = numbers.stream().mapToDouble(x -> Math.abs(x - mean)).sum();\n    deviation = sum(abs(x - mean) for x in numbers)\n    # return deviation / numbers.size();\n    return deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # List<Integer> result = new ArrayList<>();\n    result = []\n    # for (int i = 0; i < numbers.size(); i++) {\n    for i in range(len(numbers)):\n        # if (i != 0) {\n        if i != 0:\n            # result.add(delimiter);\n            result.append(delimiter)\n        # result.add(numbers.get(i));\n        result.append(numbers[i])\n    # return result;\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # List<Integer> result = new ArrayList<>();\n    result = []\n    # List<String> parenGroups = Stream.of(parenString.split(\" \")).filter(s -> s.length() > 0).toList();\n    paren_groups = [s for s in paren_string.split(\" \") if len(s) > 0]\n    # for (String group : parenGroups) {\n    for group in paren_groups:\n        # int maxDepth = 0;\n        max_depth = 0\n        # int depth = 0;\n        depth = 0\n        # for (char ch : group.toCharArray()) {\n        for ch in group:\n            # if (ch == '(') {\n            if ch == '(':\n                # depth++;\n                depth += 1\n                # maxDepth = Math.max(maxDepth, depth);\n                max_depth = max(max_depth, depth)\n            # } else if (ch == ')') {\n            elif ch == ')':\n                # depth--;\n                depth -= 1\n        # result.add(maxDepth);\n        result.append(max_depth)\n    # return result;\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # return strs.stream().filter(s -> s.contains(substring)).toList();\n    return [s for s in strs if substring in s]\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # int nSum = numbers.stream().reduce(0, (a, b) -> a + b);\n    n_sum = sum(numbers)\n    # int nProduct = numbers.stream().reduce(1, (a, b) -> a * b);\n    n_product = 1\n    for n in numbers:\n        n_product *= n\n    # return List.of(nSum, nProduct);\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # int maxSoFar = Integer.MIN_VALUE;\n    max_so_far = float('-inf')\n    # List<Integer> result = new ArrayList<>();\n    result = []\n    # for (int num : numbers) {\n    for num in numbers:\n        # maxSoFar = Math.max(maxSoFar, num);\n        max_so_far = max(max_so_far, num)\n        # result.add(maxSoFar);\n        result.append(max_so_far)\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s.equals(new StringBuilder(s).reverse().toString());\n    return s == s[::-1]\ndef make_palindrome(s: str) -> str:\n    # if (isPalindrome(s)) {\n    if is_palindrome(s):\n        # return s;\n        return s\n    # for (int i = 0; i < s.length(); i++) {\n    for i in range(len(s)):\n        # if (isPalindrome(s.substring(i))) {\n        if is_palindrome(s[i:]):\n            # return s + new StringBuilder(s.substring(0, i)).reverse().toString();\n            return s + s[:i][::-1]\n    # return \"\";\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # return IntStream.range(0, a.length()).mapToObj(i -> a.charAt(i) == b.charAt(i) ? '0' : '1').collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();\n    return ''.join(str(int(a[i] != b[i])) for i in range(len(a)))\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if (strs.isEmpty()) {\n    if not strs:\n        # return Optional.empty();\n        return None\n    # String longestS = strs.get(0);\n    longest_s = strs[0]\n    # for (String s : strs) {\n    for s in strs:\n        # if (s.length() > longestS.length()) {\n        if len(s) > len(longest_s):\n            # longestS = s;\n            longest_s = s\n    # return Optional.of(longestS);\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if (b == 0) {\n    if b == 0:\n        # return a;\n        return a\n    # else {\n    else:\n        # return greatestCommonDivisor(b, a % b);\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # List<String> prefixes = new ArrayList<>();\n    prefixes = []\n    # for (int i = 0; i < s.length(); i++) {\n    for i in range(len(s)):\n        # prefixes.add(s.substring(0, i + 1));\n        prefixes.append(s[:i + 1])\n    # return prefixes;\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # return IntStream.range(0, n + 1).mapToObj(i -> Integer.toString(i)).collect(Collectors.joining(\" \"));\n    return ' '.join(str(i) for i in range(n + 1))\n",
            "def count_distinct_characters(s: str) -> int:\n    # return (int)s.toLowerCase().chars().distinct().count();\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # Map<String, Integer> durations = Map.of(\"o\", 4, \"o|\", 2, \".|\", 1);\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    # List<String> notes = Stream.of(musicString.split(\" \")).filter(s -> s.length() > 0).toList();\n    notes = [s for s in music_string.split(\" \") if len(s) > 0]\n    # return notes.stream().map(note -> durations.get(note)).toList();\n    return [durations[note] for note in notes]\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # int times = 0;\n    times = 0\n    # for (int i = 0; i <= s.length() - substring.length(); i++) {\n    for i in range(len(s) - len(substring) + 1):\n        # if (s.substring(i, i + substring.length()).equals(substring)) {\n        if s[i:i + len(substring)] == substring:\n            # times += 1;\n            times += 1\n    # return times;\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # Map<String, Integer> numDict = Map.of(\n    num_dict = {\n        # \"zero\", 0,\n        \"zero\": 0,\n        # \"one\", 1,\n        \"one\": 1,\n        # \"two\", 2,\n        \"two\": 2,\n        # \"three\", 3,\n        \"three\": 3,\n        # \"four\", 4,\n        \"four\": 4,\n        # \"five\", 5,\n        \"five\": 5,\n        # \"six\", 6,\n        \"six\": 6,\n        # \"seven\", 7,\n        \"seven\": 7,\n        # \"eight\", 8,\n        \"eight\": 8,\n        # \"nine\", 9\n        \"nine\": 9\n    }\n    # List<String> numList = Stream.of(numbers.split(\" \")).filter(x -> numDict.containsKey(x)).collect(Collectors.toList());\n    num_list = [x for x in numbers.split(\" \") if x in num_dict]\n    # numList.sort((a, b) -> numDict.get(a) - numDict.get(b));\n    num_list.sort(key=lambda x: num_dict[x])\n    # return String.join(\" \", numList);\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[float]) -> List[float]:\n    # List<Double> sortedNumbers = numbers.stream().sorted().toList();\n    sorted_numbers = sorted(numbers)\n    # double minDiff = Double.POSITIVE_INFINITY;\n    min_diff = float('inf')\n    # List<Double> closestPair = List.of();\n    closest_pair = []\n    # for (int i = 1; i < sortedNumbers.size(); i++) {\n    for i in range(1, len(sorted_numbers)):\n        # double diff = sortedNumbers.get(i) - sortedNumbers.get(i - 1);\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if (diff < minDiff) {\n        if diff < min_diff:\n            # minDiff = diff;\n            min_diff = diff\n            # closestPair = List.of(sortedNumbers.get(i - 1), sortedNumbers.get(i));\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return closestPair;\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # double minNum = Collections.min(numbers);\n    min_num = min(numbers)\n    # double maxNum = Collections.max(numbers);\n    max_num = max(numbers)\n    # if (minNum == maxNum) {\n    if min_num == max_num:\n        # return Collections.nCopies(numbers.size(), 0.0);\n        return [0.0] * len(numbers)\n    # } else {\n    else:\n        # return numbers.stream().map(num -> (num - minNum) / (maxNum - minNum)).toList();\n        return [\n            (num - min_num) / (max_num - min_num)\n            for num in numbers\n        ]\n",
            "def filter_integers(values: List[object]) -> List[int]:\n    # return values.stream().filter(value -> value instanceof Integer).map(value -> (Integer) value).toList();\n    return [value for value in values if isinstance(value, int)]\n",
            "def str_length(s: str) -> int:\n    # return s.length();\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for (int i = 2; i < n; i++) {\n    for i in range(2, n):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return n / i;\n            return n / i\n    # return 1;\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # List<Integer> factors = new ArrayList<>();\n    factors = []\n    # int divisor = 2;\n    divisor = 2\n    # while (divisor <= n) {\n    while divisor <= n:\n        # if (n % divisor == 0) {\n        if n % divisor == 0:\n            # factors.add(divisor);\n            factors.append(divisor)\n            # n /= divisor;\n            n //= divisor\n        # else {\n        else:\n            # divisor++;\n            divisor += 1\n    # return factors;\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # Map<Integer, Integer> counts = new HashMap<>();\n    counts = defaultdict(int)\n    # for (int num : numbers) {\n    for num in numbers:\n        # counts.put(num, counts.getOrDefault(num, 0) + 1);\n        counts[num] += 1\n    # List<Integer> res = numbers.stream().filter(num -> counts.get(num) == 1).toList();\n    res = [num for num in numbers if counts[num] == 1]\n    # return res;\n    return res\n",
            "def flip_case(s: str) -> str:\n    # StringBuilder flipped = new StringBuilder();\n    flipped = []\n    # for (char ch : s.toCharArray()) {\n    for ch in s:\n        # if (!Character.isLetter(ch)) {\n        if not ch.isalpha():\n            # flipped.append(ch);\n            flipped.append(ch)\n        # } else if (Character.isLowerCase(ch)) {\n        elif ch.islower():\n            # flipped.append(Character.toUpperCase(ch));\n            flipped.append(ch.upper())\n        # } else if (Character.isUpperCase(ch)) {\n        elif ch.isupper():\n            # flipped.append(Character.toLowerCase(ch));\n            flipped.append(ch.lower())\n    # return flipped.toString();\n    return ''.join(flipped)\n",
            "def concatenate(strs: List[str]) -> str:\n    # return String.join(\"\", strs);\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # return strs.stream().filter(s -> s.startsWith(prefixStr)).toList();\n    return [s for s in strs if s.startswith(prefix_str)]\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # return l.stream().filter(num -> num > 0).toList();\n    return list(filter(lambda num: num > 0, l))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def poly(xs: List[int], x: float) -> float:\n    # double res = 0;\n    res = 0\n    # for (int i = 0; i < xs.size(); i++) {\n    for i in range(len(xs)):\n        # res += xs.get(i) * Math.pow(x, i);\n        res += xs[i] * math.pow(x, i)\n    # return res;\n    return res\ndef find_zero(xs: List[int]) -> float:\n    # double x1 = 1.0, x2 = -1.0;\n    x1 = 1.0\n    x2 = -1.0\n    # while (poly(xs, x1) * poly(xs, x2) > 0) {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2;\n        x1 *= 2\n        # x2 *= 2;\n        x2 *= 2\n    # while (Math.abs(x1 - x2) > 1e-10) {\n    while math.fabs(x1 - x2) > 1e-10:\n        # double mid = (x1 + x2) / 2;\n        mid = (x1 + x2) / 2\n        # if (poly(xs, mid) == 0) {\n        if poly(xs, mid) == 0:\n            # return mid;\n            return mid\n        # else if (poly(xs, mid) * poly(xs, x1) < 0) {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid;\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid;\n            x1 = mid\n    # return (x1 + x2) / 2;\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # var sortedThird = IntStream.range(0, l.size()).filter(i -> i % 3 == 0).mapToObj(l::get).sorted().toList();\n    sorted_third = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    # return IntStream.range(0, l.size()).mapToObj(i -> i % 3 == 0 ? sortedThird.get(i/3) : l.get(i)).toList();\n    return [sorted_third[i//3] if i % 3 == 0 else l[i] for i in range(len(l))]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # return l.stream().distinct().sorted().toList();\n    return sorted(set(l))\n",
            "def max_element(l: List[int]) -> int:\n    # if (l.isEmpty()) {\n    if not l:\n        # return 0;\n        return 0\n    # return Collections.max(l);\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # if (i % 11 == 0 || i % 13 == 0) {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += String.valueOf(i).chars().filter(c -> c == '7').count();\n            cnt += sum(1 for c in str(i) if c == '7')\n    # return cnt;\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # var sortedEven = IntStream.range(0, l.size()).filter(i -> i % 2 == 0).mapToObj(l::get).sorted().toList();\n    sorted_even = [l[i] for i in range(len(l)) if i % 2 == 0]\n    sorted_even.sort()\n    # return IntStream.range(0, l.size()).mapToObj(i -> i % 2 == 0 ? sortedEven.get(i/2) : l.get(i)).toList();\n    return [sorted_even[i//2] if i % 2 == 0 else l[i] for i in range(len(l))]\n",
            "def encode_cyclic(s: str) -> str:\n    # var result = new StringBuilder();\n    result = ''\n    # for (int i = 0; i < s.length(); i += 3) {\n    for i in range(0, len(s), 3):\n        # if (i + 3 > s.length()) {\n        if i + 3 > len(s):\n            # result.append(s.substring(i));\n            result += s[i:]\n        else:\n            # result.append(s.substring(i + 1, i + 3));\n            result += s[i + 1:i + 3]\n            # result.append(s.charAt(i));\n            result += s[i]\n    # return result.toString();\n    return result\ndef decode_cyclic(s: str) -> str:\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef prime_fib(n: int) -> int:\n    # int[] f = {0, 1};\n    f = [0, 1]\n    # int cnt = 0;\n    cnt = 0\n    # while (cnt < n) {\n    while cnt < n:\n        # f = new int[]{f[1], f[0] + f[1]};\n        f = [f[1], f[0] + f[1]]\n        # if (isPrime(f[1])) {\n        if is_prime(f[1]):\n            # cnt++;\n            cnt += 1\n    # return f[1];\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for (int i = 0; i < l.size(); i++) {\n    for i in range(len(l)):\n        # for (int j = i + 1; j < l.size(); j++) {\n        for j in range(i + 1, len(l)):\n            # for (int k = j + 1; k < l.size(); k++) {\n            for k in range(j + 1, len(l)):\n                # if (l.get(i) + l.get(j) + l.get(k) == 0) {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true;\n                    return True\n    # return false;\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return (int)Math.pow(n, 2);\n    return int(n ** 2)\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # return l.stream().map(i -> i + 1).toList();\n    return [i + 1 for i in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # Set<Integer> seen = new HashSet<>();\n    seen = set()\n    # for (int num : l) {\n    for num in l:\n        # if (seen.contains(-num)) {\n        if -num in seen:\n            # return true;\n            return True\n        # seen.add(num);\n        seen.add(num)\n    # return false;\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if (x == 0) {\n    if x == 0:\n        # return \"0\";\n        return \"0\"\n    # List<String> digits = new ArrayList<>();\n    digits = []\n    # while (x > 0) {\n    while x > 0:\n        # digits.add(String.valueOf(x % bas));\n        digits.append(str(x % bas))\n        # x /= bas;\n        x //= bas\n    # Collections.reverse(digits);\n    digits.reverse()\n    # return String.join(\"\", digits);\n    return \"\".join(digits)\n",
            "def triangle_area(a: int, h: int) -> float:\n    # return (double) (a * h) / 2;\n    return (a * h) / 2\n",
            "def fib4(n: int) -> int:\n    # int[] fib = {0, 0, 2, 0};\n    fib = [0, 0, 2, 0]\n    # for (int i = 4; i <= n; i++) {\n    for i in range(4, n + 1):\n        # fib[i % 4] = IntStream.of(fib).sum();\n        fib[i % 4] = sum(fib)\n    # return fib[n % 4];\n    return fib[n % 4]\n",
            "def median(l: List[float]) -> float:\n    # List<Double> sl = l.stream().sorted().toList();\n    sl = sorted(l)\n    # if (l.size() % 2 != 0) {\n    if len(l) % 2 != 0:\n        # return sl.get(l.size() / 2);\n        return sl[len(l) // 2]\n    # } else {\n    else:\n        # return (sl.get(l.size() / 2) + sl.get(l.size() / 2 - 1)) / 2;\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt.equals(new StringBuilder(txt).reverse().toString());\n    return txt == str(txt[::-1])\n",
            "def modp(n: int, p: int) -> int:\n    # int ret = 1;\n    ret = 1\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # ret = (ret * 2) % p;\n        ret = (ret * 2) % p\n    # return ret;\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # var result = s.chars().map(ch -> (char)(((ch - 97 + 5) % 26) + 97)).toArray();\n    result = [((ch - 97 + 5) % 26) + 97 for ch in s]\n    # return new String(result, 0, result.length);\n    return ''.join(chr(ch) for ch in result)\ndef decode_shift(s: str) -> str:\n    # var result = s.chars().map(ch -> (char)(((ch - 97 + 21) % 26) + 97)).toArray();\n    result = [((ch - 97 + 21) % 26) + 97 for ch in s]\n    # return new String(result, 0, result.length);\n    return ''.join(chr(ch) for ch in result)\n",
            "def remove_vowels(txt: str) -> str:\n    # String vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # return txt.chars().filter(c -> vowels.indexOf(c) == -1).mapToObj(c -> String.valueOf((char)c)).collect(Collectors.joining(\"\"));\n    return \"\".join(c for c in txt if c not in vowels)\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # return l.stream().allMatch(x -> x < t);\n    return all(x < t for x in l)\n",
            "def add(x: int, y: int) -> int:\n    # return x + y;\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # return s0.chars().boxed().collect(Collectors.toSet()).equals(s1.chars().boxed().collect(Collectors.toSet()));\n    return set(s0) == set(s1)\n",
            "def fib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return n;\n        return n\n    # } else {\n    else:\n        # return fib(n - 1) + fib(n - 2);\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # for (int i = 0; i < brackets.length(); i++) {\n    for i in range(len(brackets)):\n        # char b = brackets.charAt(i);\n        b = brackets[i]\n        # if (b == '<') {\n        if b == '<':\n            # depth += 1;\n            depth += 1\n        # } else if (b == '>') {\n        elif b == '>':\n            # depth -= 1;\n            depth -= 1\n        # }\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n        # }\n    # return depth == 0;\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # var diff = IntStream.range(0, l.size() - 1).map(i -> l.get(i + 1) - l.get(i)).toArray();\n    diff = [l[i + 1] - l[i] for i in range(len(l) - 1)]\n    # return IntStream.of(diff).allMatch(x -> x <= 0) || IntStream.of(diff).allMatch(x -> x >= 0);\n    return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # return l1.stream().filter(x -> l2.contains(x)).distinct().sorted().toList();\n    return sorted(set(x for x in l1 if x in l2))\n",
            "def largest_prime_factor(n: int) -> int:\n    # int i = 2;\n    i = 2\n    # while (i * i <= n) {\n    while i * i <= n:\n        # if (n % i != 0) {\n        if n % i != 0:\n            # i++;\n            i += 1\n        else:\n            # n /= i;\n            n //= i\n    # return n;\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # return IntStream.range(0, n + 1).sum();\n    return sum(range(n + 1))\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # for (int i = 0; i < brackets.length(); i++) {\n    for i in range(len(brackets)):\n        # char b = brackets.charAt(i);\n        b = brackets[i]\n        # if (b == '(') {\n        if b == '(':\n            # depth += 1;\n            depth += 1\n        # } else if (b == ')') {\n        elif b == ')':\n            # depth -= 1;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n        # }\n    # return depth == 0;\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # return IntStream.range(1, xs.size()).mapToObj(i -> i * xs.get(i)).toList();\n    return [i * xs[i] for i in range(1, len(xs))]\n",
            "def fibfib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return 0;\n        return 0\n    # int a = 0, b = 0, c = 1;\n    a = 0\n    b = 0\n    c = 1\n    # while (n > 2) {\n    while n > 2:\n        # int tmp = a + b + c;\n        tmp = a + b + c\n        # a = b; b = c; c = tmp;\n        a = b\n        b = c\n        c = tmp\n        # n -= 1;\n        n -= 1\n    # return c;\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # String vowels = \"aeiou\";\n    vowels = \"aeiou\"\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 0; i < s.length(); i++) {\n    for i in range(len(s)):\n        # if (vowels.indexOf(Character.toLowerCase(s.charAt(i))) != -1 || (i == s.length() - 1 && Character.toLowerCase(s.charAt(i)) == 'y')) {\n        if (s[i].lower() in vowels) or (i == len(s) - 1 and s[i].lower() == 'y'):\n            # cnt += 1;\n            cnt += 1\n    # return cnt;\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # String xStr = Integer.toString(x);\n    x_str = str(x)\n    # if (shift > xStr.length()) {\n    if shift > len(x_str):\n        # return new StringBuilder(xStr).reverse().toString();\n        return x_str[::-1]\n    # } else {\n    #     return xStr.substring(xStr.length() - shift) + xStr.substring(0, xStr.length() - shift);\n    # }\n    return x_str[len(x_str) - shift:] + x_str[:len(x_str) - shift]\n",
            "def digit_sum(s: str) -> int:\n    # return s.chars().filter(c -> Character.isUpperCase(c)).sum();\n    return sum(c for c in s if c.isupper())\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # String[] words = s.split(\" \");\n    words = s.split()\n    # int apples = Integer.parseInt(words[Arrays.asList(words).indexOf(\"apples\") - 1]);\n    apples = int(words[words.index(\"apples\") - 1])\n    # int oranges = Integer.parseInt(words[Arrays.asList(words).indexOf(\"oranges\") - 1]);\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # return n - apples - oranges;\n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # var evens = arr.stream().filter(n -> n % 2 == 0).toList();\n    evens = [n for n in arr if n % 2 == 0]\n    # if (evens.size() == 0) {\n    if len(evens) == 0:\n        # return List.of();\n        return []\n    # var minEven = evens.stream().mapToInt(n -> n).min().getAsInt();\n    min_even = min(evens)\n    # return List.of(minEven, arr.indexOf(minEven));\n    return [min_even, arr.index(min_even)]\n",
            "",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # List<Integer> sl = lst.stream().sorted().toList();\n    sl = sorted(lst)\n    # List<Integer> result = new ArrayList<Integer>();\n    result = []\n    # int left = 0, right = sl.size() - 1;\n    left = 0\n    right = len(sl) - 1\n    # while (left <= right) {\n    while left <= right:\n        # result.add(sl.get(left));\n        result.append(sl[left])\n        # left += 1;\n        left += 1\n        # if (left <= right) {\n        if left <= right:\n            # result.add(sl.get(right));\n            result.append(sl[right])\n            # right -= 1;\n            right -= 1\n    # return result;\n    return result\n",
            "def triangle_area(a: int, b: int, c: int) -> float:\n    # if (a + b > c && a + c > b && b + c > a) {\n    if a + b > c and a + c > b and b + c > a:\n        # double s = (a + b + c) / 2.0;\n        s = (a + b + c) / 2.0\n        # return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # } else {\n    else:\n        # return -1.0;\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if (q.size() == 0) {\n    if len(q) == 0:\n        # return false;\n        return False\n    # boolean isPalin = IntStream.range(0, q.size()).allMatch(i -> q.get(i) == q.get(q.size() - i - 1));\n    is_palin = all(q[i] == q[-i - 1] for i in range(len(q)))\n    # int total = q.stream().mapToInt(x -> x).sum();\n    total = sum(q)\n    # return isPalin && total <= w;\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # int ans = 0;\n    ans = 0\n    # for (int i = 0; i < arr.size() / 2; i++) {\n    for i in range(len(arr) // 2):\n        # if (arr.get(i) != arr.get(arr.size() - i - 1)) {\n        if arr[i] != arr[len(arr) - i - 1]:\n            # ans += 1;\n            ans += 1\n    # return ans;\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # int cnt1 = lst1.stream().mapToInt(String::length).sum();\n    cnt1 = sum(map(len, lst1))\n    # int cnt2 = lst2.stream().mapToInt(String::length).sum();\n    cnt2 = sum(map(len, lst2))\n    # return cnt1 <= cnt2 ? lst1 : lst2;\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # int cnt = 0;\n    cnt = 0\n    # for (int i = 2; i <= a; i++) {\n    for i in range(2, a + 1):\n        # if (isPrime(i)) {\n        if is_prime(i):\n            # while (a % i == 0) {\n            while a % i == 0:\n                # cnt += 1;\n                cnt += 1\n                # a /= i;\n                a //= i\n    # return cnt == 3;\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return x == n;\n        return x == n\n    # int tmp = 1;\n    tmp = 1\n    # while (tmp < x) {\n    while tmp < x:\n        # tmp *= n;\n        tmp *= n\n    # return tmp == x;\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # a = Math.abs(a);\n    a = abs(a)\n    # int root = (int)Math.round(Math.pow(a, 1.0 / 3.0));\n    root = int(round(pow(a, 1.0 / 3.0)))\n    # return root * root * root == a;\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # return (int)num.chars().filter(x -> \"2357BD\".indexOf(x) != -1).count();\n    return sum(1 for x in num if x in \"2357BD\")\n",
            "def decimal_to_binary(dec: int) -> str:\n    # String binary = Integer.toBinaryString(dec);\n    binary = bin(dec)\n    # return String.format(\"db%sdb\", binary);\n    return f\"db{binary}db\"\n",
            "def is_happy(s: str) -> bool:\n    # if (s.length() < 3) {\n    if len(s) < 3:\n        # return false;\n        return False\n    # for (int i = 0; i < s.length() - 2; i++) {\n    for i in range(len(s) - 2):\n        # if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i) == s.charAt(i + 2) || s.charAt(i + 1) == s.charAt(i + 2)) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # List<String> result = new ArrayList<>();\n    result = []\n    # for (double grade : grades) {\n    for grade in grades:\n        # if (grade == 4.0) {\n        if grade == 4.0:\n            # result.add(\"A+\");\n            result.append(\"A+\")\n        # } else if (grade > 3.7) {\n        elif grade > 3.7:\n            # result.add(\"A\");\n            result.append(\"A\")\n        # } else if (grade > 3.3) {\n        elif grade > 3.3:\n            # result.add(\"A-\");\n            result.append(\"A-\")\n        # } else if (grade > 3.0) {\n        elif grade > 3.0:\n            # result.add(\"B+\");\n            result.append(\"B+\")\n        # } else if (grade > 2.7) {\n        elif grade > 2.7:\n            # result.add(\"B\");\n            result.append(\"B\")\n        # } else if (grade > 2.3) {\n        elif grade > 2.3:\n            # result.add(\"B-\");\n            result.append(\"B-\")\n        # } else if (grade > 2.0) {\n        elif grade > 2.0:\n            # result.add(\"C+\");\n            result.append(\"C+\")\n        # } else if (grade > 1.7) {\n        elif grade > 1.7:\n            # result.add(\"C\");\n            result.append(\"C\")\n        # } else if (grade > 1.3) {\n        elif grade > 1.3:\n            # result.add(\"C-\");\n            result.append(\"C-\")\n        # } else if (grade > 1.0) {\n        elif grade > 1.0:\n            # result.add(\"D+\");\n            result.append(\"D+\")\n        # } else if (grade > 0.7) {\n        elif grade > 0.7:\n            # result.add(\"D\");\n            result.append(\"D\")\n        # } else if (grade > 0.0) {\n        elif grade > 0.0:\n            # result.add(\"D-\");\n            result.append(\"D-\")\n        # } else {\n        else:\n            # result.add(\"E\");\n            result.append(\"E\")\n    # return result;\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # int length = s.length();\n    length = len(s)\n    # if (length < 2) {\n    if length < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.sqrt(length); i++) {\n    for i in range(2, int(length ** 0.5) + 1):\n        # if (length % i == 0) {\n        if length % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if (n == 1) {\n    if n == 1:\n        # return 1;\n        return 1\n    # return 2 * 9 * (int) Math.pow(10, n - 2);\n    return 2 * 9 * int(pow(10, n - 2))\n",
            "def solve(n: int) -> str:\n    # int digitsSum = String.valueOf(n).chars().map(Character::getNumericValue).sum();\n    digitsSum = sum(map(int, str(n)))\n    # return Integer.toBinaryString(digitsSum);\n    return bin(digitsSum)\n",
            "def add(lst: List[int]) -> int:\n    # return IntStream.range(0, lst.size()).filter(i -> i % 2 == 1 && lst.get(i) % 2 == 0).map(i -> lst.get(i)).sum();\n    return sum(filter(lambda i: i % 2 == 1 and lst[i] % 2 == 0, range(len(lst))))\n",
            "def anti_shuffle(s: str) -> str:\n    # var words = Stream.of(s.split(\" \")).map(word -> word.chars().sorted().collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString()).toList();\n    words = [word for word in s.split(\" \") if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]\n    words = [word for word in words if word]",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # List<List<Integer>> coords = new ArrayList<>();\n    coords = []\n    # for (int i = 0; i < lst.size(); i++) {\n    for i in range(len(lst)):\n        # for (int j = 0; j < lst.get(i).size(); j++) {\n        for j in range(len(lst[i])):\n            # if (lst.get(i).get(j) == x) {\n            if lst[i][j] == x:\n                # coords.add(List.of(i, j));\n                coords.append([i, j])\n    # return coords.stream().sorted((a,b) -> a.get(0) == b.get(0) ? b.get(1) - a.get(1) : a.get(0) - b.get(0)).toList();\n    return sorted(coords, key=lambda a: a[0] == b[0] and b[1] - a[1] or a[0] - b[0])\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if (arr.size() == 0) {\n    if len(arr) == 0:\n        # return List.of();\n        return []\n    # if ((arr.get(0) + arr.get(arr.size() - 1)) % 2 == 0) {\n    if (arr[0] + arr[-1]) % 2 == 0:\n        # return arr.stream().sorted((a,b) -> b - a).toList();\n        return sorted(arr, key=lambda a,b: b - a)\n    # else {\n    else:\n        # return arr.stream().sorted((a,b) -> a - b).toList();\n        return sorted(arr, key=lambda a,b: a - b)\n",
            "def encrypt(s: str) -> str:\n    # StringBuilder result = new StringBuilder();\n    result = ''\n    # for (int i = 0; i < s.length(); i++) {\n    for i in range(len(s)):\n        # int shifted = s.charAt(i) + 4;\n        shifted = ord(s[i]) + 4\n        # if (shifted > 'z') {\n        if shifted > ord('z'):\n            # shifted -= 26;\n            shifted -= 26\n        # result.append((char)shifted);\n        result += chr(shifted)\n    # return result.toString();\n    return result\n",
            "def next_smallest(lst: List[int]) -> Optional[int]:\n    # List<Integer> sl = lst.stream().distinct().sorted().toList();\n    sl = sorted(set(lst))\n    # if (sl.size() < 2) {\n    if len(sl) < 2:\n        # return Optional.empty();\n        return None\n    # return Optional.of(sl.get(1));\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # String[] sentences = s.split(\"[.!?]\\\\s*\");\n    sentences = s.split(\"[.!?]\\\\s*\")\n    # return (int)Stream.of(sentences).filter(sentence -> sentence.length() >= 2 && sentence.substring(0, 2).equals(\"I \")).count();\n    return len([sentence for sentence in sentences if len(sentence) >= 2 and sentence.startswith(\"I \")])\n",
            "def any_int(x, y, z):\n    # if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # int intX = (int) x;\n        intX = x\n        # int intY = (int) y;\n        intY = y\n        # int intZ = (int) z;\n        intZ = z\n        # if ((intX + intY == intZ) || (intX + intZ == intY) || (intY + intZ == intX)) {\n        if intX + intY == intZ or intX + intZ == intY or intY + intZ == intX:\n            # return true;\n            return True\n    # }\n    # return false;\n    return False\n",
            "def encode(message: str) -> str:\n    # String vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # StringBuilder result = new StringBuilder();\n    result = []\n    # for (char ch : message.toCharArray()) {\n    for ch in message:\n        # if (Character.isAlphabetic(ch)) {\n        if ch.isalpha():\n            # char ch1 = Character.isLowerCase(ch) ? Character.toUpperCase(ch) : Character.toLowerCase(ch);\n            ch1 = ch.upper() if ch.islower() else ch.lower()\n            # if (vowels.indexOf(ch1) != -1) {\n            if vowels.find(ch1) != -1:\n                # ch1 = (char) (ch1 + 2);\n                ch1 = chr(ord(ch1) + 2)\n            # result.append(ch1);\n            result.append(ch1)\n        else:\n            # result.append(ch);\n            result.append(ch)\n    # return result.toString();\n    return \"\".join(result)\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # List<Integer> primes = lst.stream().filter(n -> isPrime(n)).toList();\n    primes = [n for n in lst if is_prime(n)]\n    # if (primes.size() == 0) {\n    if len(primes) == 0:\n        # return 0;\n        return 0\n    # String largest = String.valueOf(primes.stream().mapToInt(i -> i).max().getAsInt());\n    largest = str(max(primes))\n    # return largest.chars().map(c -> Character.getNumericValue(c)).sum();\n    return sum(map(int, largest))\n",
            "def check_dict_case(d: dict) -> bool:\n    # if (d.isEmpty()) {\n    if not d:\n        # return false;\n        return False\n    # return d.keySet().stream().allMatch(k -> k.chars().allMatch(c -> Character.isLowerCase(c))) || d.keySet().stream().allMatch(k -> k.chars().allMatch(c -> Character.isUpperCase(c)));\n    return all(k.islower() for k in d.keys()) or all(k.isupper() for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # List<Integer> primes = new ArrayList<>();\n    primes = []\n    # for (int num = 2; num < n; num++) {\n    for num in range(2, n):\n        # int num0 = num;\n        num0 = num\n        # if (primes.stream().allMatch(p -> num0 % p != 0)) {\n        if all(num0 % p != 0 for p in primes):\n            # primes.add(num);\n            primes.append(num)\n    # return primes;\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # return (Math.abs(a) % 10) * (Math.abs(b) % 10);\n    return abs(a) % 10 * abs(b) % 10\n",
            "def count_upper(s: str) -> int:\n    # String vowels = \"AEIOU\";\n    vowels = \"AEIOU\"\n    # return (int)IntStream.range(0, s.length()).filter(i -> i % 2 == 0 && vowels.contains(String.valueOf(s.charAt(i)))).count();\n    return sum(1 for i in range(len(s)) if i % 2 == 0 and s[i] in vowels)\n",
            "def closest_integer(value: str) -> int:\n    # double num = Double.parseDouble(value);\n    num = float(value)\n    # if (num >= 0) {\n    if num >= 0:\n        # return (int) (num + 0.5);\n        return int(num + 0.5)\n    # } else {\n    else:\n        # return (int) (num - 0.5);\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # return IntStream.range(0, n).map(i -> n + 2 * i).boxed().toList();\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # return Stream.of(s.split(\"[, ]\")).filter(w -> w.length() > 0).toList();\n    return list(filter(lambda w: len(w) > 0, s.split(\"[, ]\")))\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    if x > y:\n        # return -1;\n        return -1\n    # if (y % 2 == 0) {\n    if y % 2 == 0:\n        # return y;\n        return y\n    # return y != x ? y - 1 : -1;\n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> Optional[str]:\n    # if (n > m) {\n    if n > m:\n        # return Optional.empty();\n        return None\n    # int rAvg = (int)((m + n) / 2.0 + 0.5);\n    r_avg = int((m + n) / 2.0 + 0.5)\n    # return Optional.of(Integer.toBinaryString(rAvg));\n    return str(r_avg)\n",
            "def all_digits_odd(s: str) -> bool:\n    # return s.chars().allMatch(digit -> digit % 2 != 0);\n    return all(digit % 2 != 0 for digit in s)\ndef unique_digits(x: List[int]) -> List[int]:\n    # return x.stream().filter(num -> allDigitsOdd(Integer.toString(num))).sorted().toList();\n    return sorted(filter(lambda num: all_digits_odd(str(num)), x))\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # String[] digitNames = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # List<Integer> sortedArr = arr.stream().filter(x -> 1 <= x && x <= 9).sorted(Comparator.reverseOrder()).toList();\n    sorted_arr = sorted(filter(lambda x: 1 <= x and x <= 9, arr), reverse=True)\n    # return sortedArr.stream().map(x -> digitNames[x - 1]).toList();\n    return list(map(lambda x: digit_names[x - 1], sorted_arr))\n",
            "def f(n: int) -> List[int]:\n    # List<Integer> nums = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toList());\n    nums = list(range(1, n + 1))\n    # return nums.stream().map(i -> i % 2 != 0 ? nums.stream().limit(i).reduce(0, Integer::sum) : nums.stream().limit(i).reduce(1, (x, y) -> x * y)).toList();\n    return list(map(lambda i: nums.stream().limit(i).reduce(0, lambda x, y: x + y) if i % 2 != 0 else nums.stream().limit(i).reduce(1, lambda x, y: x * y), nums))\n",
            "def is_palindrome(s: str) -> bool:\n    # return s.equals(new StringBuilder(s).reverse().toString());\n    return s == str(s)[::-1]\ndef even_odd_palindrome(n: int) -> List[int]:\n    # List<Integer> cnt = Arrays.asList(0, 0);\n    cnt = [0, 0]\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # if (isPalindrome(Integer.toString(i))) {\n        if is_palindrome(str(i)):\n            # cnt.set(i % 2, cnt.get(i % 2) + 1);\n            cnt[i % 2] += 1\n    # return cnt;\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # String nStr = String.valueOf(n);\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return String.valueOf(n).chars().map(Character::getNumericValue).sum();\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return Integer.parseInt(nStr.substring(0, 2)) * 2 + digitsSum(Math.abs(n));\n        return int(n_str[0:2]) * 2 + digits_sum(abs(n))\n# }\ndef count_nums(arr: List[int]) -> int:\n    # return (int) arr.stream().filter(n -> digitsSum(n) > 0).count();\n    return sum(1 for n in arr if digits_sum(n) > 0)\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if (arr.size() == 0) {\n    if len(arr) == 0:\n        # return true;\n        return True\n    # List<Integer> sortedArr = arr.stream().sorted().toList();\n    sorted_arr = sorted(arr)\n    # for (int i = 0; i < arr.size(); i++) {\n    for i in range(len(arr)):\n        # if (arr.subList(i, arr.size()).equals(sortedArr.subList(0, arr.size() - i)) && arr.subList(0, i).equals(sortedArr.subList(arr.size() - i, arr.size()))) {\n        if arr[i:] == sorted_arr[0:len(arr) - i] and arr[0:i] == sorted_arr[len(arr) - i:len(arr)]:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # int oddCnt = (int) lst1.stream().filter(n -> n % 2 != 0).count();\n    odd_cnt = sum(1 for n in lst1 if n % 2 != 0)\n    # int evenCnt = (int) lst2.stream().filter(n -> n % 2 == 0).count();\n    even_cnt = sum(1 for n in lst2 if n % 2 == 0)\n    # return evenCnt >= oddCnt ? \"YES\" : \"NO\";\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # var freq = new HashMap<String, Integer>();\n    freq = {}\n    # var words = Stream.of(test.split(\" \")).filter(w -> w.length() > 0).toList();\n    words = [w for w in test.split(\" \") if len(w) > 0]\n    # for (var w : words) {\n    for w in words:\n        # freq.put(w, freq.getOrDefault(w, 0) + 1);\n        freq[w] = freq.get(w, 0) + 1\n    # var result = new HashMap<String, Integer>();\n    result = {}\n    # if (freq.size() > 0) {\n    if freq:\n        # var maxFreq = Collections.max(freq.values());\n        max_freq = max(freq.values())\n        # for (var entry : freq.entrySet()) {\n        for entry in freq.items():\n            # if (entry.getValue() == maxFreq) {\n            if entry[1] == max_freq:\n                # result.put(entry.getKey(), entry.getValue());\n                result[entry[0]] = entry[1]\n    # }\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s.equals(new StringBuilder(s).reverse().toString());\n    return s == s[::-1]\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # String s1 = s.chars().filter(ch -> c.indexOf(ch) == -1).collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();\n    s1 = ''.join(ch for ch in s if ch not in c)\n    # return List.of(s1, isPalindrome(s1) ? \"yes\" : \"no\");\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # List<String> result = new ArrayList<>();\n    result = []\n    # for (String num : lst) {\n    for num in lst:\n        # int n = (int)num.chars().filter(d -> d % 2 == 1).count();\n        n = sum(1 for d in num if d % 2 == 1)\n        # String rs = \"the number of odd elements in the string i of the input.\";\n        rs = \"the number of odd elements in the string {} of the input.\".format(n)\n        # result.add(rs.replace(\"i\", String.valueOf(n)));\n        result.append(rs.replace(\"i\", str(n)))\n    # return result;\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # int minSum = 0;\n    min_sum = 0\n    # int curSum = 0;\n    cur_sum = 0\n    # for (int n : nums) {\n    for n in nums:\n        # curSum = Math.min(curSum + n, 0);\n        cur_sum = min(cur_sum + n, 0)\n        # minSum = Math.min(curSum, minSum);\n        min_sum = min(cur_sum, min_sum)\n    # if (minSum == 0) {\n    if min_sum == 0:\n        # minSum = Collections.min(nums);\n        min_sum = min(nums)\n    # return minSum;\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # return grid.stream().mapToInt(arr -> (int)Math.ceil(arr.stream().mapToInt(i -> i).sum() / (double)capacity)).sum();\n    return sum(int(math.ceil(sum(arr) / capacity)) for arr in grid)\n",
            "def count_ones(num: int) -> int:\n    # return Integer.bitCount(num);\n    return bin(num).count('1')\ndef sort_array(arr: List[int]) -> List[int]:\n    # return arr.stream().sorted((a, b) -> countOnes(a) == countOnes(b) ? a - b : countOnes(a) - countOnes(b)).toList();\n    return sorted(arr, key=lambda a: count_ones(a), reverse=True)\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # String consonants = \"bcdfghjklmnpqrstvwxyz\";\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # List<String> words = Arrays.stream(s.split(\" \")).filter(w -> w.length() > 0).toList();\n    words = [w for w in s.split(\" \") if len(w) > 0]\n    # return words.stream().filter(w -> w.chars().filter(c -> consonants.indexOf(Character.toLowerCase(c)) != -1).count() == n).toList();\n    return [w for w in words if sum(1 for c in w if c.lower() in consonants) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # String vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # for (int i = word.length() - 2; i > 0; i--) {\n    for i in range(len(word) - 2, 0, -1):\n        # if (vowels.contains(word.substring(i, i + 1)) && !vowels.contains(word.substring(i - 1, i)) && !vowels.contains(word.substring(i + 1, i + 2))) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return word.substring(i, i + 1);\n            return word[i:i + 1]\n    # return \"\";\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # int depth = 0;\n    depth = 0\n    # for (char ch : s.toCharArray()) {\n    for ch in s:\n        # if (ch == '(') {\n        if ch == '(':\n            # depth++;\n            depth += 1\n        # } else {\n        else:\n            # depth--;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth == 0;\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # String s1 = lst.get(0) + lst.get(1);\n    s1 = lst[0] + lst[1]\n    # String s2 = lst.get(1) + lst.get(0);\n    s2 = lst[1] + lst[0]\n    # return check(s1) || check(s2) ? \"Yes\" : \"No\";\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if (k == 0) {\n    if k == 0:\n        # return new ArrayList<>();\n        return []\n    # return arr.stream().sorted().skip(arr.size() - k).toList();\n    return sorted(arr)[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # return IntStream.range(0, lst.size()).filter(i -> i % 2 == 0 && lst.get(i) % 2 != 0).map(i -> lst.get(i)).sum();\n    return sum(filter(partial(lambda i, lst: i % 2 == 0 and lst[i] % 2 != 0), range(len(lst))))\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # return (int)arr.stream().limit(k).filter(n -> String.valueOf(n).length() <= 2).mapToInt(n -> n).sum();\n    return sum(filter(lambda n: len(str(n)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # List<Integer> collatz = new ArrayList<>(List.of(1));\n    collatz = [1]\n    # while (n != 1) {\n    while n != 1:\n        # if (n % 2 != 0) {\n        if n % 2 != 0:\n            # collatz.add(n);\n            collatz.append(n)\n            # n = 3 * n + 1;\n            n = 3 * n + 1\n        else:\n            # n = n / 2;\n            n = n / 2\n    # Collections.sort(collatz);\n    collatz.sort()\n    # return collatz;\n    return collatz\n",
            "def valid_date(date: str) -> bool:\n    # if (date.length() != 10 || date.charAt(2) != '-' || date.charAt(5) != '-') {\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        # return false;\n        return False\n    # int m = Integer.parseInt(date.substring(0, 2));\n    m = int(date[0:2])\n    # int d = Integer.parseInt(date.substring(3, 5));\n    d = int(date[3:5])\n    # if (List.of(1, 3, 5, 7, 8, 10, 12).contains(m) && d >= 1 && d <= 31) {\n    if m in [1, 3, 5, 7, 8, 10, 12] and 1 <= d <= 31:\n        # return true;\n        return True\n    # if (List.of(4, 6, 9, 11).contains(m) && d >= 1 && d <= 30) {\n    if m in [4, 6, 9, 11] and 1 <= d <= 30:\n        # return true;\n        return True\n    # if (m == 2 && d >= 1 && d <= 29) {\n    if m == 2 and 1 <= d <= 29:\n        # return true;\n        return True\n    # return false;\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if (txt.contains(\" \")) {\n    if \" \" in txt:\n        # return List.of(txt.split(\" \"));\n        return txt.split(\" \")\n    # } else if (txt.contains(\",\")) {\n    elif \",\" in txt:\n        # return List.of(txt.split(\",\"));\n        return txt.split(\",\")\n    # } else {\n    else:\n        # return List.of(String.valueOf(txt.chars().filter(c -> Character.isLowerCase(c) && c % 2 == 0).count()));\n        return [str(sum(1 for c in txt if c.islower() and c % 2 == 0))]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if (!IntStream.range(1, lst.size()).allMatch(i -> lst.get(i-1) <= lst.get(i))) {\n    if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        # return false;\n        return False\n    # Map<Integer, Integer> freq = new HashMap<>();\n    freq = defaultdict(int)\n    # for (int i : lst) {\n    for i in lst:\n        # freq.put(i, freq.getOrDefault(i, 0) + 1);\n        freq[i] += 1\n    # return freq.values().stream().mapToInt(i -> i).max().orElse(0) <= 2;\n    return max(freq.values()) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # int l = Math.max(interval1.get(0), interval2.get(0));\n    l = max(interval1[0], interval2[0])\n    # int r = Math.min(interval1.get(1), interval2.get(1));\n    r = min(interval1[1], interval2[1])\n    # int length = r - l;\n    length = r - l\n    # return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if (arr.size() == 0) {\n    if len(arr) == 0:\n        # return Optional.empty();\n        return None\n    # if (arr.contains(0)) {\n    if 0 in arr:\n        # return Optional.of(0);\n        return 0\n    # int sign = arr.stream().filter(n -> n < 0).count() % 2 == 1 ? -1 : 1;\n    sign = -1 if arr.count(n for n in arr if n < 0) % 2 == 1 else 1\n    # return Optional.of(sign * arr.stream().mapToInt(n -> Math.abs(n)).sum());\n    return sign * sum(abs(n) for n in arr)\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # int n = grid.size();\n    n = len(grid)\n    # int minVal = n * n + 1;\n    min_val = n * n + 1\n    # for (int i = 0; i < n; i++) {\n    for i in range(n):\n        # for (int j = 0; j < n; j++) {\n        for j in range(n):\n            # if (grid.get(i).get(j) == 1) {\n            if grid[i][j] == 1:\n                # List<Integer> temp = new ArrayList<>();\n                temp = []\n                # if (i != 0) {\n                if i != 0:\n                    # temp.add(grid.get(i - 1).get(j));\n                    temp.append(grid[i - 1][j])\n                # if (j != 0) {\n                if j != 0:\n                    # temp.add(grid.get(i).get(j - 1));\n                    temp.append(grid[i][j - 1])\n                # if (i != n - 1) {\n                if i != n - 1:\n                    # temp.add(grid.get(i + 1).get(j));\n                    temp.append(grid[i + 1][j])\n                # if (j != n - 1) {\n                if j != n - 1:\n                    # temp.add(grid.get(i).get(j + 1));\n                    temp.append(grid[i][j + 1])\n                # minVal = Collections.min(temp);\n                min_val = min(temp)\n    # List<Integer> result = new ArrayList<>();\n    result = []\n    # for (int i = 0; i < k; i++) {\n    for i in range(k):\n        # result.add(i % 2 == 0 ? 1 : minVal);\n        result.append(1 if i % 2 == 0 else min_val)\n    # return result;\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if (n == 0) {\n    if n == 0:\n        # return List.of(1);\n        return [1]\n    # List<Integer> seq = new ArrayList<>(List.of(1, 3));\n    seq = [1, 3]\n    # for (int i = 2; i <= n; i++) {\n    for i in range(2, n + 1):\n        # if (i % 2 == 0) {\n        if i % 2 == 0:\n            # seq.add(i / 2 + 1);\n            seq.append(i // 2 + 1)\n        # else {\n        else:\n            # seq.add(seq.get(i - 1) + seq.get(i - 2) + (i + 3) / 2);\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) // 2)\n    # return seq;\n    return seq\n",
            "def digits(n: int) -> int:\n    # var odds = String.valueOf(n).chars().filter(d -> Character.getNumericValue(d) % 2 == 1).mapToObj(d -> Character.getNumericValue(d)).toList();\n    odds = [d for d in str(n) if int(d) % 2 == 1]\n    # return odds.size() > 0 ? odds.stream().reduce((x, y) -> x * y).get() : 0;\n    return 0 if len(odds) == 0 else reduce(lambda x, y: x * y, odds)\n",
            "def is_nested(s: str) -> bool:\n    # List<Integer> openIdx = new ArrayList<>();\n    open_idx = []\n    # List<Integer> closeIdx = new ArrayList<>();\n    close_idx = []\n    # for (int i = 0; i < s.length(); i++) {\n    for i in range(len(s)):\n        # switch (s.charAt(i)) {\n        #     case '[':\n        #         openIdx.add(i); break;\n        #     case ']':\n        #         closeIdx.add(i); break;\n        # }\n        if s[i] == '[':\n            open_idx.append(i)\n        elif s[i] == ']':\n            close_idx.append(i)\n    # Collections.reverse(closeIdx);\n    close_idx.reverse()\n    # int cnt = 0;\n    cnt = 0\n    # int i = 0;\n    i = 0\n    # int l = closeIdx.size();\n    l = len(close_idx)\n    # for (int idx : openIdx) {\n    #     if (i < l && idx < closeIdx.get(i)) {\n    #         cnt++;\n    #         i++;\n    #     }\n    # }\n    for idx in open_idx:\n        if i < l and idx < close_idx[i]:\n            cnt += 1\n            i += 1\n    # return cnt >= 2;\n    return cnt >= 2\n",
            "def sum_squares(lst: List[float]) -> int:\n    # return lst.stream().mapToInt(n -> (int) Math.pow(Math.ceil(n), 2)).sum();\n    return sum(int(math.pow(math.ceil(n), 2)) for n in lst)\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if (txt.isEmpty()) {\n    if not txt:\n        # return false;\n        return False\n    # String last = txt.substring(txt.lastIndexOf(' ') + 1);\n    last = txt.split()[-1]\n    # return last.length() == 1 && Character.isLetter(last.charAt(0));\n    return len(last) == 1 and last[0].isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if (arr.size() <= 1) {\n    if len(arr) <= 1:\n        # return -1;\n        return -1\n    # var idx = IntStream.range(1, arr.size()).filter(i -> arr.get(i) < arr.get(i - 1));\n    idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    # return idx.max().orElse(-1);\n    return max(idx) if idx else -1\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # var neg = lst.stream().filter(i -> i < 0).toList();\n    neg = [i for i in lst if i < 0]\n    # var pos = lst.stream().filter(i -> i > 0).toList();\n    pos = [i for i in lst if i > 0]\n    # Optional<Integer> maxNeg = neg.stream().max(Comparator.naturalOrder());\n    max_neg = max(neg) if neg else None\n    # Optional<Integer> minPos = pos.stream().min(Comparator.naturalOrder());\n    min_pos = min(pos) if pos else None\n    # return List.of(maxNeg, minPos);\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: object) -> float:\n    # if (o instanceof String) {\n    if isinstance(o, str):\n        # return Double.parseDouble(((String) o).replace(\",\", \".\"));\n        return float(o.replace(\",\", \".\"))\n    # } else if (o instanceof Integer) {\n    elif isinstance(o, int):\n        # return (double) (int) o;\n        return float(o)\n    # } else if (o instanceof Double) {\n    elif isinstance(o, float):\n        # return (double) o;\n        return o\n    # }\n    # throw new RuntimeException(\"Type Error\");\n    raise RuntimeError(\"Type Error\")\ndef compare_one(a: object, b: object) -> Optional[float]:\n    # double a1 = AnyToReal(a);\n    a1 = any_to_real(a)\n    # double b1 = AnyToReal(b);\n    b1 = any_to_real(b)\n    # if (a1 == b1) {\n    if a1 == b1:\n        # return Optional.empty();\n        return None\n    # } else if (a1 > b1) {\n    elif a1 > b1:\n        # return Optional.of(a1);\n        return a1\n    # } else {\n    else:\n        # return Optional.of(b1);\n        return b1\n    # }\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return n % 2 == 0 && n >= 8;\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # int fact = 1;\n    fact = 1\n    # int result = 1;\n    result = 1\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # fact *= i;\n        fact *= i\n        # result *= fact;\n        result *= fact\n    # return result;\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return txt.replaceAll(\"\\\\s{3,}\", \"-\").replace(\" \", \"_\");\n    return txt.replace(\"   \", \"-\").replace(\" \", \"_\")\n",
            "def file_name_check(file_name: str) -> str:\n    # var suf = List.of(\"txt\", \"exe\", \"dll\");\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # var lst = fileName.split(\"\\\\.\");\n    lst = file_name.split(\".\")\n    # if (lst.length != 2 || !suf.contains(lst[1]) || lst[0].length() == 0 || !Character.isLetter(lst[0].charAt(0)) || lst[0].chars().filter(x -> Character.isDigit(x)).count() > 3) {\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or lst[0].count(lambda x: x.isdigit()) > 3:\n        # return \"No\";\n        return \"No\"\n    # return \"Yes\";\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # int result = 0;\n    result = 0\n    # for (int i = 0; i < lst.size(); i++) {\n    for i in range(len(lst)):\n        # if (i % 3 == 0) {\n        if i % 3 == 0:\n            # result += Math.pow(lst.get(i), 2);\n            result += math.pow(lst[i], 2)\n        # } else if (i % 4 == 0) {\n        elif i % 4 == 0:\n            # result += Math.pow(lst.get(i), 3);\n            result += math.pow(lst[i], 3)\n        # } else {\n        else:\n            # result += lst.get(i);\n            result += lst[i]\n    # return result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (int i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # String[] words = sentence.split(\" \");\n    words = sentence.split(\" \")\n    # return String.join(\" \", Stream.of(words).filter(w -> isPrime(w.length())).toList());\n    return \" \".join(filter(lambda w: is_prime(len(w)), words))\n",
            "def simplify(x: str, n: str) -> bool:\n    # var xs = x.split(\"/\");\n    xs = x.split(\"/\")\n    # var ns = n.split(\"/\");\n    ns = n.split(\"/\")\n    # int num = Integer.parseInt(xs[0]) * Integer.parseInt(ns[0]);\n    num = int(xs[0]) * int(ns[0])\n    # int den = Integer.parseInt(xs[1]) * Integer.parseInt(ns[1]);\n    den = int(xs[1]) * int(ns[1])\n    # return num % den == 0;\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # String nStr = String.valueOf(n);\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return String.valueOf(n).chars().map(Character::getNumericValue).sum();\n        return sum(map(int, n_str))\n    else:\n        # return Integer.parseInt(nStr.substring(0, 2)) * 2 + digitsSum(Math.abs(n));\n        return int(n_str[0:2]) * 2 + digits_sum(abs(n))\ndef order_by_points(nums: List[int]) -> List[int]:\n    # return nums.stream().sorted(Comparator.comparingInt(Global::digitsSum)).toList();\n    return sorted(nums, key=digits_sum)\n",
            "def special_filter(nums: List[int]) -> int:\n    # String odds = \"13579\";\n    odds = \"13579\"\n    # return (int)nums.stream().filter(n -> n > 10 && n % 2 == 1 && odds.contains(n.toString().substring(0, 1))).count();\n    return sum(1 for n in nums if n > 10 and n % 2 == 1 and odds[0] in str(n))\n",
            "def get_max_triples(n: int) -> int:\n    # int[] c = {0, 0, 0};\n    c = [0, 0, 0]\n    # for (int i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # int a = i * i - i + 1;\n        a = i * i - i + 1\n        # c[a % 3]++;\n        c[a % 3] += 1\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6;\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # List<String> names = List.of(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if (!names.contains(planet1) || !names.contains(planet2)) {\n    if planet1 not in names or planet2 not in names:\n        # return List.of();\n        return []\n    # int l = names.indexOf(planet1);\n    l = names.index(planet1)\n    # int r = names.indexOf(planet2);\n    r = names.index(planet2)\n    # if (l > r) {\n    if l > r:\n        # int tmp = l;\n        tmp = l\n        # l = r;\n        l = r\n        # r = tmp;\n        r = tmp\n    # if (l == r) {\n    if l == r:\n        # return List.of();\n        return []\n    # return names.subList(l + 1, r);\n    return names[l + 1:r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # var result = lst.stream().filter(s -> s.length() % 2 == 0).toList();\n    result = [s for s in lst if len(s) % 2 == 0]\n    # return result.stream().sorted(Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder())).toList();\n    return sorted(result, key=lambda s: (len(s), s))\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if (n < 2) {\n    if n < 2:\n        # return y;\n        return y\n    # for (int i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return y;\n            return y\n    # return x;\n    return x\n",
            "def double_the_difference(lst: List[float]) -> int:\n    # return lst.stream().filter(n -> n >= 0 && n % 2 == 1).mapToInt(n -> (int)(n * n)).sum();\n    return sum(int(n * n) for n in lst if n >= 0 and n % 2 == 1)\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # return IntStream.range(0, game.size()).map(i -> Math.abs(game.get(i) - guess.get(i))).boxed().toList();\n    return [abs(game[i] - guess[i]) for i in range(len(game))]\n",
            "def strongest_extension(className: str, extensions: List[str]) -> str:\n    # int maxS = Integer.MIN_VALUE;\n    max_s = -2147483648\n    # String maxExt = \"\";\n    max_ext = \"\"\n    # for (String ext : extensions) {\n    for ext in extensions:\n        # int upper = (int)ext.chars().filter(c -> Character.isUpperCase(c)).count();\n        upper = sum(1 for c in ext if c.isupper())\n        # int lower = (int)ext.chars().filter(c -> Character.isLowerCase(c)).count();\n        lower = sum(1 for c in ext if c.islower())\n        # int s = upper - lower;\n        s = upper - lower\n        # if (s > maxS) {\n        if s > max_s:\n            # maxS = s;\n            max_s = s\n            # maxExt = ext;\n            max_ext = ext\n    # return String.format(\"%s.%s\", className, maxExt);\n    return \"{}.{}\".format(className, max_ext)\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if (a.length() < b.length()) {\n    if len(a) < len(b):\n        # return false;\n        return False\n    # for (int i = 0; i < b.length(); i++) {\n    for i in range(len(b)):\n        # if (a.contains(b.substring(i) + b.substring(0, i))) {\n        if a.find(b[i:] + b[:i]) != -1:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # String ds = String.valueOf(Math.abs(num));\n    ds = str(abs(num))\n    # int even = (int)ds.chars().filter(d -> d % 2 == 0).count();\n    even = sum(1 for d in ds if d % 2 == 0)\n    # return List.of(even, ds.length() - even);\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, \n    #                 10, 9, 5, 4, 1};\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, \n              10, 9, 5, 4, 1]\n    # String[] numerals = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \n    #                      \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \n                \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # StringBuilder res = new StringBuilder();\n    res = \"\"\n    # for (int i = 0; i < values.length; i++) {\n    for i in range(len(values)):\n        # while (num >= values[i]) {\n        while num >= values[i]:\n            # res.append(numerals[i]);\n            res += numerals[i]\n            # num -= values[i];\n            num -= values[i]\n    # return res.toString();\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # int[] s = new int[]{a, b, c};\n    s = [a, b, c]\n    # Arrays.sort(s);\n    s.sort()\n    # return s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # int maxCnt = 0;\n    max_cnt = 0\n    # String maxW = \"\";\n    max_w = \"\"\n    # for (String w : words) {\n    for w in words:\n        # int cnt = new HashSet<>(Arrays.asList(w.split(\"\"))).size();\n        cnt = len(set(w.split(\"\")))\n        # if (cnt > maxCnt) {\n        if cnt > max_cnt:\n            # maxCnt = cnt;\n            max_cnt = cnt\n            # maxW = w;\n            max_w = w\n        # else if (cnt == maxCnt) {\n        elif cnt == max_cnt:\n            # maxW = maxW.compareTo(w) < 0 ? maxW : w;\n            max_w = max_w if max_w < w else w\n    # return maxW;\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if (need <= remaining) {\n    if need <= remaining:\n        # return List.of(num + need, remaining - need);\n        return [num + need, remaining - need]\n    # } else {\n    else:\n        # return List.of(num + remaining, 0);\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # List<String> ops = new ArrayList<>(operators);\n    ops = list(operators)\n    # List<Integer> nums = new ArrayList<>(operands);\n    nums = list(operands)\n    # int i = ops.size() - 1;\n    i = len(ops) - 1\n    # while (i >= 0) {\n    while i >= 0:\n        # if (ops.get(i).equals(\"**\")) {\n        if ops[i] == \"**\":\n            # nums.set(i, (int) Math.pow(nums.get(i), nums.get(i + 1)));\n            nums[i] = int(nums[i] ** nums[i + 1])\n            # nums.remove(i + 1);\n            del nums[i + 1]\n            # ops.remove(i);\n            del ops[i]\n        # i -= 1;\n        i -= 1\n    # i = 0;\n    i = 0\n    # while (i < ops.size()) {\n    while i < len(ops):\n        # if (ops.get(i).equals(\"*\")) {\n        if ops[i] == \"*\":\n            # nums.set(i, nums.get(i) * nums.get(i + 1));\n            nums[i] = nums[i] * nums[i + 1]\n            # nums.remove(i + 1);\n            del nums[i + 1]\n            # ops.remove(i);\n            del ops[i]\n            # i -= 1;\n            i -= 1\n        # } else if (ops.get(i).equals(\"//\")) {\n        elif ops[i] == \"//\":\n            # nums.set(i, nums.get(i) / nums.get(i + 1));\n            nums[i] = nums[i] / nums[i + 1]\n            # nums.remove(i + 1);\n            del nums[i + 1]\n            # ops.remove(i);\n            del ops[i]\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # i = 0;\n    i = 0\n    # while (i < ops.size()) {\n    while i < len(ops):\n        # if (ops.get(i).equals(\"+\")) {\n        if ops[i] == \"+\":\n            # nums.set(i, nums.get(i) + nums.get(i + 1));\n            nums[i] = nums[i] + nums[i + 1]\n            # nums.remove(i + 1);\n            del nums[i + 1]\n            # ops.remove(i);\n            del ops[i]\n            # i -= 1;\n            i -= 1\n        # } else if (ops.get(i).equals(\"-\")) {\n        elif ops[i] == \"-\":\n            # nums.set(i, nums.get(i) - nums.get(i + 1));\n            nums[i] = nums[i] - nums[i + 1]\n            # nums.remove(i + 1);\n            del nums[i + 1]\n            # ops.remove(i);\n            del ops[i]\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # return nums.get(0);\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if (!s.chars().anyMatch(Character::isLetter) ) {\n    if not any(ch.isalpha() for ch in s):\n        # return new StringBuilder(s).reverse().toString();\n        return s[::-1]\n    # StringBuilder result = new StringBuilder();\n    result = []\n    # for (char ch : s.toCharArray() ) {\n    for ch in s:\n        # if (!Character.isLetter(ch) ) {\n        if not ch.isalpha():\n            # result.append(ch);\n            result.append(ch)\n        # else if (Character.isUpperCase(ch) ) {\n        elif ch.isupper():\n            # result.append(Character.toLowerCase(ch) );\n            result.append(ch.lower() )\n        # else if (Character.isLowerCase(ch) ) {\n        elif ch.islower():\n            # result.append(Character.toUpperCase(ch) );\n            result.append(ch.upper() )\n    # return result.toString();\n    return ''.join(result)\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if (txt.isEmpty()) {\n    if not txt:\n        # return Optional.empty();\n        return None\n    # try {\n    try:\n        # var md5Hash = MessageDigest.getInstance(\"MD5\");\n        md5_hash = hashlib.md5()\n        # byte[] txtBytes = txt.getBytes();\n        txt_bytes = txt.encode()\n        # md5Hash.update(txtBytes);\n        md5_hash.update(txt_bytes)\n        # byte[] hashBytes = md5Hash.digest();\n        hash_bytes = md5_hash.digest()\n        # StringBuilder md5Encoded = new StringBuilder();\n        md5_encoded = []\n        # for (byte b : hashBytes) {\n        for b in hash_bytes:\n            # md5Encoded.append(String.format(\"%02x\", b & 0xff));\n            md5_encoded.append(format(b & 0xff, \"02x\"))\n        # return Optional.of(md5Encoded.toString());\n        return \"\".join(md5_encoded)\n    # catch (NoSuchAlgorithmException e) {\n    except:\n        # return Optional.empty();\n        return None\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # int lower = Math.max(2, Math.min(a, b));\n    lower = max(2, min(a, b))\n    # int upper = Math.min(8, Math.max(a, b));\n    upper = min(8, max(a, b))\n    # return IntStream.rangeClosed(lower, upper).filter(n -> n % 2 == 0).boxed().toList();\n    return list(filter(lambda n: n % 2 == 0, range(lower, upper + 1)))\n"
        ]
    },
    "javascript": {
        "python": [
            "def has_close_elements(numbers: List[int], threshold: int) -> bool:\n    # for (let i = 0; i < numbers.length; i++) {\n    for i in range(len(numbers)):\n        # for (let j = i + 1; j < numbers.length; j++) {\n        for j in range(i + 1, len(numbers)):\n            # if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true;\n                return True\n    # return false;\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # const groups = [];\n    groups = []\n    # const stk = [];\n    stk = []\n    # let currentGroup = \"\";\n    current_group = \"\"\n    # const parens = parenString.replace(\" \", \"\");\n    parens = paren_string.replace(\" \", \"\")\n    # for (const ch of parens) {\n    for ch in parens:\n        # if (ch === \"(\") {\n        if ch == \"(\":\n            # stk.push(ch);\n            stk.append(ch)\n            # currentGroup += ch;\n            current_group += ch\n        # } else if (ch === \")\") {\n        elif ch == \")\":\n            # stk.pop();\n            stk.pop()\n            # currentGroup += ch;\n            current_group += ch\n            # if (stk.length === 0) {\n            if len(stk) == 0:\n                # groups.push(currentGroup);\n                groups.append(current_group)\n                # currentGroup = \"\";\n                current_group = \"\"\n    # return groups;\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return num - Math.floor(num);\n    return num - math.floor(num)\n",
            "def below_zero(operations: List[int]) -> bool:\n    # let balance = 0;\n    balance = 0\n    # for (const op of operations) {\n    for op in operations:\n        # balance += op;\n        balance += op\n        # if (balance < 0) {\n        if balance < 0:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def mean_absolute_deviation(numbers: List[int]) -> float:\n    # const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;\n    mean = sum(numbers) / len(numbers)\n    # const deviation = numbers.map((num) => Math.abs(num - mean)).reduce((sum, num) => sum + num, 0);\n    deviation = sum(map(lambda num: abs(num - mean), numbers))\n    # return deviation / numbers.length;\n    return deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # const result = [];\n    result = []\n    # for (let i = 0; i < numbers.length; i++) {\n    for i in range(len(numbers)):\n        # if (i !== 0) {\n        if i != 0:\n            # result.push(delimiter);\n            result.append(delimiter)\n        # result.push(numbers[i]);\n        result.append(numbers[i])\n    # return result;\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # const result = [];\n    result = []\n    # const parenGroups = parenString.split(\" \").filter((s) => s.length > 0);\n    paren_groups = paren_string.split(\" \")\n    paren_groups = [g for g in paren_groups if len(g) > 0]\n    # for (let group of parenGroups) {\n    for group in paren_groups:\n        # let maxDepth = 0;\n        max_depth = 0\n        # let depth = 0;\n        depth = 0\n        # for (let ch of group) {\n        for ch in group:\n            # if (ch === \"(\") {\n            if ch == \"(\":\n                # depth += 1;\n                depth += 1\n                # maxDepth = Math.max(maxDepth, depth);\n                max_depth = max(max_depth, depth)\n            # } else if (ch === \")\") {\n            elif ch == \")\":\n                # depth -= 1;\n                depth -= 1\n        # result.push(maxDepth);\n        result.append(max_depth)\n    # return result;\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # return strs.filter(s => s.includes(substring));\n    return [s for s in strs if substring in s]\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # const nSum = numbers.reduce((a, b) => a + b, 0);\n    n_sum = sum(numbers)\n    # const nProduct = numbers.reduce((a, b) => a * b, 1);\n    n_product = 1\n    for n in numbers:\n        n_product *= n\n    # return [nSum, nProduct];\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # let maxSoFar = Number.MIN_VALUE;\n    max_so_far = float('-inf')\n    # const result = [];\n    result = []\n    # for (const num of numbers) {\n    for num in numbers:\n        # maxSoFar = Math.max(maxSoFar, num);\n        max_so_far = max(max_so_far, num)\n        # result.push(maxSoFar);\n        result.append(max_so_far)\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s === s.split('').reverse().join('');\n    return s == ''.join(reversed(s.split('')))\ndef make_palindrome(s: str) -> str:\n    # if (isPalindrome(s)) {\n    if is_palindrome(s):\n        # return s;\n        return s\n    # for (let i = 0; i < s.length; i++) {\n    for i in range(len(s)):\n        # if (isPalindrome(s.slice(i))) {\n        if is_palindrome(s[i:]):\n            # return s + s.slice(0, i).split('').reverse().join('');\n            return s + ''.join(reversed(s[:i].split('')))\n    # return \"\";\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # return a.split('').map((c, i) => c === b[i] ? '0' : '1').join('');\n    return ''.join(['0' if c == b[i] else '1' for i, c in enumerate(a)])\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if (!strs.length) {\n    if not strs:\n        # return null;\n        return None\n    # let longestS = strs[0];\n    longest_s = strs[0]\n    # for (const s of strs) {\n    for s in strs:\n        # if (s.length > longestS.length) {\n        if len(s) > len(longest_s):\n            # longestS = s;\n            longest_s = s\n    # return longestS;\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if (b === 0) {\n    if b == 0:\n        # return a;\n        return a\n    # else {\n    else:\n        # return greatestCommonDivisor(b, a % b);\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # const prefixes = [];\n    prefixes = []\n    # for (let i = 0; i < s.length; i++) {\n    for i in range(len(s)):\n        # prefixes.push(s.slice(0, i + 1));\n        prefixes.append(s[:i + 1])\n    # return prefixes;\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # return Array.from({ length: n + 1 }, (_, i) => i).join(\" \");\n    return \" \".join(map(str, range(n + 1)))\n",
            "def count_distinct_characters(s: str) -> int:\n    # return new Set(s.toLowerCase()).size;\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # const durations = { \"o\": 4, \"o|\": 2, \".|\": 1 };\n    durations = { \"o\": 4, \"o|\": 2, \".|\": 1 }\n    # const notes = musicString.split(\" \").filter((s) => s.length > 0);\n    notes = [s for s in music_string.split(\" \") if len(s) > 0]\n    # return notes.map(note => durations[note]);\n    return [durations[note] for note in notes]\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # let times = 0;\n    times = 0\n    # for (let i = 0; i <= s.length - substring.length; i++) {\n    for i in range(len(s) - len(substring) + 1):\n        # if (s.slice(i, i + substring.length) === substring) {\n        if s[i:i + len(substring)] == substring:\n            # times += 1;\n            times += 1\n    # return times;\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # const numDict = {\n    #     \"zero\": 0,\n    #     \"one\": 1,\n    #     \"two\": 2,\n    #     \"three\": 3,\n    #     \"four\": 4,\n    #     \"five\": 5,\n    #     \"six\": 6,\n    #     \"seven\": 7,\n    #     \"eight\": 8,\n    #     \"nine\": 9,\n    # };\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    # const numList = numbers.split(\" \").filter(x => x in numDict);\n    num_list = [x for x in numbers.split(\" \") if x in num_dict]\n    # numList.sort((a, b) => numDict[a] - numDict[b]);\n    num_list.sort(key=lambda x: num_dict[x])\n    # return numList.join(\" \");\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[int]) -> List[int]:\n    # const sortedNumbers = [...numbers].sort((a, b) => a - b);\n    sorted_numbers = sorted(numbers)\n    # let minDiff = Infinity;\n    min_diff = float('inf')\n    # let closestPair = [];\n    closest_pair = []\n    # for (let i = 1; i < sortedNumbers.length; i++) {\n    for i in range(1, len(sorted_numbers)):\n        # const diff = sortedNumbers[i] - sortedNumbers[i - 1];\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if (diff < minDiff) {\n        if diff < min_diff:\n            # minDiff = diff;\n            min_diff = diff\n            # closestPair = [sortedNumbers[i - 1], sortedNumbers[i]];\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return closestPair;\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # const minNum = Math.min(...numbers);\n    min_num = min(numbers)\n    # const maxNum = Math.max(...numbers);\n    max_num = max(numbers)\n    # if (minNum === maxNum) {\n    if min_num == max_num:\n        # return Array(numbers.length).fill(0.0);\n        return [0.0] * len(numbers)\n    # } else {\n    #     return numbers.map(num => (num - minNum) / (maxNum - minNum));\n    # }\n    return [num - min_num / (max_num - min_num) for num in numbers]\n",
            "def filter_integers(values: List[int]) -> List[int]:\n    # return values.filter(x => typeof x === 'number' && Number.isInteger(x));\n    return list(filter(lambda x: type(x) == int and x.is_integer(), values))\n",
            "def str_length(s: str) -> int:\n    # return s.length;\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for (let i = 2; i < n; i++) {\n    for i in range(2, n):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return n / i;\n            return n / i\n    # return 1;\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # const factors = [];\n    factors = []\n    # let divisor = 2;\n    divisor = 2\n    # while (divisor <= n) {\n    while divisor <= n:\n        # if (n % divisor === 0) {\n        if n % divisor == 0:\n            # factors.push(divisor);\n            factors.append(divisor)\n            # n /= divisor;\n            n //= divisor\n        else:\n            # divisor += 1;\n            divisor += 1\n    # return factors;\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # const counts = new Map();\n    counts = {}\n    # for (const num of numbers) {\n    for num in numbers:\n        # counts.set(num, (counts.get(num) || 0) + 1);\n        counts[num] = counts.get(num, 0) + 1\n    # const res = numbers.filter(num => counts.get(num) === 1);\n    res = [num for num in numbers if counts[num] == 1]\n    # return res;\n    return res\n",
            "def flip_case(s: str) -> str:\n    # const flipped = [];\n    flipped = []\n    # for (const ch of s) {\n    for ch in s:\n        # if (ch.match(/[^a-zA-Z]/)) {\n        if ch.match(r'[^a-zA-Z]'):\n            # flipped.push(ch);\n            flipped.append(ch)\n        # } else if (ch.match(/[a-z]/)) {\n        elif ch.match(r'[a-z]'):\n            # flipped.push(ch.toUpperCase());\n            flipped.append(ch.upper())\n        # } else if (ch.match(/[A-Z]/)) {\n        elif ch.match(r'[A-Z]'):\n            # flipped.push(ch.toLowerCase());\n            flipped.append(ch.lower())\n    # return flipped.join('');\n    return ''.join(flipped)\n",
            "def concatenate(strs: List[str]) -> str:\n    # return strs.join(\"\");\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # return strs.filter(s => s.startsWith(prefixStr));\n    return [s for s in strs if s.startswith(prefix_str)]\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # return l.filter(num => num > 0);\n    return list(filter(lambda num: num > 0, l))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def poly(xs: List[float], x: float) -> float:\n    # let res = 0;\n    res = 0\n    # for (let i = 0; i < xs.length; i++) {\n    for i in range(len(xs)):\n        # res += xs[i] * Math.pow(x, i);\n        res += xs[i] * x ** i\n    # return res;\n    return res\ndef find_zero(xs: List[float]) -> float:\n    # let [x1, x2] = [1.0, -1.0];\n    x1, x2 = 1.0, -1.0\n    # while (poly(xs, x1) * poly(xs, x2) > 0) {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2;\n        x1 *= 2\n        # x2 *= 2;\n        x2 *= 2\n    # while (Math.abs(x1 - x2) > 1e-10) {\n    while abs(x1 - x2) > 1e-10:\n        # const mid = (x1 + x2) / 2;\n        mid = (x1 + x2) / 2\n        # if (poly(xs, mid) === 0) {\n        if poly(xs, mid) == 0:\n            # return mid;\n            return mid\n        # else if (poly(xs, mid) * poly(xs, x1) < 0) {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid;\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid;\n            x1 = mid\n    # return (x1 + x2) / 2;\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # const sortedThird = l.filter((_, i) => i % 3 === 0).sort((a, b) => a - b);\n    sorted_third = sorted([x for i, x in enumerate(l) if i % 3 == 0])\n    # return l.map((x, i) => i % 3 === 0 ? sortedThird[i / 3] : x);\n    return [sorted_third[i // 3] if i % 3 == 0 else x for i, x in enumerate(l)]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # return [... new Set(l)].sort((a, b) => a - b);\n    return sorted(set(l))\n",
            "def max_element(l: List[int]) -> int:\n    # if (l.length === 0) {\n    if len(l) == 0:\n        # return 0;\n        return 0\n    # return Math.max(...l);\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # let cnt = 0;\n    cnt = 0\n    # for (let i = 0; i < n; i++) {\n    for i in range(n):\n        # if (i % 11 === 0 || i % 13 === 0) {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += String(i).split(\"7\").length - 1;\n            cnt += len(str(i).split(\"7\")) - 1\n    # return cnt;\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # const sortedEven = l.filter((_, i) => (i & 1) === 0).sort((a, b) => a - b);\n    sorted_even = sorted([x for i, x in enumerate(l) if i & 1 == 0])\n    # return l.map((x, i) => (i & 1) === 0 ? sortedEven[i / 2] : x);\n    return [sorted_even[i // 2] if i & 1 == 0 else x for i, x in enumerate(l)]\n",
            "def encode_cyclic(s: str) -> str:\n    # const result = [];\n    result = []\n    # for (let i = 0; i < s.length; i += 3) {\n    for i in range(0, len(s), 3):\n        # if (i + 3 > s.length) {\n        if i + 3 > len(s):\n            # result.push(s.slice(i));\n            result.append(s[i:])\n        # } else {\n        else:\n            # result.push(s.slice(i+1, i+3));\n            result.append(s[i+1:i+3])\n            # result.push(s[i]);\n            result.append(s[i])\n    # return result.join(\"\");\n    return \"\".join(result)\ndef decode_cyclic(s: str) -> str:\n    # return encodeCyclic(encodeCyclic(s));\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef prime_fib(n: int) -> int:\n    # let f = [0, 1];\n    f = [0, 1]\n    # let cnt = 0;\n    cnt = 0\n    # while (cnt < n) {\n    while cnt < n:\n        # f = [f[1], f[0] + f[1]];\n        f = [f[1], f[0] + f[1]]\n        # if (isPrime(f[1])) {\n        if is_prime(f[1]):\n            # cnt++;\n            cnt += 1\n    # return f[1];\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for (let i = 0; i < l.length; i++) {\n    for i in range(len(l)):\n        # for (let j = i + 1; j < l.length; j++) {\n        for j in range(i + 1, len(l)):\n            # for (let k = j + 1; k < l.length; k++) {\n            for k in range(j + 1, len(l)):\n                # if (l[i] + l[j] + l[k] === 0) {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true;\n                    return True\n    # return false;\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return Math.pow(n, 2);\n    return n ** 2\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # return l.map(i => i + 1);\n    return [i + 1 for i in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # const seen = new Set();\n    seen = set()\n    # for (const num of l) {\n    for num in l:\n        # if (seen.has(-num)) {\n        if -num in seen:\n            # return true;\n            return True\n        # seen.add(num);\n        seen.add(num)\n    # return false;\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if (x === 0) {\n    if x == 0:\n        # return \"0\";\n        return \"0\"\n    # const digits = [];\n    digits = []\n    # while (x > 0) {\n    while x > 0:\n        # digits.push((x % bas).toString());\n        digits.append(str(x % bas))\n        # x = Math.trunc(x / bas);\n        x = x // bas\n    # return digits.reverse().join(\"\");\n    return \"\".join(reversed(digits))\n",
            "def triangle_area(a: float, h: float) -> float:\n    # return a * h / 2;\n    return a * h / 2\n",
            "def fib4(n: int) -> int:\n    # let fib = [0, 0, 2, 0];\n    fib = [0, 0, 2, 0]\n    # for (let i = 4; i <= n; i++) {\n    for i in range(4, n + 1):\n        # fib[i % 4] = fib.reduce((a, b) => a + b);\n        fib[i % 4] = sum(fib)\n    # return fib[n % 4];\n    return fib[n % 4]\n",
            "def median(l: List[int]) -> float:\n    # const sl = [...l].sort((a, b) => a - b);\n    sl = sorted(l)\n    # if (l.length % 2 !== 0) {\n    if len(l) % 2 != 0:\n        # return sl[Math.trunc(l.length / 2)];\n        return sl[len(l) // 2]\n    # else {\n    else:\n        # return (sl[Math.trunc(l.length / 2)] + sl[Math.trunc(l.length / 2) - 1]) / 2;\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt === txt.split('').reverse().join('');\n    return txt == txt[::-1]\n",
            "def modp(n: int, p: int) -> int:\n    # let ret = 1;\n    ret = 1\n    # for (let i = 0; i < n; i++) {\n    for i in range(n):\n        # ret = (ret * 2) % p;\n        ret = (ret * 2) % p\n    # return ret;\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # const result = [...s].map(ch => String.fromCharCode((ch.charCodeAt(0) - 97 + 5) % 26 + 97));\n    result = [String.fromCharCode((ord(ch) - 97 + 5) % 26 + 97) for ch in s]\n    # return result.join('');\n    return ''.join(result)\ndef decode_shift(s: str) -> str:\n    # const result = [...s].map(ch => String.fromCharCode((ch.charCodeAt(0) - 97 + 21) % 26 + 97));\n    result = [String.fromCharCode((ord(ch) - 97 + 21) % 26 + 97) for ch in s]\n    # return result.join('');\n    return ''.join(result)\n",
            "def remove_vowels(txt: str) -> str:\n    # const vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # return txt.split('').filter(char => !vowels.includes(char)).join('');\n    return ''.join(filter(lambda char: char not in vowels, txt.split('')))\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # return l.every(x => x < t);\n    return all(x < t for x in l)\n",
            "def add(x: int, y: int) -> int:\n    # return x + y;\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # return _.isEqual(new Set([...s0]), new Set([...s1]));\n    return _.isEqual(set(s0), set(s1))\n",
            "def fib(n):\n    # if (n <= 1) {\n    if n <= 1:\n        # return n;\n        return n\n    # } else {\n    else:\n        # return fib(n - 1) + fib(n - 2);\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: List[str]) -> bool:\n    # let depth = 0;\n    depth = 0\n    # for (const b of brackets) {\n    for b in brackets:\n        # if (b == '<') {\n        if b == '<':\n            # depth += 1;\n            depth += 1\n        # } else if (b == '>') {\n        elif b == '>':\n            # depth -= 1;\n            depth -= 1\n        # }\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n        # }\n    # return depth == 0;\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # const diff = l.slice(1).map((x, i) => x - l[i]);\n    diff = [x - l[i] for i, x in enumerate(l[1:])]\n    # return diff.every(x => x <= 0) || diff.every(x => x >= 0);\n    return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # return [...new Set(l1)].filter(element => l2.includes(element)).sort();\n    return sorted(set(l1).intersection(l2))\n",
            "def largest_prime_factor(n: int) -> int:\n    # let i = 2;\n    i = 2\n    # while (i * i <= n) {\n    while i * i <= n:\n        # if (n % i) {\n        if n % i:\n            # i += 1;\n            i += 1\n        else:\n            # n /= i;\n            n //= i\n    # return n;\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # return [...Array(n + 1).keys()].reduce((a, b) => a + b, 0);\n    return sum([*range(n + 1)])\n",
            "def correct_bracketing(brackets: List[str]) -> bool:\n    # let depth = 0;\n    depth = 0\n    # for (const b of brackets) {\n    for b in brackets:\n        # if (b == '(') {\n        if b == '(':\n            # depth += 1;\n            depth += 1\n        # } else if (b == ')') {\n        elif b == ')':\n            # depth -= 1;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth == 0;\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # return xs.map((x, i) => x * i).slice(1);\n    return [x * i for i, x in enumerate(xs)][1:]\n",
            "def fibfib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return 0;\n        return 0\n    # let a = 0, b = 0, c = 1;\n    a = 0\n    b = 0\n    c = 1\n    # while (n > 2) {\n    while n > 2:\n        # [a, b, c] = [b, c, a + b + c];\n        a, b, c = b, c, a + b + c\n        # n -= 1;\n        n -= 1\n    # return c;\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # const vowels = \"aeiou\";\n    vowels = \"aeiou\"\n    # let cnt = 0;\n    cnt = 0\n    # for (let i = 0; i < s.length; i++) {\n    for i in range(len(s)):\n        # if (vowels.includes(s[i].toLowerCase()) || (i == s.length - 1 && s[i].toLowerCase() == \"y\")) {\n        if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n            # cnt += 1;\n            cnt += 1\n    # return cnt;\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # const xStr = x.toString();\n    x_str = str(x)\n    # if (shift > xStr.length) {\n    if shift > len(x_str):\n        # return xStr.split('').reverse().join('');\n        return ''.join(reversed(x_str))\n    # } else {\n    #     return xStr.slice(-shift) + xStr.slice(0, -shift);\n    # }\n    return x_str[-shift:] + x_str[:-shift]\n",
            "def digit_sum(s: str) -> int:\n    # return s.split('').filter(c => c.match(/[A-Z]/)).map(c => c.charCodeAt(0)).reduce((a, b) => a + b, 0);\n    return sum(map(lambda c: ord(c), filter(lambda c: c.isupper(), s.split(''))))\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # const words = s.split(' ');\n    words = s.split(' ')\n    # const apples = parseInt(words[words.indexOf('apples') - 1]);\n    apples = int(words[words.index('apples') - 1])\n    # const oranges = parseInt(words[words.indexOf('oranges') - 1]);\n    oranges = int(words[words.index('oranges') - 1])\n    # return n - apples - oranges;\n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # const evens = arr.filter(n => n % 2 == 0);\n    evens = [n for n in arr if n % 2 == 0]\n    # if (evens.length == 0) {\n    if len(evens) == 0:\n        # return [];\n        return []\n    # const minEven = Math.min(...evens);\n    min_even = min(evens)\n    # return [minEven, arr.indexOf(minEven)];\n    return [min_even, arr.index(min_even)]\n",
            "def search(lst: List[int]) -> int:\n    # const freqs = new Map();\n    freqs = {}\n    # for (let n of lst) {\n    for n in lst:\n        # freqs.set(n, (freqs.get(n) || 0) + 1);\n        freqs[n] = freqs.get(n, 0) + 1\n    # const goodVals = [...freqs.entries()].filter(p => p[1] >= p[0]).map(p => p[0]);\n    good_vals = [p[0] for p in freqs.items() if p[1] >= p[0]]\n    # return Math.max(...goodVals, -1);\n    return max(good_vals, default=-1)\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # const sl = [...lst].sort((a, b) => a - b);\n    sl = sorted(lst)\n    # const result = [];\n    result = []\n    # let left = 0, right = sl.length - 1;\n    left = 0\n    right = len(sl) - 1\n    # while (left <= right) {\n    while left <= right:\n        # result.push(sl[left]);\n        result.append(sl[left])\n        # left += 1;\n        left += 1\n        # if (left <= right) {\n        if left <= right:\n            # result.push(sl[right]);\n            result.append(sl[right])\n            # right -= 1;\n            right -= 1\n    # return result;\n    return result\n",
            "def triangle_area(a: float, b: float, c: float) -> float:\n    # if (a + b > c && a + c > b && b + c > a) {\n    if a + b > c and a + c > b and b + c > a:\n        # const s = (a + b + c) / 2;\n        s = (a + b + c) / 2\n        # return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # else {\n    else:\n        # return -1.0;\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if (q.length == 0) {\n    if len(q) == 0:\n        # return false;\n        return False\n    # const isPalin = Array.from(q.keys()).every(i => q[i] == q[q.length - i - 1]);\n    is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    # const total = q.reduce((a, b) => a + b);\n    total = sum(q)\n    # return isPalin && total <= w;\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # let ans = 0;\n    ans = 0\n    # for (let i = 0; i < Math.trunc(arr.length / 2); i++) {\n    for i in range(int(len(arr) / 2)):\n        # if (arr[i] != arr[arr.length - i - 1]) {\n        if arr[i] != arr[len(arr) - i - 1]:\n            # ans += 1;\n            ans += 1\n    # return ans;\n    return ans\n",
            "def total_match(lst1: List[List[int]], lst2: List[List[int]]) -> List[List[int]]:\n    # const cnt1 = lst1.reduce((a, b) => a + b.length, 0);\n    cnt1 = sum(map(len, lst1))\n    # const cnt2 = lst2.reduce((a, b) => a + b.length, 0);\n    cnt2 = sum(map(len, lst2))\n    # return cnt1 <= cnt2 ? lst1 : lst2;\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # let cnt = 0;\n    cnt = 0\n    # for (let i = 2; i <= a; i++) {\n    for i in range(2, a + 1):\n        # if (isPrime(i)) {\n        if is_prime(i):\n            # while (a % i === 0) {\n            while a % i == 0:\n                # cnt += 1;\n                cnt += 1\n                # a /= i;\n                a //= i\n    # return cnt === 3;\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return x === n;\n        return x == n\n    # let tmp = 1;\n    tmp = 1\n    # while (tmp < x) {\n    while tmp < x:\n        # tmp *= n;\n        tmp *= n\n    # return tmp === x;\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # a = Math.abs(a);\n    a = abs(a)\n    # const root = Math.round(Math.pow(a, 1.0 / 3.0));\n    root = round(pow(a, 1.0 / 3.0))\n    # return root * root * root === a;\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # return num.split('').filter((x) => \"2357BD\".includes(x)).length;\n    return len([x for x in num if x in \"2357BD\"])\n",
            "def decimal_to_binary(dec: int) -> str:\n    # const binary = dec.toString(2);\n    binary = bin(dec)\n    # return `db${binary}db`;\n    return f'db{binary}db'\n",
            "def is_happy(s: str) -> bool:\n    # if (s.length < 3) {\n    if len(s) < 3:\n        # return false;\n        return False\n    # for (let i = 0; i < s.length - 2; i++) {\n    for i in range(len(s) - 2):\n        # if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # const result = [];\n    result = []\n    # for (const g of grades) {\n    for g in grades:\n        # switch (true) {\n        #     case g === 4.0:\n        #         result.push(\"A+\"); break;\n        if g == 4.0:\n            # result.push(\"A+\"); break;\n            result.append(\"A+\")\n            # case g > 3.7:\n        elif g > 3.7:\n            # result.push(\"A\"); break;\n            result.append(\"A\")\n            # case g > 3.3:\n        elif g > 3.3:\n            # result.push(\"A-\"); break;\n            result.append(\"A-\")\n            # case g > 3.0:\n        elif g > 3.0:\n            # result.push(\"B+\"); break;\n            result.append(\"B+\")\n            # case g > 2.7:\n        elif g > 2.7:\n            # result.push(\"B\"); break;\n            result.append(\"B\")\n            # case g > 2.3:\n        elif g > 2.3:\n            # result.push(\"B-\"); break;\n            result.append(\"B-\")\n            # case g > 2.0:\n        elif g > 2.0:\n            # result.push(\"C+\"); break;\n            result.append(\"C+\")\n            # case g > 1.7:\n        elif g > 1.7:\n            # result.push(\"C\"); break;\n            result.append(\"C\")\n            # case g > 1.3:\n        elif g > 1.3:\n            # result.push(\"C-\"); break;\n            result.append(\"C-\")\n            # case g > 1.0:\n        elif g > 1.0:\n            # result.push(\"D+\"); break;\n            result.append(\"D+\")\n            # case g > 0.7:\n        elif g > 0.7:\n            # result.push(\"D\"); break;\n            result.append(\"D\")\n            # case g > 0.0:\n        elif g > 0.0:\n            # result.push(\"D-\"); break;\n            result.append(\"D-\")\n            # default:\n        else:\n            # result.push(\"E\"); break;\n            result.append(\"E\")\n    # return result;\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # const length = s.length;\n    length = len(s)\n    # if (length < 2) {\n    if length < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(length)); i++) {\n    for i in range(2, int(math.floor(math.sqrt(length))) + 1):\n        # if (length % i === 0) {\n        if length % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if (n === 1) {\n    if n == 1:\n        # return 1;\n        return 1\n    # return 2 * 9 * Math.pow(10, n - 2);\n    return 2 * 9 * pow(10, n - 2)\n",
            "def solve(n: int) -> str:\n    # const digitsSum = Array.from(String(n), Number).reduce((a, b) => a + b);\n    digits_sum = sum(map(int, str(n)))\n    # return digitsSum.toString(2);\n    return bin(digits_sum)[2:]\n",
            "def add(lst: List[int]) -> int:\n    # return lst.filter((x, i) => i % 2 === 1 && x % 2 === 0).reduce((a, b) => a + b, 0);\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)\n",
            "def anti_shuffle(s: str) -> str:\n    # const words = s.split(' ').map(word => word.split('').sort().join(''));\n    words = [word.split('').sort().join('') for word in s.split(' ')]\n    # return words.join(' ');\n    return ' '.join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # const coords = [];\n    coords = []\n    # for (let i = 0; i < lst.length; i++) {\n    for i in range(len(lst)):\n        # for (let j = 0; j < lst[i].length; j++) {\n        for j in range(len(lst[i])):\n            # if (lst[i][j] === x) {\n            if lst[i][j] == x:\n                # coords.push([i, j]);\n                coords.append([i, j])\n    # return coords.sort((a, b) => a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n    return sorted(coords, key=lambda a: a[0] == b[0] and b[1] - a[1] or a[0] - b[0])\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if (arr.length == 0) {\n    if len(arr) == 0:\n        # return [];\n        return []\n    # if ((arr[0] + arr[arr.length - 1]) % 2 == 0) {\n    if (arr[0] + arr[len(arr) - 1]) % 2 == 0:\n        # return [...arr].sort((a, b) => b - a);\n        return sorted(arr, key=lambda x: x, reverse=True)\n    # } else {\n    else:\n        # return [...arr].sort((a, b) => a - b);\n        return sorted(arr, key=lambda x: x)\n",
            "def encrypt(s: str) -> str:\n    # const result = [];\n    result = []\n    # for (const ch of s) {\n    for ch in s:\n        # let shifted = ch.charCodeAt(0) + 4;\n        shifted = ord(ch) + 4\n        # if (shifted > 'z'.charCodeAt(0)) {\n        if shifted > ord('z'):\n            # shifted -= 26;\n            shifted -= 26\n        # result.push(String.fromCharCode(shifted));\n        result.append(chr(shifted))\n    # return result.join('');\n    return ''.join(result)\n",
            "def next_smallest(lst: List[int]) -> int:\n    # const sl = [...new Set(lst)].sort((a, b) => a - b);\n    sl = sorted(set(lst))\n    # if (sl.length < 2) {\n    if len(sl) < 2:\n        # return null;\n        return None\n    # return sl[1];\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # const sentences = s.split(/[.!?]\\s*/);\n    sentences = s.split(r\"[.!?]\\s*\")\n    # return sentences.filter(sentence => sentence.length >= 2 && sentence.slice(0, 2) == \"I \").length;\n    return len([sentence for sentence in sentences if len(sentence) >= 2 and sentence[:2] == \"I \"])\n",
            "def any_int(x: int, y: int, z: int) -> bool:\n    # if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # if (x + y === z || x + z === y || y + z === x) {\n        if x + y == z or x + z == y or y + z == x:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def encode(message: str) -> str:\n    # const vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # const result = [];\n    result = []\n    # for (const ch of message) {\n    for ch in message:\n        # if (ch.match(/[a-z]/i)) {\n        if ch.isalpha():\n            # let ch1 = ch.toUpperCase() === ch ? ch.toLowerCase() : ch.toUpperCase();\n            ch1 = ch.lower() if ch.isupper() else ch.upper()\n            # if (vowels.includes(ch1)) {\n            if ch1 in vowels:\n                # ch1 = String.fromCharCode(ch1.charCodeAt(0) + 2);\n                ch1 = chr(ord(ch1) + 2)\n            # result.push(ch1);\n            result.append(ch1)\n        # } else {\n        else:\n            # result.push(ch);\n            result.append(ch)\n    # return result.join(\"\");\n    return \"\".join(result)\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.floor(math.sqrt(n)) + 1)):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # const primes = lst.filter(n => isPrime(n));\n    primes = list(filter(is_prime, lst))\n    # if (primes.length === 0) {\n    if len(primes) == 0:\n        # return 0;\n        return 0\n    # const largest = String(Math.max(...primes));\n    largest = str(max(primes))\n    # return [...largest].map(c => parseInt(c)).reduce((a, b) => a + b);\n    return sum(map(int, largest))\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if (d.size === 0) {\n    if len(d) == 0:\n        # return false;\n        return False\n    # return [...d.keys()].every((k) => RegExp('^[A-Z]+$').test(k)) || [...d.keys()].every((k) => RegExp('^[a-z]+$').test(k));\n    return all(RegExp('^[A-Z]+$').test(k) for k in d.keys()) or all(RegExp('^[a-z]+$').test(k) for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # const primes = [];\n    primes = []\n    # for (let num = 2; num < n; num++) {\n    for num in range(2, n):\n        # if (primes.every(p => num % p !== 0)) {\n        if all(num % p != 0 for p in primes):\n            # primes.push(num);\n            primes.append(num)\n    # return primes;\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # return (Math.abs(a) % 10) * (Math.abs(b) % 10);\n    return abs(a) % 10 * abs(b) % 10\n",
            "def count_upper(s: str) -> int:\n    # const vowels = \"AEIOU\";\n    vowels = \"AEIOU\"\n    # return [...s].filter((c, i) => i % 2 === 0 && vowels.includes(c)).length;\n    return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n",
            "def closest_integer(value: float) -> int:\n    # const num = parseFloat(value);\n    num = float(value)\n    # if (num >= 0) {\n    if num >= 0:\n        # return Math.trunc(num + 0.5);\n        return int(num + 0.5)\n    # } else {\n    else:\n        # return Math.trunc(num - 0.5);\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # return [...Array(n).keys()].map(i => n + 2 * i);\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # return s.split(/[ ,]/).filter(w => w.length > 0);\n    return [w for w in s.split(/[ ,]/) if len(w) > 0]\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    if x > y:\n        # return -1;\n        return -1\n    # if (y % 2 == 0) {\n    if y % 2 == 0:\n        # return y;\n        return y\n    # return y != x ? y - 1 : -1;\n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> str:\n    # if (n > m) {\n    if n > m:\n        # return null;\n        return None\n    # const rAvg = Math.trunc((n + m) / 2.0 + 0.5);\n    r_avg = int((n + m) / 2.0 + 0.5)\n    # return rAvg.toString(2);\n    return bin(r_avg)\n",
            "def all_digits_odd(s: str) -> bool:\n    # return [...s].every(digit => digit.codePointAt(0) % 2 !== 0);\n    return all(digit.codePointAt(0) % 2 != 0 for digit in s)\ndef unique_digits(x: List[int]) -> List[int]:\n    # return x.filter(num => allDigitsOdd(String(num))).sort((a, b) => a - b);\n    return sorted(filter(lambda num: all_digits_odd(str(num)), x))\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # const digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # const sortedArr = arr.filter(x => 1 <= x && x <= 9).sort((a, b) => b - a);\n    sorted_arr = sorted(filter(lambda x: 1 <= x and x <= 9, arr), reverse=True)\n    # return sortedArr.map(x => digitNames[x - 1]);\n    return [digit_names[x - 1] for x in sorted_arr]\n",
            "def f(n: int) -> List[int]:\n    # const nums = [...Array(n).keys()].map(x => x + 1);\n    nums = list(range(1, n + 1))\n    # return nums.map(i => i % 2 !== 0 ? nums.slice(0, i).reduce((x, y) => x + y) : nums.slice(0, i).reduce((x, y) => x * y));\n    return [i % 2 != 0 ? sum(nums[:i]) : prod(nums[:i]) for i in nums]\n",
            "def is_palindrome(s: str) -> bool:\n    # return s === s.split('').reverse().join('');\n    return s == ''.join(reversed(s))\ndef even_odd_palindrome(n: int) -> List[int]:\n    # const cnt = [0, 0];\n    cnt = [0, 0]\n    # for (let i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # if (isPalindrome(i.toString())) {\n        if is_palindrome(str(i)):\n            # cnt[i % 2]++;\n            cnt[i % 2] += 1\n    # return cnt\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # const nStr = n.toString();\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return Array.from(nStr, Number).reduce((a, b) => a + b);\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return parseInt(nStr.slice(0, 2)) * 2 + digitsSum(Math.abs(n));\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# }\ndef count_nums(arr: List[int]) -> int:\n    # return arr.filter(n => digitsSum(n) > 0).length;\n    return len(list(filter(lambda n: digits_sum(n) > 0, arr)))\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if (arr.length === 0) {\n    if len(arr) == 0:\n        # return true;\n        return True\n    # const sortedArr = [...arr].sort((a, b) => a - b);\n    sorted_arr = sorted(arr)\n    # for (let i = 0; i < arr.length; i++) {\n    for i in range(len(arr)):\n        # if (_.isEqual(arr.slice(i), sortedArr.slice(0, arr.length - i)) && _.isEqual(arr.slice(0, i), sortedArr.slice(arr.length - i))) {\n        if _.isEqual(arr[i:], sorted_arr[:len(arr) - i]) and _.isEqual(arr[:i], sorted_arr[len(arr) - i:]):\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # const oddCnt = lst1.filter(n => n % 2 !== 0).length;\n    odd_cnt = len([n for n in lst1 if n % 2 != 0])\n    # const evenCnt = lst2.filter(n => n % 2 === 0).length;\n    even_cnt = len([n for n in lst2 if n % 2 == 0])\n    # return evenCnt >= oddCnt ? \"YES\" : \"NO\";\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # const freq = new Map();\n    freq = {}\n    # const words = test.split(\" \").filter(w => w.length > 0);\n    words = [w for w in test.split(\" \") if len(w) > 0]\n    # for (let w of words) {\n    for w in words:\n        # freq.set(w, (freq.get(w) || 0) + 1);\n        freq[w] = freq.get(w, 0) + 1\n    # const result = new Map();\n    result = {}\n    # if (freq.size > 0) {\n    if freq:\n        # const maxFreq = Math.max(...freq.values());\n        max_freq = max(freq.values())\n        # for (let [k, v] of freq) {\n        for k, v in freq.items():\n            # if (v === maxFreq) {\n            if v == max_freq:\n                # result.set(k, v);\n                result[k] = v\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s === s.split('').reverse().join('');\n    return s == ''.join(reversed(s.split('')))\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # const s1 = s.split('').filter(ch => !c.includes(ch)).join('');\n    s1 = ''.join(ch for ch in s.split('') if ch not in c)\n    # return [s1, isPalindrome(s1) ? \"yes\" : \"no\"];\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # const result = [];\n    result = []\n    # for (const num of lst) {\n    for num in lst:\n        # const n = [...num].filter(d => d.charCodeAt(0) % 2 == 1).length;\n        n = len([d for d in num if ord(d) % 2 == 1])\n        # const rs = \"the number of odd elements in the string i of the input.\";\n        rs = \"the number of odd elements in the string i of the input.\"\n        # result.push(rs.replaceAll(\"i\", n.toString()));\n        result.append(rs.replace(\"i\", n))\n    # return result;\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # let minSum = 0;\n    min_sum = 0\n    # let curSum = 0;\n    cur_sum = 0\n    # for (const n of nums) {\n    for n in nums:\n        # curSum = Math.min(curSum + n, 0);\n        cur_sum = min(cur_sum + n, 0)\n        # minSum = Math.min(curSum, minSum);\n        min_sum = min(cur_sum, min_sum)\n    # if (minSum == 0) {\n    if min_sum == 0:\n        # minSum = Math.min(...nums);\n        min_sum = min(nums)\n    # return minSum;\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # return grid.reduce((acc, arr) => acc + Math.ceil(arr.reduce((acc, n) => acc + n, 0) / capacity), 0);\n    return sum(acc + int(ceil(sum(arr) / capacity)) for arr in grid for acc in [0])\n",
            "def count_ones(num: int) -> int:\n    # return num.toString(2).split('1').length - 1;\n    return len(bin(num).replace('0b', '').split('1')) - 1\ndef sort_array(arr: List[int]) -> List[int]:\n    # return [...arr].sort((a, b) => countOnes(a) == countOnes(b) ? a - b : countOnes(a) - countOnes(b));\n    return sorted(arr, key=lambda x: count_ones(x), reverse=True)\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # const consonants = \"bcdfghjklmnpqrstvwxyz\";\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # const words = s.split(\" \").filter(w => w.length > 0);\n    words = [w for w in s.split(\" \") if len(w) > 0]\n    # return words.filter(w => [...w].filter(c => consonants.includes(c.toLowerCase())).length == n);\n    return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # const vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # for (let i = word.length - 2; i > 0; i--) {\n    for i in range(word.length - 2, 0, -1):\n        # if (vowels.includes(word[i]) && !vowels.includes(word[i - 1]) && !vowels.includes(word[i + 1])) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return word[i];\n            return word[i]\n    # return \"\";\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # let depth = 0;\n    depth = 0\n    # for (let ch of s) {\n    for ch in s:\n        # if (ch === \"(\") {\n        if ch == \"(\":\n            # depth++;\n            depth += 1\n        # } else {\n        else:\n            # depth--;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth === 0;\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # const s1 = lst[0] + lst[1];\n    s1 = lst[0] + lst[1]\n    # const s2 = lst[1] + lst[0];\n    s2 = lst[1] + lst[0]\n    # return check(s1) || check(s2) ? \"Yes\" : \"No\";\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if (k === 0) {\n    if k == 0:\n        # return [];\n        return []\n    # return [...arr].sort((a, b) => a - b).slice(-k);\n    return sorted(arr)[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # return lst.filter((x, i) => i % 2 === 0 && x % 2 !== 0).reduce((a, b) => a + b, 0);\n    return sum(filter(lambda x: x % 2 != 0 and i % 2 == 0, lst))\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # return arr.slice(0, k).filter(n => n.toString().length <= 2).reduce((a, b) => a + b, 0);\n    return sum(filter(lambda n: len(str(n)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # const collatz = [1];\n    collatz = [1]\n    # while (n !== 1) {\n    while n != 1:\n        # if (n % 2 !== 0) {\n        if n % 2 != 0:\n            # collatz.push(n);\n            collatz.append(n)\n            # n = 3 * n + 1;\n            n = 3 * n + 1\n        else:\n            # n = n / 2;\n            n = n / 2\n    # return collatz.sort((a, b) => a - b);\n    return sorted(collatz)\n",
            "def valid_date(date: str) -> bool:\n    # if (date.length !== 10 || date[2] !== \"-\" || date[5] !== \"-\") {\n    if len(date) != 10 or date[2] != \"-\" or date[5] != \"-\":\n        # return false;\n        return False\n    # const m = parseInt(date.slice(0, 2));\n    m = int(date[:2])\n    # const d = parseInt(date.slice(3, 5));\n    d = int(date[3:5])\n    # if ([1, 3, 5, 7, 8, 10, 12].includes(m) && d >= 1 && d <= 31) {\n    if m in [1, 3, 5, 7, 8, 10, 12] and 1 <= d <= 31:\n        # return true;\n        return True\n    # if ([4, 6, 9, 11].includes(m) && d >= 1 && d <= 30) {\n    if m in [4, 6, 9, 11] and 1 <= d <= 30:\n        # return true;\n        return True\n    # if (m === 2 && d >= 1 && d <= 29) {\n    if m == 2 and 1 <= d <= 29:\n        # return true;\n        return True\n    # return false;\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if (txt.includes(\" \")) {\n    if \" \" in txt:\n        # return txt.split(\" \");\n        return txt.split(\" \")\n    # } else if (txt.includes(\",\")) {\n    elif \",\" in txt:\n        # return txt.split(\",\");\n        return txt.split(\",\")\n    # } else {\n    else:\n        # return [[...txt].filter(c => /[a-z]/.test(c) && c.charCodeAt(0) % 2 === 0).length.toString()];\n        return [str(len([c for c in txt if c.isalpha() and ord(c) % 2 == 0]))]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if (!lst.slice(1).map((n, i) => lst[i] <= n).every(a => a)) {\n    if not lst[1:].map(lambda n, i: lst[i] <= n).every(lambda a: a):\n        # return false;\n        return False\n    # const freq = new Map();\n    freq = {}\n    # for (const i of lst) {\n    for i in lst:\n        # freq.set(i, (freq.get(i) || 0) + 1);\n        freq[i] = freq.get(i, 0) + 1\n    # return Math.max(...freq.values()) <= 2;\n    return max(freq.values()) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # const l = Math.max(interval1[0], interval2[0]);\n    l = max(interval1[0], interval2[0])\n    # const r = Math.min(interval1[1], interval2[1]);\n    r = min(interval1[1], interval2[1])\n    # const length = r - l;\n    length = r - l\n    # return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if (arr.length === 0) {\n    if len(arr) == 0:\n        # return null;\n        return None\n    # if (arr.includes(0)) {\n    if 0 in arr:\n        # return 0;\n        return 0\n    # const sign = arr.filter(n => n < 0).length % 2 === 1 ? -1 : 1;\n    sign = 1 if arr.count(n => n < 0) % 2 == 1 else -1\n    # return sign * arr.map(n => Math.abs(n)).reduce((a, b) => a + b);\n    return sign * sum(map(n => abs(n), arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # const n = grid.length;\n    n = len(grid)\n    # let minVal = n * n + 1;\n    min_val = n * n + 1\n    # for (let i = 0; i < n; i++) {\n    for i in range(n):\n        # for (let j = 0; j < n; j++) {\n        for j in range(n):\n            # if (grid[i][j] === 1) {\n            if grid[i][j] == 1:\n                # const temp = [];\n                temp = []\n                # if (i !== 0) {\n                if i != 0:\n                    # temp.push(grid[i - 1][j]);\n                    temp.append(grid[i - 1][j])\n                # if (j !== 0) {\n                if j != 0:\n                    # temp.push(grid[i][j - 1]);\n                    temp.append(grid[i][j - 1])\n                # if (i !== n - 1) {\n                if i != n - 1:\n                    # temp.push(grid[i + 1][j]);\n                    temp.append(grid[i + 1][j])\n                # if (j !== n - 1) {\n                if j != n - 1:\n                    # temp.push(grid[i][j + 1]);\n                    temp.append(grid[i][j + 1])\n                # minVal = Math.min(...temp);\n                min_val = min(temp)\n    # const result = [];\n    result = []\n    # for (let i = 0; i < k; i++) {\n    for i in range(k):\n        # result.push(i % 2 === 0 ? 1 : minVal);\n        result.append(1 if i % 2 == 0 else min_val)\n    # return result;\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if (n === 0) {\n    if n == 0:\n        # return [1];\n        return [1]\n    # const seq = [1, 3];\n    seq = [1, 3]\n    # for (let i = 2; i <= n; i++) {\n    for i in range(2, n + 1):\n        # if (i % 2 === 0) {\n        if i % 2 == 0:\n            # seq.push(i / 2 + 1);\n            seq.append(i // 2 + 1)\n        # } else {\n        else:\n            # seq.push(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n    # return seq;\n    return seq\n",
            "def digits(n: int) -> int:\n    # const odds = [...n.toString()].filter(d => parseInt(d) % 2 === 1).map(d => parseInt(d));\n    odds = [d for d in str(n) if int(d) % 2 == 1]\n    # return odds.length > 0 ? odds.reduce((a, b) => a * b) : 0;\n    return reduce(lambda a, b: a * b, odds) if odds else 0\n",
            "def is_nested(s: str) -> bool:\n    # const openIdx = [];\n    open_idx = []\n    # const closeIdx = [];\n    close_idx = []\n    # for (let [i, ch] of [...s].entries()) {\n    for i, ch in enumerate([*s]):\n        # switch (ch) {\n        #     case '[':\n        #         openIdx.push(i); break;\n        #     case ']':\n        #         closeIdx.push(i); break;\n        # }\n        if ch == '[':\n            open_idx.append(i)\n        elif ch == ']':\n            close_idx.append(i)\n    # closeIdx.reverse();\n    close_idx.reverse()\n    # let cnt = 0;\n    cnt = 0\n    # let i = 0;\n    i = 0\n    # const l = closeIdx.length;\n    l = len(close_idx)\n    # for (let idx of openIdx) {\n    for idx in open_idx:\n        # if (i < l && idx < closeIdx[i]) {\n        #     cnt += 1;\n        #     i += 1;\n        # }\n        if i < l and idx < close_idx[i]:\n            cnt += 1\n            i += 1\n    # return cnt >= 2;\n    return cnt >= 2\n",
            "def sum_squares(lst: List[int]) -> int:\n    # return lst.map(n => Math.pow(Math.ceil(n), 2)).reduce((a, b) => a + b, 0);\n    return sum(map(lambda n: pow(math.ceil(n), 2), lst))\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if (!txt) {\n    if not txt:\n        # return false;\n        return False\n    # const last = txt.substring(txt.lastIndexOf(\" \") + 1);\n    last = txt.split(\" \")[-1]\n    # return last.length === 1 && /[a-z]/i.test(last[0]);\n    return len(last) == 1 and bool(re.match(r\"[a-z]\", last[0], re.IGNORECASE))\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if (arr.length <= 1) {\n    if len(arr) <= 1:\n        # return -1;\n        return -1\n    # const idx = [...Array(arr.length).keys()].slice(1).filter(i => arr[i] < arr[i - 1])\n    idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    # return Math.max(...idx, -1);\n    return max(idx, default=-1)\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # const neg = lst.filter(i => i < 0);\n    neg = [i for i in lst if i < 0]\n    # const pos = lst.filter(i => i > 0);\n    pos = [i for i in lst if i > 0]\n    # const maxNeg = neg.length > 0 ? Math.max(...neg) : null;\n    max_neg = max(neg) if len(neg) > 0 else None\n    # const minPos = pos.length > 0 ? Math.min(...pos) : null;\n    min_pos = min(pos) if len(pos) > 0 else None\n    # return [maxNeg, minPos];\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if (typeof o === 'string') {\n    if isinstance(o, str):\n        # return parseFloat(o.replace(',', '.'));\n        return float(o.replace(',', '.'))\n    # } else if (typeof o === 'number') {\n    elif isinstance(o, (int, float)):\n        # return o;\n        return o\n    # }\n    # throw new Error('Type Error');\n    raise TypeError('Type Error')\ndef compare_one(a: Any, b: Any) -> float:\n    # let a1 = anyToReal(a);\n    a1 = any_to_real(a)\n    # let b1 = anyToReal(b);\n    b1 = any_to_real(b)\n    # if (a1 === b1) {\n    if a1 == b1:\n        # return null;\n        return None\n    # } else if (a1 > b1) {\n    elif a1 > b1:\n        # return a1;\n        return a1\n    # } else {\n    else:\n        # return b1;\n        return b1\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return n % 2 === 0 && n >= 8;\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # let fact = 1;\n    fact = 1\n    # let result = 1;\n    result = 1\n    # for (let i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # fact *= i;\n        fact *= i\n        # result *= fact;\n        result *= fact\n    # return result;\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return txt.replace(/\\s{3,}/g, \"-\").replace(/\\s/g, \"_\");\n    return txt.replace(\"   \", \"-\").replace(\" \", \"_\")\n",
            "def file_name_check(file_name: str) -> str:\n    # const suf = [\"txt\", \"exe\", \"dll\"];\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # const lst = fileName.split('.');\n    lst = file_name.split('.')\n    # if (lst.length !== 2 || !suf.includes(lst[1]) || lst[0].length === 0 || !lst[0][0].match(/[a-z]/i) || [...lst[0]].filter(ch => ch.match(/\\d/)).length > 3) {\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or lst[0][0].lower() not in 'abcdefghijklmnopqrstuvwxyz' or len([ch for ch in lst[0] if ch.isdigit()]) > 3:\n        # return \"No\";\n        return \"No\"\n    # return \"Yes\";\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # let result = 0;\n    result = 0\n    # for (let i = 0; i < lst.length; i++) {\n    for i in range(len(lst)):\n        # if (i % 3 === 0) {\n        if i % 3 == 0:\n            # result += Math.pow(lst[i], 2);\n            result += pow(lst[i], 2)\n        # } else if (i % 4 === 0) {\n        elif i % 4 == 0:\n            # result += Math.pow(lst[i], 3);\n            result += pow(lst[i], 3)\n        # } else {\n        else:\n            # result += lst[i];\n            result += lst[i]\n    # return result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.floor(math.sqrt(n)) + 1)):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # const words = sentence.split(\" \");\n    words = sentence.split(\" \")\n    # return words.filter(w => isPrime(w.length)).join(\" \");\n    return \" \".join([w for w in words if is_prime(len(w))])\n",
            "def simplify(x: str, n: str) -> bool:\n    # const xs = x.split('/');\n    xs = x.split('/')\n    # const ns = n.split('/');\n    ns = n.split('/')\n    # const num = parseInt(xs[0]) * parseInt(ns[0]);\n    num = int(xs[0]) * int(ns[0])\n    # const den = parseInt(xs[1]) * parseInt(ns[1]);\n    den = int(xs[1]) * int(ns[1])\n    # return num % den === 0;\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # const nStr = n.toString();\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return Array.from(nStr, Number).reduce((a, b) => a + b);\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return parseInt(nStr.slice(0, 2)) * 2 + digitsSum(Math.abs(n));\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# }\ndef order_by_points(nums: List[int]) -> List[int]:\n    # return [...nums].sort((a, b) => digitsSum(a) - digitsSum(b));\n    return sorted(nums, key=lambda x: digits_sum(x))\n",
            "def special_filter(nums: List[int]) -> int:\n    # const odds = \"13579\";\n    odds = \"13579\"\n    # return nums.filter(n => n > 10 && n % 2 === 1 && odds.includes(n.toString()[0])).length;\n    return len([n for n in nums if n > 10 and n % 2 == 1 and odds.includes(str(n)[0])])\n",
            "def get_max_triples(n: int) -> int:\n    # const c = [0, 0, 0];\n    c = [0, 0, 0]\n    # for (let i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # const a = i * i - i + 1;\n        a = i * i - i + 1\n        # c[a % 3]++;\n        c[a % 3] += 1\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6;\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # const names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if (!names.includes(planet1) || !names.includes(planet2)) {\n    if planet1 not in names or planet2 not in names:\n        # return [];\n        return []\n    # let l = names.indexOf(planet1);\n    l = names.index(planet1)\n    # let r = names.indexOf(planet2);\n    r = names.index(planet2)\n    # if (l > r) {\n    if l > r:\n        # [l, r] = [r, l];\n        l, r = r, l\n    # if (l === r) {\n    if l == r:\n        # return [];\n        return []\n    # return names.slice(l + 1, r);\n    return names[l + 1:r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # const result = lst.filter(s => s.length % 2 === 0);\n    result = [s for s in lst if len(s) % 2 == 0]\n    # return result.sort((a, b) => {\n    #     if (a.length === b.length) {\n    #         return a.localeCompare(b, undefined, { sensitivity: 'base' });\n    #     }\n    #     return a.length - b.length;\n    # });\n    return sorted(result, key=lambda a, b: a.localeCompare(b, undefined, { 'sensitivity': 'base' }) if len(a) == len(b) else len(a) - len(b))\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if (n < 2) {\n    if n < 2:\n        # return y;\n        return y\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return y;\n            return y\n    # return x;\n    return x\n",
            "def double_the_difference(lst: List[int]) -> int:\n    # return lst.filter(n => n >= 0 && n % 2 === 1).reduce((a, b) => a + b * b, 0);\n    return sum(n * n for n in lst if n >= 0 and n % 2 == 1)\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # return game.map((x, i) => Math.abs(x - guess[i]));\n    return [abs(x - guess[i]) for x in game]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # let maxS = Number.MIN_SAFE_INTEGER;\n    max_s = float('-inf')\n    # let maxExt = \"\";\n    max_ext = \"\"\n    # for (const ext of extensions) {\n    for ext in extensions:\n        # const upper = [...ext].filter(c => c.toUpperCase() === c).length;\n        upper = sum(1 for c in ext if c.isupper())\n        # const lower = [...ext].filter(c => c.toLowerCase() === c).length;\n        lower = sum(1 for c in ext if c.islower())\n        # const s = upper - lower;\n        s = upper - lower\n        # if (s > maxS) {\n        if s > max_s:\n            # maxS = s;\n            max_s = s\n            # maxExt = ext;\n            max_ext = ext\n    # return `${className}.${maxExt}`;\n    return f\"{class_name}.{max_ext}\"\n",
            "def cycpattern_check(a: List[int], b: List[int]) -> bool:\n    # if (a.length < b.length) {\n    if len(a) < len(b):\n        # return false;\n        return False\n    # for (let i = 0; i < b.length; i++) {\n    for i in range(len(b)):\n        # if (a.includes(b.slice(i) + b.slice(0, i))) {\n        if a.count(b[i:]) > 0:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def even_odd_count(num: int) -> Tuple[int, int]:\n    # const ds = Math.abs(num).toString();\n    ds = str(abs(num))\n    # const even = [...ds].filter(d => d.codePointAt(0) % 2 === 0).length;\n    even = len([d for d in ds if ord(d) % 2 == 0])\n    # return [even, ds.length - even];\n    return even, len(ds) - even\n",
            "def int_to_mini_roman(num: int) -> str:\n    # const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1];\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1]\n    # const numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\" , \"v\", \"iv\", \"i\"];\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\" , \"v\", \"iv\", \"i\"]\n    # let res = [];\n    res = []\n    # for (let i = 0; i < values.length; i++) {\n    for i in range(len(values)):\n        # while (num >= values[i]) {\n        while num >= values[i]:\n            # res.push(numerals[i]);\n            res.append(numerals[i])\n            # num -= values[i];\n            num -= values[i]\n    # return res.join(\"\");\n    return \"\".join(res)\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # const s = [a, b, c].sort((a, b) => a - b);\n    s = sorted([a, b, c])\n    # return s[0] * s[0] + s[1] * s[1] === s[2] * s[2];\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # let maxCnt = 0;\n    max_cnt = 0\n    # let maxW = \"\";\n    max_w = \"\"\n    # for (let w of words) {\n    for w in words:\n        # let cnt = new Set(w).size;\n        cnt = len(set(w))\n        # if (cnt > maxCnt) {\n        if cnt > max_cnt:\n            # maxCnt = cnt;\n            max_cnt = cnt\n            # maxW = w;\n            max_w = w\n        # } else if (cnt === maxCnt) {\n        elif cnt == max_cnt:\n            # maxW = maxW < w ? maxW : w;\n            max_w = max_w if max_w < w else w\n    # return maxW;\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if (need <= remaining) {\n    if need <= remaining:\n        # return [num + need, remaining - need];\n        return [num + need, remaining - need]\n    # } else {\n    else:\n        # return [num + remaining, 0];\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # const ops = [...operators];\n    ops = list(operators)\n    # const nums = [...operands];\n    nums = list(operands)\n    # let i = ops.length - 1;\n    i = len(ops) - 1\n    # while (i >= 0) {\n    while i >= 0:\n        # if (ops[i] === \"**\") {\n        if ops[i] == \"**\":\n            # nums[i] = Math.pow(nums[i], nums[i + 1]);\n            nums[i] = pow(nums[i], nums[i + 1])\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n        # i -= 1;\n        i -= 1\n    # i = 0;\n    i = 0\n    # while (i < ops.length) {\n    while i < len(ops):\n        # if (ops[i] === \"*\") {\n        if ops[i] == \"*\":\n            # nums[i] = nums[i] * nums[i + 1];\n            nums[i] = nums[i] * nums[i + 1]\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if (ops[i] === \"//\") {\n        elif ops[i] == \"//\":\n            # nums[i] = Math.trunc(nums[i] / nums[i + 1]);\n            nums[i] = int(nums[i] / nums[i + 1])\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # i = 0;\n    i = 0\n    # while (i < ops.length) {\n    while i < len(ops):\n        # if (ops[i] === \"+\") {\n        if ops[i] == \"+\":\n            # nums[i] = nums[i] + nums[i + 1];\n            nums[i] = nums[i] + nums[i + 1]\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if (ops[i] === \"-\") {\n        elif ops[i] == \"-\":\n            # nums[i] = nums[i] - nums[i + 1];\n            nums[i] = nums[i] - nums[i + 1]\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # return nums[0];\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if (![...s].some(ch => ch.match(/[a-zA-Z]/))) {\n    if not any(ch.match(/[a-zA-Z]/) for ch in s):\n        # return s.split('').reverse().join('');\n        return ''.join(reversed(s.split('')))\n    # let result = [];\n    result = []\n    # for (const ch of s) {\n    for ch in s:\n        # if (!ch.match(/[a-zA-Z]/)) {\n        if not ch.match(/[a-zA-Z]/):\n            # result.push(ch);\n            result.append(ch)\n        # else if (ch.match(/[A-Z]/)) {\n        elif ch.match(/[A-Z]/):\n            # result.push(ch.toLowerCase());\n            result.append(ch.lower())\n        # else if (ch.match(/[a-z]/)) {\n        elif ch.match(/[a-z]/):\n            # result.push(ch.toUpperCase());\n            result.append(ch.upper())\n    # return result.join('');\n    return ''.join(result)\n",
            "def string_to_md5(txt: str) -> str:\n    # if (!txt) {\n    if not txt:\n        # return null;\n        return None\n    # const md5Hash = crypto.createHash('md5');\n    md5_hash = hashlib.md5()\n    # const txtBytes = Buffer.from(txt);\n    txt_bytes = txt.encode()\n    # md5Hash.update(txtBytes);\n    md5_hash.update(txt_bytes)\n    # const md5Encoded = md5Hash.digest('hex');\n    md5_encoded = md5_hash.hexdigest()\n    # return md5Encoded;\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # const lower = Math.max(2, Math.min(a, b));\n    lower = max(2, min(a, b))\n    # const upper = Math.min(8, Math.max(a, b));\n    upper = min(8, max(a, b))\n    # if (lower > upper) {\n    if lower > upper:\n        # return [];\n        return []\n    # return Array.from({ length: upper - lower + 1}, (_, i) => i + lower).filter(n => n % 2 === 0);\n    return [i + lower for i in range(upper - lower + 1) if i % 2 == 0]\n"
        ]
    },
    "kotlin": {
        "python": [
            "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # for (i in 0 until numbers.size) {\n    for i in range(numbers.size):\n        # for (j in i + 1 until numbers.size) {\n        for j in range(i + 1, numbers.size):\n            # if (abs(numbers[i] - numbers[j]) < threshold) {\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true\n                return True\n    # return false\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # val groups = mutableListOf<String>()\n    groups = []\n    # val stk = mutableListOf<Char>()\n    stk = []\n    # var currentGroup = \"\"\n    current_group = \"\"\n    # val parens = parenString.replace(\" \", \"\")\n    parens = paren_string.replace(\" \", \"\")\n    # for (ch in parens) {\n    for ch in parens:\n        # if (ch == '(') {\n        if ch == '(':\n            # stk.add(ch)\n            stk.append(ch)\n            # currentGroup += ch\n            current_group += ch\n        # } else if (ch == ')') {\n        elif ch == ')':\n            # stk.removeLast()\n            stk.pop()\n            # currentGroup += ch\n            current_group += ch\n            # if (stk.isEmpty()) {\n            if not stk:\n                # groups.add(currentGroup)\n                groups.append(current_group)\n                # currentGroup = \"\"\n                current_group = \"\"\n    # return groups\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return num - floor(num)\n    return num - floor(num)\n",
            "def below_zero(operations: List[int]) -> bool:\n    # var balance = 0\n    balance = 0\n    # for (op in operations) {\n    for op in operations:\n        # balance += op\n        balance += op\n        # if (balance < 0) {\n        if balance < 0:\n            # return true\n            return True\n    # return false\n    return False\n",
            "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # val mean = numbers.sum() / numbers.size\n    mean = sum(numbers) / len(numbers)\n    # val deviation = numbers.map { abs(it - mean) }.sum()\n    deviation = sum(abs(n - mean) for n in numbers)\n    # return deviation / numbers.size\n    return deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # val result = mutableListOf<Int>()\n    result = []\n    # for (i in numbers.indices) {\n    for i in range(len(numbers)):\n        # if (i != 0) {\n        if i != 0:\n            # result.add(delimiter)\n            result.append(delimiter)\n        # result.add(numbers[i])\n        result.append(numbers[i])\n    # return result\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # val result = mutableListOf<Int>()\n    result = []\n    # val parenGroups = parenString.split(\" \").filter { it.isNotEmpty() }\n    paren_groups = paren_string.split(\" \")\n    # for (group in parenGroups) {\n    for group in paren_groups:\n        # var maxDepth = 0\n        max_depth = 0\n        # var depth = 0\n        depth = 0\n        # for (ch in group) {\n        for ch in group:\n            # if (ch == '(') {\n            if ch == \"(\":\n                # depth++\n                depth += 1\n                # maxDepth = max(maxDepth, depth)\n                max_depth = max(max_depth, depth)\n            # } else if (ch == ')') {\n            elif ch == \")\":\n                # depth--\n                depth -= 1\n        # result.add(maxDepth)\n        result.append(max_depth)\n    # return result\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # return strs.filter { it.contains(substring) }\n    return list(filter(lambda it: substring in it, strs))\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # val nSum = numbers.sum()\n    n_sum = sum(numbers)\n    # val nProduct = numbers.fold(1) { acc, i -> acc * i }\n    n_product = 1\n    for i in numbers:\n        n_product *= i\n    # return listOf(nSum, nProduct)\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # var maxSoFar = Int.MIN_VALUE\n    max_so_far = -2147483648\n    # val result = mutableListOf<Int>()\n    result = []\n    # for (num in numbers) {\n    for num in numbers:\n        # maxSoFar = max(maxSoFar, num)\n        max_so_far = max(max_so_far, num)\n        # result.add(maxSoFar)\n        result.append(max_so_far)\n    # return result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == s.reversed()\n    return s == s[::-1]\ndef make_palindrome(s: str) -> str:\n    # if (isPalindrome(s)) {\n    if is_palindrome(s):\n        # return s\n        return s\n    # for (i in s.indices) {\n    for i in range(len(s)):\n        # if (isPalindrome(s.substring(i))) {\n        if is_palindrome(s[i:]):\n            # return s + s.substring(0, i).reversed()\n            return s + s[:i][::-1]\n    # return \"\"\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # return a.zip(b) { x, y -> if (x == y) '0' else '1' }.joinToString(\"\")\n    return ''.join([('0' if x == y else '1') for x, y in zip(a, b)])\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if (strs.isEmpty()) {\n    if not strs:\n        # return null\n        return None\n    # var longestS = strs[0]\n    longest_s = strs[0]\n    # for (s in strs) {\n    for s in strs:\n        # if (s.length > longestS.length) {\n        if len(s) > len(longest_s):\n            # longestS = s\n            longest_s = s\n    # return longestS\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if (b == 0) {\n    if b == 0:\n        # return a\n        return a\n    # else {\n    else:\n        # return greatestCommonDivisor(b, a % b)\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # val prefixes = mutableListOf<String>()\n    prefixes = []\n    # for (i in 0 until s.length) {\n    for i in range(s.length):\n        # prefixes.add(s.substring(0, i + 1))\n        prefixes.append(s[0:i+1])\n    # return prefixes\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # return (0..n).joinToString(\" \")\n    return \" \".join(str(i) for i in range(n + 1))\n",
            "def count_distinct_characters(s: str) -> int:\n    # return s.toLowerCase().toCharArray().distinct().size\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # val durations = mapOf(\"o\" to 4, \"o|\" to 2, \".|\" to 1)\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    # val notes = musicString.split(\" \").filter { it.isNotEmpty() }\n    notes = [note for note in music_string.split(\" \") if note]\n    # return notes.map { durations[it]!! }\n    return [durations[note] for note in notes]\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # var times = 0\n    times = 0\n    # for (i in 0..(s.length - substring.length)) {\n    for i in range(0, s.length - substring.length + 1):\n        # if (s.substring(i, i + substring.length) == substring) {\n        if s[i:i + substring.length] == substring:\n            # times += 1\n            times += 1\n    # return times\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # val numDict = mapOf(\n    #     \"zero\" to 0,\n    #     \"one\" to 1,\n    #     \"two\" to 2,\n    #     \"three\" to 3,\n    #     \"four\" to 4,\n    #     \"five\" to 5,\n    #     \"six\" to 6,\n    #     \"seven\" to 7,\n    #     \"eight\" to 8,\n    #     \"nine\" to 9\n    # )\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    # val numList = numbers.split(\" \").filter { it in numDict }.toMutableList()\n    num_list = [n for n in numbers.split(\" \") if n in num_dict]\n    # numList.sortBy { numDict[it] }\n    num_list.sort(key=lambda n: num_dict[n])\n    # return numList.joinToString(\" \")\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[float]) -> List[float]:\n    # val sortedNumbers = numbers.sorted()\n    sorted_numbers = sorted(numbers)\n    # var minDiff = Double.POSITIVE_INFINITY\n    min_diff = float('inf')\n    # var closestPair = listOf<Double>()\n    closest_pair = []\n    # for (i in 1 until sortedNumbers.size) {\n    for i in range(1, len(sorted_numbers)):\n        # val diff = sortedNumbers[i] - sortedNumbers[i - 1]\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if (diff < minDiff) {\n        if diff < min_diff:\n            # minDiff = diff\n            min_diff = diff\n            # closestPair = listOf(sortedNumbers[i - 1], sortedNumbers[i])\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return closestPair\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # val minNum = numbers.minOrNull() ?: 0.0\n    min_num = min(numbers) if numbers else 0.0\n    # val maxNum = numbers.maxOrNull() ?: 0.0\n    max_num = max(numbers) if numbers else 0.0\n    # if (minNum == maxNum) {\n    if min_num == max_num:\n        # return List(numbers.size) { 0.0 }\n        return [0.0] * len(numbers)\n    else:\n        # return numbers.map { (it - minNum) / (maxNum - minNum) }\n        return [(it - min_num) / (max_num - min_num) for it in numbers]\n",
            "def filter_integers(values: List[Any]) -> List[int]:\n    # return values.filterIsInstance<Int>()\n    return list(filter(lambda x: isinstance(x, int), values))\n",
            "def str_length(s: str) -> int:\n    # return s.length\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for (i in 2 until n) {\n    for i in range(2, n):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return n / i\n            return n / i\n    # return 1\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # val factors = mutableListOf<Int>()\n    factors = []\n    # var divisor = 2\n    divisor = 2\n    # var num = n\n    num = n\n    # while (divisor <= num) {\n    while divisor <= num:\n        # if (num % divisor == 0) {\n        if num % divisor == 0:\n            # factors.add(divisor)\n            factors.append(divisor)\n            # num /= divisor\n            num //= divisor\n        else:\n            # divisor++\n            divisor += 1\n    # return factors\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # val counts = mutableMapOf<Int, Int>()\n    counts = {}\n    # for (num in numbers) {\n    for num in numbers:\n        # counts[num] = counts.getOrDefault(num, 0) + 1\n        counts[num] = counts.get(num, 0) + 1\n    # val res = numbers.filter { counts[it] == 1 }\n    res = [num for num in numbers if counts[num] == 1]\n    # return res\n    return res\n",
            "def flip_case(s: str) -> str:\n    # var flipped = StringBuilder();\n    flipped = \"\"\n    # for (ch in s) {\n    for ch in s:\n        # if (!ch.isLetter()) {\n        if not ch.isalpha():\n            # flipped.append(ch);\n            flipped += ch\n        # } else if (ch.isLowerCase()) {\n        elif ch.islower():\n            # flipped.append(ch.toUpperCase());\n            flipped += ch.upper()\n        # } else if (ch.isUpperCase()) {\n        elif ch.isupper():\n            # flipped.append(ch.toLowerCase());\n            flipped += ch.lower()\n    # return flipped.toString();\n    return flipped\n",
            "def concatenate(strs: List[str]) -> str:\n    # return strs.joinToString(\"\")\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # return strs.filter { it.startsWith(prefixStr) }\n    return list(filter(lambda it: it.startswith(prefix_str), strs))\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # return l.filter { it > 0 }\n    return list(filter(lambda it: it > 0, l))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (i in 2..floor(sqrt(n.toDouble())).toInt()) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def poly(xs: List[int], x: float) -> float:\n    # var res = 0.0\n    res = 0.0\n    # for (i in xs.indices) {\n    for i in range(len(xs)):\n        # res += xs[i] * x.pow(i.toDouble())\n        res += xs[i] * pow(x, i)\n    # return res\n    return res\ndef find_zero(xs: List[int]) -> float:\n    # var (x1, x2) = listOf(1.0, -1.0)\n    x1, x2 = 1.0, -1.0\n    # while (poly(xs, x1) * poly(xs, x2) > 0) {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2\n        x1 *= 2\n        # x2 *= 2\n        x2 *= 2\n    # while (abs(x1 - x2) > 1e-10) {\n    while abs(x1 - x2) > 1e-10:\n        # val mid = (x1 + x2) / 2\n        mid = (x1 + x2) / 2\n        # if (poly(xs, mid) == 0.0) {\n        if poly(xs, mid) == 0.0:\n            # return mid\n            return mid\n        # else if (poly(xs, mid) * poly(xs, x1) < 0) {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid\n            x1 = mid\n    # return (x1 + x2) / 2\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # val sortedThird = l.filterIndexed { i, _ -> i % 3 == 0 }.sorted()\n    sorted_third = sorted([x for i, x in enumerate(l) if i % 3 == 0])\n    # return l.mapIndexed { i, x -> if (i % 3 == 0) sortedThird[i / 3] else x }\n    return [sorted_third[i / 3] if i % 3 == 0 else x for i, x in enumerate(l)]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # return l.toSet().sorted()\n    return sorted(set(l))\n",
            "def max_element(l: List[int]) -> int:\n    # if (l.isEmpty()) {\n    if not l:\n        # return 0\n        return 0\n    # return l.maxOrNull()!!\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # var cnt = 0\n    cnt = 0\n    # for (i in 0 until n) {\n    for i in range(n):\n        # if (i % 11 == 0 || i % 13 == 0) {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += i.toString().count { it == '7' }\n            cnt += i.toString().count('7')\n    # return cnt\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # val sortedEven = l.filterIndexed { i, _ -> i % 2 == 0 }.sorted()\n    sorted_even = sorted([x for i, x in enumerate(l) if i % 2 == 0])\n    # return l.mapIndexed { i, x -> if (i % 2 == 0) sortedEven[i / 2] else x }\n    return [sorted_even[i / 2] if i % 2 == 0 else x for i, x in enumerate(l)]\n",
            "def encode_cyclic(s: str) -> str:\n    # val result = StringBuilder()\n    result = ''\n    # for (i in 0 until s.length step 3) {\n    for i in range(0, len(s), 3):\n        # if (i + 3 > s.length) {\n        if i + 3 > len(s):\n            # result.append(s.substring(i))\n            result += s[i:]\n        else:\n            # result.append(s.substring(i + 1, i + 3))\n            result += s[i + 1:i + 3]\n            # result.append(s[i])\n            result += s[i]\n    # return result.toString()\n    return result\ndef decode_cyclic(s: str) -> str:\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (i in 2..floor(sqrt(n.toDouble())).toInt()) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef prime_fib(n: int) -> int:\n    # var f = listOf(0, 1)\n    f = [0, 1]\n    # var cnt = 0\n    cnt = 0\n    # while (cnt < n) {\n    while cnt < n:\n        # f = listOf(f[1], f[0] + f[1])\n        f = [f[1], f[0] + f[1]]\n        # if (isPrime(f[1])) {\n        if is_prime(f[1]):\n            # cnt++\n            cnt += 1\n    # return f[1]\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for (i in 0 until l.size) {\n    for i in range(len(l)):\n        # for (j in i + 1 until l.size) {\n        for j in range(i + 1, len(l)):\n            # for (k in j + 1 until l.size) {\n            for k in range(j + 1, len(l)):\n                # if (l[i] + l[j] + l[k] == 0) {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true;\n                    return True\n    # return false;\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return n.toDouble().pow(2).toInt()\n    return int(n ** 2)\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # return l.map { it + 1 }\n    return [it + 1 for it in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # val seen = mutableSetOf<Int>()\n    seen = set()\n    # for (num in l) {\n    for num in l:\n        # if (-num in seen) {\n        if -num in seen:\n            # return true\n            return True\n        # seen.add(num)\n        seen.add(num)\n    # return false\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # var x = x\n    # if (x == 0) {\n    if x == 0:\n        # return \"0\"\n        return \"0\"\n    # val digits = mutableListOf<String>()\n    digits = []\n    # while (x > 0) {\n    while x > 0:\n        # digits.add((x % bas).toString())\n        digits.append(str(x % bas))\n        # x /= bas\n        x //= bas\n    # return digits.reversed().joinToString(\"\")\n    return \"\".join(reversed(digits))\n",
            "def triangle_area(a: int, h: int) -> float:\n    # return (a * h).toDouble() / 2\n    return (a * h) / 2\n",
            "def fib4(n: int) -> int:\n    # val fib = mutableListOf(0, 0, 2, 0)\n    fib = [0, 0, 2, 0]\n    # for (i in 4..n) {\n    for i in range(4, n + 1):\n        # fib[i % 4] = fib.sum()\n        fib[i % 4] = sum(fib)\n    # return fib[n % 4]\n    return fib[n % 4]\n",
            "def median(l: List[float]) -> float:\n    # val sl = l.sorted()\n    sl = sorted(l)\n    # if (l.size % 2 != 0) {\n    if len(l) % 2 != 0:\n        # return sl[l.size / 2]\n        return sl[len(l) // 2]\n    # } else {\n    else:\n        # return (sl[l.size / 2] + sl[l.size / 2 - 1]) / 2\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt == txt.reversed()\n    return txt == txt[::-1]\n",
            "def modp(n: int, p: int) -> int:\n    # var ret = 1;\n    ret = 1\n    # for (i in 0..n-1) {\n    for i in range(0, n):\n        # ret = (ret * 2) % p;\n        ret = (ret * 2) % p\n    # return ret;\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # val result = s.toList().map { ((it.toInt() - 97 + 5) % 26 + 97).toChar() }\n    result = [((ord(c) - 97 + 5) % 26 + 97).to_bytes(1, 'big') for c in s]\n    # return result.joinToString(\"\")\n    return ''.join(result)\ndef decode_shift(s: str) -> str:\n    # val result = s.toList().map { ((it.toInt() - 97 + 21) % 26 + 97).toChar() }\n    result = [((ord(c) - 97 + 21) % 26 + 97).to_bytes(1, 'big') for c in s]\n    # return result.joinToString(\"\")\n    return ''.join(result)\n",
            "def remove_vowels(txt: str) -> str:\n    # val vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # return txt.filter { char -> char !in vowels }\n    return ''.join(char for char in txt if char not in vowels)\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # return l.all { it < t }\n    return all(it < t for it in l)\n",
            "def add(x: int, y: int) -> int:\n    # return x + y\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # return s0.toSet() == s1.toSet()\n    return set(s0) == set(s1)\n",
            "def fib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return n\n        return n\n    # } else {\n    else:\n        # return fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # var depth = 0\n    depth = 0\n    # for (b in brackets) {\n    for b in brackets:\n        # if (b == '<') {\n        if b == '<':\n            # depth += 1\n            depth += 1\n        # } else if (b == '>') {\n        elif b == '>':\n            # depth -= 1\n            depth -= 1\n        # }\n        # if (depth < 0) {\n        if depth < 0:\n            # return false\n            return False\n    # return depth == 0\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # val diff = l.zip(l.drop(1)).map { it.second - it.first }\n    diff = [it.second - it.first for it in zip(l, l[1:])]\n    # return diff.all { it <= 0 } || diff.all { it >= 0 }\n    return all(it <= 0 for it in diff) or all(it >= 0 for it in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # return l1.intersect(l2).toList().sorted()\n    return sorted(set(l1).intersection(l2))\n",
            "def largest_prime_factor(n: int) -> int:\n    # var n = n\n    # var i = 2    \n    i = 2\n    # while (i * i <= n) {\n    while i * i <= n:\n        # if (n % i != 0) {\n        if n % i != 0:\n            # i++\n            i += 1\n        else:\n            # n /= i\n            n //= i\n    # return n\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # return (0..n).sum()\n    return sum(range(n + 1))\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # var depth = 0\n    depth = 0\n    # for (b in brackets) {\n    for b in brackets:\n        # if (b == '(') {\n        if b == '(':\n            # depth += 1\n            depth += 1\n        # } else if (b == ')') {\n        elif b == ')':\n            # depth -= 1\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false\n            return False\n    # return depth == 0\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # return xs.mapIndexed { i, x -> x * i }.drop(1)\n    return [x * i for i, x in enumerate(xs)][1:]\n",
            "def fibfib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return 0;\n        return 0\n    # var (a, b, c) = listOf(0, 0, 1);\n    a, b, c = 0, 0, 1\n    # var n = n;\n    n = n\n    # while (n > 2) {\n    while n > 2:\n        # a = b.also { b = c.also { c = a + b + c } };\n        a = b\n        b = c\n        c = a + b + c\n        # n -= 1;\n        n -= 1\n    # return c;\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # val vowels = \"aeiou\";\n    vowels = \"aeiou\"\n    # var cnt = 0;\n    cnt = 0\n    # for (i in 0 until s.length) {\n    for i in range(len(s)):\n        # if (vowels.contains(s[i].toLowerCase()) || (i == s.length - 1 && s[i].toLowerCase() == 'y')) {\n        if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == 'y'):\n            # cnt += 1;\n            cnt += 1\n    # return cnt;\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # val xStr = x.toString()\n    x_str = str(x)\n    # if (shift > xStr.length) {\n    if shift > len(x_str):\n        # return xStr.reversed()\n        return x_str[::-1]\n    else:\n        # return xStr.substring(xStr.length - shift) + xStr.substring(0, xStr.length - shift)\n        return x_str[len(x_str) - shift:] + x_str[:len(x_str) - shift]\n",
            "def digit_sum(s: str) -> int:\n    # return s.filter { it.isUpperCase() }.sumBy { it.toInt() }\n    return sum(map(int, filter(lambda it: it.isupper(), s)))\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # val words = s.split(' ')\n    words = s.split(' ')\n    # val apples = words[words.indexOf(\"apples\") - 1].toInt()\n    apples = int(words[words.index(\"apples\") - 1])\n    # val oranges = words[words.indexOf(\"oranges\") - 1].toInt()\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # return n - apples - oranges\n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # val evens = arr.filter { it % 2 == 0 }\n    evens = [e for e in arr if e % 2 == 0]\n    # if (evens.isEmpty()) {\n    if not evens:\n        # return emptyList()\n        return []\n    # val minEven = evens.min()\n    min_even = min(evens)\n    # return listOf(minEven, arr.indexOf(minEven))\n    return [min_even, arr.index(min_even)]\n",
            "def search(lst: List[int]) -> int:\n    # val freqs = mutableMapOf<Int, Int>()\n    freqs = {}\n    # for (n in lst) {\n    for n in lst:\n        # freqs[n] = freqs.getOrDefault(n, 0) + 1\n        freqs[n] = freqs.get(n, 0) + 1\n    # val goodVals = freqs.filter { it.value >= it.key }.map { it.key }\n    good_vals = [k for k, v in freqs.items() if v >= k]\n    # return goodVals.maxOrNull() ?: -1\n    return max(good_vals) if good_vals else -1\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # val sl = lst.sorted()\n    sl = sorted(lst)\n    # val result = mutableListOf<Int>()\n    result = []\n    # var (left, right) = listOf(0, sl.size - 1)\n    left, right = 0, len(sl) - 1\n    # while (left <= right) {\n    while left <= right:\n        # result.add(sl[left])\n        result.append(sl[left])\n        # left += 1\n        left += 1\n        # if (left <= right) {\n        if left <= right:\n            # result.add(sl[right])\n            result.append(sl[right])\n            # right -= 1\n            right -= 1\n    # return result\n    return result\n",
            "def triangle_area(a: int, b: int, c: int) -> float:\n    # if (a + b > c && a + c > b && b + c > a) {\n    if a + b > c and a + c > b and b + c > a:\n        # val s = (a + b + c) / 2.0\n        s = (a + b + c) / 2.0\n        # return sqrt(s * (s - a) * (s - b) * (s - c))\n        return sqrt(s * (s - a) * (s - b) * (s - c))\n    else:\n        # return -1.0\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if (q.size == 0) {\n    if len(q) == 0:\n        # return false\n        return False\n    # val isPalin = q.indices.all { i -> q[i] == q[q.size - i - 1] }\n    is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    # val total = q.sum()\n    total = sum(q)\n    # return isPalin && total <= w\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # var ans = 0\n    ans = 0\n    # for (i in 0 until arr.size / 2) {\n    for i in range(0, arr.size / 2):\n        # if (arr[i] != arr[arr.size - i - 1]) {\n        if arr[i] != arr[arr.size - i - 1]:\n            # ans += 1\n            ans += 1\n    # return ans\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # val cnt1 = lst1.sumBy { x -> x.length }\n    cnt1 = sum(map(lambda x: len(x), lst1))\n    # val cnt2 = lst2.sumBy { x -> x.length }\n    cnt2 = sum(map(lambda x: len(x), lst2))\n    # return if (cnt1 <= cnt2) lst1 else lst2\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (i in 2..floor(sqrt(n.toDouble())).toInt()) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # var cnt = 0;\n    cnt = 0\n    # var a = a;\n    # for (i in 2..a) {\n    for i in range(2, a + 1):\n        # if (isPrime(i)) {\n        if is_prime(i):\n            # while (a % i == 0) {\n            while a % i == 0:\n                # cnt++;\n                cnt += 1\n                # a /= i;\n                a //= i\n    # return cnt == 3;\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return x == n;\n        return x == n\n    # var tmp = 1;\n    tmp = 1\n    # while (tmp < x) {\n    while tmp < x:\n        # tmp *= n;\n        tmp *= n\n    # return tmp == x;\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # val a = abs(a);\n    a = abs(a)\n    # val root = round(a.toDouble().pow(1.0 / 3.0)).toInt();\n    root = round(pow(a, 1.0 / 3.0))\n    # return root * root * root == a;\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # return num.filter { \"2357BD\".contains(it) }.length;\n    return len(num.replace(\"2357BD\", \"\"))\n",
            "def decimal_to_binary(dec: int) -> str:\n    # val binary = dec.toString(2)\n    binary = bin(dec)\n    # return \"db${binary}db\"\n    return \"db\" + binary + \"db\"\n",
            "def is_happy(s: str) -> bool:\n    # if (s.length < 3) {\n    if len(s) < 3:\n        # return false\n        return False\n    # for (i in 0 until s.length - 2) {\n    for i in range(0, len(s) - 2):\n        # if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false\n            return False\n    # return true\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # val result = mutableListOf<String>()\n    result = []\n    # for (g in grades) {\n    for g in grades:\n        # when {\n        #     g == 4.0 -> result.add(\"A+\")\n        if g == 4.0:\n            result.append(\"A+\")\n        #     g > 3.7 -> result.add(\"A\")\n        elif g > 3.7:\n            result.append(\"A\")\n        #     g > 3.3 -> result.add(\"A-\")\n        elif g > 3.3:\n            result.append(\"A-\")\n        #     g > 3.0 -> result.add(\"B+\")\n        elif g > 3.0:\n            result.append(\"B+\")\n        #     g > 2.7 -> result.add(\"B\")\n        elif g > 2.7:\n            result.append(\"B\")\n        #     g > 2.3 -> result.add(\"B-\")\n        elif g > 2.3:\n            result.append(\"B-\")\n        #     g > 2.0 -> result.add(\"C+\")\n        elif g > 2.0:\n            result.append(\"C+\")\n        #     g > 1.7 -> result.add(\"C\")\n        elif g > 1.7:\n            result.append(\"C\")\n        #     g > 1.3 -> result.add(\"C-\")\n        elif g > 1.3:\n            result.append(\"C-\")\n        #     g > 1.0 -> result.add(\"D+\")\n        elif g > 1.0:\n            result.append(\"D+\")\n        #     g > 0.7 -> result.add(\"D\")\n        elif g > 0.7:\n            result.append(\"D\")\n        #     g > 0.0 -> result.add(\"D-\")\n        elif g > 0.0:\n            result.append(\"D-\")\n        #     else -> result.add(\"E\")\n        else:\n            result.append(\"E\")\n    # return result\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # val length = s.length\n    length = len(s)\n    # if (length < 2) {\n    if length < 2:\n        # return false;\n        return False\n    # for (i in 2..floor(sqrt(length.toDouble())).toInt()) {\n    for i in range(2, floor(sqrt(length)) + 1):\n        # if (length % i == 0) {\n        if length % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if (n == 1) {\n    if n == 1:\n        # return 1\n        return 1\n    # return 2 * 9 * (10.0.pow(n - 2)).toInt()\n    return 2 * 9 * (10.0 ** (n - 2))\n",
            "def solve(n: int) -> str:\n    # val digitsSum = n.toString().map { it.toString().toInt() }.sum()\n    digitsSum = sum(map(int, str(n)))\n    # return digitsSum.toString(2)\n    return bin(digitsSum)[2:]\n",
            "def add(lst: List[int]) -> int:\n    # return lst.filterIndexed { i, x -> i % 2 == 1 && x % 2 == 0 }.sum()\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)\n",
            "def anti_shuffle(s: str) -> str:\n    # val words = s.split(\" \").map { it.toCharArray().sorted().joinToString(\"\") }\n    words = [\n        \"\".join(sorted(word))\n        for word in s.split(\" \")\n    ]\n    # return words.joinToString(\" \")\n    return \" \".join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # val coords = mutableListOf<List<Int>>()\n    coords = []\n    # for (i in lst.indices) {\n    for i in range(len(lst)):\n        # for (j in lst[i].indices) {\n        for j in range(len(lst[i])):\n            # if (lst[i][j] == x) {\n            if lst[i][j] == x:\n                # coords.add(listOf(i, j))\n                coords.append([i, j])\n    # return coords.sortedByDescending { it[1] }. sortedBy { it[0] }\n    return sorted(coords, key=lambda x: x[1], reverse=True).sorted(key=lambda x: x[0])\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if (arr.isEmpty()) {\n    if not arr:\n        # return emptyList()\n        return []\n    # if ((arr[0] + arr[arr.size - 1]) % 2 == 0) {\n    if (arr[0] + arr[-1]) % 2 == 0:\n        # return arr.sortedDescending()\n        return sorted(arr, reverse=True)\n    # else {\n    else:\n        # return arr.sorted()\n        return sorted(arr)\n",
            "def encrypt(s: str) -> str:\n    # val result = StringBuilder()\n    result = []\n    # for (ch in s) {\n    for ch in s:\n        # var shifted = ch.toInt() + 4\n        shifted = ord(ch) + 4\n        # if (shifted > 'z'.toInt()) {\n        if shifted > ord('z'):\n            # shifted -= 26\n            shifted -= 26\n        # result.append(shifted.toChar())\n        result.append(chr(shifted))\n    # return result.toString()\n    return ''.join(result)\n",
            "def next_smallest(lst: List[int]) -> Optional[int]:\n    # val sl = lst.toSet().sorted()\n    sl = sorted(set(lst))\n    # if (sl.size < 2) {\n    if len(sl) < 2:\n        # return null\n        return None\n    # return sl[1]\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # val sentences = s.split(Regex(\"[.!?]\\\\s*\"))\n    sentences = re.split(r\"[.!?]\\s*\", s)\n    # return sentences.filter { it.length >= 2 && it.substring(0, 2) == \"I \" }.count()\n    return len(list(filter(lambda it: len(it) >= 2 and it[:2] == \"I \", sentences)))\n",
            "def any_int(x: Any, y: Any, z: Any) -> bool:\n    # if (x is Int && y is Int && z is Int) {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # if ((x + y == z) || (x + z == y) || (y + z == x)) {\n        if (x + y == z) or (x + z == y) or (y + z == x):\n            # return true\n            return True\n    # return false\n    return False\n",
            "def encode(message: str) -> str:\n    # val vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # val result = StringBuilder()\n    result = \"\"\n    # for (ch in message) {\n    for ch in message:\n        # if (ch.isLetter()) {\n        if ch.isalpha():\n            # var ch1 = if (ch.isLowerCase()) ch.toUpperCase() else ch.toLowerCase()\n            ch1 = ch.upper() if ch.islower() else ch.lower()\n            # if (ch1 in vowels) {\n            if ch1 in vowels:\n                # ch1 = (ch1.toInt() + 2).toChar()\n                ch1 = chr(ord(ch1) + 2)\n            # result.append(ch1)\n            result += ch1\n        else:\n            # result.append(ch)\n            result += ch\n    # return result.toString()\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (i in 2..floor(sqrt(n.toDouble())).toInt()) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # val primes = lst.filter { n -> isPrime(n) }\n    primes = list(filter(lambda n: is_prime(n), lst))\n    # if (primes.size == 0) {\n    if len(primes) == 0:\n        # return 0;\n        return 0\n    # val largest = primes.max().toString();\n    largest = str(max(primes))\n    # return largest.map { c -> c.digitToInt() }.sum();\n    return sum(map(lambda c: int(c), largest))\n",
            "def check_dict_case(d: Map[str, str]) -> bool:\n    # if (d.size == 0) {\n    if len(d) == 0:\n        # return false;\n        return False\n    # return d.keys.all { k -> k.all { c -> c.isLowerCase() } } || d.keys.all { k -> k.all { c -> c.isUpperCase() } };\n    return all(k.islower() for k in d.keys()) or all(k.isupper() for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # val primes = mutableListOf<Int>()\n    primes = []\n    # for (num in 2 until n) {\n    for num in range(2, n):\n        # if (primes.all { p -> num % p != 0 }) {\n        if all(p % num != 0 for p in primes):\n            # primes.add(num)\n            primes.append(num)\n    # return primes\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # return (abs(a) % 10) * (abs(b) % 10)\n    return abs(a) % 10 * abs(b) % 10\n",
            "def count_upper(s: str) -> int:\n    # val vowels = \"AEIOU\"\n    vowels = \"AEIOU\"\n    # return s.filterIndexed { i, c -> i % 2 == 0 && vowels.contains(c) }.count()\n    return sum(1 for i, c in enumerate(s) if i % 2 == 0 and c in vowels)\n",
            "def closest_integer(value: str) -> int:\n    # val num = value.toDouble()\n    num = float(value)\n    # return if (num >= 0) {\n    #     (num + 0.5).toInt()\n    # } else {\n    #     (num - 0.5).toInt()\n    # }\n    return int(num + 0.5) if num >= 0 else int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # return (0 until n).map { i -> n + 2 * i }\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # return s.split(\"[, ]\".toRegex()).filter { it.length > 0 }\n    return list(filter(lambda x: len(x) > 0, s.split(r'[, ]')))\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    if x > y:\n        # return -1;\n        return -1\n    # if (y % 2 == 0) {\n    if y % 2 == 0:\n        # return y;\n        return y\n    # return if (y != x) y - 1 else -1 \n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> str:\n    # if (n > m) {\n    if n > m:\n        # return null\n        return None\n    # val rAvg = ((n + m).toDouble() / 2.0 + 0.5).toInt()\n    r_avg = int((n + m) / 2.0 + 0.5)\n    # return rAvg.toString(2)\n    return str(r_avg)\n",
            "def all_digits_odd(s: str) -> bool:\n    # return s.all { it.code % 2 != 0 }\n    return all(it.code % 2 != 0 for it in s)\ndef unique_digits(x: List[int]) -> List[int]:\n    # return x.filter { allDigitsOdd(it.toString()) }.sorted()\n    return sorted(filter(lambda it: all_digits_odd(str(it)), x))\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # val digitNames = listOf(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # val sortedArr = arr.filter { 1 <= it && it <= 9 }.sortedDescending()\n    sorted_arr = sorted(filter(lambda x: 1 <= x and x <= 9, arr), reverse=True)\n    # return sortedArr.map { digitNames[it - 1] }\n    return list(map(lambda x: digit_names[x - 1], sorted_arr))\n",
            "def f(n: int) -> List[int]:\n    # val nums = (1..n).toList()\n    nums = list(range(1, n + 1))\n    # return nums.mapIndexed { i, it -> if (it % 2 != 0) nums.take(i + 1).sum() else nums.take(i + 1).reduce { x, y -> x * y } }\n    return [\n        nums.take(i + 1).sum() if it % 2 != 0 else nums.take(i + 1).reduce(lambda x, y: x * y)\n        for i, it in enumerate(nums)\n    ]\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == s.reversed()\n    return s == s[::-1]\ndef even_odd_palindrome(n: int) -> List[int]:\n    # val cnt = mutableListOf(0, 0)\n    cnt = [0, 0]\n    # for (i in 1..n) {\n    for i in range(1, n + 1):\n        # if (isPalindrome(i.toString())) {\n        if is_palindrome(str(i)):\n            # cnt[i % 2]++\n            cnt[i % 2] += 1\n    # return cnt\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # val nStr = n.toString()\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return nStr.map { it.toString().toInt() }.sum()\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return nStr.substring(0, 2).toInt() * 2 + digitsSum(abs(n))\n        return int(n_str[0:2]) * 2 + digits_sum(abs(n))\n    # }\ndef count_nums(arr: List[int]) -> int:\n    # return arr.count { digitsSum(it) > 0 }\n    return sum(1 for it in arr if digits_sum(it) > 0)\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if (arr.isEmpty()) {\n    if not arr:\n        # return true\n        return True\n    # val sortedArr = arr.sorted()\n    sorted_arr = sorted(arr)\n    # for (i in 0 until arr.size) {\n    for i in range(arr.size):\n        # if (arr.subList(i, arr.size) == sortedArr.subList(0, arr.size - i) && arr.subList(0, i) == sortedArr.subList(arr.size - i, sortedArr.size)) {\n        if arr[i:] == sorted_arr[0:arr.size - i] and arr[0:i] == sorted_arr[arr.size - i:]:\n            # return true\n            return True\n    # return false\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # val oddCnt = lst1.count { it % 2 != 0 }\n    odd_cnt = sum(1 for it in lst1 if it % 2 != 0)\n    # val evenCnt = lst2.count { it % 2 == 0 }\n    even_cnt = sum(1 for it in lst2 if it % 2 == 0)\n    # return if (evenCnt >= oddCnt) \"YES\" else \"NO\"\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # val freq = mutableMapOf<String, Int>()\n    freq = {}\n    # val words = test.split(\" \").filter { it.length > 0 }\n    words = [w for w in test.split(\" \") if len(w) > 0]\n    # for (w in words) {\n    for w in words:\n        # freq[w] = freq.getOrDefault(w, 0) + 1\n        freq[w] = freq.get(w, 0) + 1\n    # val result = mutableMapOf<String, Int>()\n    result = {}\n    # if (freq.size > 0) {\n    if freq:\n        # val maxFreq = freq.values.max()\n        max_freq = max(freq.values())\n        # for (kv in freq) {\n        for kv in freq.items():\n            # if (kv.value == maxFreq) {\n            if kv[1] == max_freq:\n                # result[kv.key] = kv.value\n                result[kv[0]] = kv[1]\n    # return result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == s.reversed()\n    return s == s[::-1]\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # val s1 = s.filter { it !in c }\n    s1 = ''.join(filter(lambda x: x not in c, s))\n    # return listOf(s1, if (isPalindrome(s1)) \"yes\" else \"no\")\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # val result = mutableListOf<String>()\n    result = []\n    # for (num in lst) {\n    for num in lst:\n        # val n = num.filter { it.toInt() % 2 == 1 }.length\n        n = len(list(filter(lambda it: it.toInt() % 2 == 1, num)))\n        # val rs = \"the number of odd elements in the string i of the input.\"\n        rs = \"the number of odd elements in the string i of the input.\"\n        # result.add(rs.replace(\"i\", n.toString()))\n        result.append(rs.replace(\"i\", n.toString()))\n    # return result\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # var minSum = 0\n    min_sum = 0\n    # var curSum = 0\n    cur_sum = 0\n    # for (n in nums) {\n    for n in nums:\n        # curSum = minOf(curSum + n, 0)\n        cur_sum = min(cur_sum + n, 0)\n        # minSum = minOf(curSum, minSum)\n        min_sum = min(cur_sum, min_sum)\n    # if (minSum == 0) {\n    if min_sum == 0:\n        # minSum = nums.min()!!\n        min_sum = min(nums)\n    # return minSum\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # return grid.sumBy { ceil(it.sum() / capacity.toDouble()).toInt() }\n    return sum(ceil(sum(row) / capacity) for row in grid)\n",
            "def count_ones(num: int) -> int:\n    # return num.toString(2).count { it == '1' }\n    return num.to_bytes(2, 'big').count(b'1')\ndef sort_array(arr: List[int]) -> List[int]:\n    # return arr.sortedWith(compareBy({ countOnes(it) }, { it }))\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # val consonants = \"bcdfghjklmnpqrstvwxyz\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # val words = s.split(\" \").filter { it.length > 0 }\n    words = [w for w in s.split(\" \") if len(w) > 0]\n    # return words.filter { it.filter { c -> consonants.contains(c.toLowerCase()) }.length == n }\n    return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # val vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # for (i in word.length - 2 downTo 1) {\n    for i in range(word.length - 2, 0, -1):\n        # if (word[i] in vowels && word[i - 1] !in vowels && word[i + 1] !in vowels) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return word[i].toString()\n            return word[i]\n    # return \"\"\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # var depth = 0\n    depth = 0\n    # for (ch in s) {\n    for ch in s:\n        # if (ch == '(') {\n        if ch == '(':\n            # depth++\n            depth += 1\n        else:\n            # depth--\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false\n            return False\n    # return depth == 0\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # val s1 = lst[0] + lst[1]\n    s1 = lst[0] + lst[1]\n    # val s2 = lst[1] + lst[0]\n    s2 = lst[1] + lst[0]\n    # return if (check(s1) || check(s2)) \"Yes\" else \"No\"\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if (k == 0) {\n    if k == 0:\n        # return emptyList()\n        return []\n    # return arr.sorted().takeLast(k)\n    return sorted(arr)[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # return lst.filterIndexed { i, x -> i % 2 == 0 && x % 2 != 0 }.sum()\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # return arr.take(k).filter { it.toString().length <= 2 }.sum()\n    return sum(filter(lambda it: len(str(it)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # val collatz = mutableListOf(1)\n    collatz = [1]\n    # var n = n\n    n = n\n    # while (n != 1) {\n    while n != 1:\n        # if (n % 2 != 0) {\n        if n % 2 != 0:\n            # collatz.add(n)\n            collatz.append(n)\n            # n = 3 * n + 1\n            n = 3 * n + 1\n        else:\n            # n = n / 2\n            n = n / 2\n    # return collatz.sorted()\n    return sorted(collatz)\n",
            "def valid_date(date: str) -> bool:\n    # if (date.length != 10 || date[2] != '-' || date[5] != '-') {\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        # return false\n        return False\n    # val m = date.substring(0, 2).toInt()\n    m = int(date[0:2])\n    # val d = date.substring(3, 5).toInt()\n    d = int(date[3:5])\n    # if (m in listOf(1, 3, 5, 7, 8, 10, 12) && d >= 1 && d <= 31) {\n    if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n        # return true\n        return True\n    # if (m in listOf(4, 6, 9, 11) && d >= 1 && d <= 30) {\n    if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n        # return true\n        return True\n    # if (m == 2 && d >= 1 && d <= 29) {\n    if m == 2 and d >= 1 and d <= 29:\n        # return true\n        return True\n    # return false\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if (\" \" in txt) {\n    if \" \" in txt:\n        # return txt.split(\" \")\n        return txt.split(\" \")\n    # } else if (\",\" in txt) {\n    elif \",\" in txt:\n        # return txt.split(\",\")\n        return txt.split(\",\")\n    # } else {\n    else:\n        # return listOf(txt.filter { it.isLowerCase() && it.toInt() % 2 == 0 }.count().toString())\n        return [txt.filter(lambda it: it.islower() and int(it) % 2 == 0).count().__str__()]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if (!lst.drop(1).zip(lst).all { (a, b) -> b <= a }) {\n    if not all(b <= a for a, b in zip(lst, lst[1:])):\n        # return false\n        return False\n    # val freq = mutableMapOf<Int, Int>()\n    freq = {}\n    # for (i in lst) {\n    for i in lst:\n        # freq[i] = freq.getOrDefault(i, 0) + 1\n        freq[i] = freq.get(i, 0) + 1\n    # return freq.values.maxOrNull() ?: 0 <= 2\n    return max(freq.values()) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (i in 2..floor(sqrt(n.toDouble())).toInt()) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # val l = max(interval1[0], interval2[0])\n    l = max(interval1[0], interval2[0])\n    # val r = min(interval1[1], interval2[1])\n    r = min(interval1[1], interval2[1])\n    # val length = r - l\n    length = r - l\n    # return if (length > 0 && isPrime(length)) \"YES\" else \"NO\"\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if (arr.isEmpty()) {\n    if not arr:\n        # return null\n        return None\n    # if (0 in arr) {\n    if 0 in arr:\n        # return 0\n        return 0\n    # val sign = if (arr.count { it < 0 } % 2 == 1) -1 else 1\n    sign = -1 if arr.count(lambda x: x < 0) % 2 == 1 else 1\n    # return sign * arr.sumOf { it.absoluteValue }\n    return sign * sum(map(abs, arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # val n = grid.size\n    n = len(grid)\n    # var minVal = n * n + 1\n    min_val = n * n + 1\n    # for (i in 0 until n) {\n    for i in range(n):\n        # for (j in 0 until n) {\n        for j in range(n):\n            # if (grid[i][j] == 1) {\n            if grid[i][j] == 1:\n                # val temp = mutableListOf<Int>()\n                temp = []\n                # if (i != 0) {\n                if i != 0:\n                    # temp.add(grid[i - 1][j])\n                    temp.append(grid[i - 1][j])\n                # if (j != 0) {\n                if j != 0:\n                    # temp.add(grid[i][j - 1])\n                    temp.append(grid[i][j - 1])\n                # if (i != n - 1) {\n                if i != n - 1:\n                    # temp.add(grid[i + 1][j])\n                    temp.append(grid[i + 1][j])\n                # if (j != n - 1) {\n                if j != n - 1:\n                    # temp.add(grid[i][j + 1])\n                    temp.append(grid[i][j + 1])\n                # minVal = temp.min()\n                min_val = min(temp)\n    # val result = mutableListOf<Int>()\n    result = []\n    # for (i in 0 until k) {\n    for i in range(k):\n        # result.add(if (i % 2 == 0) 1 else minVal)\n        result.append(1 if i % 2 == 0 else min_val)\n    # return result\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if (n == 0) {\n    if n == 0:\n        # return listOf(1)\n        return [1]\n    # val seq = mutableListOf(1, 3)\n    seq = [1, 3]\n    # for (i in 2..n) {\n    for i in range(2, n + 1):\n        # if (i % 2 == 0) {\n        if i % 2 == 0:\n            # seq.add(i / 2 + 1)\n            seq.append(i // 2 + 1)\n        else:\n            # seq.add(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) // 2)\n    # return seq\n    return seq\n",
            "def digits(n: int) -> int:\n    # val odds = n.toString().filter { it.digitToInt() % 2 == 1 }.map { it.digitToInt() }\n    odds = [int(x) for x in str(n) if int(x) % 2 == 1]\n    # return if (odds.size > 0) odds.reduce { x, y -> x * y } else 0\n    return odds[0] * odds[1] if len(odds) > 0 else 0\n",
            "def is_nested(s: str) -> bool:\n    # val openIdx = mutableListOf<Int>()\n    open_idx = []\n    # val closeIdx = mutableListOf<Int>()\n    close_idx = []\n    # for ((i, ch) in s.withIndex()) {\n    for i, ch in enumerate(s):\n        # when (ch) {\n        #     '[' -> openIdx.add(i)\n        if ch == '[':\n            open_idx.append(i)\n        #     ']' -> closeIdx.add(i)\n        elif ch == ']':\n            close_idx.append(i)\n    # }\n    # closeIdx.reverse()\n    close_idx.reverse()\n    # var cnt = 0\n    cnt = 0\n    # var i = 0\n    i = 0\n    # val l = closeIdx.size\n    l = len(close_idx)\n    # for (idx in openIdx) {\n    for idx in open_idx:\n        # if (i < l && idx < closeIdx[i]) {\n        if i < l and idx < close_idx[i]:\n            # cnt++\n            cnt += 1\n            # i++\n            i += 1\n    # }\n    # return cnt >= 2\n    return cnt >= 2\n",
            "def sum_squares(lst: List[float]) -> int:\n    # return lst.map { ceil(it).pow(2).toInt() }.sum()\n    return sum(map(lambda it: ceil(it).pow(2).toInt(), lst))\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if (txt.isEmpty()) {\n    if not txt:\n        # return false\n        return False\n    # val last = txt.substringAfterLast(\" \")\n    last = txt.rsplit(\" \", 1)[-1]\n    # return last.length == 1 && last[0].isLetter()\n    return len(last) == 1 and last[0].isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if (arr.size <= 1) {\n    if len(arr) <= 1:\n        # return -1\n        return -1\n    # val idx = (1 until arr.size).filter { i -> arr[i] < arr[i - 1] }\n    idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    # return idx.maxOrNull() ?: -1\n    return max(idx) if idx else -1\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # val neg = lst.filter { it < 0 }\n    neg = [e for e in lst if e < 0]\n    # val pos = lst.filter { it > 0 }\n    pos = [e for e in lst if e > 0]\n    # val maxNeg = neg.maxOrNull()\n    max_neg = max(neg) if neg else None\n    # val minPos = pos.minOrNull()\n    min_pos = min(pos) if pos else None\n    # return listOf(maxNeg, minPos)\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if (o is String) {\n    if isinstance(o, str):\n        # return o.replace(\",\", \".\").toDouble()\n        return float(o.replace(\",\", \".\"))\n    # } else if (o is Int) {\n    elif isinstance(o, int):\n        # return o.toDouble()\n        return float(o)\n    # } else if (o is Double) {\n    elif isinstance(o, float):\n        # return o as Double\n        return o\n    # }\n    # throw Exception(\"Unknown type\")\n    raise Exception(\"Unknown type\")\ndef compare_one(a: Any, b: Any) -> float:\n    # val a1 = anyToReal(a)\n    a1 = any_to_real(a)\n    # val b1 = anyToReal(b)\n    b1 = any_to_real(b)\n    # if (a1 == b1) {\n    if a1 == b1:\n        # return null\n        return None\n    # } else if (a1 > b1) {\n    elif a1 > b1:\n        # return a1\n        return a1\n    # } else {\n    else:\n        # return b1\n        return b1\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return n % 2 == 0 && n >= 8\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # var fact = 1\n    fact = 1\n    # var result = 1\n    result = 1\n    # for (i in 1..n) {\n    for i in range(1, n + 1):\n        # fact *= i\n        fact *= i\n        # result *= fact\n        result *= fact\n    # return result\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return txt.replace(Regex(\"\\\\s{3,}\"), \"-\").replace(\" \", \"_\")\n    return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n",
            "def file_name_check(file_name: str) -> str:\n    # val suf = listOf(\"txt\", \"exe\", \"dll\")\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # val lst = fileName.split(\".\")\n    lst = file_name.split(\".\")\n    # if (lst.size != 2 || lst[1] !in suf || lst[0].length == 0 || !lst[0][0].isLetter() || lst[0].count { it.isDigit() } > 3) {\n    if lst.size != 2 or lst[1] not in suf or lst[0].length == 0 or not lst[0][0].isalpha() or lst[0].count(lambda it: it.isdigit()) > 3:\n        # return \"No\"\n        return \"No\"\n    # return \"Yes\"\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # var result = 0\n    result = 0\n    # for (i in lst.indices) {\n    for i in range(len(lst)):\n        # if (i % 3 == 0) {\n        if i % 3 == 0:\n            # result += lst[i].toDouble().pow(2).toInt()\n            result += lst[i] ** 2\n        # } else if (i % 4 == 0) {\n        elif i % 4 == 0:\n            # result += lst[i].toDouble().pow(3).toInt()\n            result += lst[i] ** 3\n        # } else {\n        else:\n            # result += lst[i]\n            result += lst[i]\n    # return result\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (i in 2..floor(sqrt(n.toDouble())).toInt()) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # val words = sentence.split(\" \")\n    words = sentence.split(\" \")\n    # return words.filter { isPrime(it.length) }.joinToString(\" \")\n    return \" \".join(filter(lambda w: is_prime(len(w)), words))\n",
            "def simplify(x: str, n: str) -> bool:\n    # val xs = x.split(\"/\")\n    xs = x.split(\"/\")\n    # val ns = n.split(\"/\")\n    ns = n.split(\"/\")\n    # val num = xs[0].toInt() * ns[0].toInt()\n    num = int(xs[0]) * int(ns[0])\n    # val den = xs[1].toInt() * ns[1].toInt()\n    den = int(xs[1]) * int(ns[1])\n    # return num % den == 0\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # val nStr = n.toString()\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return nStr.map { it.toString().toInt() }.sum()\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return nStr.substring(0, 2).toInt() * 2 + digitsSum(abs(n))\n        return int(n_str[0:2]) * 2 + digits_sum(abs(n))\n    # }\ndef order_by_points(nums: List[int]) -> List[int]:\n    # return nums.sortedBy { digitsSum(it) }\n    return sorted(nums, key=digits_sum)\n",
            "def special_filter(nums: List[int]) -> int:\n    # val odds = \"13579\"\n    odds = \"13579\"\n    # return  nums.filter { it > 10 && it % 2 == 1 && odds.contains(it.toString()[0]) }.size\n    return len(list(filter(lambda it: it > 10 and it % 2 == 1 and odds.contains(str(it)[0]), nums)))\n",
            "def get_max_triples(n: int) -> int:\n    # val c = arrayOf(0, 0, 0)\n    c = [0, 0, 0]\n    # for (i in 1..n) {\n    for i in range(1, n + 1):\n        # val a = i * i - i + 1\n        a = i * i - i + 1\n        # c[a % 3] += 1\n        c[a % 3] += 1\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # val names = listOf(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if (planet1 !in names || planet2 !in names) {\n    if planet1 not in names or planet2 not in names:\n        # return emptyList()\n        return []\n    # var l = names.indexOf(planet1)\n    l = names.index(planet1)\n    # var r = names.indexOf(planet2)\n    r = names.index(planet2)\n    # if (l > r) {\n    if l > r:\n        # l = r.also { r = l }\n        l, r = r, l\n    # if (l == r) {\n    if l == r:\n        # return emptyList()\n        return []\n    # return names.subList(l + 1, r)\n    return names[l + 1:r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # val result = lst.filter { it.length % 2 == 0 }\n    result = [e for e in lst if len(e) % 2 == 0]\n    # return result.sortedWith(compareBy({ it.length }, { it }))\n    return sorted(result, key=lambda x: (len(x), x))\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if (n < 2) {\n    if n < 2:\n        # return y;\n        return y\n    # for (i in 2..floor(sqrt(n.toDouble())).toInt()) {\n    for i in range(2, floor(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return y;\n            return y\n    # return x;\n    return x\n",
            "def double_the_difference(lst: List[float]) -> int:\n    # return lst.filter { it >= 0 && it % 2 == 1.0 }.map { (it * it).toInt() }.sum()\n    return sum(map(lambda it: (it * it).toInt(), filter(lambda it: it >= 0 and it % 2 == 1.0, lst)))\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # return game.zip(guess).map { (x, y) -> abs(x - y) }\n    return [abs(x - y) for x, y in zip(game, guess)]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # var maxS = Int.MIN_VALUE\n    max_s = -2147483648\n    # var maxExt = \"\"\n    max_ext = \"\"\n    # for (ext in extensions) {\n    for ext in extensions:\n        # val upper = ext.count { it.isUpperCase() }\n        upper = sum(1 for c in ext if c.isupper())\n        # val lower = ext.count { it.isLowerCase() }\n        lower = sum(1 for c in ext if c.islower())\n        # val s = upper - lower\n        s = upper - lower\n        # if (s > maxS) {\n        if s > max_s:\n            # maxS = s\n            max_s = s\n            # maxExt = ext\n            max_ext = ext\n    # return \"$className.$maxExt\"\n    return f\"{class_name}.{max_ext}\"\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if (a.length < b.length) {\n    if len(a) < len(b):\n        # return false\n        return False\n    # for (i in b.indices) {\n    for i in range(len(b)):\n        # if (b.substring(i) + b.substring(0, i) in a) {\n        if b[i:] + b[:i] in a:\n            # return true\n            return True\n    # return false\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # val ds = abs(num).toString()\n    ds = str(abs(num))\n    # val even = ds.count { it.toInt() % 2 == 0 }\n    even = ds.count(lambda x: int(x) % 2 == 0)\n    # return listOf(even, ds.length - even)\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # val values = listOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 ,5, 4, 1)\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 ,5, 4, 1]\n    # val numerals = listOf(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # var res = StringBuilder()\n    res = \"\"\n    # var num = num\n    num = num\n    # for (i in values.indices) {\n    for i in range(len(values)):\n        # while (num >= values[i]) {\n        while num >= values[i]:\n            # res.append(numerals[i])\n            res += numerals[i]\n            # num -= values[i]\n            num -= values[i]\n    # return res.toString()\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # val s = listOf(a, b, c).sorted()\n    s = sorted([a, b, c])\n    # return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # var maxCnt = 0\n    max_cnt = 0\n    # var maxW = \"\"\n    max_w = \"\"\n    # for (w in words) {\n    for w in words:\n        # val cnt = w.toSet().size\n        cnt = len(set(w))\n        # if (cnt > maxCnt) {\n        if cnt > max_cnt:\n            # maxCnt = cnt\n            max_cnt = cnt\n            # maxW = w\n            max_w = w\n        # else if (cnt == maxCnt) {\n        elif cnt == max_cnt:\n            # maxW = minOf(maxW, w)\n            max_w = min(max_w, w)\n    # return maxW\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if (need <= remaining) {\n    if need <= remaining:\n        # return listOf(num + need, remaining - need)\n        return [num + need, remaining - need]\n    # } else {\n    else:\n        # return listOf(num + remaining, 0)\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # val ops = operators.toMutableList()\n    ops = operators.copy()\n    # val nums = operands.toMutableList()\n    nums = operands.copy()\n    # var i = ops.size - 1\n    i = len(ops) - 1\n    # while (i >= 0) {\n    while i >= 0:\n        # if (ops[i] == \"**\") {\n        if ops[i] == \"**\":\n            # nums[i] = nums[i].toDouble().pow(nums[i + 1]).toInt()\n            nums[i] = pow(nums[i], nums[i + 1])\n            # nums.removeAt(i + 1)\n            del nums[i + 1]\n            # ops.removeAt(i)\n            del ops[i]\n        # i -= 1\n        i -= 1\n    # i = 0\n    i = 0\n    # while (i < ops.size) {\n    while i < len(ops):\n        # if (ops[i] == \"*\") {\n        if ops[i] == \"*\":\n            # nums[i] = nums[i] * nums[i + 1]\n            nums[i] *= nums[i + 1]\n            # nums.removeAt(i + 1)\n            del nums[i + 1]\n            # ops.removeAt(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # } else if (ops[i] == \"//\") {\n        elif ops[i] == \"//\":\n            # nums[i] = nums[i] / nums[i + 1]\n            nums[i] //= nums[i + 1]\n            # nums.removeAt(i + 1)\n            del nums[i + 1]\n            # ops.removeAt(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # }\n        # i += 1\n        i += 1\n    # i = 0\n    i = 0\n    # while (i < ops.size) {\n    while i < len(ops):\n        # if (ops[i] == \"+\") {\n        if ops[i] == \"+\":\n            # nums[i] = nums[i] + nums[i + 1]\n            nums[i] += nums[i + 1]\n            # nums.removeAt(i + 1)\n            del nums[i + 1]\n            # ops.removeAt(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # } else if (ops[i] == \"-\") {\n        elif ops[i] == \"-\":\n            # nums[i] = nums[i] - nums[i + 1]\n            nums[i] -= nums[i + 1]\n            # nums.removeAt(i + 1)\n            del nums[i + 1]\n            # ops.removeAt(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # }\n        # i += 1\n        i += 1\n    # return nums[0]\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if (!s.any { it.isLetter() }) {\n    if not any(ch.isalpha() for ch in s):\n        # return s.reversed()\n        return s[::-1]\n    # val result = StringBuilder()\n    result = []\n    # for (ch in s) {\n    for ch in s:\n        # if (!ch.isLetter()) {\n        if not ch.isalpha():\n            # result.append(ch)\n            result.append(ch)\n        # else if (ch.isUpperCase()) {\n        elif ch.isupper():\n            # result.append(ch.toLowerCase())\n            result.append(ch.lower())\n        # else if (ch.isLowerCase()) {\n        elif ch.islower():\n            # result.append(ch.toUpperCase())\n            result.append(ch.upper())\n    # return result.toString()\n    return ''.join(result)\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if (txt.isEmpty()) {\n    if not txt:\n        # return null\n        return None\n    # val md5Hash = MessageDigest.getInstance(\"MD5\")\n    md5_hash = hashlib.md5()\n    # val txtBytes = txt.toByteArray()\n    txt_bytes = txt.encode()\n    # val md5Encoded = md5Hash.digest(txtBytes).joinToString(\"\") { \"%02x\".format(it) }\n    md5_encoded = md5_hash.update(txt_bytes).hexdigest()\n    # return md5Encoded\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # val lower = maxOf(2, minOf(a, b))\n    lower = max(2, min(a, b))\n    # val upper = minOf(8, maxOf(a, b))\n    upper = min(8, max(a, b))\n    # return (lower..upper).filter { it % 2 == 0 }\n    return [i for i in range(lower, upper + 1) if i % 2 == 0]\n"
        ]
    },
    "php": {
        "python": [
            "def has_close_elements(numbers: List[int], threshold: int) -> bool:\n    # for ($i = 0; $i < count($numbers); $i++) {\n    for i in range(len(numbers)):\n        # for ($j = $i + 1; $j < count($numbers); $j++) {\n        for j in range(i + 1, len(numbers)):\n            # if (abs($numbers[$i] - $numbers[$j]) < $threshold) {\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true;\n                return True\n    # return false;\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # $groups = [];\n    groups = []\n    # $stk = [];\n    stk = []\n    # $currentGroup = \"\";\n    current_group = \"\"\n    # $parens = str_replace(\" \", \"\", $parenString);\n    parens = paren_string.replace(\" \", \"\")\n    # foreach (str_split($parens) as $ch) {\n    for ch in parens:\n        # if ($ch === \"(\") {\n        if ch == \"(\":\n            # array_push($stk, $ch);\n            stk.append(ch)\n            # $currentGroup .= $ch;\n            current_group += ch\n        # } else if ($ch === \")\") {\n        elif ch == \")\":\n            # array_pop($stk);\n            stk.pop()\n            # $currentGroup .= $ch;\n            current_group += ch\n            # if (count($stk) === 0) {\n            if len(stk) == 0:\n                # array_push($groups, $currentGroup);\n                groups.append(current_group)\n                # $currentGroup = \"\";\n                current_group = \"\"\n    # return $groups;\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return $num - floor($num);\n    return num - int(num)\n",
            "def below_zero(operations: List[int]) -> bool:\n    # $balance = 0;\n    balance = 0\n    # foreach ($operations as $op) {\n    for op in operations:\n        # $balance += $op;\n        balance += op\n        # if ($balance < 0) {\n        if balance < 0:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def mean_absolute_deviation(numbers: List[int]) -> float:\n    # $mean = array_sum($numbers) / count($numbers);\n    mean = sum(numbers) / len(numbers)\n    # $deviation = array_sum(array_map(function($x) use ($mean) {\n    #     return abs($x - $mean); \n    # }, $numbers));\n    deviation = sum(abs(x - mean) for x in numbers)\n    # return $deviation / count($numbers);\n    return deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # $result = [];\n    result = []\n    # for ($i = 0; $i < count($numbers); $i++) {\n    for i in range(len(numbers)):\n        # if ($i != 0) {\n        if i != 0:\n            # $result[] = $delimiter;\n            result.append(delimiter)\n        # $result[] = $numbers[$i];\n        result.append(numbers[i])\n    # return $result;\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # $result = [];\n    result = []\n    # $parenGroups = array_filter(explode(\" \", $parenString), function($s) {\n    #     return strlen($s) > 0;\n    # });\n    paren_groups = list(filter(lambda s: len(s) > 0, paren_string.split(\" \")))\n    # foreach ($parenGroups as $group) {\n    for group in paren_groups:\n        # $maxDepth = 0;\n        max_depth = 0\n        # $depth = 0;\n        depth = 0\n        # foreach (str_split($group) as $ch) {\n        for ch in group:\n            # if ($ch == \"(\") {\n            if ch == \"(\":\n                # $depth += 1;\n                depth += 1\n                # $maxDepth = max($maxDepth, $depth);\n                max_depth = max(max_depth, depth)\n            # } elseif ($ch == \")\") {\n            elif ch == \")\":\n                # $depth -= 1;\n                depth -= 1\n        # $result[] = $maxDepth;\n        result.append(max_depth)\n    # return $result;\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # return array_filter($strs, function($s) use ($substring) {\n    #     return strpos($s, $substring) !== false;\n    # });\n    return list(filter(lambda s: substring in s, strs))\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # $nSum = array_sum($numbers);\n    n_sum = sum(numbers)\n    # $nProduct = array_product($numbers);\n    n_product = 1\n    for n in numbers:\n        n_product *= n\n    # return [$nSum, $nProduct];\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # $max_so_far = PHP_INT_MIN;\n    max_so_far = float('-inf')\n    # $result = [];\n    result = []\n    # foreach ($numbers as $num) {\n    for num in numbers:\n        # $max_so_far = max($max_so_far, $num);\n        max_so_far = max(max_so_far, num)\n        # $result[] = $max_so_far;\n        result.append(max_so_far)\n    # return $result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return $s === strrev($s);\n    return s == s[::-1]\ndef make_palindrome(s: str) -> Optional[str]:\n    # if (isPalindrome($s)) {\n    if is_palindrome(s):\n        # return $s;\n        return s\n    # for ($i = 0; $i < strlen($s); $i++) {\n    for i in range(len(s)):\n        # if (isPalindrome(substr($s, $i))) {\n        if is_palindrome(s[i:]):\n            # return $s . strrev(substr($s, 0, $i));\n            return s + s[:i][::-1]\n    # return \"\";\n    return None\n",
            "def string_xor(a: str, b: str) -> str:\n    # return implode('', array_map(function ($x, $y) { return $x === $y ? '0' : '1'; }, str_split($a), str_split($b)));\n    return ''.join('1' if x == y else '0' for x, y in zip(a, b))\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if (empty($strs)) {\n    if not strs:\n        # return null;\n        return None\n    # $longest_s = $strs[0];\n    longest_s = strs[0]\n    # foreach ($strs as $s) {\n    for s in strs:\n        # if (strlen($s) > strlen($longest_s)) {\n        if len(s) > len(longest_s):\n            # $longest_s = $s;\n            longest_s = s\n    # return $longest_s;\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if ($b == 0) {\n    if b == 0:\n        # return $a;\n        return a\n    # else {\n    else:\n        # return greatestCommonDivisor($b, $a % $b);\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # $prefixes = [];\n    prefixes = []\n    # for ($i = 0; $i < strlen($s); $i++) {\n    for i in range(len(s)):\n        # $prefixes[] = substr($s, 0, $i + 1);\n        prefixes.append(s[:i + 1])\n    # return $prefixes;\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # return implode(\" \", range(0, $n));\n    return \" \".join(map(str, range(n)))\n",
            "def count_distinct_characters(s: str) -> int:\n    # return count(array_unique(str_split(strtolower($s))));\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # $durations = [\"o\" => 4, \"o|\" => 2, \".|\" => 1];\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    # $notes = array_filter(explode(\" \", $musicString), function($s) {\n    #     return strlen($s) > 0;\n    # });\n    notes = list(filter(lambda s: len(s) > 0, music_string.split(\" \")))\n    # return array_map(function($note) use ($durations) {\n    #     return $durations[$note];\n    # }, $notes);\n    return list(map(lambda note: durations[note], notes))\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # $times = 0;\n    times = 0\n    # for ($i = 0; $i <= strlen($s) - strlen($substring); $i++) {\n    for i in range(len(s) - len(substring) + 1):\n        # if (substr($s, $i, strlen($substring)) === $substring) {\n        if s[i:i + len(substring)] == substring:\n            # $times += 1;\n            times += 1\n    # return $times;\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # $num_dict = [\n    #     \"zero\" => 0,\n    #     \"one\" => 1,\n    #     \"two\" => 2,\n    #     \"three\" => 3,\n    #     \"four\" => 4,\n    #     \"five\" => 5,\n    #     \"six\" => 6,\n    #     \"seven\" => 7,\n    #     \"eight\" => 8,\n    #     \"nine\" => 9,\n    # ];\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    # $num_list = array_filter(explode(\" \", $numbers), function($x) use ($num_dict) {\n    #     return array_key_exists($x, $num_dict);\n    # });\n    num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    # usort($num_list, function($a, $b) use ($num_dict) {\n    #     return $num_dict[$a] - $num_dict[$b];\n    # });\n    num_list.sort(key=lambda x: num_dict[x])\n    # return implode(\" \", $num_list);\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[int]) -> List[int]:\n    # $sorted_numbers = $numbers;\n    sorted_numbers = numbers\n    # sort($sorted_numbers);\n    sorted_numbers.sort()\n    # $min_diff = INF;\n    min_diff = float('inf')\n    # $closest_pair = [];\n    closest_pair = []\n    # for ($i = 1; $i < count($sorted_numbers); $i++) {\n    for i in range(1, len(sorted_numbers)):\n        # $diff = $sorted_numbers[$i] - $sorted_numbers[$i - 1];\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if ($diff < $min_diff) {\n        if diff < min_diff:\n            # $min_diff = $diff;\n            min_diff = diff\n            # $closest_pair = [$sorted_numbers[$i - 1], $sorted_numbers[$i]];\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return $closest_pair;\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # $min_num = min($numbers);\n    min_num = min(numbers)\n    # $max_num = max($numbers);\n    max_num = max(numbers)\n    # if ($min_num == $max_num) {\n    if min_num == max_num:\n        # return array_fill(0, count($numbers), 0.0);\n        return [0.0] * len(numbers)\n    # } else {\n    else:\n        # return array_map(function($num) use ($min_num, $max_num) {\n        return list(map(lambda num: (num - min_num) / (max_num - min_num), numbers))\n        # }, $numbers);\n",
            "def filter_integers(values: List[int]) -> List[int]:\n    # return array_filter($values, function($x) {\n    #     return is_int($x);\n    # });\n    return list(filter(lambda x: isinstance(x, int), values))\n",
            "def str_length(s: str) -> int:\n    # return strlen($s);\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for ($i = 2; $i < $n; $i++) {\n    for i in range(2, n):\n        # if ($n % $i == 0) {\n        if n % i == 0:\n            # return $n / $i;\n            return n / i\n    # return 1;\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # $factors = [];\n    factors = []\n    # $divisor = 2;\n    divisor = 2\n    # while ($divisor <= $n) {\n    while divisor <= n:\n        # if ($n % $divisor == 0) {\n        if n % divisor == 0:\n            # $factors[] = $divisor;\n            factors.append(divisor)\n            # $n /= $divisor;\n            n /= divisor\n        else:\n            # $divisor++;\n            divisor += 1\n    # return $factors;\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # $counts = array();\n    counts = {}\n    # foreach ($numbers as $num) {\n    for num in numbers:\n        # $counts[$num] = ($counts[$num] ?? 0) + 1;\n        counts[num] = counts.get(num, 0) + 1\n    # $res = array_filter($numbers, function($num) use ($counts) {\n    #     return $counts[$num] == 1;\n    # });\n    res = []\n    for num in numbers:\n        if counts[num] == 1:\n            res.append(num)\n    # return $res;\n    return res\n",
            "def flip_case(s: str) -> str:\n    # $flipped = \"\";\n    flipped = \"\"\n    # foreach (str_split($s) as $ch) {\n    for ch in s:\n        # if (!ctype_alpha($ch)) {\n        if not ch.isalpha():\n            # $flipped .= $ch;\n            flipped += ch\n        # } else if (ctype_lower($ch)) {\n        elif ch.islower():\n            # $flipped .= strtoupper($ch);\n            flipped += ch.upper()\n        # } else if (ctype_upper($ch)) {\n        elif ch.isupper():\n            # $flipped .= strtolower($ch);\n            flipped += ch.lower()\n    # return $flipped;\n    return flipped\n",
            "def concatenate(strs: List[str]) -> str:\n    # return implode(\"\", $strs);\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # return array_filter($strs, function($str) use ($prefixStr) {\n    #     return strpos($str, $prefixStr) === 0;\n    # });\n    return list(filter(lambda str: str.startswith(prefix_str), strs))\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # return array_filter($l, function($num) {\n    #     return $num > 0;\n    # });\n    return list(filter(lambda num: num > 0, l))\n",
            "def is_prime(n: int) -> bool:\n    # if ($n < 2) {\n    if n < 2:\n        # return False;\n        return False\n    # for ($i = 2; $i <= floor(sqrt($n)); $i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if ($n % $i == 0) {\n        if n % i == 0:\n            # return False;\n            return False\n    # return True;\n    return True\n",
            "def poly(xs: List[float], x: float) -> float:\n    # $res = 0;\n    res = 0\n    # for ($i = 0; $i < count($xs); $i++) {\n    for i in range(len(xs)):\n        # $res += $xs[$i] * pow($x, $i);\n        res += xs[i] * pow(x, i)\n    # return $res;\n    return res\ndef find_zero(xs: List[float]) -> float:\n    # [$x1, $x2] = [1.0, -1.0];\n    x1, x2 = 1.0, -1.0\n    # while (poly($xs, $x1) * poly($xs, $x2) > 0) {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # $x1 *= 2;\n        x1 *= 2\n        # $x2 *= 2;\n        x2 *= 2\n    # while (abs($x1 - $x2) > 1e-10) {\n    while abs(x1 - x2) > 1e-10:\n        # $mid = ($x1 + $x2) / 2;\n        mid = (x1 + x2) / 2\n        # if (poly($xs, $mid) == 0) {\n        if poly(xs, mid) == 0:\n            # return $mid;\n            return mid\n        # elseif (poly($xs, $mid) * poly($xs, $x1) < 0) {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # $x2 = $mid;\n            x2 = mid\n        # else {\n        else:\n            # $x1 = $mid;\n            x1 = mid\n    # return ($x1 + $x2) / 2;\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # $sortedThird = array_values(array_filter($l, function($i) { return $i % 3 == 0; }, ARRAY_FILTER_USE_KEY));\n    sorted_third = list(filter(lambda i: i % 3 == 0, l))\n    # sort($sortedThird);\n    sorted_third.sort()\n    # return array_map(function($i, $x) use ($sortedThird) { return ($i % 3 == 0) ? $sortedThird[$i / 3] : $x; }, array_keys($l), $l);\n    return [sorted_third[i / 3] if i % 3 == 0 else x for i, x in enumerate(l)]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # $result = array_unique($l);\n    result = list(set(l))\n    # sort($result);\n    result.sort()\n    # return $result;\n    return result\n",
            "def max_element(l: List[int]) -> int:\n    # if (empty($l)) {\n    if not l:\n        # return 0;\n        return 0\n    # return max($l);\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # $cnt = 0;\n    cnt = 0\n    # for ($i = 0; $i < $n; $i++) {\n    for i in range(n):\n        # if ($i % 11 == 0 || $i % 13 == 0) {\n        if i % 11 == 0 or i % 13 == 0:\n            # $cnt += substr_count((string)$i, \"7\");\n            cnt += i.count(\"7\")\n    # return $cnt;\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # $sortedEven = array_values(array_filter($l, function($i) { return $i % 2 == 0; }, ARRAY_FILTER_USE_KEY));\n    sorted_even = list(filter(lambda i: i % 2 == 0, l))\n    # sort($sortedEven);\n    sorted_even.sort()\n    # return array_map(function($i, $x) use ($sortedEven) { return ($i % 2 == 0) ? $sortedEven[$i / 2] : $x; }, array_keys($l), $l);\n    return [sorted_even[i / 2] if i % 2 == 0 else x for i, x in enumerate(l)]\n",
            "def encode_cyclic(s: str) -> str:\n    # $result = \"\";\n    result = \"\"\n    # for ($i = 0; $i < strlen($s); $i += 3) {\n    for i in range(0, len(s), 3):\n        # if ($i + 3 > strlen($s)) {\n        if i + 3 > len(s):\n            # $result .= substr($s, $i);\n            result += s[i:]\n        else:\n            # $result .= substr($s, $i + 1, 2);\n            result += s[i + 1:i + 3]\n            # $result .= $s[$i];\n            result += s[i]\n    # return $result;\n    return result\ndef decode_cyclic(s: str) -> str:\n    # return encodeCyclic(encodeCyclic($s));\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if ($n < 2) {\n    if n < 2:\n        # return False;\n        return False\n    # for ($i = 2; $i <= floor(sqrt($n)); $i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if ($n % $i == 0) {\n        if n % i == 0:\n            # return False;\n            return False\n    # return True;\n    return True\ndef prime_fib(n: int) -> int:\n    # $f = [0, 1];\n    f = [0, 1]\n    # $cnt = 0;\n    cnt = 0\n    # while ($cnt < $n) {\n    while cnt < n:\n        # $f = [$f[1], $f[0] + $f[1]];\n        f = [f[1], f[0] + f[1]]\n        # if (isPrime($f[1])) {\n        if is_prime(f[1]):\n            # $cnt++;\n            cnt += 1\n    # return $f[1];\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for ($i = 0; $i < count($l); $i++) {\n    for i in range(len(l)):\n        # for ($j = $i + 1; $j < count($l); $j++) {\n        for j in range(i + 1, len(l)):\n            # for ($k = $j + 1; $k < count($l); $k++) {\n            for k in range(j + 1, len(l)):\n                # if ($l[$i] + $l[$j] + $l[$k] == 0) {\n                if l[i] + l[j] + l[k] == 0:\n                    # return True;\n                    return True\n    # return False;\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return pow($n, 2);\n    return n ** 2\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # return array_map(function($i) {\n    #     return $i + 1;\n    # }, $l);\n    return list(map(lambda i: i + 1, l))\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # $seen = [];\n    seen = {}\n    # foreach ($l as $num) {\n    for num in l:\n        # if (array_key_exists(-$num, $seen)) {\n        if -num in seen:\n            # return true;\n            return True\n        # $seen[$num] = true;\n        seen[num] = True\n    # return False;\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if ($x === 0) {\n    if x == 0:\n        # return \"0\";\n        return \"0\"\n    # $digits = [];\n    digits = []\n    # while ($x > 0) {\n    while x > 0:\n        # $digits[] = strval($x % $bas);\n        digits.append(str(x % bas))\n        # $x = intval($x / $bas);\n        x = int(x / bas)\n    # return implode(\"\", array_reverse($digits));\n    return \"\".join(reversed(digits))\n",
            "def triangle_area(a: float, h: float) -> float:\n    # return $a * $h / 2;\n    return a * h / 2\n",
            "def fib4(n: int) -> int:\n    # $fib = [0, 0, 2, 0];\n    fib = [0, 0, 2, 0]\n    # for ($i = 4; $i <= $n; $i++) {\n    for i in range(4, n + 1):\n        # $fib[$i % 4] = array_sum($fib);\n        fib[i % 4] = sum(fib)\n    # return $fib[$n % 4];\n    return fib[n % 4]\n",
            "def median(l: List[int]) -> float:\n    # $sl = $l;\n    sl = l\n    # sort($sl);\n    sl.sort()\n    # if (count($l) % 2 !== 0) {\n    if len(l) % 2 != 0:\n        # return $sl[count($l) / 2];\n        return sl[len(l) // 2]\n    else:\n        # return ($sl[count($l) / 2] + $sl[count($l) / 2 - 1]) / 2;\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # return $txt === strrev($txt);\n    return txt == txt[::-1]\n",
            "def modp(n: int, p: int) -> int:\n    # $ret = 1;\n    ret = 1\n    # for ($i = 0; $i < $n; $i++) {\n    for i in range(n):\n        # $ret = ($ret * 2) % $p;\n        ret = (ret * 2) % p\n    # return $ret;\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # $result = array_map(function ($ch) {\n    #     return chr(((ord($ch) - 97 + 5) % 26) + 97);\n    # }, str_split($s));\n    result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    # return implode(\"\", $result);\n    return \"\".join(result)\ndef decode_shift(s: str) -> str:\n    # $result = array_map(function ($ch) {\n    #     return chr(((ord($ch) - 97 + 21) % 26) + 97);\n    # }, str_split($s));\n    result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    # return implode(\"\", $result);\n    return \"\".join(result)\n",
            "def remove_vowels(txt: str) -> str:\n    # $vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # return implode(\"\", array_filter(str_split($txt), function($char) use ($vowels) {\n    #     return strpos($vowels, $char) === false;\n    # }));\n    return \"\".join(filter(lambda char: char not in vowels, list(txt)))\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # return count(array_filter($l, function($x) use ($t) { return $x < $t; })) == count($l);\n    return len(list(filter(lambda x: x < t, l))) == len(l)\n",
            "def add(x: int, y: int) -> int:\n    # return $x + $y;\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # $set0 = array_unique(str_split($s0));\n    set0 = list(set(s0))\n    # $set1 = array_unique(str_split($s1));\n    set1 = list(set(s1))\n    # sort($set0);\n    set0.sort()\n    # sort($set1);\n    set1.sort()\n    # return $set0 == $set1;\n    return set0 == set1\n",
            "def fib(n: int) -> int:\n    # if ($n <= 1) {\n    if n <= 1:\n        # return $n;\n        return n\n    # } else {\n    else:\n        # return fib($n - 1) + fib($n - 2);\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # $depth = 0;\n    depth = 0\n    # foreach (str_split($brackets) as $b) {\n    for b in brackets:\n        # if ($b == '<') {\n        if b == '<':\n            # $depth += 1;\n            depth += 1\n        # } else if ($b == '>') {\n        elif b == '>':\n            # $depth -= 1;\n            depth -= 1\n        # if ($depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return $depth == 0;\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # $diff = array_map(function ($a, $b) { return $b - $a; }, array_slice($l, 0, -1), array_slice($l, 1));\n    diff = [b - a for a, b in zip(l[:-1], l[1:])]\n    # return count(array_filter($diff, function($x) { return $x <= 0; })) == count($diff) || count(array_filter($diff, function($x) { return $x >= 0; })) == count($diff);\n    return sum(1 for x in diff if x <= 0) == len(diff) or sum(1 for x in diff if x >= 0) == len(diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # $result = array_intersect($l1, $l2);\n    result = list(set(l1) & set(l2))\n    # sort($result);\n    result.sort()\n    # return $result;\n    return result\n",
            "def largest_prime_factor(n: int) -> int:\n    # $i = 2;\n    i = 2\n    # while ($i * $i <= $n) {\n    while i * i <= n:\n        # if ($n % $i) {\n        if n % i:\n            # $i += 1;\n            i += 1\n        else:\n            # $n /= $i;\n            n //= i\n    # return $n;\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # return array_sum(range(0, $n));\n    return sum(range(0, n))\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # $depth = 0;\n    depth = 0\n    # foreach (str_split($brackets) as $b) {\n    for b in brackets:\n        # if ($b == '(') {\n        if b == '(':\n            # $depth += 1;\n            depth += 1\n        # } else if ($b == ')') {\n        elif b == ')':\n            # $depth -= 1;\n            depth -= 1\n        # if ($depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return $depth == 0;\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # return array_slice(array_map(function($x, $i) { return $x * $i; }, $xs, range(0, count($xs) - 1)), 1);\n    return xs[1:]\n",
            "def fibfib(n: int) -> int:\n    # if ($n <= 1) {\n    if n <= 1:\n        # return 0;\n        return 0\n    # [$a, $b, $c] = [0, 0, 1];\n    a, b, c = 0, 0, 1\n    # while ($n > 2) {\n    while n > 2:\n        # [$a, $b, $c] = [$b, $c, $a + $b + $c];\n        a, b, c = b, c, a + b + c\n        # $n -= 1;\n        n -= 1\n    # return $c;\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # $vowels = \"aeiou\";\n    vowels = \"aeiou\"\n    # $cnt = 0;\n    cnt = 0\n    # for ($i = 0; $i < strlen($s); $i++) {\n    for i in range(len(s)):\n        # if (strpos($vowels, strtolower($s[$i])) !== false || ($i == strlen($s) - 1 && strtolower($s[$i]) == \"y\")) {\n        if (str.lower(s[i]) in vowels or (i == len(s) - 1 and str.lower(s[i]) == \"y\")):\n            # $cnt += 1;\n            cnt += 1\n    # return $cnt;\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> int:\n    # $xStr = strval($x);\n    x_str = str(x)\n    # if ($shift > strlen($xStr)) {\n    if shift > len(x_str):\n        # return strrev($xStr);\n        return int(x_str[::-1])\n    else:\n        # return substr($xStr, -$shift) . substr($xStr, 0, -$shift);\n        return int(x_str[-shift:] + x_str[:-shift])\n",
            "def digit_sum(s: str) -> int:\n    # return array_sum(array_map('ord', array_filter(str_split($s), 'ctype_upper')));\n    return sum(map(ord, filter(lambda x: x.isupper(), s)))\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # $words = explode(' ', $s);\n    words = s.split(' ')\n    # $apples = $words[array_search('apples', $words) - 1];\n    apples = words[words.index('apples') - 1]\n    # $oranges = $words[array_search('oranges', $words) - 1];\n    oranges = words[words.index('oranges') - 1]\n    # return $n - $apples - $oranges;\n    return n - int(apples) - int(oranges)\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # $evens = array_filter($arr, function($x) { return $x % 2 == 0; });\n    evens = list(filter(lambda x: x % 2 == 0, arr))\n    # if (empty($evens)) {\n    if not evens:\n        # return [];\n        return []\n    # $minEven = min($evens);\n    min_even = min(evens)\n    # return [$minEven, array_search($minEven, $arr)];\n    return [min_even, evens.index(min_even)]\n",
            "def search(lst: List[int]) -> int:\n    # $freqs = array();\n    freqs = {}\n    # foreach ($lst as $n) {\n    for n in lst:\n        # $freqs[$n] = ($freqs[$n] ?? 0) + 1;\n        freqs[n] = freqs.get(n, 0) + 1\n    # $goodVals = array_filter($freqs, function($v, $k) { return $v >= $k; }, ARRAY_FILTER_USE_BOTH);\n    good_vals = {k: v for k, v in freqs.items() if v >= k}\n    # return max([...array_keys($goodVals), -1]);\n    return max(good_vals.keys(), default=-1)\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # $sl = $lst;\n    sl = lst\n    # sort($sl);\n    sl.sort()\n    # $result = array();\n    result = []\n    # [$left, $right] = [0, count($sl) - 1];\n    left, right = 0, len(sl) - 1\n    # while ($left <= $right) {\n    while left <= right:\n        # $result[] = $sl[$left];\n        result.append(sl[left])\n        # $left += 1;\n        left += 1\n        # if ($left <= $right) {\n        if left <= right:\n            # $result[] = $sl[$right];\n            result.append(sl[right])\n            # $right -= 1;\n            right -= 1\n    # return $result;\n    return result\n",
            "def triangle_area(a: float, b: float, c: float) -> float:\n    # if ($a + $b > $c && $a + $c > $b && $b + $c > $a) {\n    if a + b > c and a + c > b and b + c > a:\n        # $s = ($a + $b + $c) / 2;\n        s = (a + b + c) / 2\n        # return sqrt($s * ($s - $a) * ($s - $b) * ($s - $c));\n        return sqrt(s * (s - a) * (s - b) * (s - c))\n    else:\n        # return -1.0;\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if (count($q) == 0) {\n    if len(q) == 0:\n        # return false;\n        return False\n    # $isPalin = count(array_filter($q, function($i) use ($q) { return $q[$i] == $q[count($q) - $i - 1]; })) == count($q);\n    is_palin = len(list(filter(lambda i: q[i] == q[len(q) - i - 1], range(len(q))))) == len(q)\n    # $total = array_sum($q);\n    total = sum(q)\n    # return $isPalin && $total <= $w;\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # $ans = 0;\n    ans = 0\n    # for ($i = 0; $i < intval(count($arr) / 2); $i++) {\n    for i in range(int(len(arr) / 2)):\n        # if ($arr[$i] != $arr[count($arr) - $i - 1]) {\n        if arr[i] != arr[len(arr) - i - 1]:\n            # $ans += 1;\n            ans += 1\n    # return $ans;\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # $cnt1 = array_sum(array_map('strlen', $lst1));\n    cnt1 = sum(map(len, lst1))\n    # $cnt2 = array_sum(array_map('strlen', $lst2));\n    cnt2 = sum(map(len, lst2))\n    # return $cnt1 <= $cnt2 ? $lst1 : $lst2;\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if ($n < 2) {\n    if n < 2:\n        # return False;\n        return False\n    # for ($i = 2; $i <= floor(sqrt($n)); $i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if ($n % $i == 0) {\n        if n % i == 0:\n            # return False;\n            return False\n    # return True;\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # $cnt = 0;\n    cnt = 0\n    # for ($i = 2; $i <= $a; $i++) {\n    for i in range(2, a + 1):\n        # if (isPrime($i)) {\n        if is_prime(i):\n            # while ($a % $i == 0) {\n            while a % i == 0:\n                # $cnt += 1;\n                cnt += 1\n                # $a /= $i;\n                a //= i\n    # return $cnt == 3;\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if ($n < 2) {\n    if n < 2:\n        # return $x == $n;\n        return x == n\n    # $tmp = 1;\n    tmp = 1\n    # while ($tmp < $x) {\n    while tmp < x:\n        # $tmp *= $n;\n        tmp *= n\n    # return $tmp == $x;\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # $a = abs($a);\n    a = abs(a)\n    # $root = intval(round(pow($a, 1.0 / 3.0)));\n    root = int(round(pow(a, 1.0 / 3.0)))\n    # return $root * $root * $root == $a;\n    return root * root * root == a\n",
            "def hex_key(num: int) -> int:\n    # return count(array_intersect(str_split($num), str_split(\"2357BD\")));\n    return len(set(str(num)).intersection(\"2357BD\"))\n",
            "def decimal_to_binary(dec: int) -> str:\n    # $binary = decbin($dec);\n    binary = bin(dec)\n    # return \"db{$binary}db\";\n    return \"db\" + binary + \"db\"\n",
            "def is_happy(s: str) -> bool:\n    # if (strlen($s) < 3) {\n    if len(s) < 3:\n        # return false;\n        return False\n    # for ($i = 0; $i < strlen($s) - 2; $i++) {\n    for i in range(len(s) - 2):\n        # if ($s[$i] == $s[$i + 1] || $s[$i] == $s[$i + 2] || $s[$i + 1] == $s[$i + 2]) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # $result = [];\n    result = []\n    # foreach ($grades as $g) {\n    for g in grades:\n        # switch (true) {\n        #     case $g == 4.0:\n        #         $result[] = \"A+\"; break;\n        if g == 4.0:\n            result.append(\"A+\")\n        #     case $g > 3.7:\n        #         $result[] = \"A\"; break;\n        elif g > 3.7:\n            result.append(\"A\")\n        #     case $g > 3.3:\n        #         $result[] = \"A-\"; break;\n        elif g > 3.3:\n            result.append(\"A-\")\n        #     case $g > 3.0:\n        #         $result[] = \"B+\"; break;\n        elif g > 3.0:\n            result.append(\"B+\")\n        #     case $g > 2.7:\n        #         $result[] = \"B\"; break;\n        elif g > 2.7:\n            result.append(\"B\")\n        #     case $g > 2.3:\n        #         $result[] = \"B-\"; break;\n        elif g > 2.3:\n            result.append(\"B-\")\n        #     case $g > 2.0:\n        #         $result[] = \"C+\"; break;\n        elif g > 2.0:\n            result.append(\"C+\")\n        #     case $g > 1.7:\n        #         $result[] = \"C\"; break;\n        elif g > 1.7:\n            result.append(\"C\")\n        #     case $g > 1.3:\n        #         $result[] = \"C-\"; break;\n        elif g > 1.3:\n            result.append(\"C-\")\n        #     case $g > 1.0:\n        #         $result[] = \"D+\"; break;\n        elif g > 1.0:\n            result.append(\"D+\")\n        #     case $g > 0.7:\n        #         $result[] = \"D\"; break;\n        elif g > 0.7:\n            result.append(\"D\")\n        #     case $g > 0.0:\n        #         $result[] = \"D-\"; break;\n        elif g > 0.0:\n            result.append(\"D-\")\n        #     default:\n        #         $result[] = \"E\"; break;\n        else:\n            result.append(\"E\")\n    # return $result;\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # $length = strlen($s);\n    length = len(s)\n    # if ($length < 2) {\n    if length < 2:\n        # return False;\n        return False\n    # for ($i = 2; $i <= floor(sqrt($length)); $i++) {\n    for i in range(2, int(sqrt(length)) + 1):\n        # if ($length % $i == 0) {\n        if length % i == 0:\n            # return False;\n            return False\n    # return True;\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if ($n == 1) {\n    if n == 1:\n        # return 1;\n        return 1\n    # return 2 * 9 * pow(10, $n - 2);\n    return 2 * 9 * pow(10, n - 2)\n",
            "def solve(n: int) -> str:\n    # $digitsSum = array_sum(str_split($n));\n    digits_sum = sum(map(int, str(n)))\n    # return decbin($digitsSum);\n    return bin(digits_sum)[2:]\n",
            "def add(lst: List[int]) -> int:\n    # return array_sum(array_filter($lst, function($v, $k) {\n    #     return $k % 2 == 1 && $v % 2 == 0;\n    # }, ARRAY_FILTER_USE_BOTH));\n    return sum(filter(lambda v, k: k % 2 == 1 and v % 2 == 0, enumerate(lst)))\n",
            "def anti_shuffle(s: str) -> str:\n    # $words = array_map(function($word) {\n    #     $chars = str_split($word);\n    #     sort($chars);\n    #     return implode('', $chars);\n    # }, explode(' ', $s));\n    words = [\n        ''.join(sorted(list(word)))\n        for word in s.split(' ')\n    ]\n    # return implode(' ', $words);\n    return ' '.join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # $coords = [];\n    coords = []\n    # foreach ($lst as $i => $row) {\n    for i, row in enumerate(lst):\n        # foreach ($row as $j => $value) {\n        for j, value in enumerate(row):\n            # if ($value == $x) {\n            if value == x:\n                # $coords[] = [$i, $j];\n                coords.append([i, j])\n    # usort($coords, function($a, $b) {\n    coords.sort(key=lambda a, b: a[0] == b[0] and b[1] - a[1] or a[0] - b[0])\n    # return $coords;\n    return coords\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if (count($arr) == 0) {\n    if len(arr) == 0:\n        # return [];\n        return []\n    # $result = $arr;\n    result = arr\n    # if (($arr[0] + $arr[count($arr) - 1]) % 2 == 0) {\n    if (arr[0] + arr[-1]) % 2 == 0:\n        # rsort($result);\n        result.reverse()\n        # return $result;\n        return result\n    # else {\n    else:\n        # sort($result);\n        result.sort()\n        # return $result;\n        return result\n",
            "def encrypt(s: str) -> str:\n    # $result = \"\";\n    result = \"\"\n    # foreach (str_split($s) as $ch) {\n    for ch in s:\n        # $shifted = ord($ch) + 4;\n        shifted = ord(ch) + 4\n        # if ($shifted > ord('z')) {\n        if shifted > ord('z'):\n            # $shifted -= 26;\n            shifted -= 26\n        # $result .= chr($shifted);\n        result += chr(shifted)\n    # return $result;\n    return result\n",
            "def next_smallest(lst: List[int]) -> int:\n    # $sl = array_values(array_unique($lst));\n    sl = list(set(lst))\n    # sort($sl);\n    sl.sort()\n    # if (count($sl) < 2) {\n    if len(sl) < 2:\n        # return null;\n        return None\n    # }\n    # return $sl[1];\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # $sentences = preg_split(\"/[.!?]\\s*/\", $s);\n    sentences = re.split(r\"[.!?]\\s*\", s)\n    # return count(array_filter($sentences, function($sentence) {\n    #     return strlen($sentence) >= 2 && substr($sentence, 0, 2) == \"I \";\n    # }));\n    return len(list(filter(lambda sentence: len(sentence) >= 2 and sentence[:2] == \"I \", sentences)))\n",
            "def any_int(x: int, y: int, z: int) -> bool:\n    # if (is_int($x) && is_int($y) && is_int($z)) {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # if (($x + $y == $z) || ($x + $z == $y) || ($y + $z == $x)) {\n        if (x + y == z) or (x + z == y) or (y + z == x):\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def encode(message: str) -> str:\n    # $vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # $result = \"\";\n    result = \"\"\n    # foreach (str_split($message) as $ch) {\n    for ch in message:\n        # if (ctype_alpha($ch)) {\n        if ch.isalpha():\n            # $ch1 = ctype_lower($ch) ? strtoupper($ch) : strtolower($ch);\n            ch1 = ch.upper() if ch.islower() else ch.lower()\n            # if (strpos($vowels, $ch1) !== false) {\n            if ch1 in vowels:\n                # $ch1 = chr(ord($ch1) + 2);\n                ch1 = chr(ord(ch1) + 2)\n            # $result .= $ch1;\n            result += ch1\n        else:\n            # $result .= $ch;\n            result += ch\n    # return $result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if ($n < 2) {\n    #     return False;\n    # }\n    if n < 2:\n        return False\n    # for ($i = 2; $i <= floor(sqrt($n)); $i++) {\n    #     if ($n % $i == 0) {\n    #         return False;\n    #     }\n    # }\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    # return True;\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # $primes = array_filter($lst, \"isPrime\");\n    primes = list(filter(is_prime, lst))\n    # if (count($primes) == 0) {\n    #     return 0;\n    # }\n    if len(primes) == 0:\n        return 0\n    # $largest = max($primes);\n    largest = max(primes)\n    # return array_sum(str_split($largest));\n    return sum(map(int, str(largest)))\n",
            "def check_dict_case(d: Dict) -> bool:\n    # if (count($d) == 0) {\n    if len(d) == 0:\n        # return False;\n        return False\n    # return count(array_filter(array_keys($d), function($k) {\n    return len(list(filter(lambda k: k.islower(), d.keys()))) == len(d) or len(list(filter(lambda k: k.isupper(), d.keys()))) == len(d)\n",
            "def count_up_to(n: int) -> List[int]:\n    # $primes = [];\n    primes = []\n    # for ($num = 2; $num < $n; $num++) {\n    for num in range(2, n):\n        # if (count(array_filter($primes, function($p) use ($num) {\n        if len(list(filter(lambda p: num % p != 0, primes))) == len(primes):\n            # return $primes[] = $num;\n            primes.append(num)\n    # return $primes;\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # return (abs($a) % 10) * (abs($b) % 10);\n    return abs(a) % 10 * abs(b) % 10\n",
            "def count_upper(s: str) -> int:\n    # $vowels = \"AEIOU\";\n    vowels = \"AEIOU\"\n    # return count(array_filter(str_split($s), function($c, $i) use ($vowels) {\n    return len(list(filter(lambda c, i: i % 2 == 0 and vowels.find(c) != -1, str_split(s))))\n    # }, ARRAY_FILTER_USE_BOTH));\n",
            "def closest_integer(value: float) -> int:\n    # $num = floatval($value);\n    num = float(value)\n    # if ($num >= 0) {\n    if num >= 0:\n        # return intval($num + 0.5);\n        return int(num + 0.5)\n    # } else {\n    else:\n        # return intval($num - 0.5);\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # return array_map(function($i) use ($n) {\n    #     return $n + 2 * $i;\n    # }, range(0, $n - 1));\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # return preg_split(\"/[ ,]/\", $s, -1, PREG_SPLIT_NO_EMPTY);\n    return re.split(r\"[ ,]\", s)\n",
            "def choose_num(x: int, y: int) -> int:\n    # if ($x > $y) {\n    if x > y:\n        # return -1;\n        return -1\n    # if ($y % 2 == 0) {\n    if y % 2 == 0:\n        # return $y;\n        return y\n    # return $y != $x ? $y - 1 : -1;\n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> str:\n    # if ($n > $m) {\n    if n > m:\n        # return null;\n        return None\n    # $rAvg = intVal(($n + $m) / 2 + 0.5);\n    r_avg = int(round((n + m) / 2))\n    # return decbin($rAvg);\n    return bin(r_avg)\n",
            "def all_digits_odd(s: str) -> bool:\n    # return count(array_filter(str_split($s), function($digit) { return ord($digit) % 2 != 0; })) == strlen($s);\n    return len(list(filter(lambda digit: ord(digit) % 2 != 0, str_split(s)))) == len(s)\ndef unique_digits(x: List[int]) -> List[int]:\n    # $result = array_filter($x, function($x) { return allDigitsOdd(strval($x)); });\n    result = list(filter(lambda x: all_digits_odd(str(x)), x))\n    # sort($result);\n    result.sort()\n    # return $result;\n    return result\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # $digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # $sorted_arr = array_filter($arr, function($x) { return 1 <= $x && $x <= 9; });\n    sorted_arr = list(filter(lambda x: 1 <= x and x <= 9, arr))\n    # rsort($sorted_arr);\n    sorted_arr.sort(reverse=True)\n    # return array_map(function($x) use ($digit_names) { return $digit_names[$x - 1]; }, $sorted_arr);\n    return list(map(lambda x: digit_names[x - 1], sorted_arr))\n",
            "def f(n: int) -> List[int]:\n    # $nums = range(1, $n);\n    nums = list(range(1, n))\n    # return array_map(function($i) use ($nums) {\n    return list(map(lambda i:\n        # if ($i % 2 != 0) {\n        if i % 2 != 0:\n            # return array_sum(array_slice($nums, 0, $i));\n            return sum(nums[:i])\n        else:\n            # return array_reduce(array_slice($nums, 0, $i), function($x, $y) { return $x * $y; }, 1);\n            return reduce(lambda x, y: x * y, nums[:i], 1)\n    # }, $nums);\n    ), nums)\n",
            "def is_palindrome(s: str) -> bool:\n    # return $s === strrev($s);\n    return s == s[::-1]\ndef even_odd_palindrome(n: int) -> List[int]:\n    # $cnt = [0, 0];\n    cnt = [0, 0]\n    # for ($i = 1; $i <= $n; $i++) {\n    for i in range(1, n + 1):\n        # if (isPalindrome((string)$i)) {\n        if is_palindrome(str(i)):\n            # $cnt[$i % 2]++;\n            cnt[i % 2] += 1\n    # return $cnt;\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # $nStr = (string)$n;\n    n_str = str(n)\n    # if ($n >= 0) {\n    if n >= 0:\n        # return array_sum(str_split($nStr));\n        return sum(map(int, n_str))\n    else:\n        # return 2 * intVal(substr($nStr, 0, 2)) + digitsSum(abs($n));\n        return 2 * int(n_str[:2]) + digits_sum(abs(n))\ndef count_nums(arr: List[int]) -> int:\n    # return count(array_filter($arr, function($n) {\n    #     return digitsSum($n) > 0;\n    # }));\n    return sum(1 for n in arr if digits_sum(n) > 0)\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if (count($arr) === 0) {\n    if len(arr) == 0:\n        # return true;\n        return True\n    # $sortedArr = $arr;\n    sorted_arr = arr\n    # sort($sortedArr);\n    sorted_arr.sort()\n    # for ($i = 0; $i < count($arr); $i++) {\n    for i in range(len(arr)):\n        # if (array_slice($arr, $i) === array_slice($sortedArr, 0, count($arr) - $i) && array_slice($arr, 0, $i) === array_slice($sortedArr, count($arr) - $i)) {\n        if arr[i:] == sorted_arr[0:len(arr) - i] and arr[0:i] == sorted_arr[len(arr) - i:]:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # $oddCnt = count(array_filter($lst1, function($n) {\n    #     return $n % 2 != 0;\n    # }));\n    odd_cnt = sum(1 for n in lst1 if n % 2 != 0)\n    # $evenCnt = count(array_filter($lst2, function($n) {\n    #     return $n % 2 == 0;\n    # }));\n    even_cnt = sum(1 for n in lst2 if n % 2 == 0)\n    # return $evenCnt >= $oddCnt ? \"YES\" : \"NO\";\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # $freq = [];\n    freq = {}\n    # $words = array_filter(explode(\" \", $test), function($w) {\n    #     return strlen($w) > 0;\n    # });\n    words = list(filter(lambda w: len(w) > 0, test.split(\" \")))\n    # foreach ($words as $w) {\n    for w in words:\n        # $freq[$w] = ($freq[$w] ?? 0) + 1;\n        freq[w] = freq.get(w, 0) + 1\n    # $result = [];\n    result = {}\n    # if (count($freq) > 0) {\n    if len(freq) > 0:\n        # $maxFreq = max($freq);\n        max_freq = max(freq.values())\n        # foreach ($freq as $k => $v) {\n        #     if ($v == $maxFreq) {\n        #         $result[$k] = $v;\n        #     }\n        # }\n        for k, v in freq.items():\n            if v == max_freq:\n                result[k] = v\n    # return $result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return $s === strrev($s);\n    return s == s[::-1]\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # $s1 = implode('', array_filter(str_split($s), function($ch) use ($c) { return !in_array($ch, str_split($c)); }));\n    s1 = ''.join(filter(lambda ch: ch not in c, s))\n    # return [$s1, isPalindrome($s1) ? \"yes\" : \"no\"];\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # $result = [];\n    result = []\n    # foreach ($lst as $num) {\n    for num in lst:\n        # $n = count(array_filter(str_split($num), function($d) { return ord($d) % 2 == 1; }));\n        n = len(list(filter(lambda d: ord(d) % 2 == 1, str_split(num))))\n        # $rs = \"the number of odd elements in the string i of the input.\";\n        rs = \"the number of odd elements in the string i of the input.\"\n        # $result[] = str_replace(\"i\", $n, $rs);\n        result.append(rs.replace(\"i\", str(n)))\n    # return $result;\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # $minSum = 0;\n    min_sum = 0\n    # $curSum = 0;\n    cur_sum = 0\n    # foreach ($nums as $n) {\n    for n in nums:\n        # $curSum = min($curSum + $n, 0);\n        cur_sum = min(cur_sum + n, 0)\n        # $minSum = min($curSum, $minSum);\n        min_sum = min(cur_sum, min_sum)\n    # if ($minSum == 0) {\n    if min_sum == 0:\n        # $minSum = min($nums);\n        min_sum = min(nums)\n    # return $minSum;\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # return array_sum(array_map(function($arr) use ($capacity) {\n    return sum(map(lambda arr: ceil(sum(arr) / capacity), grid))\n    #     return ceil(array_sum($arr) / $capacity);\n    # }, $grid));\n",
            "def count_ones(num: int) -> int:\n    # return substr_count(decbin($num), '1');\n    return bin(num).count('1')\ndef sort_array(arr: List[int]) -> List[int]:\n    # $result = $arr;\n    result = arr\n    # usort($result, function($a, $b) {\n    #     return countOnes($a) == countOnes($b) ? $a - $b : countOnes($a) - countOnes($b);\n    # });\n    result.sort(key=lambda x: (count_ones(x), x))\n    # return $result;\n    return result\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # $consonants = \"bcdfghjklmnpqrstvwxyz\";\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # $words = array_filter(explode(\" \", $s), function($w) { return strlen($w) > 0; });\n    words = list(filter(lambda w: len(w) > 0, s.split(\" \")))\n    # return array_filter($words, function($w) use ($n, $consonants) {\n    return list(filter(lambda w: count(list(filter(lambda c: c in consonants, list(map(lambda c: c.lower(), list(w)))))) == n, words))\n",
            "def get_closest_vowel(word: str) -> str:\n    # $vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # for ($i = strlen($word) - 2; $i > 0; $i--) {\n    for i in range(len(word) - 2, 0, -1):\n        # if (strpos($vowels, $word[$i]) !== false && strpos($vowels, $word[$i - 1]) === false && strpos($vowels, $word[$i + 1]) === false) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return $word[$i];\n            return word[i]\n    # return \"\";\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # $depth = 0;\n    depth = 0\n    # foreach(str_split($s) as $ch) {\n    for ch in s:\n        # if ($ch == \"(\") {\n        if ch == \"(\":\n            # $depth++;\n            depth += 1\n        else:\n            # $depth--;\n            depth -= 1\n        # if ($depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return $depth == 0;\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # $s1 = $lst[0] . $lst[1];\n    s1 = lst[0] + lst[1]\n    # $s2 = $lst[1] . $lst[0];\n    s2 = lst[1] + lst[0]\n    # return check($s1) || check($s2) ? \"Yes\" : \"No\";\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if ($k == 0) {\n    if k == 0:\n        # return [];\n        return []\n    # $result = $arr;\n    result = arr\n    # sort($result);\n    result.sort()\n    # return array_slice($result, -$k);\n    return result[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # return array_sum(array_filter($lst, function($v, $k) {\n    #     return $k % 2 == 0 && $v % 2 != 0;\n    # }, ARRAY_FILTER_USE_BOTH));\n    return sum(filter(lambda v, k: k % 2 == 0 and v % 2 != 0, enumerate(lst)))\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # return array_sum(array_filter(array_slice($arr, 0, $k), function($n) {\n    #     return strlen(strval($n)) <= 2;\n    # }));\n    return sum(filter(lambda n: len(str(n)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # $collatz = [1];\n    collatz = [1]\n    # while ($n != 1) {\n    while n != 1:\n        # if ($n % 2 != 0) {\n        if n % 2 != 0:\n            # $collatz[] = $n;\n            collatz.append(n)\n            # $n = 3 * $n + 1;\n            n = 3 * n + 1\n        else:\n            # $n = $n / 2;\n            n = n / 2\n    # sort($collatz);\n    collatz.sort()\n    # return $collatz;\n    return collatz\n",
            "def valid_date(date: str) -> bool:\n    # if (strlen($date) != 10 || $date[2] != \"-\" || $date[5] != \"-\") {\n    if len(date) != 10 or date[2] != \"-\" or date[5] != \"-\":\n        # return false;\n        return False\n    # $m = intval(substr($date, 0, 2));\n    m = int(date[:2])\n    # $d = intval(substr($date, 3, 2));\n    d = int(date[3:5])\n    # if (in_array($m, [1, 3, 5, 7, 8, 10, 12]) && $d >= 1 && $d <= 31) {\n    if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n        # return true;\n        return True\n    # if (in_array($m, [4, 6, 9, 11]) && $d >= 1 && $d <= 30) {\n    if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n        # return true;\n        return True\n    # if ($m == 2 && $d >= 1 && $d <= 29) {\n    if m == 2 and d >= 1 and d <= 29:\n        # return true;\n        return True\n    # return false;\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if (strpos($txt, \" \") !== false) {\n    if \" \" in txt:\n        # return explode(\" \", $txt);\n        return txt.split()\n    # } elseif (strpos($txt, \",\") !== false) {\n    elif \",\" in txt:\n        # return explode(\",\", $txt);\n        return txt.split(\",\")\n    # } else {\n    else:\n        # return [strval(count(array_filter(str_split($txt), function($c) {\n        #     return ctype_lower($c) && ord($c) % 2 == 0;\n        # })))];\n        return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if (!array_reduce(array_map(function ($i, $j) { return $i <= $j; }, array_slice($lst, 0, -1), array_slice($lst, 1)), function ($a, $b) { return $a && $b; }, true)) {\n    if not all(i <= j for i, j in zip(lst[:-1], lst[1:])):\n        # return false;\n        return False\n    # $freq = array();\n    freq = {}\n    # foreach ($lst as $i) {\n    for i in lst:\n        # $freq[$i] = ($freq[$i] ?? 0) + 1;\n        freq[i] = freq.get(i, 0) + 1\n    # return count($lst) == 0 || max(array_values($freq)) <= 2;\n    return len(lst) == 0 or max(freq.values()) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if ($n < 2) {\n    if n < 2:\n        # return False;\n        return False\n    # for ($i = 2; $i <= floor(sqrt($n)); $i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if ($n % $i == 0) {\n        if n % i == 0:\n            # return False;\n            return False\n    # return True;\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # $l = max($interval1[0], $interval2[0]);\n    l = max(interval1[0], interval2[0])\n    # $r = min($interval1[1], $interval2[1]);\n    r = min(interval1[1], interval2[1])\n    # $length = $r - $l;\n    length = r - l\n    # return $length > 0 && isPrime($length) ? \"YES\" : \"NO\";\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> int:\n    # if (count($arr) == 0) {\n    if len(arr) == 0:\n        # return null;\n        return None\n    # if (in_array(0, $arr)) {\n    if 0 in arr:\n        # return 0;\n        return 0\n    # $sign = count(array_filter($arr, function ($n) { return $n < 0; })) % 2 == 1 ? -1 : 1;\n    sign = -1 if len(list(filter(lambda n: n < 0, arr))) % 2 == 1 else 1\n    # return $sign * array_sum(array_map(function ($n) { return abs($n); }, $arr));\n    return sign * sum(map(lambda n: abs(n), arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # $n = count($grid);\n    n = len(grid)\n    # $minVal = $n * $n + 1;\n    min_val = n * n + 1\n    # for ($i = 0; $i < $n; $i++) {\n    for i in range(n):\n        # for ($j = 0; $j < $n; $j++) {\n        for j in range(n):\n            # if ($grid[$i][$j] == 1) {\n            if grid[i][j] == 1:\n                # $temp = [];\n                temp = []\n                # if ($i != 0) {\n                if i != 0:\n                    # $temp[] = $grid[$i - 1][$j];\n                    temp.append(grid[i - 1][j])\n                # if ($j != 0) {\n                if j != 0:\n                    # $temp[] = $grid[$i][$j - 1];\n                    temp.append(grid[i][j - 1])\n                # if ($i != $n - 1) {\n                if i != n - 1:\n                    # $temp[] = $grid[$i + 1][$j];\n                    temp.append(grid[i + 1][j])\n                # if ($j != $n - 1) {\n                if j != n - 1:\n                    # $temp[] = $grid[$i][$j + 1];\n                    temp.append(grid[i][j + 1])\n                # $minVal = min($temp);\n                min_val = min(temp)\n    # $result = [];\n    result = []\n    # for ($i = 0; $i < $k; $i++) {\n    for i in range(k):\n        # $result[] = $i % 2 == 0 ? 1 : $minVal;\n        result.append(1 if i % 2 == 0 else min_val)\n    # return $result;\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if ($n == 0) {\n    if n == 0:\n        # return [1];\n        return [1]\n    # $seq = [1, 3];\n    seq = [1, 3]\n    # for ($i = 2; $i <= $n; $i++) {\n    for i in range(2, n + 1):\n        # if ($i % 2 == 0) {\n        if i % 2 == 0:\n            # $seq[] = $i / 2 + 1;\n            seq.append(i // 2 + 1)\n        else:\n            # $seq[] = $seq[$i - 1] + $seq[$i - 2] + ($i + 3) / 2;\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n    # return $seq;\n    return seq\n",
            "def digits(n: int) -> int:\n    # $odds = array_map(function ($x) { return intval($x); }, array_filter(str_split($n), function ($x) { return intval($x) % 2 == 1; }));\n    odds = list(map(int, filter(lambda x: int(x) % 2 == 1, str(n))))\n    # return count($odds) > 0 ? array_product($odds) : 0;\n    return len(odds) > 0 and reduce(lambda x, y: x * y, odds) or 0\n",
            "def is_nested(s: str) -> bool:\n    # $openIdx = [];\n    open_idx = []\n    # $closeIdx = [];\n    close_idx = []\n    # foreach (str_split($s) as $i => $ch) {\n    for i, ch in enumerate(s):\n        # switch ($ch) {\n        #     case '[':\n        #         $openIdx[] = $i; break;\n        #     case ']':\n        #         $closeIdx[] = $i; break;\n        # }\n        if ch == '[':\n            open_idx.append(i)\n        elif ch == ']':\n            close_idx.append(i)\n    # $closeIdx = array_reverse($closeIdx);\n    close_idx = list(reversed(close_idx))\n    # $cnt = 0;\n    cnt = 0\n    # $i = 0;\n    i = 0\n    # $l = count($closeIdx);\n    l = len(close_idx)\n    # foreach ($openIdx as $idx) {\n    #     if ($i < $l && $idx < $closeIdx[$i]) {\n    #         $cnt += 1;\n    #         $i += 1;\n    #     }\n    # }\n    for idx in open_idx:\n        if i < l and idx < close_idx[i]:\n            cnt += 1\n            i += 1\n    # return $cnt >= 2;\n    return cnt >= 2\n",
            "def sum_squares(lst: List[int]) -> int:\n    # return array_sum(array_map(function ($n) { return pow(ceil($n), 2); }, $lst));\n    return sum(map(lambda n: pow(ceil(n), 2), lst))\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if (empty($txt)) {\n    if not txt:\n        # return false;\n        return False\n    # $last = substr($txt, (strrpos($txt, \" \")?:-1) + 1);\n    last = txt[txt.rfind(\" \"):]\n    # return strlen($last) == 1 && ctype_alpha($last);\n    return len(last) == 1 and last.isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if (count($arr) <= 1) {\n    if len(arr) <= 1:\n        # return -1;\n        return -1\n    # $idx = array_filter(range(1, count($arr) - 1), function ($i) use ($arr) { return $arr[$i] < $arr[$i - 1]; });\n    idx = list(filter(lambda i: arr[i] < arr[i - 1], range(1, len(arr) - 1)))\n    # return max([...$idx, -1]);\n    return max(idx, -1)\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # $neg = array_filter($lst, function($i) { return $i < 0; });\n    neg = list(filter(lambda i: i < 0, lst))\n    # $pos = array_filter($lst, function($i) { return $i > 0; });\n    pos = list(filter(lambda i: i > 0, lst))\n    # $maxNeg = count($neg) > 0 ? max($neg) : null;\n    max_neg = max(neg) if len(neg) > 0 else None\n    # $minPos = count($pos) > 0 ? min($pos) : null;\n    min_pos = min(pos) if len(pos) > 0 else None\n    # return [$maxNeg, $minPos];\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if (is_string($o)) {\n    if isinstance(o, str):\n        # return floatval(str_replace(',', '.', $o));\n        return float(o.replace(',', '.'))\n    # } elseif (is_int($o)) {\n    elif isinstance(o, int):\n        # return floatval($o);\n        return float(o)\n    # } elseif (is_float($o)) {\n    elif isinstance(o, float):\n        # return $o;\n        return o\n    # }\n    # throw new RuntimeException(\"Unknown type\");\n    raise RuntimeError(\"Unknown type\")\ndef compare_one(a: Any, b: Any) -> float:\n    # $a1 = anyToReal($a);\n    a1 = any_to_real(a)\n    # $b1 = anyToReal($b);\n    b1 = any_to_real(b)\n    # if ($a1 == $b1) {\n    if a1 == b1:\n        # return null;\n        return None\n    # } elseif ($a1 > $b1) {\n    elif a1 > b1:\n        # return $a1;\n        return a1\n    # } else {\n    else:\n        # return $b1;\n        return b1\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return $n % 2 == 0 && $n >= 8;\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # $fact = 1;\n    fact = 1\n    # $result = 1;\n    result = 1\n    # for ($i = 1; $i <= $n; $i++) {\n    for i in range(1, n + 1):\n        # $fact *= $i;\n        fact *= i\n        # $result *= $fact;\n        result *= fact\n    # return $result;\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return str_replace(\" \", \"_\", preg_replace(\"/\\s{3,}/\", \"-\", $txt));\n    return txt.replace(\" \", \"_\").replace(\" \", \"-\")\n",
            "def file_name_check(file_name: str) -> str:\n    # $suf = [\"txt\", \"exe\", \"dll\"];\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # $lst = explode(\".\", $fileName);\n    lst = file_name.split(\".\")\n    # if (count($lst) != 2 || !in_array($lst[1], $suf) || strlen($lst[0]) == 0 || !ctype_alpha($lst[0][0]) || count(array_filter(str_split($lst[0]), function ($ch) { return ctype_digit($ch); })) > 3) {\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len(list(filter(lambda ch: ch.isdigit(), lst[0]))) > 3:\n        # return \"No\";\n        return \"No\"\n    # return \"Yes\";\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # $result = 0;\n    result = 0\n    # for ($i = 0; $i < count($lst); $i++) {\n    for i in range(len(lst)):\n        # if ($i % 3 == 0) {\n        if i % 3 == 0:\n            # $result += pow($lst[$i], 2);\n            result += pow(lst[i], 2)\n        # } elseif ($i % 4 == 0) {\n        elif i % 4 == 0:\n            # $result += pow($lst[$i], 3);\n            result += pow(lst[i], 3)\n        # } else {\n        else:\n            # $result += $lst[$i];\n            result += lst[i]\n    # return $result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if ($n < 2) {\n    if n < 2:\n        # return False;\n        return False\n    # for ($i = 2; $i <= floor(sqrt($n)); $i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if ($n % $i == 0) {\n        if n % i == 0:\n            # return False;\n            return False\n    # return True;\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # $words = explode(\" \", $sentence);\n    words = sentence.split(\" \")\n    # return implode(\" \", array_filter($words, function ($w) { return isPrime(strlen($w)); }));\n    return \" \".join(filter(lambda w: is_prime(len(w)), words))\n",
            "def simplify(x: str, n: str) -> bool:\n    # $xs = explode('/', $x);\n    xs = x.split('/')\n    # $ns = explode('/', $n);\n    ns = n.split('/')\n    # $num = intval($xs[0]) * intval($ns[0]);\n    num = int(xs[0]) * int(ns[0])\n    # $den = intval($xs[1]) * intval($ns[1]);\n    den = int(xs[1]) * int(ns[1])\n    # return $num % $den == 0;\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # $nStr = (string)$n;\n    n_str = str(n)\n    # if ($n >= 0) {\n    if n >= 0:\n        # return array_sum(str_split($nStr));\n        return sum(map(int, n_str))\n    else:\n        # return 2 * intVal(substr($nStr, 0, 2)) + digitsSum(abs($n));\n        return 2 * int(n_str[:2]) + digits_sum(abs(n))\ndef order_by_points(nums: List[int]) -> List[int]:\n    # $result = $nums;\n    result = nums\n    # usort($result, function ($a, $b) {\n    #     return digitsSum($a) - digitsSum($b);\n    # });\n    result.sort(key=lambda a, b: digits_sum(a) - digits_sum(b))\n    # return $result;\n    return result\n",
            "def special_filter(nums: List[int]) -> int:\n    # $odds = \"13579\";\n    odds = \"13579\"\n    # return count(array_filter($nums, function ($n) use ($odds) { return $n > 10 && $n % 2 == 1 && strpos($odds, strval($n)[0]) !== false; }));\n    return len(list(filter(lambda n: n > 10 and n % 2 == 1 and odds.find(str(n)[0]) != -1, nums)))\n",
            "def get_max_triples(n: int) -> int:\n    # $c = [0, 0, 0];\n    c = [0, 0, 0]\n    # for ($i = 1; $i <= $n; $i++) {\n    for i in range(1, n + 1):\n        # $a = $i * $i - $i + 1;\n        a = i * i - i + 1\n        # $c[$a % 3] += 1;\n        c[a % 3] += 1\n    # return $c[0] * $c[1] * $c[2] + ($c[0] * ($c[0] - 1) * ($c[0] - 2) + $c[1] * ($c[1] - 1) * ($c[1] - 2) + $c[2] * ($c[2] - 1) * ($c[2] - 2)) / 6;\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # $names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if (!in_array($planet1, $names) || !in_array($planet2, $names)) {\n    if planet1 not in names or planet2 not in names:\n        # return [];\n        return []\n    # $l = array_search($planet1, $names);\n    l = names.index(planet1)\n    # $r = array_search($planet2, $names);\n    r = names.index(planet2)\n    # if ($l > $r) {\n    if l > r:\n        # [$l, $r] = [$r, $l];\n        l, r = r, l\n    # if ($l == $r) {\n    if l == r:\n        # return [];\n        return []\n    # return array_slice($names, $l + 1, $r - $l - 1);\n    return names[l + 1: r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # $result = array_filter($lst, function ($x) { return strlen($x) % 2 == 0; });\n    result = list(filter(lambda x: len(x) % 2 == 0, lst))\n    # usort($result, function ($a, $b) {\n    #     if (strlen($a) == strlen($b)) {\n    #         return strcmp($a, $b);\n    #     } else {\n    #         return strlen($a) - strlen($b);\n    #     }\n    # });\n    result.sort(key=lambda x: (len(x), x))\n    # return $result;\n    return result\n",
            "def x_or_y(n: int, x: int, y: int) -> Union[int, str]:\n    # if ($n < 2) {\n    if n < 2:\n        # return $y;\n        return y\n    # for ($i = 2; $i <= floor(sqrt($n)); $i++) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if ($n % $i == 0) {\n        if n % i == 0:\n            # return $y;\n            return y\n    # return $x;\n    return x\n",
            "def double_the_difference(lst: List[int]) -> int:\n    # return array_sum(array_map(function ($n) { return $n * $n; }, array_filter($lst, function ($n) { return $n >= 0 && $n % 2 == 1; })));\n    return sum(map(lambda n: n * n, filter(lambda n: n >= 0 and n % 2 == 1, lst)))\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # return array_map(function($x, $y) {\n    #     return abs($x - $y);\n    # }, $game, $guess);\n    return [abs(x - y) for x, y in zip(game, guess)]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # $maxS = -PHP_INT_MAX;\n    max_s = -float('inf')\n    # $maxExt = \"\";\n    max_ext = \"\"\n    # foreach ($extensions as $ext) {\n    for ext in extensions:\n        # $upper = strlen(preg_replace('/[^A-Z]/', '', $ext));\n        upper = len(re.sub(r'[^A-Z]', '', ext))\n        # $lower = strlen(preg_replace('/[^a-z]/', '', $ext));\n        lower = len(re.sub(r'[^a-z]', '', ext))\n        # $s = $upper - $lower;\n        s = upper - lower\n        # if ($s > $maxS) {\n        if s > max_s:\n            # $maxS = $s;\n            max_s = s\n            # $maxExt = $ext;\n            max_ext = ext\n    # return \"$className.$maxExt\";\n    return f\"{class_name}.{max_ext}\"\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if (strlen($a) < strlen($b)) {\n    if len(a) < len(b):\n        # return false;\n        return False\n    # for ($i = 0; $i < strlen($b); $i++) {\n    for i in range(len(b)):\n        # if (strpos($a, substr($b, $i) . substr($b, 0, $i)) !== false) {\n        if a.find(b[i:] + b[:i]) != -1:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # $ds = strval(abs($num));\n    ds = str(abs(num))\n    # $even = count(array_filter(str_split($ds), function($d) { return ord($d) % 2 == 0; }));\n    even = sum(1 for d in ds if ord(d) % 2 == 0)\n    # return [$even, strlen($ds) - $even];\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # $values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1];\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1]\n    # $numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # $res = \"\";\n    res = \"\"\n    # for ($i = 0; $i < count($values); $i++) {\n    for i in range(len(values)):\n        # while ($num >= $values[$i]) {\n        while num >= values[i]:\n            # $res .= $numerals[$i];\n            res += numerals[i]\n            # $num -= $values[$i];\n            num -= values[i]\n    # return $res;   \n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # $s = [$a, $b, $c];\n    s = [a, b, c]\n    # sort($s);\n    s.sort()\n    # return $s[0] * $s[0] + $s[1] * $s[1] == $s[2] * $s[2];\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # $max_cnt = 0;\n    max_cnt = 0\n    # $max_w = \"\";\n    max_w = \"\"\n    # foreach ($words as $w) {\n    for w in words:\n        # $cnt = count(array_unique(str_split($w)));\n        cnt = len(set(w))\n        # if ($cnt > $max_cnt) {\n        if cnt > max_cnt:\n            # $max_cnt = $cnt;\n            max_cnt = cnt\n            # $max_w = $w;\n            max_w = w\n        # elseif ($cnt == $max_cnt) {\n        elif cnt == max_cnt:\n            # $max_w = min($max_w, $w);\n            max_w = min(max_w, w)\n    # return $max_w;\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if ($need <= $remaining) {\n    if need <= remaining:\n        # return [$num + $need, $remaining - $need];\n        return [num + need, remaining - need]\n    else:\n        # return [$num + $remaining, 0];\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # $ops = $operators;\n    ops = operators\n    # $nums = $operands;\n    nums = operands\n    # $i = count($ops) - 1;\n    i = len(ops) - 1\n    # while ($i >= 0) {\n    while i >= 0:\n        # if ($ops[$i] == \"**\") {\n        if ops[i] == \"**\":\n            # $nums[$i] = pow($nums[$i], $nums[$i + 1]);\n            nums[i] = pow(nums[i], nums[i + 1])\n            # array_splice($nums, $i + 1, 1);\n            del nums[i + 1]\n            # array_splice($ops, $i, 1);\n            del ops[i]\n        # $i -= 1;\n        i -= 1\n    # $i = 0;\n    i = 0\n    # while ($i < count($ops)) {\n    while i < len(ops):\n        # if ($ops[$i] == \"*\") {\n        if ops[i] == \"*\":\n            # $nums[$i] = $nums[$i] * $nums[$i + 1];\n            nums[i] = nums[i] * nums[i + 1]\n            # array_splice($nums, $i + 1, 1);\n            del nums[i + 1]\n            # array_splice($ops, $i, 1);\n            del ops[i]\n            # $i -= 1;\n            i -= 1\n        # } elseif ($ops[$i] == \"//\") {\n        elif ops[i] == \"//\":\n            # $nums[$i] = intdiv($nums[$i], $nums[$i + 1]);\n            nums[i] = intdiv(nums[i], nums[i + 1])\n            # array_splice($nums, $i + 1, 1);\n            del nums[i + 1]\n            # array_splice($ops, $i, 1);\n            del ops[i]\n            # $i -= 1;\n            i -= 1\n        # }\n        # $i += 1;\n        i += 1\n    # $i = 0;\n    i = 0\n    # while ($i < count($ops)) {\n    while i < len(ops):\n        # if ($ops[$i] == \"+\") {\n        if ops[i] == \"+\":\n            # $nums[$i] = $nums[$i] + $nums[$i + 1];\n            nums[i] = nums[i] + nums[i + 1]\n            # array_splice($nums, $i + 1, 1);\n            del nums[i + 1]\n            # array_splice($ops, $i, 1);\n            del ops[i]\n            # $i -= 1;\n            i -= 1\n        # } elseif ($ops[$i] == \"-\") {\n        elif ops[i] == \"-\":\n            # $nums[$i] = $nums[$i] - $nums[$i + 1];\n            nums[i] = nums[i] - nums[i + 1]\n            # array_splice($nums, $i + 1, 1);\n            del nums[i + 1]\n            # array_splice($ops, $i, 1);\n            del ops[i]\n            # $i -= 1;\n            i -= 1\n        # }\n        # $i += 1;\n        i += 1\n    # return $nums[0];\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if (empty(array_filter(str_split($s), function ($ch) {\n    #     return ctype_alpha($ch);\n    # }))) {\n    if not any(map(lambda ch: ch.isalpha(), s)):\n        # return strrev($s);\n        return s[::-1]\n    # $result = \"\";\n    result = \"\"\n    # foreach (str_split($s) as $ch) {\n    for ch in s:\n        # if (!ctype_alpha($ch)) {\n        if not ch.isalpha():\n            # $result .= $ch;\n            result += ch\n        # } elseif (ctype_upper($ch)) {\n        elif ch.isupper():\n            # $result .= strtolower($ch);\n            result += ch.lower()\n        # } elseif (ctype_lower($ch)) {\n        elif ch.islower():\n            # $result .= strtoupper($ch);\n            result += ch.upper()\n    # return $result;\n    return result\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if(empty($txt)){\n    if not txt:\n        # return null;\n        return None\n    # $txt_bytes = utf8_encode($txt);\n    txt_bytes = txt.encode('utf-8')\n    # $md5_encoded = md5($txt_bytes);\n    md5_encoded = md5(txt_bytes).hexdigest()\n    # return $md5_encoded;\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # $lower = max(2, min($a, $b));\n    lower = max(2, min(a, b))\n    # $upper = min(8, max($a, $b));\n    upper = min(8, max(a, b))\n    # if ($lower > $upper) {\n    if lower > upper:\n        # return [];\n        return []\n    # return array_filter(range($lower, $upper), function($i) { return $i % 2 === 0; });\n    return list(filter(lambda i: i % 2 == 0, range(lower, upper)))\n"
        ]
    },
    "python": {
        "cpp": [
            "bool hasCloseElements(const vector<float>& numbers, float threshold) {\n    // for i in range(len(numbers)):\n    for (int i = 0; i < numbers.size(); i++) {\n        // for j in range(i + 1, len(numbers)):\n        for (int j = i + 1; j < numbers.size(); j++) {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                // return True\n                return true;\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "vector<string> separateParenGroups(const string& paren_string) {\n    // groups = []\n    vector<string> groups;\n    // stk = []\n    stack<char> stk;\n    // current_group = \"\"\n    string current_group;\n    // parens = paren_string.replace(\" \", \"\")\n    string parens = paren_string;\n    for (char ch : parens) {\n        // if ch == \"(\":\n        if (ch == '(') {\n            // stk.append(ch)\n            stk.push(ch);\n            // current_group += ch\n            current_group += ch;\n        }\n        // elif ch == \")\":\n        else if (ch == ')') {\n            // stk.pop()\n            stk.pop();\n            // current_group += ch\n            current_group += ch;\n            // if not stk:\n            if (stk.empty()) {\n                // groups.append(current_group)\n                groups.push_back(current_group);\n                // current_group = \"\"\n                current_group = \"\";\n            }\n        }\n    }\n    // return groups\n    return groups;\n}\n",
            "float truncateNumber(float num) {\n    // return num - floor(num)\n    return num - floor(num);\n}\n",
            "bool belowZero(const vector<int>& operations) {\n    // balance = 0\n    int balance = 0;\n    // for op in operations:\n    for (int op : operations) {\n        // balance += op\n        balance += op;\n        // if balance < 0:\n        if (balance < 0) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "double meanAbsoluteDeviation(const vector<double>& numbers) {\n    // mean = sum(numbers) / len(numbers)\n    double mean = 0;\n    for (double x : numbers) {\n        mean += x;\n    }\n    mean /= numbers.size();\n    // deviation = sum(abs(x - mean) for x in numbers)\n    double deviation = 0;\n    for (double x : numbers) {\n        deviation += abs(x - mean);\n    }\n    // return deviation / len(numbers)\n    return deviation / numbers.size();\n}\n",
            "vector<int> intersperse(const vector<int>& numbers, int delimiter) {\n    // result = []\n    vector<int> result;\n    // for i in range(len(numbers)):\n    for (int i = 0; i < numbers.size(); i++) {\n        // if i != 0:\n        if (i != 0) {\n            // result.append(delimiter)\n            result.push_back(delimiter);\n        }\n        // result.append(numbers[i])\n        result.push_back(numbers[i]);\n    }\n    // return result\n    return result;\n}\n",
            "vector<int> parseNestedParens(const string& paren_string) {\n    // result = []\n    vector<int> result;\n    // paren_groups = paren_string.split()\n    vector<string> paren_groups;\n    string::size_type start = 0;\n    string::size_type end = 0;\n    while ((end = paren_string.find(\" \", start)) != string::npos) {\n        paren_groups.push_back(paren_string.substr(start, end - start));\n        start = end + 1;\n    }\n    paren_groups.push_back(paren_string.substr(start));\n    // for group in paren_groups:\n    for (const string& group : paren_groups) {\n        // max_depth = 0\n        int max_depth = 0;\n        // depth = 0\n        int depth = 0;\n        // for ch in group:\n        for (char ch : group) {\n            // if ch == \"(\":\n            if (ch == '(') {\n                // depth += 1\n                ++depth;\n                // max_depth = max(max_depth, depth)\n                max_depth = max(max_depth, depth);\n            }\n            // elif ch == \")\":\n            else if (ch == ')') {\n                // depth -= 1\n                --depth;\n            }\n        }\n        // result.append(max_depth)\n        result.push_back(max_depth);\n    }\n    // return result\n    return result;\n}\n",
            "vector<string> filterBySubstring(const vector<string>& strs, const string& substring) {\n    // return [s for s in strs if substring in s]\n    vector<string> result;\n    for (const string& s : strs) {\n        if (s.find(substring) != string::npos) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n",
            "vector<int> sumProduct(const vector<int>& numbers) {\n    // n_sum = sum(numbers)\n    int n_sum = accumulate(numbers.begin(), numbers.end(), 0);\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    int n_product = 1;\n    for (int n : numbers) {\n        n_product *= n;\n    }\n    // return [n_sum, n_product]\n    return {n_sum, n_product};\n}\n",
            "vector<int> rollingMax(const vector<int>& numbers) {\n    // max_so_far = float(\"-inf\")\n    int max_so_far = numeric_limits<int>::min();\n    // result = []\n    vector<int> result;\n    // for num in numbers:\n    for (int num : numbers) {\n        // max_so_far = max(max_so_far, num)\n        max_so_far = max(max_so_far, num);\n        // result.append(max_so_far)\n        result.push_back(max_so_far);\n    }\n    // return result\n    return result;\n}\n",
            "bool isPalindrome(const string& s) {\n    // return s == s[::-1]\n    return s == string(rbegin(s), rend(s));\n}\nstring makePalindrome(const string& s) {\n    // if is_palindrome(s):\n    if (isPalindrome(s)) {\n        // return s\n        return s;\n    }\n    // for i in range(len(s)):\n    for (int i = 0; i < s.size(); ++i) {\n        // if is_palindrome(s[i:]):\n        if (isPalindrome(s.substr(i))) {\n            // return s + s[:i][::-1]\n            return s + string(rbegin(s.substr(0, i)), rend(s.substr(0, i)));\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "string stringXor(const string& a, const string& b) {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    string result;\n    for (int i = 0; i < a.size(); ++i) {\n        result += a[i] == b[i] ? '0' : '1';\n    }\n    return result;\n}\n",
            "optional<string> longest(const vector<string>& strs) {\n    // if not strs:\n    if (strs.empty()) {\n        // return None\n        return nullopt;\n    }\n    // longest_s = strs[0]\n    string longest_s = strs[0];\n    // for s in strs:\n    for (const string& s : strs) {\n        // if len(s) > len(longest_s):\n        if (s.size() > longest_s.size()) {\n            // longest_s = s\n            longest_s = s;\n        }\n    }\n    // return longest_s\n    return longest_s;\n}\n",
            "int greatestCommonDivisor(int a, int b) {\n    // if b == 0:\n    if (b == 0) {\n        // return a\n        return a;\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        return greatestCommonDivisor(b, a % b);\n    }\n}\n",
            "vector<string> allPrefixes(const string& s) {\n    // prefixes = []\n    vector<string> prefixes;\n    // for i in range(len(s)):\n    for (int i = 0; i < s.size(); i++) {\n        // prefixes.append(s[: i + 1])\n        prefixes.push_back(s.substr(0, i + 1));\n    }\n    // return prefixes\n    return prefixes;\n}\n",
            "string stringSequence(int n) {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i << \" \";\n    }\n    return ss.str();\n}\n",
            "int countDistinctCharacters(const string& s) {\n    // return len(set(s.lower()))\n    return set(s.begin(), s.end()).size();\n}\n",
            "vector<int> parseMusic(const string& music_string) {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    map<string, int> durations = {\n        {\"o\", 4},\n        {\"o|\", 2},\n        {\".|\", 1}\n    };\n    // notes = music_string.split()\n    vector<string> notes = split(music_string, ' ');\n    // return [durations[note] for note in notes]\n    vector<int> result;\n    for (const string& note : notes) {\n        result.push_back(durations[note]);\n    }\n    return result;\n}\n",
            "int howManyTimes(const string& s, const string& substring) {\n    // times = 0\n    int times = 0;\n    // for i in range(len(s) - len(substring) + 1):\n    for (int i = 0; i < s.size() - substring.size() + 1; i++) {\n        // if s[i : i + len(substring)] == substring:\n        if (s.substr(i, substring.size()) == substring) {\n            // times += 1\n            times++;\n        }\n    }\n    // return times\n    return times;\n}\n",
            "string sortNumbers(const string& numbers) {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    map<string, int> num_dict = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9},\n    };\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    vector<string> num_list;\n    for (const auto& x : numbers.split(\" \")) {\n        if (num_dict.find(x) != num_dict.end()) {\n            num_list.push_back(x);\n        }\n    }\n    // num_list.sort(key=lambda x: num_dict[x])\n    sort(num_list.begin(), num_list.end(), [&num_dict](const string& x, const string& y) {\n        return num_dict[x] < num_dict[y];\n    });\n    // return \" \".join(num_list)\n    return join(num_list, \" \");\n}\n",
            "vector<float> findClosestElements(const vector<float>& numbers) {\n    // sorted_numbers = sorted(numbers)\n    vector<float> sorted_numbers(numbers);\n    sort(sorted_numbers.begin(), sorted_numbers.end());\n    // min_diff = float(\"inf\")\n    float min_diff = numeric_limits<float>::infinity();\n    // closest_pair = []\n    vector<float> closest_pair;\n    // for i in range(1, len(sorted_numbers)):\n    for (int i = 1; i < sorted_numbers.size(); i++) {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        float diff = sorted_numbers[i] - sorted_numbers[i - 1];\n        // if diff < min_diff:\n        if (diff < min_diff) {\n            // min_diff = diff\n            min_diff = diff;\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closest_pair = {sorted_numbers[i - 1], sorted_numbers[i]};\n        }\n    }\n    // return closest_pair\n    return closest_pair;\n}\n",
            "vector<float> rescaleToUnit(const vector<float>& numbers) {\n    // min_num = min(numbers)\n    float min_num = *min_element(numbers.begin(), numbers.end());\n    // max_num = max(numbers)\n    float max_num = *max_element(numbers.begin(), numbers.end());\n    // if min_num == max_num:\n    if (min_num == max_num) {\n        // return [0.0] * len(numbers)\n        return vector<float>(numbers.size(), 0.0);\n    } else {\n        // return [(num - min_num) / (max_num - min_num) for num in numbers]\n        vector<float> result;\n        for (float num : numbers) {\n            result.push_back((num - min_num) / (max_num - min_num));\n        }\n        return result;\n    }\n}\n",
            "vector<int> filterIntegers(const vector<int>& values) {\n    // return [x for x in values if isinstance(x, int)]\n    vector<int> result;\n    for (int x : values) {\n        if (is_same<decltype(x), int>::value) {\n            result.push_back(x);\n        }\n    }\n    return result;\n}\n",
            "int strLength(const string& s) {\n    // return len(s)\n    return s.length();\n}\n",
            "int largestDivisor(int n) {\n    // for i in range(2, n):\n    for (int i = 2; i < n; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return n // i\n            return n / i;\n        }\n    }\n    // return 1\n    return 1;\n}\n",
            "vector<int> factorize(int n) {\n    // factors = []\n    vector<int> factors;\n    // divisor = 2\n    int divisor = 2;\n    // while divisor <= n:\n    while (divisor <= n) {\n        // if n % divisor == 0:\n        if (n % divisor == 0) {\n            // factors.append(divisor)\n            factors.push_back(divisor);\n            // n //= divisor\n            n /= divisor;\n        } else {\n            // divisor += 1\n            divisor++;\n        }\n    }\n    // return factors\n    return factors;\n}\n",
            "vector<int> removeDuplicates(const vector<int>& numbers) {\n    // counts = {}\n    unordered_map<int, int> counts;\n    // for num in numbers:\n    for (int num : numbers) {\n        // counts[num] = counts.get(num, 0) + 1\n        counts[num] = counts.count(num) + 1;\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    vector<int> res;\n    for (int num : numbers) {\n        if (counts[num] == 1) {\n            res.push_back(num);\n        }\n    }\n    // return res\n    return res;\n}\n",
            "string flipCase(const string& s) {\n    // flipped = []\n    vector<char> flipped;\n    // for ch in s:\n    for (char ch : s) {\n        // if not ch.isalpha():\n        if (!isalpha(ch)) {\n            // flipped.append(ch)\n            flipped.push_back(ch);\n        }\n        // elif ch.islower():\n        else if (islower(ch)) {\n            // flipped.append(ch.upper())\n            flipped.push_back(toupper(ch));\n        }\n        // elif ch.isupper():\n        else if (isupper(ch)) {\n            // flipped.append(ch.lower())\n            flipped.push_back(tolower(ch));\n        }\n    }\n    // return ''.join(flipped)\n    return string(flipped.begin(), flipped.end());\n}\n",
            "string concatenate(const vector<string>& strs) {\n    // return \"\".join(strs)\n    string result;\n    for (const string& str : strs) {\n        result += str;\n    }\n    return result;\n}\n",
            "vector<string> filterByPrefix(const vector<string>& strs, const string& prefix_str) {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    vector<string> result;\n    for (const string& s : strs) {\n        if (s.starts_with(prefix_str)) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n",
            "vector<int> getPositive(const vector<int>& l) {\n    // return [num for num in l if num > 0]\n    vector<int> result;\n    for (int num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "double poly(const vector<int>& xs, double x) {\n    double res = 0.0;\n    for (int i = 0; i < xs.size(); ++i) {\n        res += xs[i] * pow(x, i);\n    }\n    return res;\n}\ndouble findZero(const vector<int>& xs) {\n    double x1 = 1.0, x2 = -1.0;\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        x1 *= 2;\n        x2 *= 2;\n    }\n    while (abs(x1 - x2) > 1e-10) {\n        double mid = (x1 + x2) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid;\n        } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            x2 = mid;\n        } else {\n            x1 = mid;\n        }\n    }\n    return (x1 + x2) / 2;\n}\n",
            "vector<int> sortThird(const vector<int>& l) {\n    // sorted_third = sorted(l[::3])\n    vector<int> sorted_third(l.begin(), l.begin() + l.size() / 3);\n    sort(sorted_third.begin(), sorted_third.end());\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    vector<int> result;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            result.push_back(sorted_third[i / 3]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;\n}\n",
            "vector<int> listUnique(const vector<int>& l) {\n    // return sorted(list(set(l)))\n    set<int> s(l.begin(), l.end());\n    vector<int> result(s.begin(), s.end());\n    sort(result.begin(), result.end());\n    return result;\n}\n",
            "int maxElement(const vector<int>& l) {\n    // if not l:\n    if (l.empty()) {\n        // return 0\n        return 0;\n    }\n    // return max(l)\n    return *max_element(l.begin(), l.end());\n}\n",
            "int fizzBuzz(int n) {\n    // cnt = 0\n    int cnt = 0;\n    // for i in range(n):\n    for (int i = 0; i < n; ++i) {\n        // if i % 11 == 0 or i % 13 == 0:\n        if (i % 11 == 0 || i % 13 == 0) {\n            // cnt += str(i).count(\"7\")\n            cnt += count(to_string(i).begin(), to_string(i).end(), '7');\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "vector<int> sortEven(const vector<int>& l) {\n    // sorted_even = sorted(l[::2])\n    vector<int> sorted_even(l.begin(), l.begin() + l.size() / 2);\n    sort(sorted_even.begin(), sorted_even.end());\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    vector<int> result;\n    for (int i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            result.push_back(sorted_even[i / 2]);\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;\n}\n",
            "string encodeCyclic(const string& s) {\n    // result = []\n    vector<string> result;\n    // for i in range(0, len(s), 3):\n    for (int i = 0; i < s.size(); i += 3) {\n        // if i + 3 > len(s):\n        if (i + 3 > s.size()) {\n            // result.append(s[i:])\n            result.push_back(s.substr(i));\n        } else {\n            // result.append(s[i+1:i+3])\n            result.push_back(s.substr(i+1, 2));\n            // result.append(s[i])\n            result.push_back(s.substr(i, 1));\n        }\n    }\n    // return \"\".join(result)\n    return string(result.begin(), result.end());\n}\nstring decodeCyclic(const string& s) {\n    return encodeCyclic(encodeCyclic(s));\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nint primeFib(int n) {\n    // f = [0, 1]\n    vector<int> f = {0, 1};\n    // cnt = 0\n    int cnt = 0;\n    // while cnt < n:\n    while (cnt < n) {\n        // f = [f[1], f[0] + f[1]]\n        f = {f[1], f[0] + f[1]};\n        // if is_prime(f[1]):\n        if (isPrime(f[1])) {\n            // cnt += 1\n            cnt++;\n        }\n    }\n    // return f[1]\n    return f[1];\n}\n",
            "bool triplesSumToZero(const vector<int>& l) {\n    // for i in range(len(l)):\n    for (int i = 0; i < l.size(); i++) {\n        // for j in range(i + 1, len(l)):\n        for (int j = i + 1; j < l.size(); j++) {\n            // for k in range(j + 1, len(l)):\n            for (int k = j + 1; k < l.size(); k++) {\n                // if l[i] + l[j] + l[k] == 0:\n                if (l[i] + l[j] + l[k] == 0) {\n                    // return True\n                    return true;\n                }\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "int carRaceCollision(int n) {\n    // return n ** 2\n    return pow(n, 2);\n}\n",
            "vector<int> incrList(const vector<int>& l) {\n    // return [i + 1 for i in l]\n    vector<int> result;\n    for (int i : l) {\n        result.push_back(i + 1);\n    }\n    return result;\n}\n",
            "bool pairsSumToZero(const vector<int>& l) {\n    // seen = set()\n    set<int> seen;\n    // for num in l:\n    for (int num : l) {\n        // if -num in seen:\n        if (seen.find(-num) != seen.end()) {\n            // return True\n            return true;\n        }\n        // seen.add(num)\n        seen.insert(num);\n    }\n    // return False\n    return false;\n}\n",
            "string changeBase(int x, int bas) {\n    // if x == 0:\n    if (x == 0) {\n        // return \"0\"\n        return \"0\";\n    }\n    // digits = []\n    vector<string> digits;\n    // while x > 0:\n    while (x > 0) {\n        // digits.append(str(x % bas))\n        digits.push_back(to_string(x % bas));\n        // x //= bas\n        x /= bas;\n    }\n    // return \"\".join(digits[::-1])\n    return string(digits.rbegin(), digits.rend());\n}\n",
            "float triangleArea(int a, int h) {\n    // return a * h / 2\n    return a * h / 2.0;\n}\n",
            "int fib4(int n) {\n    // fib = [0, 0, 2, 0]\n    vector<int> fib = {0, 0, 2, 0};\n    // for i in range(4, n + 1):\n    for (int i = 4; i <= n; i++) {\n        // fib[i % 4] = sum(fib)\n        fib[i % 4] = fib[0] + fib[1] + fib[2];\n    }\n    // return fib[n % 4]\n    return fib[n % 4];\n}\n",
            "double median(const vector<double>& l) {\n    // sl = sorted(l)\n    vector<double> sl(l);\n    sort(sl.begin(), sl.end());\n    // if len(l) % 2 != 0:\n    if (l.size() % 2 != 0) {\n        // return sl[len(l) // 2]\n        return sl[l.size() / 2];\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (sl[l.size() / 2] + sl[l.size() / 2 - 1]) / 2;\n    }\n}\n",
            "bool isPalindrome(const string& txt) {\n    // return txt == txt[::-1]\n    return txt == string(txt.rbegin(), txt.rend());\n}\n",
            "int modp(int n, int p) {\n    // ret = 1\n    int ret = 1;\n    // for _ in range(n):\n    for (int i = 0; i < n; ++i) {\n        // ret = (ret * 2) % p\n        ret = (ret * 2) % p;\n    }\n    // return ret\n    return ret;\n}\n",
            "string encodeShift(const string& s) {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    vector<char> result;\n    for (char ch : s) {\n        result.push_back(((ch - 97 + 5) % 26) + 97);\n    }\n    // return \"\".join(result)\n    return string(result.begin(), result.end());\n}\nstring decodeShift(const string& s) {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    vector<char> result;\n    for (char ch : s) {\n        result.push_back(((ch - 97 + 21) % 26) + 97);\n    }\n    // return \"\".join(result)\n    return string(result.begin(), result.end());\n}\n",
            "string removeVowels(const string& txt) {\n    // vowels = \"aeiouAEIOU\"\n    set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    // return \"\".join([char for char in txt if char not in vowels])\n    string result;\n    for (char c : txt) {\n        if (vowels.find(c) == vowels.end()) {\n            result += c;\n        }\n    }\n    return result;\n}\n",
            "bool belowThreshold(const vector<int>& l, int t) {\n    // return all(x < t for x in l)\n    return all_of(l.begin(), l.end(), [t](int x) { return x < t; });\n}\n",
            "int add(int x, int y) {\n    // return x + y\n    return x + y;\n}\n",
            "bool sameChars(const string& s0, const string& s1) {\n    // return set(s0) == set(s1)\n    return set<char>(s0.begin(), s0.end()) == set<char>(s1.begin(), s1.end());\n}\n",
            "int fib(int n) {\n    // if n <= 1:\n    if (n <= 1) {\n        // return n\n        return n;\n    } else {\n        // return fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n",
            "bool correctBracketing(const string& brackets) {\n    // depth = 0\n    int depth = 0;\n    // for b in brackets:\n    for (char b : brackets) {\n        // if b == \"<\":\n        if (b == '<') {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \">\":\n        else if (b == '>') {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return depth == 0;\n}\n",
            "bool monotonic(const vector<int>& l) {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    vector<int> diff;\n    for (int i = 0; i < l.size() - 1; ++i) {\n        diff.push_back(l[i + 1] - l[i]);\n    }\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    for (int x : diff) {\n        if (x > 0) {\n            return false;\n        }\n    }\n    for (int x : diff) {\n        if (x < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "vector<int> common(const vector<int>& l1, const vector<int>& l2) {\n    // return sorted(list(set(l1) & set(l2)))\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n    set<int> s3(s1);\n    s3.insert(s2.begin(), s2.end());\n    vector<int> result(s3.begin(), s3.end());\n    sort(result.begin(), result.end());\n    return result;\n}\n",
            "int largestPrimeFactor(int n) {\n    // i = 2\n    int i = 2;\n    // while i * i <= n:\n    while (i * i <= n) {\n        // if n % i:\n        if (n % i) {\n            // i += 1\n            i += 1;\n        } else {\n            // n //= i\n            n /= i;\n        }\n    }\n    // return n\n    return n;\n}\n",
            "int sumToN(int n) {\n    // return sum(range(n + 1))\n    return std::accumulate(0, n + 1);\n}\n",
            "bool correctBracketing(const string& brackets) {\n    // depth = 0\n    int depth = 0;\n    // for b in brackets:\n    for (char b : brackets) {\n        // if b == \"(\":\n        if (b == '(') {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \")\":\n        else if (b == ')') {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return depth == 0;\n}\n",
            "vector<int> derivative(const vector<int>& xs) {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    vector<int> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n",
            "int fibfib(int n) {\n    // if n <= 1:\n    if (n <= 1) {\n        // return 0 \n        return 0;\n    }\n    // a, b, c = 0, 0, 1\n    int a = 0, b = 0, c = 1;\n    // while n > 2:\n    while (n > 2) {\n        // a, b, c = b, c, a + b + c\n        a = b;\n        b = c;\n        c = a + b + c;\n        // n -= 1\n        n -= 1;\n    }\n    // return c\n    return c;\n}\n",
            "int vowelsCount(const string& s) {\n    // vowels = \"aeiou\"\n    const string vowels = \"aeiou\";\n    // cnt = 0\n    int cnt = 0;\n    // for i in range(len(s)):\n    for (int i = 0; i < s.size(); ++i) {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if (s[i] == 'y' || vowels.find(s[i]) != string::npos) {\n            // cnt += 1\n            ++cnt;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "string circularShift(int x, int shift) {\n    // x_str = str(x)\n    string x_str = to_string(x);\n    // if shift > len(x_str):\n    if (shift > x_str.length()) {\n        // return x_str[::-1]\n        return string(x_str.rbegin(), x_str.rend());\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return x_str.substr(x_str.length() - shift) + x_str.substr(0, x_str.length() - shift);\n    }\n}\n",
            "int digitSum(const string& s) {\n    // return sum(ord(c) for c in s if c.isupper())\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n",
            "int fruitDistribution(const string& s, int n) {\n    // words = s.split(' ')\n    vector<string> words = split(s, ' ');\n    // apples = int(words[words.index(\"apples\") - 1])\n    int apples = stoi(words[words.index(\"apples\") - 1]);\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    int oranges = stoi(words[words.index(\"oranges\") - 1]);\n    // return n - apples - oranges\n    return n - apples - oranges;\n}\n",
            "vector<int> pluck(const vector<int>& arr) {\n    // evens = [n for n in arr if n % 2 == 0]\n    vector<int> evens;\n    for (int n : arr) {\n        if (n % 2 == 0) {\n            evens.push_back(n);\n        }\n    }\n    // if len(evens) == 0:\n    if (evens.empty()) {\n        // return []\n        return {};\n    }\n    // min_even = min(evens)\n    int min_even = *min_element(evens.begin(), evens.end());\n    // return [min_even, arr.index(min_even)]\n    return {min_even, distance(arr.begin(), find(arr.begin(), arr.end(), min_even))};\n}\n",
            "int search(const vector<int>& lst) {\n    // freqs = {}\n    unordered_map<int, int> freqs;\n    // for n in lst:\n    for (int n : lst) {\n        // freqs[n] = freqs.get(n, 0) + 1\n        freqs[n] = freqs.count(n) ? freqs[n] + 1 : 1;\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    vector<int> good_vals;\n    for (auto& [k, v] : freqs) {\n        if (v >= k) {\n            good_vals.push_back(k);\n        }\n    }\n    // return max(good_vals, default=-1)\n    return good_vals.empty() ? -1 : *max_element(good_vals.begin(), good_vals.end());\n}\n",
            "vector<int> strangeSortList(const vector<int>& lst) {\n    // sl = sorted(lst)\n    vector<int> sl(lst);\n    sort(sl.begin(), sl.end());\n    // result = []\n    vector<int> result;\n    // left, right = 0, len(sl) - 1\n    int left = 0, right = sl.size() - 1;\n    // while left <= right:\n    while (left <= right) {\n        // result.append(sl[left])\n        result.push_back(sl[left]);\n        // left += 1\n        left++;\n        // if left <= right:\n        if (left <= right) {\n            // result.append(sl[right])\n            result.push_back(sl[right]);\n            // right -= 1\n            right--;\n        }\n    }\n    // return result\n    return result;\n}\n",
            "double triangleArea(int a, int b, int c) {\n    // if a + b > c and a + c > b and b + c > a:\n    if (a + b > c && a + c > b && b + c > a) {\n        // s = (a + b + c) / 2.0\n        double s = (a + b + c) / 2.0;\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // return -1.0\n        return -1.0;\n    }\n}\n",
            "bool willItFly(const vector<int>& q, int w) {\n    // if len(q) == 0:\n    if (q.empty()) {\n        // return False\n        return false;\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    bool is_palin = true;\n    for (int i = 0; i < q.size(); ++i) {\n        if (q[i] != q[q.size() - i - 1]) {\n            is_palin = false;\n            break;\n        }\n    }\n    // total = sum(q)\n    int total = 0;\n    for (int e : q) {\n        total += e;\n    }\n    // return is_palin and total <= w\n    return is_palin && total <= w;\n}\n",
            "int smallestChange(const vector<int>& arr) {\n    // ans = 0\n    int ans = 0;\n    // for i in range(len(arr) // 2):\n    for (int i = 0; i < arr.size() / 2; ++i) {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if (arr[i] != arr[arr.size() - i - 1]) {\n            // ans += 1\n            ++ans;\n        }\n    }\n    // return ans\n    return ans;\n}\n",
            "vector<string> totalMatch(const vector<string>& lst1, const vector<string>& lst2) {\n    // cnt1 = sum(len(s) for s in lst1)\n    int cnt1 = 0;\n    for (const string& s : lst1) {\n        cnt1 += s.length();\n    }\n    // cnt2 = sum(len(s) for s in lst2)\n    int cnt2 = 0;\n    for (const string& s : lst2) {\n        cnt2 += s.length();\n    }\n    // return lst1 if cnt1 <= cnt2 else lst2\n    return cnt1 <= cnt2 ? lst1 : lst2;\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nbool isMultiplyPrime(int a) {\n    // cnt = 0\n    int cnt = 0;\n    // for i in range(2, a + 1):\n    for (int i = 2; i <= a + 1; i++) {\n        // if is_prime(i):\n        if (isPrime(i)) {\n            // while a % i == 0:\n            while (a % i == 0) {\n                // cnt += 1\n                cnt++;\n                // a /= i\n                a /= i;\n            }\n        }\n    }\n    // return cnt == 3\n    return cnt == 3;\n}\n",
            "bool isSimplePower(int x, int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return x == n\n        return x == n;\n    }\n    // tmp = 1\n    int tmp = 1;\n    // while tmp < x:\n    while (tmp < x) {\n        // tmp *= n\n        tmp *= n;\n    }\n    // return tmp == x\n    return tmp == x;\n}\n",
            "bool isCube(int a) {\n    // a = abs(a)\n    a = abs(a);\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    int root = int(round(pow(a, 1.0 / 3.0)));\n    // return root * root * root == a\n    return root * root * root == a;\n}\n",
            "int hexKey(const string& num) {\n    // return len([x for x in num if x in \"2357BD\"])\n    return count_if(num.begin(), num.end(), [](char x) {\n        return x == '2' || x == '3' || x == '5' || x == '7' || x == 'B' || x == 'D';\n    });\n}\n",
            "string decimalToBinary(int dec) {\n    // binary = bin(dec)[2:]\n    string binary = bitset<32>(dec).to_string();\n    // return f\"db{binary}db\"\n    return \"db\" + binary + \"db\";\n}\n",
            "bool isHappy(const string& s) {\n    // if len(s) < 3:\n    if (s.size() < 3) {\n        // return False\n        return false;\n    }\n    // for i in range(len(s) - 2):\n    for (int i = 0; i < s.size() - 2; ++i) {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "vector<string> numericalLetterGrade(const vector<float>& grades) {\n    // result = []\n    vector<string> result;\n    // for g in grades:\n    for (float g : grades) {\n        // if g == 4.0:\n        if (g == 4.0) {\n            // result.append(\"A+\")\n            result.push_back(\"A+\");\n        }\n        // elif g > 3.7:\n        else if (g > 3.7) {\n            // result.append(\"A\")\n            result.push_back(\"A\");\n        }\n        // elif g > 3.3:\n        else if (g > 3.3) {\n            // result.append(\"A-\")\n            result.push_back(\"A-\");\n        }\n        // elif g > 3.0:\n        else if (g > 3.0) {\n            // result.append(\"B+\")\n            result.push_back(\"B+\");\n        }\n        // elif g > 2.7:\n        else if (g > 2.7) {\n            // result.append(\"B\")\n            result.push_back(\"B\");\n        }\n        // elif g > 2.3:\n        else if (g > 2.3) {\n            // result.append(\"B-\")\n            result.push_back(\"B-\");\n        }\n        // elif g > 2.0:\n        else if (g > 2.0) {\n            // result.append(\"C+\")\n            result.push_back(\"C+\");\n        }\n        // elif g > 1.7:\n        else if (g > 1.7) {\n            // result.append(\"C\")\n            result.push_back(\"C\");\n        }\n        // elif g > 1.3:\n        else if (g > 1.3) {\n            // result.append(\"C-\")\n            result.push_back(\"C-\");\n        }\n        // elif g > 1.0:\n        else if (g > 1.0) {\n            // result.append(\"D+\")\n            result.push_back(\"D+\");\n        }\n        // elif g > 0.7:\n        else if (g > 0.7) {\n            // result.append(\"D\")\n            result.push_back(\"D\");\n        }\n        // elif g > 0.0:\n        else if (g > 0.0) {\n            // result.append(\"D-\")\n            result.push_back(\"D-\");\n        }\n        // else:\n        else {\n            // result.append(\"E\")\n            result.push_back(\"E\");\n        }\n    }\n    // return result\n    return result;\n}\n",
            "bool primeLength(const string& s) {\n    // length = len(s)\n    int length = s.length();\n    // if length < 2:\n    if (length < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for (int i = 2; i <= floor(sqrt(length)) + 1; ++i) {\n        // if length % i == 0:\n        if (length % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "int startsOneEnds(int n) {\n    // if n == 1:\n    if (n == 1) {\n        // return 1\n        return 1;\n    }\n    // return 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * pow(10, n - 2);\n}\n",
            "string solve(int n) {\n    // digits_sum = sum(int(d) for d in str(n))\n    int digits_sum = 0;\n    for (char d : to_string(n)) {\n        digits_sum += d - '0';\n    }\n    // return bin(digits_sum)[2:]\n    return string(bitset<32>(digits_sum).to_string().substr(2));\n}\n",
            "int add(const vector<int>& lst) {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    return accumulate(lst.begin(), lst.end(), 0, [](int a, int b) {\n        return a + (b % 2 == 0 && (b - 1) % 2 == 1);\n    });\n}\n",
            "string antiShuffle(const string& s) {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    vector<string> words;\n    for (int i = 0; i < s.size();) {\n        int j = i;\n        while (j < s.size() && s[j] != ' ') {\n            ++j;\n        }\n        string word = s.substr(i, j - i);\n        sort(word.begin(), word.end());\n        words.push_back(word);\n        i = j + 1;\n    }\n    // return \" \".join(words)\n    return join(words, \" \");\n}\n",
            "vector<vector<int>> getRow(const vector<vector<int>>& lst, int x) {\n    // coords = []\n    vector<vector<int>> coords;\n    // for i in range(len(lst)):\n    for (int i = 0; i < lst.size(); ++i) {\n        // for j in range(len(lst[i])):\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // if lst[i][j] == x:\n            if (lst[i][j] == x) {\n                // coords.append([i, j])\n                coords.push_back({i, j});\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    sort(coords.begin(), coords.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\n    });\n    return coords;\n}\n",
            "vector<int> sortArray(const vector<int>& arr) {\n    // if len(arr) == 0:\n    if (arr.empty()) {\n        // return []\n        return {};\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if ((arr[0] + arr.back()) % 2 == 0) {\n        // return sorted(arr, reverse=True)\n        vector<int> result(arr);\n        sort(result.begin(), result.end(), greater<int>());\n        return result;\n    } else {\n        // return sorted(arr)\n        vector<int> result(arr);\n        sort(result.begin(), result.end());\n        return result;\n    }\n}\n",
            "string encrypt(const string& s) {\n    // result = []\n    string result;\n    // for ch in s:\n    for (char ch : s) {\n        // shifted = ord(ch) + 4\n        int shifted = ch + 4;\n        // if shifted > ord('z'):\n        if (shifted > 'z') {\n            // shifted -= 26\n            shifted -= 26;\n        }\n        // result.append(chr(shifted))\n        result.push_back(shifted);\n    }\n    // return \"\".join(result)\n    return result;\n}\n",
            "int nextSmallest(const vector<int>& lst) {\n    // sl = sorted(set(lst))\n    vector<int> sl;\n    set<int> s(lst.begin(), lst.end());\n    copy(s.begin(), s.end(), back_inserter(sl));\n    sort(sl.begin(), sl.end());\n    // if len(sl) < 2:\n    if (sl.size() < 2) {\n        // return None\n        return -1;\n    }\n    // return sl[1]\n    return sl[1];\n}\n",
            "int isBored(const string& s) {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    regex re(\"[.!?]\\\\s*\");\n    auto sentences = regex_split(s, re);\n    // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    int result = 0;\n    for (const auto& sentence : sentences) {\n        if (sentence.size() >= 2 && sentence.substr(0, 2) == \"I \") {\n            result++;\n        }\n    }\n    return result;\n}\n",
            "bool anyInt(const string& x, const string& y, const string& z) {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if (typeid(x) == typeid(int) && typeid(y) == typeid(int) && typeid(z) == typeid(int)) {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if (x.toInt() + y.toInt() == z.toInt() || x.toInt() + z.toInt() == y.toInt() || y.toInt() + z.toInt() == x.toInt()) {\n            return true;\n        }\n    }\n    return false;\n}\n",
            "string encode(const string& message) {\n    // vowels = \"aeiouAEIOU\"\n    const string vowels = \"aeiouAEIOU\";\n    // result = []\n    vector<char> result;\n    // for ch in message:\n    for (char ch : message) {\n        // if ch.isalpha():\n        if (isalpha(ch)) {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            char ch1 = ch;\n            if (islower(ch)) {\n                ch1 = toupper(ch);\n            } else {\n                ch1 = tolower(ch);\n            }\n            // if ch1 in vowels:\n            if (vowels.find(ch1) != string::npos) {\n                // ch1 = chr(ord(ch1) + 2)\n                ch1 = char(ch1 + 2);\n            }\n            // result.append(ch1)\n            result.push_back(ch1);\n        } else {\n            // result.append(ch)\n            result.push_back(ch);\n        }\n    }\n    // return \"\".join(result)\n    return string(result.begin(), result.end());\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nint skjkasdkd(const vector<int>& lst) {\n    // primes = [n for n in lst if is_prime(n)]\n    vector<int> primes;\n    for (int n : lst) {\n        if (isPrime(n)) {\n            primes.push_back(n);\n        }\n    }\n    // if len(primes) == 0:\n    if (primes.empty()) {\n        // return 0\n        return 0;\n    }\n    // largest = str(max(primes))\n    string largest = to_string(max(primes));\n    // return sum(int(digit) for digit in largest)\n    int sum = 0;\n    for (char digit : largest) {\n        sum += digit - '0';\n    }\n    return sum;\n}\n",
            "bool checkDictCase(const unordered_map<string, string>& d) {\n    // if not d:\n    if (d.empty()) {\n        // return False\n        return false;\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    for (auto& [k, v] : d) {\n        if (islower(k[0]) != islower(v[0])) {\n            return false;\n        }\n    }\n    return true;\n}\n",
            "vector<int> countUpTo(int n) {\n    // primes = []\n    vector<int> primes;\n    // for num in range(2, n):\n    for (int num = 2; num < n; ++num) {\n        // if all(num % p != 0 for p in primes):\n        if (all_of(primes.begin(), primes.end(), [num](int p) { return num % p != 0; })) {\n            // primes.append(num)\n            primes.push_back(num);\n        }\n    }\n    // return primes\n    return primes;\n}\n",
            "int multiply(int a, int b) {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    return abs(a) % 10 * abs(b) % 10;\n}\n",
            "int countUpper(const string& s) {\n    // vowels = \"AEIOU\"\n    const string vowels = \"AEIOU\";\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    int result = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0 && vowels.find(s[i]) != string::npos) {\n            ++result;\n        }\n    }\n    return result;\n}\n",
            "int closestInteger(const std::string& value) {\n    // num = float(value)\n    double num = std::stod(value);\n    // if num >= 0:\n    if (num >= 0) {\n        // return int(num + 0.5)\n        return static_cast<int>(num + 0.5);\n    } else {\n        // return int(num - 0.5)\n        return static_cast<int>(num - 0.5);\n    }\n}\n",
            "vector<int> makeAPile(int n) {\n    // return [n + 2 * i for i in range(n)]\n    vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(n + 2 * i);\n    }\n    return result;\n}\n",
            "vector<string> wordsString(const string& s) {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    regex re(R\"([, ])\");\n    vector<string> result;\n    for (auto w : s | std::views::split(re)) {\n        if (w.size() > 0) {\n            result.push_back(w);\n        }\n    }\n    return result;\n}\n",
            "int chooseNum(int x, int y) {\n    // if x > y:\n    if (x > y) {\n        // return -1\n        return -1;\n    }\n    // if y % 2 == 0:\n    if (y % 2 == 0) {\n        // return y\n        return y;\n    }\n    // return y - 1 if x != y else -1\n    return y - 1;\n}\n",
            "string roundedAvg(int n, int m) {\n    // if n > m:\n    if (n > m) {\n        // return None\n        return \"\";\n    }\n    // r_avg = int((m + n) / 2.0 + 0.5)\n    int r_avg = int((m + n) / 2.0 + 0.5);\n    // return bin(r_avg)[2:]\n    return string(bitset<32>(r_avg).to_string().substr(32 - r_avg));\n}\n",
            "bool allDigitsOdd(const string& s) {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    for (char digit : s) {\n        if (digit % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nvector<int> uniqueDigits(const vector<int>& x) {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    vector<int> result;\n    for (int num : x) {\n        if (allDigitsOdd(to_string(num))) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}\n",
            "vector<string> byLength(const vector<int>& arr) {\n    // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    vector<string> digit_names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n    vector<int> sorted_arr;\n    for (int x : arr) {\n        if (1 <= x && x <= 9) {\n            sorted_arr.push_back(x);\n        }\n    }\n    sort(sorted_arr.begin(), sorted_arr.end(), greater<int>());\n    // return [digit_names[x-1] for x in sorted_arr]\n    vector<string> result;\n    for (int x : sorted_arr) {\n        result.push_back(digit_names[x-1]);\n    }\n    return result;\n}\n",
            "vector<int> f(int n) {\n    // nums = list(range(1, n + 1))\n    vector<int> nums(n);\n    iota(nums.begin(), nums.end(), 1);\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        result[i] = i % 2 != 0 ? accumulate(nums.begin(), nums.begin() + i + 1, 0) : accumulate(nums.begin(), nums.begin() + i + 1, 1, [](int x, int y) { return x * y; });\n    }\n    return result;\n}\n",
            "bool isPalindrome(const string& txt) {\n    // return txt == txt[::-1]\n    return txt == string(txt.rbegin(), txt.rend());\n}\nvector<int> evenOddPalindrome(int n) {\n    // cnt = [0, 0]\n    vector<int> cnt(2, 0);\n    // for i in range(1, n + 1):\n    for (int i = 1; i <= n; ++i) {\n        // if is_palindrome(str(i)):\n        if (isPalindrome(to_string(i))) {\n            // cnt[i % 2] += 1\n            cnt[i % 2] += 1;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "int digitsSum(int n) {\n    string n_str = to_string(n);\n    if (n >= 0) {\n        return accumulate(n_str.begin(), n_str.end(), 0, [](int a, char b) { return a + b - '0'; });\n    } else {\n        return (n_str[0] - '0') * 2 + digitsSum(abs(n));\n    }\n}\nint countNums(const vector<int>& arr) {\n    return count_if(arr.begin(), arr.end(), [](int n) { return digitsSum(n) > 0; });\n}\n",
            "bool moveOneBall(const vector<int>& arr) {\n    // if len(arr) == 0:\n    if (arr.empty()) {\n        // return True\n        return true;\n    }\n    // sorted_arr = sorted(arr)\n    vector<int> sorted_arr(arr);\n    sort(sorted_arr.begin(), sorted_arr.end());\n    // for i in range(0, len(arr)):\n    for (int i = 0; i < arr.size(); ++i) {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if (arr.size() - i == sorted_arr.size() - i && arr.size() - i == sorted_arr.size() - i && equal(arr.begin(), arr.begin() + i, sorted_arr.begin() + sorted_arr.size() - i) && equal(arr.begin() + i, arr.end(), sorted_arr.begin())) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "string canExchange(const vector<int>& lst1, const vector<int>& lst2) {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    int odd_cnt = count_if(lst1.begin(), lst1.end(), [](int num) { return num % 2 != 0; });\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    int even_cnt = count_if(lst2.begin(), lst2.end(), [](int num) { return num % 2 == 0; });\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    return even_cnt >= odd_cnt ? \"YES\" : \"NO\";\n}\n",
            "map<string, int> histogram(const string& test) {\n    // freq = {}\n    map<string, int> freq;\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    vector<string> words;\n    for (string w : test.split(\" \")) {\n        if (w.length() > 0) {\n            words.push_back(w);\n        }\n    }\n    // for w in words:\n    for (string w : words) {\n        // freq[w] = freq.get(w, 0) + 1\n        freq[w] = freq.get(w, 0) + 1;\n    }\n    // result = {}\n    map<string, int> result;\n    // if len(freq) > 0:\n    if (freq.size() > 0) {\n        // max_freq = max(freq.values())\n        int max_freq = *max_element(freq.begin(), freq.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n            return a.second < b.second;\n        });\n        // for k, v in freq.items():\n        for (auto& [k, v] : freq) {\n            // if v == max_freq:\n            if (v == max_freq) {\n                // result[k] = v\n                result[k] = v;\n            }\n        }\n    }\n    // return result\n    return result;\n}\n",
            "bool isPalindrome(const string& s) {\n    // return s == s[::-1]\n    return s == string(s.rbegin(), s.rend());\n}\nvector<string> reverseDelete(const string& s, const string& c) {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    string s1;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) {\n            s1 += ch;\n        }\n    }\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    return {s1, isPalindrome(s1) ? \"yes\" : \"no\"};\n}\n",
            "vector<string> oddCount(const vector<string>& lst) {\n    // result = []\n    vector<string> result;\n    // for num in lst:\n    for (const string& num : lst) {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        int n = 0;\n        for (char d : num) {\n            n += (d % 2 == 1);\n        }\n        // rs = \"the number of odd elements in the string i of the input.\"\n        string rs = \"the number of odd elements in the string \" + to_string(n) + \" of the input.\";\n        // result.append(rs.replace(\"i\", str(n)))\n        result.push_back(rs);\n    }\n    // return result\n    return result;\n}\n",
            "int minSubArraySum(const vector<int>& nums) {\n    // min_sum = 0\n    int min_sum = 0;\n    // cur_sum = 0\n    int cur_sum = 0;\n    // for n in nums:\n    for (int n : nums) {\n        // cur_sum = min(cur_sum + n, 0)\n        cur_sum = min(cur_sum + n, 0);\n        // min_sum = min(cur_sum, min_sum)\n        min_sum = min(cur_sum, min_sum);\n    }\n    // if min_sum == 0:\n    if (min_sum == 0) {\n        // min_sum = min(nums)\n        min_sum = *min_element(nums.begin(), nums.end());\n    }\n    // return min_sum\n    return min_sum;\n}\n",
            "int maxFill(const vector<vector<int>>& grid, int capacity) {\n    // return sum([ceil(sum(arr) / capacity) for arr in grid])\n    return accumulate(grid.begin(), grid.end(), 0, [capacity](int sum, const vector<int>& arr) {\n        return sum + ceil(accumulate(arr.begin(), arr.end(), 0.0) / capacity);\n    });\n}\n",
            "int countOnes(int num) {\n    // return bin(num).count(\"1\")\n    return count(to_string(num).begin(), to_string(num).end(), '1');\n}\nvector<int> sortArray(const vector<int>& arr) {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    vector<int> result(arr);\n    sort(result.begin(), result.end(), [](int a, int b) {\n        return make_pair(countOnes(a), a) < make_pair(countOnes(b), b);\n    });\n    return result;\n}\n",
            "vector<string> selectWords(const string& s, int n) {\n    // consonants = \"bcdfghjklmnpqrstvwxyz\"\n    const string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    vector<string> words;\n    for (size_t i = 0; i < s.size();) {\n        size_t j = i;\n        while (j < s.size() && s[j] != ' ') {\n            ++j;\n        }\n        if (j > i) {\n            words.push_back(s.substr(i, j - i));\n        }\n        i = j + 1;\n    }\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    vector<string> result;\n    for (const string& w : words) {\n        int count = 0;\n        for (char c : w) {\n            if (consonants.find(tolower(c)) != string::npos) {\n                ++count;\n            }\n        }\n        if (count == n) {\n            result.push_back(w);\n        }\n    }\n    return result;\n}\n",
            "string getClosestVowel(const string& word) {\n    // vowels = \"aeiouAEIOU\"\n    const string vowels = \"aeiouAEIOU\";\n    // for i in range(len(word) - 2, 0, -1):\n    for (int i = word.size() - 2; i >= 0; i--) {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if (vowels.find(word[i]) != string::npos && vowels.find(word[i - 1]) == string::npos && vowels.find(word[i + 1]) == string::npos) {\n            // return word[i]\n            return word.substr(i, 1);\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "bool check(const string& s) {\n    int depth = 0;\n    for (char ch : s) {\n        if (ch == '(') {\n            depth += 1;\n        } else {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\nstring matchParens(const vector<string>& lst) {\n    string s1 = lst[0] + lst[1];\n    string s2 = lst[1] + lst[0];\n    return \"Yes\" + (check(s1) || check(s2));\n}\n",
            "vector<int> maximum(const vector<int>& arr, int k) {\n    // if k == 0:\n    if (k == 0) {\n        // return []\n        return {};\n    }\n    // return sorted(arr)[-k:]\n    vector<int> result(arr.begin(), arr.end());\n    sort(result.begin(), result.end());\n    return vector<int>(result.end() - k, result.end());\n}\n",
            "int solution(const vector<int>& lst) {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    return accumulate(lst.begin(), lst.end(), 0, [](int sum, int x) {\n        return sum + (x % 2 != 0 && (x - 1) % 2 == 0 ? x : 0);\n    });\n}\n",
            "int addElements(const vector<int>& arr, int k) {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    return accumulate(arr.begin(), arr.begin() + k, 0, [](int sum, int n) {\n        return sum + (to_string(n).length() <= 2 ? n : 0);\n    });\n}\n",
            "vector<int> getOddCollatz(int n) {\n    // collatz = [1]\n    vector<int> collatz = {1};\n    // while n != 1:\n    while (n != 1) {\n        // if n % 2 != 0:\n        if (n % 2 != 0) {\n            // collatz.append(n)\n            collatz.push_back(n);\n            // n = 3 * n + 1\n            n = 3 * n + 1;\n        } else {\n            // n = n // 2\n            n /= 2;\n        }\n    }\n    // return sorted(collatz)\n    sort(collatz.begin(), collatz.end());\n    return collatz;\n}\n",
            "bool validDate(const string& date) {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n    // m = int(date[:2])\n    int m = stoi(date.substr(0, 2));\n    // d = int(date[3:5])\n    int d = stoi(date.substr(3, 2));\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) {\n        if (d >= 1 && d <= 31) {\n            return true;\n        }\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if (m == 4 || m == 6 || m == 9 || m == 11) {\n        if (d >= 1 && d <= 30) {\n            return true;\n        }\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if (m == 2) {\n        if (d >= 1 && d <= 29) {\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "vector<string> splitWords(const string& txt) {\n    // if \" \" in txt:\n    if (txt.find(' ') != string::npos) {\n        // return txt.split(\" \")\n        return vector<string>(txt.begin(), txt.end());\n    }\n    // elif \",\" in txt:\n    else if (txt.find(',') != string::npos) {\n        // return txt.split(\",\")\n        return vector<string>(txt.begin(), txt.end());\n    }\n    // else:\n    else {\n        // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c) && c % 2 == 0) {\n                count++;\n            }\n        }\n        return vector<string>({to_string(count)});\n    }\n}\n",
            "bool isSorted(const vector<int>& lst) {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i-1] > lst[i]) {\n            return false;\n        }\n    }\n    // freq = {}\n    map<int, int> freq;\n    // for i in lst:\n    for (int i : lst) {\n        // freq[i] = freq.get(i, 0) + 1\n        freq[i] = freq.count(i) + 1;\n    }\n    // return max(freq.values(), default=0) <= 2\n    return *max_element(freq.begin(), freq.end()) <= 2;\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= floor(sqrt(n)) + 1; ++i) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nstring intersection(const vector<int>& interval1, const vector<int>& interval2) {\n    // l = max(interval1[0], interval2[0])\n    int l = max(interval1[0], interval2[0]);\n    // r = min(interval1[1], interval2[1])\n    int r = min(interval1[1], interval2[1]);\n    // length = r - l\n    int length = r - l;\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n}\n",
            "int prodSigns(const vector<int>& arr) {\n    // if not arr:\n    if (arr.empty()) {\n        // return None\n        return 0;\n    }\n    // if 0 in arr:\n    if (find(arr.begin(), arr.end(), 0) != arr.end()) {\n        // return 0\n        return 0;\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    int sign = count_if(arr.begin(), arr.end(), [](int n) { return n < 0; }) % 2 == 1 ? -1 : 1;\n    // return sign * sum([abs(n) for n in arr])\n    return sign * accumulate(arr.begin(), arr.end(), 0, [](int a, int b) { return a + abs(b); });\n}\n",
            "vector<int> minPath(const vector<vector<int>>& grid, int k) {\n    // n = len(grid)\n    int n = grid.size();\n    // min_val = n * n + 1\n    int min_val = n * n + 1;\n    // for i in range(n):\n    for (int i = 0; i < n; ++i) {\n        // for j in range(n):\n        for (int j = 0; j < n; ++j) {\n            // if grid[i][j] == 1:\n            if (grid[i][j] == 1) {\n                // temp = []\n                vector<int> temp;\n                // if i != 0:\n                if (i != 0) {\n                    // temp.append(grid[i - 1][j])\n                    temp.push_back(grid[i - 1][j]);\n                }\n                // if j != 0:\n                if (j != 0) {\n                    // temp.append(grid[i][j - 1])\n                    temp.push_back(grid[i][j - 1]);\n                }\n                // if i != n - 1:\n                if (i != n - 1) {\n                    // temp.append(grid[i + 1][j])\n                    temp.push_back(grid[i + 1][j]);\n                }\n                // if j != n - 1:\n                if (j != n - 1) {\n                    // temp.append(grid[i][j + 1])\n                    temp.push_back(grid[i][j + 1]);\n                }\n                // min_val = min(temp)\n                min_val = min(min_val, *min_element(temp.begin(), temp.end()));\n            }\n        }\n    }\n    // result = []\n    vector<int> result;\n    // for i in range(k):\n    for (int i = 0; i < k; ++i) {\n        // result.append(1 if i % 2 == 0 else min_val)\n        result.push_back(i % 2 == 0 ? 1 : min_val);\n    }\n    // return result\n    return result;\n}\n",
            "vector<int> tri(int n) {\n    // if n == 0:\n    if (n == 0) {\n        // return [1]\n        return {1};\n    }\n    // seq = [1, 3]\n    vector<int> seq = {1, 3};\n    // for i in range(2, n + 1):\n    for (int i = 2; i <= n; ++i) {\n        // if i % 2 == 0:\n        if (i % 2 == 0) {\n            // seq.append(i / 2 + 1)\n            seq.push_back(i / 2 + 1);\n        } else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq.push_back(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n        }\n    }\n    // return seq\n    return seq;\n}\n",
            "int digits(int n) {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    vector<int> odds;\n    string str_n = to_string(n);\n    for (char d : str_n) {\n        if (d % 2 == 1) {\n            odds.push_back(d - '0');\n        }\n    }\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    return odds.size() > 0 ? accumulate(odds.begin(), odds.end(), 1, multiplies<int>()) : 0;\n}\n",
            "bool isNested(const string& s) {\n    // open_idx = []\n    vector<int> open_idx;\n    // close_idx = []\n    vector<int> close_idx;\n    // for i, ch in enumerate(s):\n    for (int i = 0; i < s.size(); i++) {\n        char ch = s[i];\n        // if ch == '[':\n        if (ch == '[') {\n            // open_idx.append(i)\n            open_idx.push_back(i);\n        }\n        // elif ch == ']':\n        else if (ch == ']') {\n            // close_idx.append(i)\n            close_idx.push_back(i);\n        }\n    }\n    // close_idx.reverse()\n    reverse(close_idx.begin(), close_idx.end());\n    // cnt = 0\n    int cnt = 0;\n    // i = 0\n    int i = 0;\n    // l = len(close_idx)\n    int l = close_idx.size();\n    // for idx in open_idx:\n    for (int idx : open_idx) {\n        // if i < l and idx < close_idx[i]:\n        if (i < l && idx < close_idx[i]) {\n            // cnt += 1\n            cnt++;\n            // i += 1\n            i++;\n        }\n    }\n    // return cnt >= 2\n    return cnt >= 2;\n}\n",
            "int sumSquares(const vector<float>& lst) {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    int result = 0;\n    for (float n : lst) {\n        result += pow(ceil(n), 2);\n    }\n    return result;\n}\n",
            "bool checkIfLastCharIsALetter(const string& txt) {\n    // if not txt:\n    if (txt.empty()) {\n        // return False\n        return false;\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    string last = txt.substr(txt.rfind(' ') + 1);\n    // return len(last) == 1 and last[0].isalpha()\n    return last.size() == 1 && last[0].isalpha();\n}\n",
            "int canArrange(const vector<int>& arr) {\n    // if len (arr) <= 1:\n    if (arr.size() <= 1) {\n        // return -1\n        return -1;\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    vector<int> idx;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            idx.push_back(i);\n        }\n    }\n    // return max(idx, default=-1)\n    return idx.empty() ? -1 : *max_element(idx.begin(), idx.end());\n}\n",
            "vector<int> largestSmallestIntegers(const vector<int>& lst) {\n    // neg = [i for i in lst if i < 0]\n    vector<int> neg;\n    for (int i : lst) {\n        if (i < 0) {\n            neg.push_back(i);\n        }\n    }\n    // pos = [i for i in lst if i > 0]\n    vector<int> pos;\n    for (int i : lst) {\n        if (i > 0) {\n            pos.push_back(i);\n        }\n    }\n    // max_neg = max(neg) if len(neg) > 0 else None\n    int max_neg = numeric_limits<int>::min();\n    if (neg.size() > 0) {\n        max_neg = *max_element(neg.begin(), neg.end());\n    }\n    // min_pos = min(pos) if len(pos) > 0 else None\n    int min_pos = numeric_limits<int>::max();\n    if (pos.size() > 0) {\n        min_pos = *min_element(pos.begin(), pos.end());\n    }\n    // return [max_neg, min_pos]\n    return {max_neg, min_pos};\n}\n",
            "double anyToReal(const string& o) {\n    return stod(o);\n}\ndouble anyToReal(int o) {\n    return o;\n}\ndouble anyToReal(double o) {\n    return o;\n}\ndouble compareOne(const string& a, const string& b) {\n    double a1 = anyToReal(a);\n    double b1 = anyToReal(b);\n    if (a1 == b1) {\n        return 0;\n    }\n    return a1 > b1 ? a1 : b1;\n}\ndouble compareOne(int a, int b) {\n    double a1 = anyToReal(a);\n    double b1 = anyToReal(b);\n    if (a1 == b1) {\n        return 0;\n    }\n    return a1 > b1 ? a1 : b1;\n}\ndouble compareOne(double a, double b) {\n    double a1 = anyToReal(a);\n    double b1 = anyToReal(b);\n    if (a1 == b1) {\n        return 0;\n    }\n    return a1 > b1 ? a1 : b1;\n}\n",
            "bool isEqualToSumEven(int32_t n) {\n    // return n % 2 == 0 and n >= 8\n    return n % 2 == 0 && n >= 8;\n}\n",
            "int specialFactorial(int n) {\n    // fact = 1\n    int fact = 1;\n    // result = 1\n    int result = 1;\n    // for i in range(1, n + 1):\n    for (int i = 1; i <= n; ++i) {\n        // fact *= i\n        fact *= i;\n        // result *= fact\n        result *= fact;\n    }\n    // return result\n    return result;\n}\n",
            "string fixSpaces(const string& txt) {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    return regex_replace(regex_replace(txt, regex(R\"(\\s{3,})\"), \"-\"), regex(R\"(\\s)\"), \"_\");\n}\n",
            "string fileNameCheck(const string& file_name) {\n    // suf = [\"txt\", \"exe\", \"dll\"]\n    vector<string> suf = {\"txt\", \"exe\", \"dll\"};\n    // lst = file_name.split(\".\")\n    vector<string> lst = split(file_name, \".\");\n    if (lst.size() != 2 || !find(suf.begin(), suf.end(), lst[1]) || lst[0].size() == 0 || !isalpha(lst[0][0]) || count_if(lst[0].begin(), lst[0].end(), [](char x) { return isdigit(x); }) > 3) {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n",
            "int sumSquares(const vector<int>& lst) {\n    // result = 0\n    int result = 0;\n    // for i in range(len(lst)):\n    for (int i = 0; i < lst.size(); i++) {\n        // if i % 3 == 0:\n        if (i % 3 == 0) {\n            // result += pow(lst[i], 2)\n            result += pow(lst[i], 2);\n        }\n        // elif i % 4 == 0:\n        else if (i % 4 == 0) {\n            // result += pow(lst[i], 3)\n            result += pow(lst[i], 3);\n        }\n        // else:\n        else {\n            // result += lst[i]\n            result += lst[i];\n        }\n    }\n    // return result\n    return result;\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nstring wordsInSentence(const string& sentence) {\n    // words = sentence.split(\" \")\n    vector<string> words = split(sentence, ' ');\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    string result;\n    for (const string& w : words) {\n        if (isPrime(w.size())) {\n            result += w + ' ';\n        }\n    }\n    return result;\n}\n",
            "bool simplify(const string& x, const string& n) {\n    // xs = x.split(\"/\")\n    vector<string> xs;\n    {\n        stringstream ss(x);\n        string token;\n        while (getline(ss, token, '/')) {\n            xs.push_back(token);\n        }\n    }\n    // ns = n.split(\"/\")\n    vector<string> ns;\n    {\n        stringstream ss(n);\n        string token;\n        while (getline(ss, token, '/')) {\n            ns.push_back(token);\n        }\n    }\n    // num = int(xs[0]) * int(ns[0])\n    int num = stoi(xs[0]) * stoi(ns[0]);\n    // den = int(xs[1]) * int(ns[1])\n    int den = stoi(xs[1]) * stoi(ns[1]);\n    // return num % den == 0\n    return num % den == 0;\n}\n",
            "int digitsSum(int n) {\n    string n_str = to_string(n);\n    if (n >= 0) {\n        return accumulate(n_str.begin(), n_str.end(), 0, [](int a, char b) { return a + b - '0'; });\n    } else {\n        return (n_str[0] - '0') * 2 + digitsSum(abs(n));\n    }\n}\nvector<int> orderByPoints(const vector<int>& nums) {\n    return vector<int>(nums.begin(), nums.end());\n}\n",
            "int specialFilter(const vector<int>& nums) {\n    // odds = \"13579\"\n    string odds = \"13579\";\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    return count_if(nums.begin(), nums.end(), [&](int n) {\n        return n > 10 && n % 2 == 1 && odds.find(to_string(n)[0]) != string::npos;\n    });\n}\n",
            "int getMaxTriples(int n) {\n    // c = [0, 0, 0]\n    vector<int> c(3, 0);\n    // for i in range(1, n + 1):\n    for (int i = 1; i <= n; i++) {\n        // a = i * i - i + 1\n        int a = i * i - i + 1;\n        // c[a % 3] += 1\n        c[a % 3]++;\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6;\n}\n",
            "vector<string> bf(const string& planet1, const string& planet2) {\n    // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    vector<string> names = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    // if planet1 not in names or planet2 not in names:\n    if (find(names.begin(), names.end(), planet1) == names.end() || find(names.begin(), names.end(), planet2) == names.end()) {\n        // return []\n        return {};\n    }\n    // l = names.index(planet1)\n    int l = distance(names.begin(), find(names.begin(), names.end(), planet1));\n    // r = names.index(planet2)\n    int r = distance(names.begin(), find(names.begin(), names.end(), planet2));\n    // if l > r:\n    if (l > r) {\n        // l, r = r, l\n        swap(l, r);\n    }\n    // if l == r:\n    if (l == r) {\n        // return []\n        return {};\n    }\n    // return names[l + 1 : r]\n    return vector<string>(names.begin() + l + 1, names.begin() + r);\n}\n",
            "vector<string> sortedListSum(const vector<string>& lst) {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    vector<string> result;\n    for (const string& s : lst) {\n        if (s.size() % 2 == 0) {\n            result.push_back(s);\n        }\n    }\n    // return sorted(result, key=lambda x: (len(x), x))\n    sort(result.begin(), result.end(), [](const string& a, const string& b) {\n        return a.size() < b.size() || (a.size() == b.size() && a < b);\n    });\n    return result;\n}\n",
            "int xOrY(int n, int x, int y) {\n    // if n < 2:\n    if (n < 2) {\n        // return y\n        return y;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return y\n            return y;\n        }\n    }\n    // return x\n    return x;\n}\n",
            "int doubleTheDifference(const vector<float>& lst) {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    int result = 0;\n    for (float n : lst) {\n        if (n >= 0 && fmod(n, 2) == 1) {\n            result += n * n;\n        }\n    }\n    return result;\n}\n",
            "vector<int> compare(const vector<int>& game, const vector<int>& guess) {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    vector<int> result;\n    for (int i = 0; i < game.size(); ++i) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;\n}\n",
            "string strongestExtension(const string& class_name, const vector<string>& extensions) {\n    // max_s = float(\"-inf\")\n    float max_s = -INFINITY;\n    // max_ext = \"\"\n    string max_ext;\n    // for ext in extensions:\n    for (const string& ext : extensions) {\n        // upper = len([c for c in ext if c.isupper()])\n        int upper = count_if(ext.begin(), ext.end(), [](char c) { return isupper(c); });\n        // lower = len([c for c in ext if c.islower()])\n        int lower = count_if(ext.begin(), ext.end(), [](char c) { return islower(c); });\n        // s = upper - lower\n        int s = upper - lower;\n        // if s > max_s:\n        if (s > max_s) {\n            // max_s = s\n            max_s = s;\n            // max_ext = ext\n            max_ext = ext;\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    return class_name + \".\" + max_ext;\n}\n",
            "bool cycpatternCheck(const string& a, const string& b) {\n    // if len(a) < len(b):\n    if (a.size() < b.size()) {\n        // return False\n        return false;\n    }\n    // for i in range(len(b)):\n    for (int i = 0; i < b.size(); ++i) {\n        // if b[i:] + b[:i] in a:\n        if (a.find(b.substr(i) + b.substr(0, i)) != string::npos) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "vector<int> evenOddCount(int num) {\n    // ds = str(abs(num))\n    string ds = to_string(abs(num));\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    int even = 0;\n    for (char d : ds) {\n        if (d % 2 == 0) {\n            even++;\n        }\n    }\n    // return [even, len(ds) - even]\n    return {even, ds.size() - even};\n}\n",
            "string intToMiniRoman(int num) {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    vector<string> numerals = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    // res = []\n    vector<string> res;\n    // for i in range(len(values)):\n    for (int i = 0; i < values.size(); i++) {\n        // while num >= values[i]:\n        while (num >= values[i]) {\n            // res.append(numerals[i])\n            res.push_back(numerals[i]);\n            // num -= values[i]\n            num -= values[i];\n        }\n    }\n    // return \"\".join(res)\n    return string(res.begin(), res.end());\n}\n",
            "bool rightAngleTriangle(int a, int b, int c) {\n    // s = sorted([a, b, c])\n    vector<int> s = {a, b, c};\n    sort(s.begin(), s.end());\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n}\n",
            "string findMax(const vector<string>& words) {\n    // max_cnt = 0\n    int max_cnt = 0;\n    // max_w = \"\"\n    string max_w = \"\";\n    // for w in words:\n    for (const string& w : words) {\n        // cnt = len(set(w))\n        int cnt = 0;\n        set<char> s;\n        for (char c : w) {\n            s.insert(c);\n        }\n        cnt = s.size();\n        // if cnt > max_cnt:\n        if (cnt > max_cnt) {\n            // max_cnt = cnt\n            max_cnt = cnt;\n            // max_w = w\n            max_w = w;\n        }\n        // elif cnt == max_cnt:\n        else if (cnt == max_cnt) {\n            // max_w = min(max_w, w)\n            max_w = min(max_w, w);\n        }\n    }\n    // return max_w\n    return max_w;\n}\n",
            "vector<int> eat(int num, int need, int remaining) {\n    // if need <= remaining:\n    if (need <= remaining) {\n        // return [num + need, remaining - need]\n        return {num + need, remaining - need};\n    } else {\n        // return [num + remaining, 0]\n        return {num + remaining, 0};\n    }\n}\n",
            "int doAlgebra(const vector<string>& operators, const vector<int>& operands) {\n    // ops = operators.copy()\n    vector<string> ops = operators;\n    // nums = operands.copy()\n    vector<int> nums = operands;\n    // i = len(ops) - 1\n    int i = ops.size() - 1;\n    // while i >= 0:\n    while (i >= 0) {\n        // if ops[i] == \"**\":\n        if (ops[i] == \"**\") {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            nums[i] = pow(nums[i], nums[i + 1]);\n            // nums.pop(i + 1)\n            nums.erase(nums.begin() + i + 1);\n            // ops.pop(i)\n            ops.erase(ops.begin() + i);\n        }\n        // i -= 1\n        i -= 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while (i < ops.size()) {\n        // if ops[i] == \"*\":\n        if (ops[i] == \"*\") {\n            // nums[i] = nums[i] * nums[i + 1]\n            nums[i] = nums[i] * nums[i + 1];\n            // nums.pop(i + 1)\n            nums.erase(nums.begin() + i + 1);\n            // ops.pop(i)\n            ops.erase(ops.begin() + i);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"//\":\n        else if (ops[i] == \"//\") {\n            // nums[i] = nums[i] // nums[i + 1]\n            nums[i] = nums[i] / nums[i + 1];\n            // nums.pop(i + 1)\n            nums.erase(nums.begin() + i + 1);\n            // ops.pop(i)\n            ops.erase(ops.begin() + i);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while (i < ops.size()) {\n        // if ops[i] == \"+\":\n        if (ops[i] == \"+\") {\n            // nums[i] = nums[i] + nums[i + 1]\n            nums[i] = nums[i] + nums[i + 1];\n            // nums.pop(i + 1)\n            nums.erase(nums.begin() + i + 1);\n            // ops.pop(i)\n            ops.erase(ops.begin() + i);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"-\":\n        else if (ops[i] == \"-\") {\n            // nums[i] = nums[i] - nums[i + 1]\n            nums[i] = nums[i] - nums[i + 1];\n            // nums.pop(i + 1)\n            nums.erase(nums.begin() + i + 1);\n            // ops.pop(i)\n            ops.erase(ops.begin() + i);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // return nums[0]\n    return nums[0];\n}\n",
            "string solve(const string& s) {\n    // if not any(ch.isalpha() for ch in s):\n    if (find_if(s.begin(), s.end(), [](char ch) { return isalpha(ch); }) == s.end()) {\n        // return s[::-1]\n        return string(s.rbegin(), s.rend());\n    }\n    // result = []\n    string result;\n    // for ch in s:\n    for (char ch : s) {\n        // if not ch.isalpha():\n        if (!isalpha(ch)) {\n            // result.append(ch)\n            result.push_back(ch);\n        }\n        // elif ch.isupper():\n        else if (isupper(ch)) {\n            // result.append(ch.lower())\n            result.push_back(tolower(ch));\n        }\n        // elif ch.islower():\n        else if (islower(ch)) {\n            // result.append(ch.upper())\n            result.push_back(toupper(ch));\n        }\n    }\n    // return \"\".join(result)\n    return result;\n}\n",
            "optional<string> stringToMd5(const string& txt) {\n    // if not txt:\n    if (txt.empty()) {\n        // return None\n        return nullopt;\n    }\n    // md5_hash = hashlib.md5()\n    CryptoPP::MD5 md5_hash;\n    // txt_bytes = txt.encode()\n    string txt_bytes = txt;\n    // md5_hash.update(txt_bytes)\n    md5_hash.Update((const byte*)txt_bytes.c_str(), txt_bytes.size());\n    // md5_encoded = md5_hash.hexdigest()\n    string md5_encoded;\n    md5_hash.Final(md5_encoded);\n    // return md5_encoded\n    return md5_encoded;\n}\n",
            "vector<int> generateIntegers(int a, int b) {\n    // lower = max(2, min(a, b))\n    int lower = max(2, min(a, b));\n    // upper = min(8, max(a, b))\n    int upper = min(8, max(a, b));\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    vector<int> result;\n    for (int i = lower; i <= upper; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n"
        ],
        "csharp": [
            "class Global {\n    public static bool HasCloseElements(IList<float> numbers, float threshold) {\n        // for i in range(len(numbers)):\n        for (int i = 0; i < numbers.Count; i++) {\n            // for j in range(i + 1, len(numbers)):\n            for (int j = i + 1; j < numbers.Count; j++) {\n                // if abs(numbers[i] - numbers[j]) < threshold:\n                if (Math.Abs(numbers[i] - numbers[j]) < threshold) {\n                    // return True\n                    return true;\n                }\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static IList<string> SeparateParenGroups(string parenString) {\n        // groups = []\n        var groups = new List<string>();\n        // stk = []\n        var stk = new Stack<char>();\n        // current_group = \"\"\n        var currentGroup = \"\";\n        // parens = paren_string.replace(\" \", \"\")\n        var parens = parenString.Replace(\" \", \"\");\n        // for ch in parens:\n        foreach (var ch in parens) {\n            // if ch == \"(\":\n            if (ch == '(') {\n                // stk.append(ch)\n                stk.Push(ch);\n                // current_group += ch\n                currentGroup += ch;\n            }\n            // elif ch == \")\":\n            else if (ch == ')') {\n                // stk.pop()\n                stk.Pop();\n                // current_group += ch\n                currentGroup += ch;\n                // if not stk:\n                if (stk.Count == 0) {\n                    // groups.append(current_group)\n                    groups.Add(currentGroup);\n                    // current_group = \"\"\n                    currentGroup = \"\";\n                }\n            }\n        }\n        // return groups\n        return groups;\n    }\n}\n",
            "class Global {\n    public static float TruncateNumber(float num) {\n        // return num - floor(num)\n        return num - Math.Floor(num);\n    }\n}\n",
            "class Global {\n    public static bool BelowZero(IList<int> operations) {\n        // balance = 0\n        int balance = 0;\n        // for op in operations:\n        foreach (var op in operations) {\n            // balance += op\n            balance += op;\n            // if balance < 0:\n            if (balance < 0) {\n                // return True\n                return true;\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static double MeanAbsoluteDeviation(IList<double> numbers) {\n        // mean = sum(numbers) / len(numbers)\n        double mean = numbers.Sum() / numbers.Count;\n        // deviation = sum(abs(x - mean) for x in numbers)\n        double deviation = numbers.Sum(x => Math.Abs(x - mean));\n        // return deviation / len(numbers)\n        return deviation / numbers.Count;\n    }\n}\n",
            "class Global {\n    public static IList<int> Intersperse(IList<int> numbers, int delimiter) {\n        // result = []\n        var result = new List<int>();\n        // for i in range(len(numbers)):\n        for (int i = 0; i < numbers.Count; i++) {\n            // if i != 0:\n            if (i != 0) {\n                // result.append(delimiter)\n                result.Add(delimiter);\n            }\n            // result.append(numbers[i])\n            result.Add(numbers[i]);\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static IList<int> ParseNestedParens(string parenString) {\n        // result = []\n        var result = new List<int>();\n        // paren_groups = paren_string.split()\n        var parenGroups = parenString.Split(' ');\n        // for group in paren_groups:\n        foreach (var group in parenGroups) {\n            // max_depth = 0\n            var maxDepth = 0;\n            // depth = 0\n            var depth = 0;\n            // for ch in group:\n            foreach (var ch in group) {\n                // if ch == \"(\":\n                if (ch == '(') {\n                    // depth += 1\n                    depth += 1;\n                    // max_depth = max(max_depth, depth)\n                    maxDepth = Math.Max(maxDepth, depth);\n                }\n                // elif ch == \")\":\n                else if (ch == ')') {\n                    // depth -= 1\n                    depth -= 1;\n                }\n            }\n            // result.append(max_depth)\n            result.Add(maxDepth);\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static IList<string> FilterBySubstring(IList<string> strs, string substring) {\n        // return [s for s in strs if substring in s]\n        return strs.Where(s => s.Contains(substring)).ToList();\n    }\n}\n",
            "class Global {\n    public static IList<int> SumProduct(IList<int> numbers) {\n        // n_sum = sum(numbers)\n        var nSum = numbers.Sum();\n        // n_product = reduce(lambda x, y: x * y, numbers, 1)\n        var nProduct = numbers.Aggregate(1, (x, y) => x * y);\n        // return [n_sum, n_product]\n        return new List<int> { nSum, nProduct };\n    }\n}\n",
            "class Global {\n    public static IList<int> RollingMax(IList<int> numbers) {\n        // max_so_far = float(\"-inf\")\n        var maxSoFar = float.MinValue;\n        // result = []\n        var result = new List<int>();\n        // for num in numbers:\n        foreach (var num in numbers) {\n            // max_so_far = max(max_so_far, num)\n            maxSoFar = Math.Max(maxSoFar, num);\n            // result.append(max_so_far)\n            result.Add(maxSoFar);\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static bool IsPalindrome(string s) {\n        // return s == s[::-1]\n        return s == new string(s.Reverse());\n    }\n    public static string MakePalindrome(string s) {\n        // if is_palindrome(s):\n        if (IsPalindrome(s)) {\n            // return s\n            return s;\n        }\n        // for i in range(len(s)):\n        for (int i = 0; i < s.Length; i++) {\n            // if is_palindrome(s[i:]):\n            if (IsPalindrome(s.Substring(i))) {\n                // return s + s[:i][::-1]\n                return s + s.Substring(0, i).Reverse();\n            }\n        }\n        // return \"\"\n        return \"\";\n    }\n}\n",
            "class Global {\n    public static string StringXor(string a, string b) {\n        // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n        return string.Join(\"\", a.Zip(b, (x, y) => x == y ? \"0\" : \"1\"));\n    }\n}\n",
            "class Global {\n    public static string Longest(IList<string> strs) {\n        // if not strs:\n        if (strs == null || strs.Count == 0) {\n            // return None\n            return null;\n        }\n        // longest_s = strs[0]\n        var longestS = strs[0];\n        // for s in strs:\n        foreach (var s in strs) {\n            // if len(s) > len(longest_s):\n            if (s.Length > longestS.Length) {\n                // longest_s = s\n                longestS = s;\n            }\n        }\n        // return longest_s\n        return longestS;\n    }\n}\n",
            "class Global {\n    public static int GreatestCommonDivisor(int a, int b) {\n        // if b == 0:\n        if (b == 0) {\n            // return a\n            return a;\n        } else {\n            // return greatest_common_divisor(b, a % b)\n            return GreatestCommonDivisor(b, a % b);\n        }\n    }\n}\n",
            "class Global {\n    public static IList<string> AllPrefixes(string s) {\n        // prefixes = []\n        var prefixes = new List<string>();\n        // for i in range(len(s)):\n        for (int i = 0; i < s.Length; i++) {\n            // prefixes.append(s[: i + 1])\n            prefixes.Add(s.Substring(0, i + 1));\n        }\n        // return prefixes\n        return prefixes;\n    }\n}\n",
            "class Global {\n    public static string StringSequence(int n) {\n        // return \" \".join([str(i) for i in range(n + 1)])\n        return string.Join(\" \", Enumerable.Range(0, n + 1).Select(i => i.ToString()));\n    }\n}\n",
            "class Global {\n    public static int CountDistinctCharacters(string s) {\n        // return len(set(s.lower()))\n        return new HashSet<char>(s.ToLower()).Count;\n    }\n}\n",
            "class Global {\n    public static IList<int> ParseMusic(string musicString) {\n        // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n        var durations = new Dictionary<string, int> {\n            {\"o\", 4},\n            {\"o|\", 2},\n            {\".|\", 1}\n        };\n        // notes = music_string.split()\n        var notes = musicString.Split(' ');\n        // return [durations[note] for note in notes]\n        return notes.Select(note => durations[note]).ToList();\n    }\n}\n",
            "class Global {\n    public static int HowManyTimes(string s, string substring) {\n        // times = 0\n        int times = 0;\n        // for i in range(len(s) - len(substring) + 1):\n        for (int i = 0; i < s.Length - substring.Length + 1; i++) {\n            // if s[i : i + len(substring)] == substring:\n            if (s.Substring(i, substring.Length) == substring) {\n                // times += 1\n                times++;\n            }\n        }\n        // return times\n        return times;\n    }\n}\n",
            "class Global {\n    public static string SortNumbers(string numbers) {\n        // num_dict = {\n        //     \"zero\": 0,\n        //     \"one\": 1,\n        //     \"two\": 2,\n        //     \"three\": 3,\n        //     \"four\": 4,\n        //     \"five\": 5,\n        //     \"six\": 6,\n        //     \"seven\": 7,\n        //     \"eight\": 8,\n        //     \"nine\": 9,\n        // }\n        var numDict = new Dictionary<string, int> {\n            { \"zero\", 0 },\n            { \"one\", 1 },\n            { \"two\", 2 },\n            { \"three\", 3 },\n            { \"four\", 4 },\n            { \"five\", 5 },\n            { \"six\", 6 },\n            { \"seven\", 7 },\n            { \"eight\", 8 },\n            { \"nine\", 9 },\n        };\n        // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n        var numList = new List<string>(\n            Array.FindAll(numbers.Split(\" \"), x => numDict.ContainsKey(x))\n        );\n        // num_list.sort(key=lambda x: num_dict[x])\n        numList.Sort((x, y) => numDict[x].CompareTo(numDict[y]));\n        // return \" \".join(num_list)\n        return string.Join(\" \", numList);\n    }\n}\n",
            "class Global {\n    public static IList<float> FindClosestElements(IList<float> numbers) {\n        // sorted_numbers = sorted(numbers)\n        var sortedNumbers = new List<float>(numbers);\n        sortedNumbers.Sort();\n        // min_diff = float(\"inf\")\n        var minDiff = float.PositiveInfinity;\n        // closest_pair = []\n        var closestPair = new List<float>();\n        // for i in range(1, len(sorted_numbers)):\n        for (int i = 1; i < sortedNumbers.Count; i++) {\n            // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n            var diff = sortedNumbers[i] - sortedNumbers[i - 1];\n            // if diff < min_diff:\n            if (diff < minDiff) {\n                // min_diff = diff\n                minDiff = diff;\n                // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n                closestPair.Clear();\n                closestPair.Add(sortedNumbers[i - 1]);\n                closestPair.Add(sortedNumbers[i]);\n            }\n        }\n        // return closest_pair\n        return closestPair;\n    }\n}\n",
            "class Global {\n    public static IList<float> RescaleToUnit(IList<float> numbers) {\n        // min_num = min(numbers)\n        var minNum = numbers[0];\n        foreach (var num in numbers) {\n            if (num < minNum) {\n                minNum = num;\n            }\n        }\n        // max_num = max(numbers)\n        var maxNum = numbers[0];\n        foreach (var num in numbers) {\n            if (num > maxNum) {\n                maxNum = num;\n            }\n        }\n        // if min_num == max_num:\n        if (minNum == maxNum) {\n            // return [0.0] * len(numbers)\n            var result = new List<float>();\n            for (int i = 0; i < numbers.Count; i++) {\n                result.Add(0.0f);\n            }\n            return result;\n        }\n        // else:\n        else {\n            // return [(num - min_num) / (max_num - min_num) for num in numbers]\n            var result = new List<float>();\n            foreach (var num in numbers) {\n                result.Add((num - minNum) / (maxNum - minNum));\n            }\n            return result;\n        }\n    }\n}\n",
            "class Global {\n    public static IList<int> FilterIntegers(IList<object> values) {\n        // return [x for x in values if isinstance(x, int)]\n        return values.Where(x => x is int).Cast<int>().ToList();\n    }\n}\n",
            "class Global {\n    public static int StrLength(string s) {\n        // return len(s)\n        return s.Length;\n    }\n}\n",
            "class Global {\n    public static int LargestDivisor(int n) {\n        // for i in range(2, n):\n        for (int i = 2; i < n; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return n // i\n                return n / i;\n            }\n        }\n        // return 1\n        return 1;\n    }\n}\n",
            "class Global {\n    public static IList<int> Factorize(int n) {\n        // factors = []\n        var factors = new List<int>();\n        // divisor = 2\n        int divisor = 2;\n        // while divisor <= n:\n        while (divisor <= n) {\n            // if n % divisor == 0:\n            if (n % divisor == 0) {\n                // factors.append(divisor)\n                factors.Add(divisor);\n                // n //= divisor\n                n /= divisor;\n            } else {\n                // divisor += 1\n                divisor++;\n            }\n        }\n        // return factors\n        return factors;\n    }\n}\n",
            "class Global {\n    public static IList<int> RemoveDuplicates(IList<int> numbers) {\n        // counts = {}\n        var counts = new Dictionary<int, int>();\n        // for num in numbers:\n        foreach (var num in numbers) {\n            // counts[num] = counts.get(num, 0) + 1\n            counts[num] = counts.ContainsKey(num) ? counts[num] + 1 : 1;\n        }\n        // res = [num for num in numbers if counts[num] == 1]\n        var res = new List<int>();\n        foreach (var num in numbers) {\n            if (counts[num] == 1) {\n                res.Add(num);\n            }\n        }\n        // return res\n        return res;\n    }\n}\n",
            "class Global {\n    public static string FlipCase(string s) {\n        // flipped = []\n        var flipped = new List<char>();\n        // for ch in s:\n        foreach (var ch in s) {\n            // if not ch.isalpha():\n            if (!char.IsLetter(ch)) {\n                // flipped.append(ch)\n                flipped.Add(ch);\n            }\n            // elif ch.islower():\n            else if (char.IsLower(ch)) {\n                // flipped.append(ch.upper())\n                flipped.Add(char.ToUpper(ch));\n            }\n            // elif ch.isupper():\n            else if (char.IsUpper(ch)) {\n                // flipped.append(ch.lower())\n                flipped.Add(char.ToLower(ch));\n            }\n        }\n        // return ''.join(flipped)\n        return new string(flipped.ToArray());\n    }\n}\n",
            "class Global {\n    public static string Concatenate(IList<string> strs) {\n        // return \"\".join(strs)\n        return string.Join(\"\", strs);\n    }\n}\n",
            "class Global {\n    public static IList<string> FilterByPrefix(IList<string> strs, string prefixStr) {\n        // return [s for s in strs if s.startswith(prefix_str)]\n        return strs.Where(s => s.StartsWith(prefixStr)).ToList();\n    }\n}\n",
            "class Global {\n    public static IList<int> GetPositive(IList<int> l) {\n        // return [num for num in l if num > 0]\n        return l.Where(num => num > 0).ToList();\n    }\n}\n",
            "class Global {\n    public static bool IsPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= (int)Math.Floor(Math.Sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n}\n",
            "class Global {\n    public static double Poly(IList<int> xs, double x) {\n        // res = 0.0\n        double res = 0.0;\n        // for i in range(len(xs)):\n        for (int i = 0; i < xs.Count; i++) {\n            // res += xs[i] * x**i\n            res += xs[i] * Math.Pow(x, i);\n        }\n        // return res\n        return res;\n    }\n    public static double FindZero(IList<int> xs) {\n        // x1, x2 = 1.0, -1.0\n        double x1 = 1.0, x2 = -1.0;\n        // while poly(xs, x1) * poly(xs, x2) > 0:\n        while (Poly(xs, x1) * Poly(xs, x2) > 0) {\n            // x1 *= 2\n            x1 *= 2;\n            // x2 *= 2\n            x2 *= 2;\n        }\n        // while abs(x1 - x2) > 1e-10:\n        while (Math.Abs(x1 - x2) > 1e-10) {\n            // mid = (x1 + x2) / 2\n            double mid = (x1 + x2) / 2;\n            // if poly(xs, mid) == 0:\n            if (Poly(xs, mid) == 0) {\n                // return mid\n                return mid;\n            }\n            // elif poly(xs, mid) * poly(xs, x1) < 0:\n            else if (Poly(xs, mid) * Poly(xs, x1) < 0) {\n                // x2 = mid\n                x2 = mid;\n            }\n            // else:\n            else {\n                // x1 = mid\n                x1 = mid;\n            }\n        }\n        // return (x1 + x2) / 2\n        return (x1 + x2) / 2;\n    }\n}\n",
            "class Global {\n    public static IList<int> SortThird(IList<int> l) {\n        // sorted_third = sorted(l[::3])\n        var sortedThird = new List<int>(l.Count);\n        for (int i = 0; i < l.Count; i += 3) {\n            sortedThird.Add(l[i]);\n        }\n        sortedThird.Sort();\n        // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n        var result = new List<int>(l.Count);\n        for (int i = 0; i < l.Count; i++) {\n            result.Add(i % 3 == 0 ? sortedThird[i / 3] : l[i]);\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static IList<int> ListUnique(IList<int> l) {\n        // return sorted(list(set(l)))\n        return new List<int>(new HashSet<int>(l));\n    }\n}\n",
            "class Global {\n    public static int MaxElement(IList<int> l) {\n        // if not l:\n        if (l == null || l.Count == 0) {\n            // return 0\n            return 0;\n        }\n        // return max(l)\n        return l.Max();\n    }\n}\n",
            "class Global {\n    public static int FizzBuzz(int n) {\n        // cnt = 0\n        int cnt = 0;\n        // for i in range(n):\n        for (int i = 0; i < n; i++) {\n            // if i % 11 == 0 or i % 13 == 0:\n            if (i % 11 == 0 || i % 13 == 0) {\n                // cnt += str(i).count(\"7\")\n                cnt += i.ToString().Count(c => c == '7');\n            }\n        }\n        // return cnt\n        return cnt;\n    }\n}\n",
            "class Global {\n    public static IList<int> SortEven(IList<int> l) {\n        // sorted_even = sorted(l[::2])\n        var sortedEven = new List<int>(l.Count / 2);\n        for (int i = 0; i < l.Count; i += 2) {\n            sortedEven.Add(l[i]);\n        }\n        sortedEven.Sort();\n        // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n        var result = new List<int>(l.Count);\n        for (int i = 0; i < l.Count; i++) {\n            result.Add(i % 2 == 0 ? sortedEven[i / 2] : l[i]);\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static string EncodeCyclic(string s) {\n        // result = []\n        var result = new List<string>();\n        // for i in range(0, len(s), 3):\n        for (int i = 0; i < s.Length; i += 3) {\n            // if i + 3 > len(s):\n            if (i + 3 > s.Length) {\n                // result.append(s[i:])\n                result.Add(s.Substring(i));\n            } else {\n                // result.append(s[i+1:i+3])\n                result.Add(s.Substring(i + 1, 2));\n                // result.append(s[i])\n                result.Add(s[i].ToString());\n            }\n        }\n        // return \"\".join(result)\n        return string.Join(\"\", result);\n    }\n    public static string DecodeCyclic(string s) {\n        return EncodeCyclic(EncodeCyclic(s));\n    }\n}\n",
            "class Global {\n    public static bool IsPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= (int)Math.Floor(Math.Sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static int PrimeFib(int n) {\n        // f = [0, 1]\n        var f = new List<int> { 0, 1 };\n        // cnt = 0\n        var cnt = 0;\n        // while cnt < n:\n        while (cnt < n) {\n            // f = [f[1], f[0] + f[1]]\n            f = new List<int> { f[1], f[0] + f[1] };\n            // if is_prime(f[1]):\n            if (IsPrime(f[1])) {\n                // cnt += 1\n                cnt += 1;\n            }\n        }\n        // return f[1]\n        return f[1];\n    }\n}\n",
            "class Global {\n    public static bool TriplesSumToZero(IList<int> l) {\n        // for i in range(len(l)):\n        for (int i = 0; i < l.Count; i++) {\n            // for j in range(i + 1, len(l)):\n            for (int j = i + 1; j < l.Count; j++) {\n                // for k in range(j + 1, len(l)):\n                for (int k = j + 1; k < l.Count; k++) {\n                    // if l[i] + l[j] + l[k] == 0:\n                    if (l[i] + l[j] + l[k] == 0) {\n                        // return True\n                        return true;\n                    }\n                }\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static int CarRaceCollision(int n) {\n        // return n ** 2\n        return (int)Math.Pow(n, 2);\n    }\n}\n",
            "class Global {\n    public static IList<int> IncrList(IList<int> l) {\n        // return [i + 1 for i in l]\n        return l.Select(i => i + 1).ToList();\n    }\n}\n",
            "class Global {\n    public static bool PairsSumToZero(IList<int> l) {\n        // seen = set()\n        var seen = new HashSet<int>();\n        // for num in l:\n        foreach (var num in l) {\n            // if -num in seen:\n            if (seen.Contains(-num)) {\n                // return True\n                return true;\n            }\n            // seen.add(num)\n            seen.Add(num);\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static string ChangeBase(int x, int bas) {\n        // if x == 0:\n        if (x == 0) {\n            // return \"0\"\n            return \"0\";\n        }\n        // digits = []\n        var digits = new List<string>();\n        // while x > 0:\n        while (x > 0) {\n            // digits.append(str(x % bas))\n            digits.Add(x % bas).ToString();\n            // x //= bas\n            x /= bas;\n        }\n        // return \"\".join(digits[::-1])\n        return string.Join(\"\", digits.ToArray());\n    }\n}\n",
            "class Global {\n    public static double TriangleArea(int a, int h) {\n        // return a * h / 2\n        return (double)a * h / 2;\n    }\n}\n",
            "class Global {\n    public static int Fib4(int n) {\n        // fib = [0, 0, 2, 0]\n        var fib = new int[] { 0, 0, 2, 0 };\n        // for i in range(4, n + 1):\n        for (int i = 4; i <= n; i++) {\n            // fib[i % 4] = sum(fib)\n            fib[i % 4] = fib[0] + fib[1] + fib[2];\n        }\n        // return fib[n % 4]\n        return fib[n % 4];\n    }\n}\n",
            "class Global {\n    public static float Median(IList<float> l) {\n        // sl = sorted(l)\n        var sl = new List<float>(l);\n        sl.Sort();\n        // if len(l) % 2 != 0:\n        if (l.Count % 2 != 0) {\n            // return sl[len(l) // 2]\n            return sl[l.Count / 2];\n        } else {\n            // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n            return (sl[l.Count / 2] + sl[l.Count / 2 - 1]) / 2;\n        }\n    }\n}\n",
            "class Global {\n    public static bool IsPalindrome(string txt) {\n        // return txt == txt[::-1]\n        return txt == new string(txt.Reverse());\n    }\n}\n",
            "class Global {\n    public static int Modp(int n, int p) {\n        // ret = 1\n        int ret = 1;\n        // for _ in range(n):\n        for (int i = 0; i < n; i++) {\n            // ret = (ret * 2) % p\n            ret = (ret * 2) % p;\n        }\n        // return ret\n        return ret;\n    }\n}\n",
            "class Global {\n    public static string EncodeShift(string s) {\n        // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n        var result = new List<char>();\n        foreach (var ch in s) {\n            result.Add((char)(((ch - 'a' + 5) % 26) + 'a'));\n        }\n        // return \"\".join(result)\n        return string.Join(\"\", result);\n    }\n    public static string DecodeShift(string s) {\n        // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n        var result = new List<char>();\n        foreach (var ch in s) {\n            result.Add((char)(((ch - 'a' + 21) % 26) + 'a'));\n        }\n        // return \"\".join(result)\n        return string.Join(\"\", result);\n    }\n}\n",
            "class Global {\n    public static string RemoveVowels(string txt) {\n        // vowels = \"aeiouAEIOU\"\n        var vowels = \"aeiouAEIOU\";\n        // return \"\".join([char for char in txt if char not in vowels])\n        return string.Join(\"\", txt.Where(char => !vowels.Contains(char)));\n    }\n}\n",
            "class Global {\n    public static bool BelowThreshold(IList<int> l, int t) {\n        // return all(x < t for x in l)\n        return l.All(x => x < t);\n    }\n}\n",
            "class Global {\n    public static int Add(int x, int y) {\n        // return x + y\n        return x + y;\n    }\n}\n",
            "class Global {\n    public static bool SameChars(string s0, string s1) {\n        // return set(s0) == set(s1)\n        return new HashSet<char>(s0) == new HashSet<char>(s1);\n    }\n}\n",
            "class Global {\n    public static int Fib(int n) {\n        // if n <= 1:\n        if (n <= 1) {\n            // return n\n            return n;\n        }\n        // else:\n        else {\n            // return fib(n - 1) + fib(n - 2)\n            return Fib(n - 1) + Fib(n - 2);\n        }\n    }\n}\n",
            "class Global {\n    public static bool CorrectBracketing(string brackets) {\n        // depth = 0\n        int depth = 0;\n        // for b in brackets:\n        foreach (var b in brackets) {\n            // if b == \"<\":\n            if (b == '<') {\n                // depth += 1\n                depth += 1;\n            }\n            // elif b == \">\":\n            else if (b == '>') {\n                // depth -= 1\n                depth -= 1;\n            }\n            // if depth < 0:\n            if (depth < 0) {\n                // return False\n                return false;\n            }\n        }\n        // return depth == 0\n        return depth == 0;\n    }\n}\n",
            "class Global {\n    public static bool Monotonic(IList<int> l) {\n        // diff = [y - x for x, y in zip(l, l[1:])]\n        var diff = new List<int>();\n        for (int i = 0; i < l.Count - 1; i++) {\n            diff.Add(l[i + 1] - l[i]);\n        }\n        // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n        return diff.TrueForAll(x => x <= 0) || diff.TrueForAll(x => x >= 0);\n    }\n}\n",
            "class Global {\n    public static IList<int> Common(IList<int> l1, IList<int> l2) {\n        // return sorted(list(set(l1) & set(l2)))\n        return new List<int>(new HashSet<int>(l1) & new HashSet<int>(l2));\n    }\n}\n",
            "class Global {\n    public static int LargestPrimeFactor(int n) {\n        // i = 2\n        int i = 2;\n        // while i * i <= n:\n        while (i * i <= n) {\n            // if n % i:\n            if (n % i != 0) {\n                // i += 1\n                i += 1;\n            } else {\n                // n //= i\n                n /= i;\n            }\n        }\n        // return n\n        return n;\n    }\n}\n",
            "class Global {\n    public static int SumToN(int n) {\n        // return sum(range(n + 1))\n        return (n + 1) * (n + 1) / 2;\n    }\n}\n",
            "class Global {\n    public static bool CorrectBracketing(string brackets) {\n        // depth = 0\n        int depth = 0;\n        // for b in brackets:\n        foreach (var b in brackets) {\n            // if b == \"(\":\n            if (b == '(') {\n                // depth += 1\n                depth += 1;\n            }\n            // elif b == \")\":\n            else if (b == ')') {\n                // depth -= 1\n                depth -= 1;\n            }\n            // if depth < 0:\n            if (depth < 0) {\n                // return False\n                return false;\n            }\n        }\n        // return depth == 0\n        return depth == 0;\n    }\n}\n",
            "class Global {\n    public static IList<int> Derivative(IList<int> xs) {\n        // return [xs[i] * i for i in range(1, len(xs))]\n        var result = new List<int>();\n        for (int i = 1; i < xs.Count; i++) {\n            result.Add(xs[i] * i);\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static int Fibfib(int n) {\n        // if n <= 1:\n        if (n <= 1) {\n            // return 0 \n            return 0;\n        }\n        // a, b, c = 0, 0, 1\n        int a = 0, b = 0, c = 1;\n        // while n > 2:\n        while (n > 2) {\n            // a, b, c = b, c, a + b + c\n            a = b;\n            b = c;\n            c = a + b + c;\n            // n -= 1\n            n -= 1;\n        }\n        // return c\n        return c;\n    }\n}\n",
            "class Global {\n    public static int VowelsCount(string s) {\n        // vowels = \"aeiou\"\n        var vowels = \"aeiou\";\n        // cnt = 0\n        var cnt = 0;\n        // for i in range(len(s)):\n        for (var i = 0; i < s.Length; i++) {\n            // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n            if (s[i].ToLower() == \"y\" || vowels.Contains(s[i].ToLower())) {\n                // cnt += 1\n                cnt++;\n            }\n        }\n        // return cnt\n        return cnt;\n    }\n}\n",
            "class Global {\n    public static string CircularShift(int x, int shift) {\n        // x_str = str(x)\n        var x_str = x.ToString();\n        // if shift > len(x_str):\n        if (shift > x_str.Length) {\n            // return x_str[::-1]\n            return new string(x_str.Reverse().ToArray());\n        } else {\n            // return x_str[-shift:] + x_str[:-shift]\n            return x_str.Substring(x_str.Length - shift) + x_str.Substring(0, x_str.Length - shift);\n        }\n    }\n}\n",
            "class Global {\n    public static int DigitSum(string s) {\n        // return sum(ord(c) for c in s if c.isupper())\n        return s.ToCharArray().Where(c => char.IsUpper(c)).Sum(c => (int)c);\n    }\n}\n",
            "class Global {\n    public static int FruitDistribution(string s, int n) {\n        // words = s.split(' ')\n        var words = s.Split(' ');\n        // apples = int(words[words.index(\"apples\") - 1])\n        var apples = int.Parse(words[words.IndexOf(\"apples\") - 1]);\n        // oranges = int(words[words.index(\"oranges\") - 1])\n        var oranges = int.Parse(words[words.IndexOf(\"oranges\") - 1]);\n        // return n - apples - oranges\n        return n - apples - oranges;\n    }\n}\n",
            "class Global {\n    public static IList<int> Pluck(IList<int> arr) {\n        // evens = [n for n in arr if n % 2 == 0]\n        var evens = new List<int>();\n        foreach (var n in arr) {\n            if (n % 2 == 0) {\n                evens.Add(n);\n            }\n        }\n        // if len(evens) == 0:\n        if (evens.Count == 0) {\n            // return []\n            return new List<int>();\n        }\n        // min_even = min(evens)\n        var min_even = evens[0];\n        foreach (var n in evens) {\n            if (n < min_even) {\n                min_even = n;\n            }\n        }\n        // return [min_even, arr.index(min_even)]\n        return new List<int> { min_even, arr.IndexOf(min_even) };\n    }\n}\n",
            "class Global {\n    public static int Search(IList<int> lst) {\n        // freqs = {}\n        var freqs = new Dictionary<int, int>();\n        // for n in lst:\n        foreach (var n in lst) {\n            // freqs[n] = freqs.get(n, 0) + 1\n            freqs[n] = freqs.GetValueOrDefault(n, 0) + 1;\n        }\n        // good_vals = [k for k, v in freqs.items() if v >= k]\n        var goodVals = new List<int>();\n        foreach (var kvp in freqs) {\n            if (kvp.Value >= kvp.Key) {\n                goodVals.Add(kvp.Key);\n            }\n        }\n        // return max(good_vals, default=-1)\n        return goodVals.Count > 0 ? goodVals.Max() : -1;\n    }\n}\n",
            "class Global {\n    public static IList<int> StrangeSortList(IList<int> lst) {\n        // sl = sorted(lst)\n        var sl = new List<int>(lst);\n        sl.Sort();\n        // result = []\n        var result = new List<int>();\n        // left, right = 0, len(sl) - 1\n        var left = 0;\n        var right = sl.Count - 1;\n        // while left <= right:\n        while (left <= right) {\n            // result.append(sl[left])\n            result.Add(sl[left]);\n            // left += 1\n            left += 1;\n            // if left <= right:\n            if (left <= right) {\n                // result.append(sl[right])\n                result.Add(sl[right]);\n                // right -= 1\n                right -= 1;\n            }\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static double TriangleArea(int a, int b, int c) {\n        // if a + b > c and a + c > b and b + c > a:\n        if (a + b > c && a + c > b && b + c > a) {\n            // s = (a + b + c) / 2.0\n            var s = (a + b + c) / 2.0;\n            // return sqrt(s * (s - a) * (s - b) * (s - c))\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        } else {\n            // return -1.0\n            return -1.0;\n        }\n    }\n}\n",
            "class Global {\n    public static bool WillItFly(IList<int> q, int w) {\n        // if len(q) == 0:\n        if (q.Count == 0) {\n            // return False\n            return false;\n        }\n        // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n        bool isPalin = true;\n        for (int i = 0; i < q.Count; i++) {\n            if (q[i] != q[q.Count - i - 1]) {\n                isPalin = false;\n                break;\n            }\n        }\n        // total = sum(q)\n        int total = 0;\n        foreach (var e in q) {\n            total += e;\n        }\n        // return is_palin and total <= w\n        return isPalin && total <= w;\n    }\n}\n",
            "class Global {\n    public static int SmallestChange(IList<int> arr) {\n        // ans = 0\n        int ans = 0;\n        // for i in range(len(arr) // 2):\n        for (int i = 0; i < arr.Count / 2; i++) {\n            // if arr[i] != arr[len(arr) - i - 1]:\n            if (arr[i] != arr[arr.Count - i - 1]) {\n                // ans += 1\n                ans++;\n            }\n        }\n        // return ans\n        return ans;\n    }\n}\n",
            "class Global {\n    public static IList<string> TotalMatch(IList<string> lst1, IList<string> lst2) {\n        // cnt1 = sum(len(s) for s in lst1)\n        var cnt1 = 0;\n        foreach (var s in lst1) {\n            cnt1 += s.Length;\n        }\n        // cnt2 = sum(len(s) for s in lst2)\n        var cnt2 = 0;\n        foreach (var s in lst2) {\n            cnt2 += s.Length;\n        }\n        // return lst1 if cnt1 <= cnt2 else lst2\n        return cnt1 <= cnt2 ? lst1 : lst2;\n    }\n}\n",
            "class Global {\n    public static bool IsPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= (int)Math.Floor(Math.Sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static bool IsMultiplyPrime(int a) {\n        // cnt = 0\n        int cnt = 0;\n        // for i in range(2, a + 1):\n        for (int i = 2; i <= a + 1; i++) {\n            // if is_prime(i):\n            if (IsPrime(i)) {\n                // while a % i == 0:\n                while (a % i == 0) {\n                    // cnt += 1\n                    cnt++;\n                    // a /= i\n                    a /= i;\n                }\n            }\n        }\n        // return cnt == 3\n        return cnt == 3;\n    }\n}\n",
            "class Global {\n    public static bool IsSimplePower(int x, int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return x == n\n            return x == n;\n        }\n        // tmp = 1\n        int tmp = 1;\n        // while tmp < x:\n        while (tmp < x) {\n            // tmp *= n\n            tmp *= n;\n        }\n        // return tmp == x\n        return tmp == x;\n    }\n}\n",
            "class Global {\n    public static bool IsCube(int a) {\n        // a = abs(a)\n        a = Math.Abs(a);\n        // root = int(round(pow(a, 1.0 / 3.0)))\n        var root = (int)Math.Round(Math.Pow(a, 1.0 / 3.0));\n        // return root * root * root == a\n        return root * root * root == a;\n    }\n}\n",
            "class Global {\n    public static int HexKey(string num) {\n        // return len([x for x in num if x in \"2357BD\"])\n        return num.Count(x => \"2357BD\".Contains(x));\n    }\n}\n",
            "class Global {\n    public static string DecimalToBinary(int dec) {\n        // binary = bin(dec)[2:]\n        var binary = Convert.ToString(dec, 2);\n        // return f\"db{binary}db\"\n        return $\"db{binary}db\";\n    }\n}\n",
            "class Global {\n    public static bool IsHappy(string s) {\n        // if len(s) < 3:\n        if (s.Length < 3) {\n            // return False\n            return false;\n        }\n        // for i in range(len(s) - 2):\n        for (int i = 0; i < s.Length - 2; i++) {\n            // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n}\n",
            "class Global {\n    public static IList<string> NumericalLetterGrade(IList<float> grades) {\n        // result = []\n        var result = new List<string>();\n        // for g in grades:\n        foreach (var g in grades) {\n            // if g == 4.0:\n            if (g == 4.0) {\n                // result.append(\"A+\")\n                result.Add(\"A+\");\n            }\n            // elif g > 3.7:\n            else if (g > 3.7) {\n                // result.append(\"A\")\n                result.Add(\"A\");\n            }\n            // elif g > 3.3:\n            else if (g > 3.3) {\n                // result.append(\"A-\")\n                result.Add(\"A-\");\n            }\n            // elif g > 3.0:\n            else if (g > 3.0) {\n                // result.append(\"B+\")\n                result.Add(\"B+\");\n            }\n            // elif g > 2.7:\n            else if (g > 2.7) {\n                // result.append(\"B\")\n                result.Add(\"B\");\n            }\n            // elif g > 2.3:\n            else if (g > 2.3) {\n                // result.append(\"B-\")\n                result.Add(\"B-\");\n            }\n            // elif g > 2.0:\n            else if (g > 2.0) {\n                // result.append(\"C+\")\n                result.Add(\"C+\");\n            }\n            // elif g > 1.7:\n            else if (g > 1.7) {\n                // result.append(\"C\")\n                result.Add(\"C\");\n            }\n            // elif g > 1.3:\n            else if (g > 1.3) {\n                // result.append(\"C-\")\n                result.Add(\"C-\");\n            }\n            // elif g > 1.0:\n            else if (g > 1.0) {\n                // result.append(\"D+\")\n                result.Add(\"D+\");\n            }\n            // elif g > 0.7:\n            else if (g > 0.7) {\n                // result.append(\"D\")\n                result.Add(\"D\");\n            }\n            // elif g > 0.0:\n            else if (g > 0.0) {\n                // result.append(\"D-\")\n                result.Add(\"D-\");\n            }\n            // else:\n            else {\n                // result.append(\"E\")\n                result.Add(\"E\");\n            }\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static bool PrimeLength(string s) {\n        // length = len(s)\n        int length = s.Length;\n        // if length < 2:\n        if (length < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(length)) + 1):\n        for (int i = 2; i <= (int)Math.Floor(Math.Sqrt(length)) + 1; i++) {\n            // if length % i == 0:\n            if (length % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n}\n",
            "class Global {\n    public static int StartsOneEnds(int n) {\n        // if n == 1:\n        if (n == 1) {\n            // return 1\n            return 1;\n        }\n        // return 2 * 9 * (10 ** (n - 2))\n        return 2 * 9 * (int)Math.Pow(10, n - 2);\n    }\n}\n",
            "class Global {\n    public static string Solve(int n) {\n        // digits_sum = sum(int(d) for d in str(n))\n        var digitsSum = 0;\n        foreach (var d in str(n)) {\n            digitsSum += int(d);\n        }\n        // return bin(digits_sum)[2:]\n        return Convert.ToString(digitsSum, 2).Substring(2);\n    }\n}\n",
            "class Global {\n    public static int Add(IList<int> lst) {\n        // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n        return lst.Where((x, i) => i % 2 == 1 && x % 2 == 0).Sum();\n    }\n}\n",
            "class Global {\n    public static string AntiShuffle(string s) {\n        // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n        var words = new List<string>();\n        foreach (var word in s.Split(' ')) {\n            words.Add(string.Concat(word.OrderBy(c => c)));\n        }\n        // return \" \".join(words)\n        return string.Join(\" \", words);\n    }\n}\n",
            "class Global {\n    public static IList<IList<int>> GetRow(IList<IList<int>> lst, int x) {\n        // coords = []\n        var coords = new List<IList<int>>();\n        // for i in range(len(lst)):\n        for (int i = 0; i < lst.Count; i++) {\n            // for j in range(len(lst[i])):\n            for (int j = 0; j < lst[i].Count; j++) {\n                // if lst[i][j] == x:\n                if (lst[i][j] == x) {\n                    // coords.append([i, j])\n                    coords.Add(new List<int> { i, j });\n                }\n            }\n        }\n        // return sorted(coords, key=lambda a: (a[0], -a[1]))\n        return coords.OrderBy(a => a[0]).ThenByDescending(a => a[1]).ToList();\n    }\n}\n",
            "class Global {\n    public static IList<int> SortArray(IList<int> arr) {\n        // if len(arr) == 0:\n        if (arr.Count == 0) {\n            // return []\n            return new List<int>();\n        }\n        // if (arr[0] + arr[-1]) % 2 == 0:\n        if ((arr[0] + arr[arr.Count - 1]) % 2 == 0) {\n            // return sorted(arr, reverse=True)\n            return new List<int>(arr).Sort(Comparer<int>.Create((a, b) => b.CompareTo(a)));\n        }\n        // else:\n        else {\n            // return sorted(arr)\n            return new List<int>(arr).Sort();\n        }\n    }\n}\n",
            "class Global {\n    public static string Encrypt(string s) {\n        // result = []\n        var result = new List<char>();\n        // for ch in s:\n        foreach (var ch in s) {\n            // shifted = ord(ch) + 4\n            var shifted = (int)ch + 4;\n            // if shifted > ord('z'):\n            if (shifted > (int)'z') {\n                // shifted -= 26\n                shifted -= 26;\n            }\n            // result.append(chr(shifted))\n            result.Add((char)shifted);\n        }\n        // return \"\".join(result)\n        return new string(result.ToArray());\n    }\n}\n",
            "class Global {\n    public static int? NextSmallest(IList<int> lst) {\n        // sl = sorted(set(lst))\n        var sl = new List<int>(new HashSet<int>(lst));\n        sl.Sort();\n        // if len(sl) < 2:\n        if (sl.Count < 2) {\n            // return None\n            return null;\n        }\n        // return sl[1]\n        return sl[1];\n    }\n}\n",
            "class Global {\n    public static int IsBored(string s) {\n        // sentences = re.split(r\"[.!?]\\s*\", s)\n        var sentences = Regex.Split(s, @\"[.!?]\\s*\");\n        // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n        return sentences.Count(sentence => sentence.Length >= 2 && sentence.Substring(0, 2) == \"I \");\n    }\n}\n",
            "class Global {\n    public static bool AnyInt(object x, object y, object z) {\n        // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        if (x is int && y is int && z is int) {\n            // if (x + y == z) or (x + z == y) or (y + z == x):\n            if (x.Equals(z - y) || x.Equals(y - z) || y.Equals(z - x)) {\n                // return True\n                return true;\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static string Encode(string message) {\n        // vowels = \"aeiouAEIOU\"\n        var vowels = \"aeiouAEIOU\";\n        // result = []\n        var result = new List<char>();\n        // for ch in message:\n        foreach (var ch in message) {\n            // if ch.isalpha():\n            if (char.IsLetter(ch)) {\n                // ch1 = ch.upper() if ch.islower() else ch.lower()\n                var ch1 = char.IsLower(ch) ? char.ToUpper(ch) : char.ToLower(ch);\n                // if ch1 in vowels:\n                if (vowels.Contains(ch1)) {\n                    // ch1 = chr(ord(ch1) + 2)\n                    ch1 = (char)(ch1 + 2);\n                }\n                // result.append(ch1)\n                result.Add(ch1);\n            } else {\n                // result.append(ch)\n                result.Add(ch);\n            }\n        }\n        // return \"\".join(result)\n        return new string(result.ToArray());\n    }\n}\n",
            "class Global {\n    public static bool IsPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= (int)Math.Floor(Math.Sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static int Skjkasdkd(IList<int> lst) {\n        // primes = [n for n in lst if is_prime(n)]\n        var primes = new List<int>();\n        foreach (var n in lst) {\n            if (IsPrime(n)) {\n                primes.Add(n);\n            }\n        }\n        // if len(primes) == 0:\n        if (primes.Count == 0) {\n            // return 0\n            return 0;\n        }\n        // largest = str(max(primes))\n        var largest = primes.Max().ToString();\n        // return sum(int(digit) for digit in largest)\n        return largest.Sum(digit => (int)digit);\n    }\n}\n",
            "class Global {\n    public static bool CheckDictCase(IDictionary<string, string> d) {\n        // if not d:\n        if (d == null || d.Count == 0) {\n            // return False\n            return false;\n        }\n        // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n        return d.Keys.All(c => char.IsLower(c[0])) || d.Keys.All(c => char.IsUpper(c[0]));\n    }\n}\n",
            "class Global {\n    public static IList<int> CountUpTo(int n) {\n        // primes = []\n        var primes = new List<int>();\n        // for num in range(2, n):\n        for (int num = 2; num < n; num++) {\n            // if all(num % p != 0 for p in primes):\n            if (primes.All(p => num % p != 0)) {\n                // primes.append(num)\n                primes.Add(num);\n            }\n        }\n        // return primes\n        return primes;\n    }\n}\n",
            "class Global {\n    public static int Multiply(int a, int b) {\n        // return (abs(a) % 10) * (abs(b) % 10)\n        return Math.Abs(a) % 10 * Math.Abs(b) % 10;\n    }\n}\n",
            "class Global {\n    public static int CountUpper(string s) {\n        // vowels = \"AEIOU\"\n        var vowels = \"AEIOU\";\n        // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n        return s.Count(c => (c - 'A') % 2 == 0 && vowels.Contains(c));\n    }\n}\n",
            "class Global {\n    public static int ClosestInteger(string value) {\n        // num = float(value)\n        var num = float.Parse(value);\n        // if num >= 0:\n        if (num >= 0) {\n            // return int(num + 0.5)\n            return (int)(num + 0.5);\n        }\n        // else:\n        else {\n            // return int(num - 0.5)\n            return (int)(num - 0.5);\n        }\n    }\n}\n",
            "class Global {\n    public static IList<int> MakeAPile(int n) {\n        // return [n + 2 * i for i in range(n)]\n        return new List<int>(n);\n        for (int i = 0; i < n; i++) {\n            result[i] = n + 2 * i;\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static IList<string> WordsString(string s) {\n        // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n        return Regex.Split(s, @\"[, ]\").Where(w => w.Length > 0).ToList();\n    }\n}\n",
            "class Global {\n    public static int ChooseNum(int x, int y) {\n        // if x > y:\n        if (x > y) {\n            // return -1\n            return -1;\n        }\n        // if y % 2 == 0:\n        if (y % 2 == 0) {\n            // return y\n            return y;\n        }\n        // return y - 1 if x != y else -1\n        return y - 1;\n    }\n}\n",
            "class Global {\n    public static string RoundedAvg(int n, int m) {\n        // if n > m:\n        if (n > m) {\n            // return None\n            return null;\n        }\n        // r_avg = int((m + n) / 2.0 + 0.5)\n        var r_avg = (int)((m + n) / 2.0 + 0.5);\n        // return bin(r_avg)[2:]\n        return Convert.ToString(r_avg, 2);\n    }\n}\n",
            "class Global {\n    public static bool AllDigitsOdd(string s) {\n        // return all(ord(digit) % 2 != 0 for digit in s)\n        return s.All(digit => (digit - '0') % 2 != 0);\n    }\n    public static IList<int> UniqueDigits(IList<int> x) {\n        // return sorted([num for num in x if all_digits_odd(str(num))])\n        return x.Where(num => AllDigitsOdd(num.ToString())).OrderBy(num => num).ToList();\n    }\n}\n",
            "class Global {\n    public static IList<string> ByLength(IList<int> arr) {\n        // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        var digitNames = new List<string> { \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" };\n        // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n        var sortedArr = new List<int>();\n        foreach (var x in arr) {\n            if (1 <= x && x <= 9) {\n                sortedArr.Add(x);\n            }\n        }\n        sortedArr.Sort();\n        sortedArr.Reverse();\n        // return [digit_names[x-1] for x in sorted_arr]\n        return sortedArr.Select(x => digitNames[x - 1]).ToList();\n    }\n}\n",
            "class Global {\n    public static IList<int> F(int n) {\n        // nums = list(range(1, n + 1))\n        var nums = new List<int>();\n        for (int i = 1; i <= n; i++) {\n            nums.Add(i);\n        }\n        // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n        return nums.Select(i => {\n            if (i % 2 != 0) {\n                return nums.Take(i).Sum();\n            } else {\n                return nums.Take(i).Aggregate((x, y) => x * y);\n            }\n        }).ToList();\n    }\n}\n",
            "class Global {\n    public static bool IsPalindrome(string txt) {\n        // return txt == txt[::-1]\n        return txt == new string(txt.Reverse());\n    }\n    public static IList<int> EvenOddPalindrome(int n) {\n        // cnt = [0, 0]\n        var cnt = new List<int> { 0, 0 };\n        // for i in range(1, n + 1):\n        for (int i = 1; i <= n; i++) {\n            // if is_palindrome(str(i)):\n            if (IsPalindrome(i.ToString())) {\n                // cnt[i % 2] += 1\n                cnt[i % 2]++;\n            }\n        }\n        // return cnt\n        return cnt;\n    }\n}\n",
            "class Global {\n    public static int DigitsSum(int n) {\n        // n_str = str(n)\n        var nStr = n.ToString();\n        // if n >= 0:\n        if (n >= 0) {\n            // return sum(int(d) for d in n_str)\n            return nStr.Sum(d => int.Parse(d.ToString()));\n        }\n        // else:\n        else {\n            // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n            return int.Parse(nStr.Substring(0, 2)) * 2 + DigitsSum(Math.Abs(n));\n        }\n    }\n    public static int CountNums(IList<int> arr) {\n        // return len([n for n in arr if digits_sum(n) > 0])\n        return arr.Count(n => DigitsSum(n) > 0);\n    }\n}\n",
            "class Global {\n    public static bool MoveOneBall(IList<int> arr) {\n        // if len(arr) == 0:\n        if (arr.Count == 0) {\n            // return True\n            return true;\n        }\n        // sorted_arr = sorted(arr)\n        var sortedArr = new List<int>(arr);\n        sortedArr.Sort();\n        // for i in range(0, len(arr)):\n        for (int i = 0; i < arr.Count; i++) {\n            // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n            if (arr.GetRange(i, arr.Count - i).SequenceEqual(sortedArr.GetRange(0, arr.Count - i)) && arr.GetRange(0, i).SequenceEqual(sortedArr.GetRange(arr.Count - i, i))) {\n                // return True\n                return true;\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static string CanExchange(IList<int> lst1, IList<int> lst2) {\n        // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n        var odd_cnt = lst1.Count(num => num % 2 != 0);\n        // even_cnt = len([num for num in lst2 if num % 2 == 0])\n        var even_cnt = lst2.Count(num => num % 2 == 0);\n        // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n        return even_cnt >= odd_cnt ? \"YES\" : \"NO\";\n    }\n}\n",
            "class Global {\n    public static IDictionary<string, int> Histogram(string test) {\n        // freq = {}\n        var freq = new Dictionary<string, int>();\n        // words = [w for w in test.split(\" \") if len(w) > 0]\n        var words = new List<string>();\n        foreach (var w in test.Split(' ')) {\n            if (w.Length > 0) {\n                words.Add(w);\n            }\n        }\n        // for w in words:\n        foreach (var w in words) {\n            // freq[w] = freq.get(w, 0) + 1\n            freq[w] = freq.GetValueOrDefault(w, 0) + 1;\n        }\n        // result = {}\n        var result = new Dictionary<string, int>();\n        // if len(freq) > 0:\n        if (freq.Count > 0) {\n            // max_freq = max(freq.values())\n            var max_freq = freq.Values.Max();\n            // for k, v in freq.items():\n            foreach (var kv in freq) {\n                // if v == max_freq:\n                if (kv.Value == max_freq) {\n                    // result[k] = v\n                    result[kv.Key] = kv.Value;\n                }\n            }\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static bool IsPalindrome(string s) {\n        // return s == s[::-1]\n        return s == new string(s.Reverse());\n    }\n    public static IList<string> ReverseDelete(string s, string c) {\n        // s1 = \"\".join([ch for ch in s if ch not in c])\n        var s1 = new string(s.Where(ch => !c.Contains(ch)).ToArray());\n        // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n        return new List<string> { s1, IsPalindrome(s1) ? \"yes\" : \"no\" };\n    }\n}\n",
            "class Global {\n    public static IList<string> OddCount(IList<string> lst) {\n        // result = []\n        var result = new List<string>();\n        // for num in lst:\n        foreach (var num in lst) {\n            // n = sum(ord(d) % 2 == 1 for d in num)\n            var n = 0;\n            foreach (var d in num) {\n                n += (int)d % 2 == 1 ? 1 : 0;\n            }\n            // rs = \"the number of odd elements in the string i of the input.\"\n            var rs = \"the number of odd elements in the string i of the input.\";\n            // result.append(rs.replace(\"i\", str(n)))\n            result.Add(rs.Replace(\"i\", n.ToString()));\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static int MinSubArraySum(IList<int> nums) {\n        // min_sum = 0\n        int minSum = 0;\n        // cur_sum = 0\n        int curSum = 0;\n        // for n in nums:\n        foreach (var n in nums) {\n            // cur_sum = min(cur_sum + n, 0)\n            curSum = Math.Min(curSum + n, 0);\n            // min_sum = min(cur_sum, min_sum)\n            minSum = Math.Min(curSum, minSum);\n        }\n        // if min_sum == 0:\n        if (minSum == 0) {\n            // min_sum = min(nums)\n            minSum = nums.Min();\n        }\n        // return min_sum\n        return minSum;\n    }\n}\n",
            "class Global {\n    public static int MaxFill(IList<IList<int>> grid, int capacity) {\n        // return sum([ceil(sum(arr) / capacity) for arr in grid])\n        return grid.Sum(arr => (int)Math.Ceiling(arr.Sum() / (double)capacity));\n    }\n}\n",
            "class Global {\n    public static int CountOnes(int num) {\n        // return bin(num).count(\"1\")\n        return Convert.ToString(num, 2).Count(c => c == '1');\n    }\n    public static IList<int> SortArray(IList<int> arr) {\n        // return sorted(arr, key=lambda x: (count_ones(x), x))\n        return arr.OrderBy(x => (CountOnes(x), x)).ToList();\n    }\n}\n",
            "class Global {\n    public static IList<string> SelectWords(string s, int n) {\n        // consonants = \"bcdfghjklmnpqrstvwxyz\"\n        var consonants = \"bcdfghjklmnpqrstvwxyz\";\n        // words = [w for w in s.split(\" \") if len(w) > 0]\n        var words = new List<string>();\n        foreach (var w in s.Split(' ')) {\n            if (w.Length > 0) {\n                words.Add(w);\n            }\n        }\n        // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n        return words.FindAll(w => {\n            var count = 0;\n            foreach (var c in w) {\n                if (consonants.Contains(c.ToString().ToLower())) {\n                    count++;\n                }\n            }\n            return count == n;\n        });\n    }\n}\n",
            "class Global {\n    public static string GetClosestVowel(string word) {\n        // vowels = \"aeiouAEIOU\"\n        var vowels = \"aeiouAEIOU\";\n        // for i in range(len(word) - 2, 0, -1):\n        for (int i = word.Length - 2; i >= 0; i--) {\n            // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            if (vowels.Contains(word[i]) && !vowels.Contains(word[i - 1]) && !vowels.Contains(word[i + 1])) {\n                // return word[i]\n                return word[i].ToString();\n            }\n        }\n        // return \"\"\n        return \"\";\n    }\n}\n",
            "class Global {\n    public static bool Check(string s) {\n        // depth = 0\n        int depth = 0;\n        // for ch in s:\n        foreach (var ch in s) {\n            // if ch == \"(\":\n            if (ch == '(') {\n                // depth += 1\n                depth += 1;\n            } else {\n                // depth -= 1\n                depth -= 1;\n            }\n            // if depth < 0:\n            if (depth < 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True if depth == 0 else False\n        return depth == 0;\n    }\n    public static string MatchParens(IList<string> lst) {\n        // s1 = lst[0] + lst[1]\n        var s1 = lst[0] + lst[1];\n        // s2 = lst[1] + lst[0]\n        var s2 = lst[1] + lst[0];\n        // return \"Yes\" if check(s1) or check(s2) else \"No\"\n        return Check(s1) || Check(s2) ? \"Yes\" : \"No\";\n    }\n}\n",
            "class Global {\n    public static IList<int> Maximum(IList<int> arr, int k) {\n        // if k == 0:\n        if (k == 0) {\n            // return []\n            return new List<int>();\n        }\n        // return sorted(arr)[-k:]\n        return new List<int>(arr).Sort().GetRange(arr.Count - k, k);\n    }\n}\n",
            "class Global {\n    public static int Solution(IList<int> lst) {\n        // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n        return lst.Where((x, i) => i % 2 == 0 && x % 2 != 0).Sum();\n    }\n}\n",
            "class Global {\n    public static int AddElements(IList<int> arr, int k) {\n        // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n        return arr.Take(k).Where(n => n.ToString().Length <= 2).Sum();\n    }\n}\n",
            "class Global {\n    public static IList<int> GetOddCollatz(int n) {\n        // collatz = [1]\n        var collatz = new List<int> { 1 };\n        // while n != 1:\n        while (n != 1) {\n            // if n % 2 != 0:\n            if (n % 2 != 0) {\n                // collatz.append(n)\n                collatz.Add(n);\n                // n = 3 * n + 1\n                n = 3 * n + 1;\n            } else {\n                // n = n // 2\n                n = n / 2;\n            }\n        }\n        // return sorted(collatz)\n        return collatz.Sort();\n    }\n}\n",
            "class Global {\n    public static bool ValidDate(string date) {\n        // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n        if (date.Length != 10 || date[2] != '-' || date[5] != '-') {\n            return false;\n        }\n        // m = int(date[:2])\n        int m = int.Parse(date.Substring(0, 2));\n        // d = int(date[3:5])\n        int d = int.Parse(date.Substring(3, 2));\n        // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n        if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) {\n            if (d >= 1 && d <= 31) {\n                return true;\n            }\n        }\n        // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n        if (m == 4 || m == 6 || m == 9 || m == 11) {\n            if (d >= 1 && d <= 30) {\n                return true;\n            }\n        }\n        // if m == 2 and d >= 1 and d <= 29:\n        if (m == 2) {\n            if (d >= 1 && d <= 29) {\n                return true;\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static IList<string> SplitWords(string txt) {\n        // if \" \" in txt:\n        if (txt.Contains(\" \")) {\n            // return txt.split(\" \")\n            return txt.Split(' ');\n        }\n        // elif \",\" in txt:\n        else if (txt.Contains(\",\")) {\n            // return txt.split(\",\")\n            return txt.Split(',');\n        }\n        // else:\n        else {\n            // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n            return new List<string> {\n                ((int)txt.ToCharArray().Count(c => char.IsLower(c) && c % 2 == 0)).ToString()\n            };\n        }\n    }\n}\n",
            "class Global {\n    public static bool IsSorted(IList<int> lst) {\n        // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        if (!lst.All(i => lst[i - 1] <= i)) {\n            return false;\n        }\n        // freq = {}\n        var freq = new Dictionary<int, int>();\n        // for i in lst:\n        foreach (var i in lst) {\n            // freq[i] = freq.get(i, 0) + 1\n            freq[i] = freq.GetValueOrDefault(i, 0) + 1;\n        }\n        // return max(freq.values(), default=0) <= 2\n        return freq.Values.Max() <= 2;\n    }\n}\n",
            "class Global {\n    public static bool IsPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= (int)Math.Floor(Math.Sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static string Intersection(IList<int> interval1, IList<int> interval2) {\n        // l = max(interval1[0], interval2[0])\n        int l = Math.Max(interval1[0], interval2[0]);\n        // r = min(interval1[1], interval2[1])\n        int r = Math.Min(interval1[1], interval2[1]);\n        // length = r - l\n        int length = r - l;\n        // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n        return length > 0 && IsPrime(length) ? \"YES\" : \"NO\";\n    }\n}\n",
            "class Global {\n    public static int? ProdSigns(IList<int> arr) {\n        // if not arr:\n        if (arr == null || arr.Count == 0) {\n            // return None\n            return null;\n        }\n        // if 0 in arr:\n        if (arr.Contains(0)) {\n            // return 0\n            return 0;\n        }\n        // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n        var sign = -1;\n        if (arr.Count(n => n < 0) % 2 == 1) {\n            sign = 1;\n        }\n        // return sign * sum([abs(n) for n in arr])\n        return sign * arr.Sum(n => Math.Abs(n));\n    }\n}\n",
            "class Global {\n    public static IList<int> MinPath(IList<IList<int>> grid, int k) {\n        // n = len(grid)\n        int n = grid.Count;\n        // min_val = n * n + 1\n        int min_val = n * n + 1;\n        // for i in range(n):\n        for (int i = 0; i < n; i++) {\n            // for j in range(n):\n            for (int j = 0; j < n; j++) {\n                // if grid[i][j] == 1:\n                if (grid[i][j] == 1) {\n                    // temp = []\n                    var temp = new List<int>();\n                    // if i != 0:\n                    if (i != 0) {\n                        // temp.append(grid[i - 1][j])\n                        temp.Add(grid[i - 1][j]);\n                    }\n                    // if j != 0:\n                    if (j != 0) {\n                        // temp.append(grid[i][j - 1])\n                        temp.Add(grid[i][j - 1]);\n                    }\n                    // if i != n - 1:\n                    if (i != n - 1) {\n                        // temp.append(grid[i + 1][j])\n                        temp.Add(grid[i + 1][j]);\n                    }\n                    // if j != n - 1:\n                    if (j != n - 1) {\n                        // temp.append(grid[i][j + 1])\n                        temp.Add(grid[i][j + 1]);\n                    }\n                    // min_val = min(temp)\n                    min_val = Math.Min(min_val, temp.Min());\n                }\n            }\n        }\n        // result = []\n        var result = new List<int>();\n        // for i in range(k):\n        for (int i = 0; i < k; i++) {\n            // result.append(1 if i % 2 == 0 else min_val)\n            result.Add(i % 2 == 0 ? 1 : min_val);\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static IList<int> Tri(int n) {\n        // if n == 0:\n        if (n == 0) {\n            // return [1]\n            return new List<int> { 1 };\n        }\n        // seq = [1, 3]\n        var seq = new List<int> { 1, 3 };\n        // for i in range(2, n + 1):\n        for (int i = 2; i <= n; i++) {\n            // if i % 2 == 0:\n            if (i % 2 == 0) {\n                // seq.append(i / 2 + 1)\n                seq.Add(i / 2 + 1);\n            } else {\n                // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n                seq.Add(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n            }\n        }\n        // return seq\n        return seq;\n    }\n}\n",
            "class Global {\n    public static int Digits(int n) {\n        // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n        var odds = new List<int>();\n        foreach (var d in str(n)) {\n            if (int(d) % 2 == 1) {\n                odds.Add(int(d));\n            }\n        }\n        // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n        return odds.Count > 0 ? odds.Aggregate((x, y) => x * y) : 0;\n    }\n}\n",
            "class Global {\n    public static bool IsNested(string s) {\n        // open_idx = []\n        var openIdx = new List<int>();\n        // close_idx = []\n        var closeIdx = new List<int>();\n        // for i, ch in enumerate(s):\n        for (int i = 0; i < s.Length; i++) {\n            var ch = s[i];\n            // if ch == '[':\n            if (ch == '[') {\n                // open_idx.append(i)\n                openIdx.Add(i);\n            }\n            // elif ch == ']':\n            else if (ch == ']') {\n                // close_idx.append(i)\n                closeIdx.Add(i);\n            }\n        }\n        // close_idx.reverse()\n        closeIdx.Reverse();\n        // cnt = 0\n        var cnt = 0;\n        // i = 0\n        var i = 0;\n        // l = len(close_idx)\n        var l = closeIdx.Count;\n        // for idx in open_idx:\n        foreach (var idx in openIdx) {\n            // if i < l and idx < close_idx[i]:\n            if (i < l && idx < closeIdx[i]) {\n                // cnt += 1\n                cnt++;\n                // i += 1\n                i++;\n            }\n        }\n        // return cnt >= 2\n        return cnt >= 2;\n    }\n}\n",
            "class Global {\n    public static int SumSquares(IList<float> lst) {\n        // return sum([pow(ceil(n), 2) for n in lst])\n        return lst.Sum(n => (int)Math.Pow(Math.Ceiling(n), 2));\n    }\n}\n",
            "class Global {\n    public static bool CheckIfLastCharIsALetter(string txt) {\n        // if not txt:\n        if (string.IsNullOrEmpty(txt)) {\n            // return False\n            return false;\n        }\n        // last = txt[txt.rfind(' ') + 1:]\n        var last = txt.Substring(txt.LastIndexOf(' ') + 1);\n        // return len(last) == 1 and last[0].isalpha()\n        return last.Length == 1 && char.IsLetter(last[0]);\n    }\n}\n",
            "class Global {\n    public static int CanArrange(IList<int> arr) {\n        // if len (arr) <= 1:\n        if (arr.Count <= 1) {\n            // return -1\n            return -1;\n        }\n        // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n        var idx = new List<int>();\n        for (int i = 1; i < arr.Count; i++) {\n            if (arr[i] < arr[i - 1]) {\n                idx.Add(i);\n            }\n        }\n        // return max(idx, default=-1)\n        return idx.Count > 0 ? idx.Max() : -1;\n    }\n}\n",
            "class Global {\n    public static IList<int?> LargestSmallestIntegers(IList<int> lst) {\n        // neg = [i for i in lst if i < 0]\n        var neg = new List<int>();\n        foreach (var i in lst) {\n            if (i < 0) {\n                neg.Add(i);\n            }\n        }\n        // pos = [i for i in lst if i > 0]\n        var pos = new List<int>();\n        foreach (var i in lst) {\n            if (i > 0) {\n                pos.Add(i);\n            }\n        }\n        // max_neg = max(neg) if len(neg) > 0 else None\n        var max_neg = neg.Count > 0 ? neg.Max() : (int?)null;\n        // min_pos = min(pos) if len(pos) > 0 else None\n        var min_pos = pos.Count > 0 ? pos.Min() : (int?)null;\n        // return [max_neg, min_pos]\n        return new List<int?> { max_neg, min_pos };\n    }\n}\n",
            "class Global {\n    public static float AnyToReal(object o) {\n        // if isinstance(o, str): \n        if (o is string) {\n            // return float(o.replace(',','.'))\n            return float.Parse((string)o.Replace(',', '.'));\n        }\n        // elif isinstance(o, int):\n        else if (o is int) {\n            // return float(o)\n            return (float)(int)o;\n        }\n        // elif isinstance(o, float):\n        else if (o is float) {\n            // return o\n            return (float)o;\n        }\n        // raise RuntimeError(\"Type Error\");\n        throw new RuntimeException(\"Type Error\");\n    }\n    public static object CompareOne(object a, object b) {\n        // a1 = any_to_real(a)\n        var a1 = AnyToReal(a);\n        // b1 = any_to_real(b)\n        var b1 = AnyToReal(b);\n        // if a1 == b1:\n        if (a1 == b1) {\n            // return None\n            return null;\n        }\n        // elif a1 > b1:\n        else if (a1 > b1) {\n            // return a1\n            return a1;\n        }\n        // else:\n        else {\n            // return b1\n            return b1;\n        }\n    }\n}\n",
            "class Global {\n    public static bool IsEqualToSumEven(int n) {\n        // return n % 2 == 0 and n >= 8\n        return n % 2 == 0 && n >= 8;\n    }\n}\n",
            "class Global {\n    public static int SpecialFactorial(int n) {\n        // fact = 1\n        int fact = 1;\n        // result = 1\n        int result = 1;\n        // for i in range(1, n + 1):\n        for (int i = 1; i <= n; i++) {\n            // fact *= i\n            fact *= i;\n            // result *= fact\n            result *= fact;\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static string FixSpaces(string txt) {\n        // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n        return Regex.Replace(txt, @\"\\s{3,}\", \"-\").Replace(\" \", \"_\");\n    }\n}\n",
            "class Global {\n    public static string FileNameCheck(string fileName) {\n        // suf = [\"txt\", \"exe\", \"dll\"]\n        var suf = new List<string> { \"txt\", \"exe\", \"dll\" };\n        // lst = file_name.split(\".\")\n        var lst = fileName.Split('.');\n        // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n        if (lst.Length != 2 || !suf.Contains(lst[1]) || lst[0].Length == 0 || !char.IsLetter(lst[0][0]) || lst[0].Count(x => char.IsDigit(x)) > 3) {\n            // return \"No\"\n            return \"No\";\n        }\n        // return \"Yes\"\n        return \"Yes\";\n    }\n}\n",
            "class Global {\n    public static int SumSquares(IList<int> lst) {\n        // result = 0\n        int result = 0;\n        // for i in range(len(lst)):\n        for (int i = 0; i < lst.Count; i++) {\n            // if i % 3 == 0:\n            if (i % 3 == 0) {\n                // result += pow(lst[i], 2)\n                result += (int)Math.Pow(lst[i], 2);\n            }\n            // elif i % 4 == 0:\n            else if (i % 4 == 0) {\n                // result += pow(lst[i], 3)\n                result += (int)Math.Pow(lst[i], 3);\n            }\n            // else:\n            else {\n                // result += lst[i]\n                result += lst[i];\n            }\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static bool IsPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= (int)Math.Floor(Math.Sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static string WordsInSentence(string sentence) {\n        // words = sentence.split(\" \")\n        var words = sentence.Split(' ');\n        // return \" \".join([w for w in words if is_prime(len(w))])\n        return string.Join(\" \", words.Where(w => IsPrime(w.Length)));\n    }\n}\n",
            "class Global {\n    public static bool Simplify(string x, string n) {\n        // xs = x.split(\"/\")\n        var xs = x.Split('/');\n        // ns = n.split(\"/\")\n        var ns = n.Split('/');\n        // num = int(xs[0]) * int(ns[0])\n        var num = int.Parse(xs[0]) * int.Parse(ns[0]);\n        // den = int(xs[1]) * int(ns[1])\n        var den = int.Parse(xs[1]) * int.Parse(ns[1]);\n        // return num % den == 0\n        return num % den == 0;\n    }\n}\n",
            "class Global {\n    public static int DigitsSum(int n) {\n        // n_str = str(n)\n        var nStr = n.ToString();\n        // if n >= 0:\n        if (n >= 0) {\n            // return sum(int(d) for d in n_str)\n            return nStr.Sum(d => int.Parse(d.ToString()));\n        } else {\n            // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n            return int.Parse(nStr.Substring(0, 2)) * 2 + DigitsSum(Math.Abs(n));\n        }\n    }\n    public static IList<int> OrderByPoints(IList<int> nums) {\n        // return sorted(nums, key=digits_sum)\n        return nums.OrderBy(n => DigitsSum(n)).ToList();\n    }\n}\n",
            "class Global {\n    public static int SpecialFilter(IList<int> nums) {\n        // odds = \"13579\"\n        var odds = \"13579\";\n        // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n        return nums.Count(n => n > 10 && n % 2 == 1 && odds.Contains(n.ToString()[0]));\n    }\n}\n",
            "class Global {\n    public static int GetMaxTriples(int n) {\n        // c = [0, 0, 0]\n        var c = new int[] { 0, 0, 0 };\n        // for i in range(1, n + 1):\n        for (int i = 1; i <= n; i++) {\n            // a = i * i - i + 1\n            var a = i * i - i + 1;\n            // c[a % 3] += 1\n            c[a % 3] += 1;\n        }\n        // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n        return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2));\n    }\n}\n",
            "class Global {\n    public static IList<string> BF(string planet1, string planet2) {\n        // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        var names = new List<string> { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };\n        // if planet1 not in names or planet2 not in names:\n        if (!names.Contains(planet1) || !names.Contains(planet2)) {\n            // return []\n            return new List<string>();\n        }\n        // l = names.index(planet1)\n        var l = names.IndexOf(planet1);\n        // r = names.index(planet2)\n        var r = names.IndexOf(planet2);\n        // if l > r:\n        if (l > r) {\n            // l, r = r, l\n            var t = l;\n            l = r;\n            r = t;\n        }\n        // if l == r:\n        if (l == r) {\n            // return []\n            return new List<string>();\n        }\n        // return names[l + 1 : r]\n        return names.GetRange(l + 1, r - l - 1);\n    }\n}\n",
            "class Global {\n    public static IList<string> SortedListSum(IList<string> lst) {\n        // result = [s for s in lst if len(s) % 2 == 0]\n        var result = new List<string>();\n        foreach (var s in lst) {\n            if (s.Length % 2 == 0) {\n                result.Add(s);\n            }\n        }\n        // return sorted(result, key=lambda x: (len(x), x))\n        return result.OrderBy(x => (x.Length, x)).ToList();\n    }\n}\n",
            "class Global {\n    public static int XOrY(int n, int x, int y) {\n        // if n < 2:\n        if (n < 2) {\n            // return y\n            return y;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= (int)Math.Floor(Math.Sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return y\n                return y;\n            }\n        }\n        // return x\n        return x;\n    }\n}\n",
            "class Global {\n    public static int DoubleTheDifference(IList<float> lst) {\n        // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n        return lst.Where(n => n >= 0 && n % 2 == 1).Sum(n => n * n);\n    }\n}\n",
            "class Global {\n    public static IList<int> Compare(IList<int> game, IList<int> guess) {\n        // return [abs(x - y) for x, y in zip(game, guess)]\n        return game.Zip(guess, (x, y) => Math.Abs(x - y)).ToList();\n    }\n}\n",
            "class Global {\n    public static string StrongestExtension(string className, IList<string> extensions) {\n        // max_s = float(\"-inf\")\n        double maxS = double.NegativeInfinity;\n        // max_ext = \"\"\n        string maxExt = \"\";\n        // for ext in extensions:\n        foreach (var ext in extensions) {\n            // upper = len([c for c in ext if c.isupper()])\n            var upper = 0;\n            foreach (var c in ext) {\n                if (char.IsUpper(c)) {\n                    upper++;\n                }\n            }\n            // lower = len([c for c in ext if c.islower()])\n            var lower = 0;\n            foreach (var c in ext) {\n                if (char.IsLower(c)) {\n                    lower++;\n                }\n            }\n            // s = upper - lower\n            var s = upper - lower;\n            // if s > max_s:\n            if (s > maxS) {\n                // max_s = s\n                maxS = s;\n                // max_ext = ext\n                maxExt = ext;\n            }\n        }\n        // return f\"{class_name}.{max_ext}\"\n        return $\"{className}.{maxExt}\";\n    }\n}\n",
            "class Global {\n    public static bool CycpatternCheck(string a, string b) {\n        // if len(a) < len(b):\n        if (a.Length < b.Length) {\n            // return False\n            return false;\n        }\n        // for i in range(len(b)):\n        for (int i = 0; i < b.Length; i++) {\n            // if b[i:] + b[:i] in a:\n            if (a.Contains(b.Substring(i) + b.Substring(0, i))) {\n                // return True\n                return true;\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static IList<int> EvenOddCount(int num) {\n        // ds = str(abs(num))\n        var ds = Math.Abs(num).ToString();\n        // even = len([d for d in ds if ord(d) % 2 == 0])\n        var even = 0;\n        foreach (var d in ds) {\n            if (d % 2 == 0) {\n                even++;\n            }\n        }\n        // return [even, len(ds) - even]\n        return new List<int> { even, ds.Length - even };\n    }\n}\n",
            "class Global {\n    public static string IntToMiniRoman(int num) {\n        // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        var values = new List<int> { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n        // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n        var numerals = new List<string> { \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" };\n        // res = []\n        var res = new List<string>();\n        // for i in range(len(values)):\n        for (int i = 0; i < values.Count; i++) {\n            // while num >= values[i]:\n            while (num >= values[i]) {\n                // res.append(numerals[i])\n                res.Add(numerals[i]);\n                // num -= values[i]\n                num -= values[i];\n            }\n        }\n        // return \"\".join(res)\n        return string.Join(\"\", res);\n    }\n}\n",
            "class Global {\n    public static bool RightAngleTriangle(int a, int b, int c) {\n        // s = sorted([a, b, c])\n        var s = new List<int> { a, b, c };\n        s.Sort();\n        // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n        return s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n    }\n}\n",
            "class Global {\n    public static string FindMax(IList<string> words) {\n        // max_cnt = 0\n        int maxCnt = 0;\n        // max_w = \"\"\n        string maxW = \"\";\n        // for w in words:\n        foreach (var w in words) {\n            // cnt = len(set(w))\n            var cnt = new HashSet<char>(w).Count;\n            // if cnt > max_cnt:\n            if (cnt > maxCnt) {\n                // max_cnt = cnt\n                maxCnt = cnt;\n                // max_w = w\n                maxW = w;\n            }\n            // elif cnt == max_cnt:\n            else if (cnt == maxCnt) {\n                // max_w = min(max_w, w)\n                maxW = string.Compare(maxW, w) < 0 ? maxW : w;\n            }\n        }\n        // return max_w\n        return maxW;\n    }\n}\n",
            "class Global {\n    public static IList<int> Eat(int num, int need, int remaining) {\n        // if need <= remaining:\n        if (need <= remaining) {\n            // return [num + need, remaining - need]\n            return new List<int> { num + need, remaining - need };\n        } else {\n            // return [num + remaining, 0]\n            return new List<int> { num + remaining, 0 };\n        }\n    }\n}\n",
            "class Global {\n    public static int DoAlgebra(IList<string> operators, IList<int> operands) {\n        // ops = operators.copy()\n        var ops = new List<string>(operators);\n        // nums = operands.copy()\n        var nums = new List<int>(operands);\n        // i = len(ops) - 1\n        var i = ops.Count - 1;\n        // while i >= 0:\n        while (i >= 0) {\n            // if ops[i] == \"**\":\n            if (ops[i] == \"**\") {\n                // nums[i] = pow(nums[i], nums[i + 1])\n                nums[i] = (int)Math.Pow(nums[i], nums[i + 1]);\n                // nums.pop(i + 1)\n                nums.RemoveAt(i + 1);\n                // ops.pop(i)\n                ops.RemoveAt(i);\n            }\n            // i -= 1\n            i -= 1;\n        }\n        // i = 0\n        i = 0;\n        // while i < len(ops):\n        while (i < ops.Count) {\n            // if ops[i] == \"*\":\n            if (ops[i] == \"*\") {\n                // nums[i] = nums[i] * nums[i + 1]\n                nums[i] = nums[i] * nums[i + 1];\n                // nums.pop(i + 1)\n                nums.RemoveAt(i + 1);\n                // ops.pop(i)\n                ops.RemoveAt(i);\n                // i -= 1\n                i -= 1;\n            }\n            // elif ops[i] == \"//\":\n            else if (ops[i] == \"//\") {\n                // nums[i] = nums[i] // nums[i + 1]\n                nums[i] = nums[i] / nums[i + 1];\n                // nums.pop(i + 1)\n                nums.RemoveAt(i + 1);\n                // ops.pop(i)\n                ops.RemoveAt(i);\n                // i -= 1\n                i -= 1;\n            }\n            // i += 1\n            i += 1;\n        }\n        // i = 0\n        i = 0;\n        // while i < len(ops):\n        while (i < ops.Count) {\n            // if ops[i] == \"+\":\n            if (ops[i] == \"+\") {\n                // nums[i] = nums[i] + nums[i + 1]\n                nums[i] = nums[i] + nums[i + 1];\n                // nums.pop(i + 1)\n                nums.RemoveAt(i + 1);\n                // ops.pop(i)\n                ops.RemoveAt(i);\n                // i -= 1\n                i -= 1;\n            }\n            // elif ops[i] == \"-\":\n            else if (ops[i] == \"-\") {\n                // nums[i] = nums[i] - nums[i + 1]\n                nums[i] = nums[i] - nums[i + 1];\n                // nums.pop(i + 1)\n                nums.RemoveAt(i + 1);\n                // ops.pop(i)\n                ops.RemoveAt(i);\n                // i -= 1\n                i -= 1;\n            }\n            // i += 1\n            i += 1;\n        }\n        // return nums[0]\n        return nums[0];\n    }\n}\n",
            "class Global {\n    public static string Solve(string s) {\n        // if not any(ch.isalpha() for ch in s):\n        if (!s.Any(ch => char.IsLetter(ch))) {\n            // return s[::-1]\n            return new string(s.Reverse().ToArray());\n        }\n        // result = []\n        var result = new List<char>();\n        // for ch in s:\n        foreach (var ch in s) {\n            // if not ch.isalpha():\n            if (!char.IsLetter(ch)) {\n                // result.append(ch)\n                result.Add(ch);\n            }\n            // elif ch.isupper():\n            else if (char.IsUpper(ch)) {\n                // result.append(ch.lower())\n                result.Add(char.ToLower(ch));\n            }\n            // elif ch.islower():\n            else if (char.IsLower(ch)) {\n                // result.append(ch.upper())\n                result.Add(char.ToUpper(ch));\n            }\n        }\n        // return \"\".join(result)\n        return new string(result.ToArray());\n    }\n}\n",
            "class Global {\n    public static string StringToMd5(string txt) {\n        // if not txt:\n        if (string.IsNullOrEmpty(txt)) {\n            // return None\n            return null;\n        }\n        // md5_hash = hashlib.md5()\n        var md5_hash = MD5.Create();\n        // txt_bytes = txt.encode()\n        var txt_bytes = System.Text.Encoding.UTF8.GetBytes(txt);\n        // md5_hash.update(txt_bytes)\n        md5_hash.TransformBlock(txt_bytes, 0, txt_bytes.Length, null, 0);\n        // md5_encoded = md5_hash.hexdigest()\n        var md5_encoded = BitConverter.ToString(md5_hash.Hash).Replace(\"-\", \"\");\n        // return md5_encoded\n        return md5_encoded;\n    }\n}\n",
            "class Global {\n    public static IList<int> GenerateIntegers(int a, int b) {\n        // lower = max(2, min(a, b))\n        var lower = Math.Max(2, Math.Min(a, b));\n        // upper = min(8, max(a, b))\n        var upper = Math.Min(8, Math.Max(a, b));\n        // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n        return Enumerable.Range(lower, upper - lower + 1).Where(i => i % 2 == 0).ToList();\n    }\n}\n"
        ],
        "dart": [
            "bool hasCloseElements(List<double> numbers, double threshold) {\n    // for i in range(len(numbers)):\n    for (int i = 0; i < numbers.length; i++) {\n        // for j in range(i + 1, len(numbers)):\n        for (int j = i + 1; j < numbers.length; j++) {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                // return True\n                return true;\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "List<String> separateParenGroups(String parenString) {\n    // groups = []\n    var groups = <String>[];\n    // stk = []\n    var stk = <String>[];\n    // current_group = \"\"\n    var currentGroup = \"\";\n    // parens = paren_string.replace(\" \", \"\")\n    var parens = parenString.replaceAll(\" \", \"\");\n    // for ch in parens:\n    for (var ch in parens.split(\"\")) {\n        // if ch == \"(\":\n        if (ch == \"(\") {\n            // stk.append(ch)\n            stk.add(ch);\n            // current_group += ch\n            currentGroup += ch;\n        }\n        // elif ch == \")\":\n        else if (ch == \")\") {\n            // stk.pop()\n            stk.removeLast();\n            // current_group += ch\n            currentGroup += ch;\n            // if not stk:\n            if (stk.isEmpty) {\n                // groups.append(current_group)\n                groups.add(currentGroup);\n                // current_group = \"\"\n                currentGroup = \"\";\n            }\n        }\n    }\n    // return groups\n    return groups;\n}\n",
            "double truncateNumber(double num) {\n    // return num - floor(num)\n    return num - num.floorToDouble();\n}\n",
            "bool belowZero(List<int> operations) {\n    // balance = 0\n    int balance = 0;\n    // for op in operations:\n    for (int op in operations) {\n        // balance += op\n        balance += op;\n        // if balance < 0:\n        if (balance < 0) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "double meanAbsoluteDeviation(List<double> numbers) {\n    // mean = sum(numbers) / len(numbers)\n    double mean = numbers.reduce((a, b) => a + b) / numbers.length;\n    // deviation = sum(abs(x - mean) for x in numbers)\n    double deviation = numbers.map((x) => (x - mean).abs()).reduce((a, b) => a + b);\n    // return deviation / len(numbers)\n    return deviation / numbers.length;\n}\n",
            "List<int> intersperse(List<int> numbers, int delimiter) {\n    // result = []\n    var result = <int>[];\n    // for i in range(len(numbers)):\n    for (int i = 0; i < numbers.length; i++) {\n        // if i != 0:\n        if (i != 0) {\n            // result.append(delimiter)\n            result.add(delimiter);\n        }\n        // result.append(numbers[i])\n        result.add(numbers[i]);\n    }\n    // return result\n    return result;\n}\n",
            "List<int> parseNestedParens(String parenString) {\n    // result = []\n    var result = <int>[];\n    // paren_groups = paren_string.split()\n    var parenGroups = parenString.split(\" \");\n    // for group in paren_groups:\n    for (var group in parenGroups) {\n        // max_depth = 0\n        var maxDepth = 0;\n        // depth = 0\n        var depth = 0;\n        // for ch in group:\n        for (var ch in group.split(\"\")) {\n            // if ch == \"(\":\n            if (ch == \"(\") {\n                // depth += 1\n                depth += 1;\n                // max_depth = max(max_depth, depth)\n                maxDepth = max(maxDepth, depth);\n            }\n            // elif ch == \")\":\n            else if (ch == \")\") {\n                // depth -= 1\n                depth -= 1;\n            }\n        }\n        // result.append(max_depth)\n        result.add(maxDepth);\n    }\n    // return result\n    return result;\n}\n",
            "List<String> filterBySubstring(List<String> strs, String substring) {\n    // return [s for s in strs if substring in s]\n    return strs.where((s) => s.contains(substring)).toList();\n}\n",
            "List<int> sumProduct(List<int> numbers) {\n    // n_sum = sum(numbers)\n    int nSum = numbers.reduce((x, y) => x + y);\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    int nProduct = numbers.reduce((x, y) => x * y);\n    // return [n_sum, n_product]\n    return [nSum, nProduct];\n}\n",
            "List<int> rollingMax(List<int> numbers) {\n    // max_so_far = float(\"-inf\")\n    var maxSoFar = double.negativeInfinity;\n    // result = []\n    var result = <int>[];\n    // for num in numbers:\n    for (int num in numbers) {\n        // max_so_far = max(max_so_far, num)\n        maxSoFar = max(maxSoFar, num.toDouble());\n        // result.append(max_so_far)\n        result.add(maxSoFar.toInt());\n    }\n    // return result\n    return result;\n}\n",
            "bool isPalindrome(String s) {\n    // return s == s[::-1]\n    return s == s.split('').reversed.join();\n}\nString makePalindrome(String s) {\n    // if is_palindrome(s):\n    if (isPalindrome(s)) {\n        // return s\n        return s;\n    }\n    // for i in range(len(s)):\n    for (int i = 0; i < s.length; i++) {\n        // if is_palindrome(s[i:]):\n        if (isPalindrome(s.substring(i))) {\n            // return s + s[:i][::-1]\n            return s + s.substring(0, i).split('').reversed.join();\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "String stringXor(String a, String b) {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    return a.chars.zip(b.chars).map((e) => e.first == e.last ? \"0\" : \"1\").join();\n}\n",
            "String longest(List<String> strs) {\n    // if not strs:\n    if (strs.isEmpty) {\n        // return None\n        return null;\n    }\n    // longest_s = strs[0]\n    String longestS = strs[0];\n    // for s in strs:\n    for (String s in strs) {\n        // if len(s) > len(longest_s):\n        if (s.length > longestS.length) {\n            // longest_s = s\n            longestS = s;\n        }\n    }\n    // return longest_s\n    return longestS;\n}\n",
            "int greatestCommonDivisor(int a, int b) {\n    // if b == 0:\n    if (b == 0) {\n        // return a\n        return a;\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        return greatestCommonDivisor(b, a % b);\n    }\n}\n",
            "List<String> allPrefixes(String s) {\n    // prefixes = []\n    var prefixes = <String>[];\n    // for i in range(len(s)):\n    for (int i = 0; i < s.length; i++) {\n        // prefixes.append(s[: i + 1])\n        prefixes.add(s.substring(0, i + 1));\n    }\n    // return prefixes\n    return prefixes;\n}\n",
            "String stringSequence(int n) {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    return [for (int i = 0; i <= n; i++) i.toString()].join(' ');\n}\n",
            "int countDistinctCharacters(String s) {\n    // return len(set(s.lower()))\n    return Set.from(s.toLowerCase().split('')).length;\n}\n",
            "List<int> parseMusic(String musicString) {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    var durations = {\n        \"o\": 4,\n        \"o|\": 2,\n        \".|\": 1,\n    };\n    // notes = music_string.split()\n    var notes = musicString.split(\" \");\n    // return [durations[note] for note in notes]\n    return [for (var note in notes) durations[note]];\n}\n",
            "int howManyTimes(String s, String substring) {\n    // times = 0\n    int times = 0;\n    // for i in range(len(s) - len(substring) + 1):\n    for (int i = 0; i < s.length - substring.length + 1; i++) {\n        // if s[i : i + len(substring)] == substring:\n        if (s.substring(i, i + substring.length) == substring) {\n            // times += 1\n            times++;\n        }\n    }\n    // return times\n    return times;\n}\n",
            "String sortNumbers(String numbers) {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    var numDict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    };\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    var numList = numbers.split(\" \").where((x) => numDict.containsKey(x)).toList();\n    // num_list.sort(key=lambda x: num_dict[x])\n    numList.sort((a, b) => numDict[a].compareTo(numDict[b]));\n    // return \" \".join(num_list)\n    return numList.join(\" \");\n}\n",
            "List<double> findClosestElements(List<double> numbers) {\n    // sorted_numbers = sorted(numbers)\n    var sortedNumbers = numbers.toList()..sort();\n    // min_diff = float(\"inf\")\n    var minDiff = double.infinity;\n    // closest_pair = []\n    var closestPair = <double>[];\n    // for i in range(1, len(sorted_numbers)):\n    for (int i = 1; i < sortedNumbers.length; i++) {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        var diff = sortedNumbers[i] - sortedNumbers[i - 1];\n        // if diff < min_diff:\n        if (diff < minDiff) {\n            // min_diff = diff\n            minDiff = diff;\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closestPair = [sortedNumbers[i - 1], sortedNumbers[i]];\n        }\n    }\n    // return closest_pair\n    return closestPair;\n}\n",
            "List<double> rescaleToUnit(List<double> numbers) {\n    // min_num = min(numbers)\n    double minNum = numbers.reduce(min);\n    // max_num = max(numbers)\n    double maxNum = numbers.reduce(max);\n    // if min_num == max_num:\n    if (minNum == maxNum) {\n        // return [0.0] * len(numbers)\n        return List.filled(numbers.length, 0.0);\n    } else {\n        // return [(num - min_num) / (max_num - min_num) for num in numbers]\n        return numbers.map((num) => (num - minNum) / (maxNum - minNum)).toList();\n    }\n}\n",
            "List<int> filterIntegers(List values) {\n    // return [x for x in values if isinstance(x, int)]\n    return values.where((x) => x is int).toList();\n}\n",
            "int strLength(String s) {\n    // return len(s)\n    return s.length;\n}\n",
            "int largestDivisor(int n) {\n    // for i in range(2, n):\n    for (int i = 2; i < n; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return n // i\n            return n ~/ i;\n        }\n    }\n    // return 1\n    return 1;\n}\n",
            "List<int> factorize(int n) {\n    // factors = []\n    var factors = <int>[];\n    // divisor = 2\n    var divisor = 2;\n    // while divisor <= n:\n    while (divisor <= n) {\n        // if n % divisor == 0:\n        if (n % divisor == 0) {\n            // factors.append(divisor)\n            factors.add(divisor);\n            // n //= divisor\n            n ~/= divisor;\n        } else {\n            // divisor += 1\n            divisor++;\n        }\n    }\n    // return factors\n    return factors;\n}\n",
            "List<int> removeDuplicates(List<int> numbers) {\n    // counts = {}\n    var counts = <int, int>{};\n    // for num in numbers:\n    for (int num in numbers) {\n        // counts[num] = counts.get(num, 0) + 1\n        counts[num] = counts.putIfAbsent(num, () => 0) + 1;\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    var res = numbers.where((num) => counts[num] == 1).toList();\n    // return res\n    return res;\n}\n",
            "String flipCase(String s) {\n    // flipped = []\n    var flipped = <String>[];\n    // for ch in s:\n    for (var ch in s.split('')) {\n        // if not ch.isalpha():\n        if (!ch.contains(RegExp(r'[a-zA-Z]'))) {\n            // flipped.append(ch)\n            flipped.add(ch);\n        }\n        // elif ch.islower():\n        else if (ch.toLowerCase() == ch) {\n            // flipped.append(ch.upper())\n            flipped.add(ch.toUpperCase());\n        }\n        // elif ch.isupper():\n        else if (ch.toUpperCase() == ch) {\n            // flipped.append(ch.lower())\n            flipped.add(ch.toLowerCase());\n        }\n    }\n    // return ''.join(flipped)\n    return flipped.join();\n}\n",
            "String concatenate(List<String> strs) {\n    // return \"\".join(strs)\n    return strs.join();\n}\n",
            "List<String> filterByPrefix(List<String> strs, String prefixStr) {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    return strs.where((s) => s.startsWith(prefixStr)).toList();\n}\n",
            "List<int> getPositive(List<int> l) {\n    // return [num for num in l if num > 0]\n    return l.where((num) => num > 0).toList();\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= (sqrt(n) + 1).floor(); i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "double poly(List<int> xs, double x) {\n    double res = 0.0;\n    for (int i = 0; i < xs.length; i++) {\n        res += xs[i] * x.pow(i);\n    }\n    return res;\n}\ndouble findZero(List<int> xs) {\n    double x1 = 1.0, x2 = -1.0;\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        x1 *= 2;\n        x2 *= 2;\n    }\n    while (x1 - x2 > 1e-10) {\n        double mid = (x1 + x2) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid;\n        } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            x2 = mid;\n        } else {\n            x1 = mid;\n        }\n    }\n    return (x1 + x2) / 2;\n}\n",
            "List<int> sortThird(List<int> l) {\n    // sorted_third = sorted(l[::3])\n    var sortedThird = l.sublist(0, l.length)..sort();\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    return List.generate(l.length, (i) {\n        return i % 3 == 0 ? sortedThird[i ~/ 3] : l[i];\n    });\n}\n",
            "List<int> listUnique(List<int> l) {\n    // return sorted(list(set(l)))\n    return l.toSet().toList()..sort();\n}\n",
            "int maxElement(List<int> l) {\n    // if not l:\n    if (l.isEmpty) {\n        // return 0\n        return 0;\n    }\n    // return max(l)\n    return l.reduce(max);\n}\n",
            "int fizzBuzz(int n) {\n    // cnt = 0\n    int cnt = 0;\n    // for i in range(n):\n    for (int i = 0; i < n; i++) {\n        // if i % 11 == 0 or i % 13 == 0:\n        if (i % 11 == 0 || i % 13 == 0) {\n            // cnt += str(i).count(\"7\")\n            cnt += (i.toString().split(\"7\").length - 1);\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "List<int> sortEven(List<int> l) {\n    // sorted_even = sorted(l[::2])\n    var sortedEven = l.sublist(0, l.length)..sort();\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    return l.map((e) {\n        var i = l.indexOf(e);\n        return i % 2 == 0 ? sortedEven[i ~/ 2] : e;\n    }).toList();\n}\n",
            "String encodeCyclic(String s) {\n    // result = []\n    var result = <String>[];\n    // for i in range(0, len(s), 3):\n    for (int i = 0; i < s.length; i += 3) {\n        // if i + 3 > len(s):\n        if (i + 3 > s.length) {\n            // result.append(s[i:])\n            result.add(s.substring(i));\n        } else {\n            // result.append(s[i+1:i+3])\n            result.add(s.substring(i + 1, i + 3));\n            // result.append(s[i])\n            result.add(s[i]);\n        }\n    }\n    // return \"\".join(result)\n    return result.join();\n}\nString decodeCyclic(String s) {\n    return encodeCyclic(encodeCyclic(s));\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= (sqrt(n) + 1).floor(); i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nint primeFib(int n) {\n    // f = [0, 1]\n    var f = [0, 1];\n    // cnt = 0\n    var cnt = 0;\n    // while cnt < n:\n    while (cnt < n) {\n        // f = [f[1], f[0] + f[1]]\n        f = [f[1], f[0] + f[1]];\n        // if is_prime(f[1]):\n        if (isPrime(f[1])) {\n            // cnt += 1\n            cnt++;\n        }\n    }\n    // return f[1]\n    return f[1];\n}\n",
            "bool triplesSumToZero(List<int> l) {\n    // for i in range(len(l)):\n    for (int i = 0; i < l.length; i++) {\n        // for j in range(i + 1, len(l)):\n        for (int j = i + 1; j < l.length; j++) {\n            // for k in range(j + 1, len(l)):\n            for (int k = j + 1; k < l.length; k++) {\n                // if l[i] + l[j] + l[k] == 0:\n                if (l[i] + l[j] + l[k] == 0) {\n                    // return True\n                    return true;\n                }\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "int carRaceCollision(int n) {\n    // return n ** 2\n    return n * n;\n}\n",
            "List<int> incrList(List<int> l) {\n    // return [i + 1 for i in l]\n    return l.map((i) => i + 1).toList();\n}\n",
            "bool pairsSumToZero(List<int> l) {\n    // seen = set()\n    var seen = <int>{};\n    // for num in l:\n    for (int num in l) {\n        // if -num in seen:\n        if (-num in seen) {\n            // return True\n            return true;\n        }\n        // seen.add(num)\n        seen.add(num);\n    }\n    // return False\n    return false;\n}\n",
            "String changeBase(int x, int bas) {\n    // if x == 0:\n    if (x == 0) {\n        // return \"0\"\n        return \"0\";\n    }\n    // digits = []\n    var digits = <String>[];\n    // while x > 0:\n    while (x > 0) {\n        // digits.append(str(x % bas))\n        digits.add(x % bas);\n        // x //= bas\n        x ~/= bas;\n    }\n    // return \"\".join(digits[::-1])\n    return digits.reversed.join();\n}\n",
            "double triangleArea(int a, int h) {\n    // return a * h / 2\n    return a * h / 2;\n}\n",
            "int fib4(int n) {\n    // fib = [0, 0, 2, 0]\n    var fib = [0, 0, 2, 0];\n    // for i in range(4, n + 1):\n    for (int i = 4; i <= n; i++) {\n        // fib[i % 4] = sum(fib)\n        fib[i % 4] = fib[0] + fib[1] + fib[2];\n    }\n    // return fib[n % 4]\n    return fib[n % 4];\n}\n",
            "double median(List<double> l) {\n    // sl = sorted(l)\n    var sl = l.toList()..sort();\n    // if len(l) % 2 != 0:\n    if (l.length % 2 != 0) {\n        // return sl[len(l) // 2]\n        return sl[l.length ~/ 2];\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (sl[l.length ~/ 2] + sl[l.length ~/ 2 - 1]) / 2;\n    }\n}\n",
            "bool isPalindrome(String txt) {\n    // return txt == txt[::-1]\n    return txt == txt.split('').reversed.join();\n}\n",
            "int modp(int n, int p) {\n    // ret = 1\n    int ret = 1;\n    // for _ in range(n):\n    for (int _ = 0; _ < n; _++) {\n        // ret = (ret * 2) % p\n        ret = (ret * 2) % p;\n    }\n    // return ret\n    return ret;\n}\n",
            "String encodeShift(String s) {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    var result = [\n      for (var ch in s)\n        String.fromCharCode(((ch.codeUnitAt(0) - 97 + 5) % 26) + 97)\n    ];\n    // return \"\".join(result)\n    return result.join();\n}\nString decodeShift(String s) {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    var result = [\n      for (var ch in s)\n        String.fromCharCode(((ch.codeUnitAt(0) - 97 + 21) % 26) + 97)\n    ];\n    // return \"\".join(result)\n    return result.join();\n}\n",
            "String removeVowels(String txt) {\n    // vowels = \"aeiouAEIOU\"\n    var vowels = \"aeiouAEIOU\";\n    // return \"\".join([char for char in txt if char not in vowels])\n    return txt.split(\"\").where((char) => !vowels.contains(char)).join();\n}\n",
            "bool belowThreshold(List<int> l, int t) {\n    // return all(x < t for x in l)\n    return l.every((x) => x < t);\n}\n",
            "int add(int x, int y) {\n    // return x + y\n    return x + y;\n}\n",
            "bool sameChars(String s0, String s1) {\n    // return set(s0) == set(s1)\n    return Set.from(s0.split('')).toSet() == Set.from(s1.split('')).toSet();\n}\n",
            "int fib(int n) {\n    // if n <= 1:\n    if (n <= 1) {\n        // return n\n        return n;\n    } else {\n        // return fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n",
            "bool correctBracketing(String brackets) {\n    // depth = 0\n    int depth = 0;\n    // for b in brackets:\n    for (int i = 0; i < brackets.length; i++) {\n        // b = brackets[i]\n        String b = brackets[i];\n        // if b == \"<\":\n        if (b == \"<\") {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \">\":\n        else if (b == \">\") {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return depth == 0;\n}\n",
            "bool monotonic(List<int> l) {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    var diff = l.asMap().entries.map((e) => e.value - l[e.key + 1]).toList();\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    return diff.every((x) => x <= 0) || diff.every((x) => x >= 0);\n}\n",
            "List<int> common(List<int> l1, List<int> l2) {\n    // return sorted(list(set(l1) & set(l2)))\n    return l1.toSet().intersection(l2.toSet()).toList()..sort();\n}\n",
            "int largestPrimeFactor(int n) {\n    // i = 2\n    int i = 2;\n    // while i * i <= n:\n    while (i * i <= n) {\n        // if n % i:\n        if (n % i != 0) {\n            // i += 1\n            i++;\n        } else {\n            // n //= i\n            n ~/= i;\n        }\n    }\n    // return n\n    return n;\n}\n",
            "int sumToN(int n) {\n    // return sum(range(n + 1))\n    return List.generate(n + 1, (i) => i).reduce((a, b) => a + b);\n}\n",
            "bool correctBracketing(String brackets) {\n    // depth = 0\n    int depth = 0;\n    // for b in brackets:\n    for (int i = 0; i < brackets.length; i++) {\n        // b = brackets[i]\n        String b = brackets[i];\n        // if b == \"(\":\n        if (b == \"(\") {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \")\":\n        else if (b == \")\") {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return depth == 0;\n}\n",
            "List<int> derivative(List<int> xs) {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    return List.generate(xs.length - 1, (i) => xs[i] * (i + 1));\n}\n",
            "int fibfib(int n) {\n    // if n <= 1:\n    if (n <= 1) {\n        // return 0 \n        return 0;\n    }\n    // a, b, c = 0, 0, 1\n    int a = 0, b = 0, c = 1;\n    // while n > 2:\n    while (n > 2) {\n        // a, b, c = b, c, a + b + c\n        a = b;\n        b = c;\n        c = a + b + c;\n        // n -= 1\n        n -= 1;\n    }\n    // return c\n    return c;\n}\n",
            "int vowelsCount(String s) {\n    // vowels = \"aeiou\"\n    var vowels = \"aeiou\";\n    // cnt = 0\n    var cnt = 0;\n    // for i in range(len(s)):\n    for (int i = 0; i < s.length; i++) {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if (s[i].toLowerCase() == \"y\" && i == s.length - 1) {\n            cnt += 1;\n        } else if (vowels.contains(s[i].toLowerCase())) {\n            cnt += 1;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "String circularShift(int x, int shift) {\n    // x_str = str(x)\n    var xStr = x.toString();\n    // if shift > len(x_str):\n    if (shift > xStr.length) {\n        // return x_str[::-1]\n        return xStr.split('').reversed.join();\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return xStr.substring(xStr.length - shift) + xStr.substring(0, xStr.length - shift);\n    }\n}\n",
            "int digitSum(String s) {\n    // return sum(ord(c) for c in s if c.isupper())\n    return s.runes.where((r) => r >= 65 && r <= 90).sum;\n}\n",
            "int fruitDistribution(String s, int n) {\n    // words = s.split(' ')\n    var words = s.split(' ');\n    // apples = int(words[words.index(\"apples\") - 1])\n    var apples = int.parse(words[words.indexOf(\"apples\") - 1]);\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    var oranges = int.parse(words[words.indexOf(\"oranges\") - 1]);\n    // return n - apples - oranges\n    return n - apples - oranges;\n}\n",
            "List<int> pluck(List<int> arr) {\n    // evens = [n for n in arr if n % 2 == 0]\n    var evens = arr.where((n) => n % 2 == 0).toList();\n    // if len(evens) == 0:\n    if (evens.isEmpty) {\n        // return []\n        return [];\n    }\n    // min_even = min(evens)\n    var minEven = evens.reduce(min);\n    // return [min_even, arr.index(min_even)]\n    return [minEven, arr.indexOf(minEven)];\n}\n",
            "int search(List<int> lst) {\n    // freqs = {}\n    var freqs = <int, int>{};\n    // for n in lst:\n    for (int n in lst) {\n        // freqs[n] = freqs.get(n, 0) + 1\n        freqs[n] = (freqs[n] ?? 0) + 1;\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    var goodVals = freqs.entries.where((e) => e.value >= e.key).map((e) => e.key).toList();\n    // return max(good_vals, default=-1)\n    return goodVals.isEmpty ? -1 : goodVals.reduce(max);\n}\n",
            "List<int> strangeSortList(List<int> lst) {\n    // sl = sorted(lst)\n    var sl = lst.toList()..sort();\n    // result = []\n    var result = <int>[];\n    // left, right = 0, len(sl) - 1\n    var left = 0, right = sl.length - 1;\n    // while left <= right:\n    while (left <= right) {\n        // result.append(sl[left])\n        result.add(sl[left]);\n        // left += 1\n        left += 1;\n        // if left <= right:\n        if (left <= right) {\n            // result.append(sl[right])\n            result.add(sl[right]);\n            // right -= 1\n            right -= 1;\n        }\n    }\n    // return result\n    return result;\n}\n",
            "double triangleArea(int a, int b, int c) {\n    // if a + b > c and a + c > b and b + c > a:\n    if (a + b > c && a + c > b && b + c > a) {\n        // s = (a + b + c) / 2.0\n        var s = (a + b + c) / 2.0;\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // return -1.0\n        return -1.0;\n    }\n}\n",
            "bool willItFly(List<int> q, int w) {\n    // if len(q) == 0:\n    if (q.isEmpty) {\n        // return False\n        return false;\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    var isPalin = true;\n    for (int i = 0; i < q.length; i++) {\n        if (q[i] != q[q.length - i - 1]) {\n            isPalin = false;\n            break;\n        }\n    }\n    // total = sum(q)\n    var total = 0;\n    for (int e in q) {\n        total += e;\n    }\n    // return is_palin and total <= w\n    return isPalin && total <= w;\n}\n",
            "int smallestChange(List<int> arr) {\n    // ans = 0\n    int ans = 0;\n    // for i in range(len(arr) // 2):\n    for (int i = 0; i < arr.length ~/ 2; i++) {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if (arr[i] != arr[arr.length - i - 1]) {\n            // ans += 1\n            ans++;\n        }\n    }\n    // return ans\n    return ans;\n}\n",
            "List<String> totalMatch(List<String> lst1, List<String> lst2) {\n    // cnt1 = sum(len(s) for s in lst1)\n    int cnt1 = 0;\n    for (String s in lst1) {\n        cnt1 += s.length;\n    }\n    // cnt2 = sum(len(s) for s in lst2)\n    int cnt2 = 0;\n    for (String s in lst2) {\n        cnt2 += s.length;\n    }\n    // return lst1 if cnt1 <= cnt2 else lst2\n    return cnt1 <= cnt2 ? lst1 : lst2;\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nbool isMultiplyPrime(int a) {\n    // cnt = 0\n    var cnt = 0;\n    // for i in range(2, a + 1):\n    for (int i = 2; i <= a + 1; i++) {\n        // if is_prime(i):\n        if (isPrime(i)) {\n            // while a % i == 0:\n            while (a % i == 0) {\n                // cnt += 1\n                cnt++;\n                // a /= i\n                a ~/= i;\n            }\n        }\n    }\n    // return cnt == 3\n    return cnt == 3;\n}\n",
            "bool isSimplePower(int x, int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return x == n\n        return x == n;\n    }\n    // tmp = 1\n    var tmp = 1;\n    // while tmp < x:\n    while (tmp < x) {\n        // tmp *= n\n        tmp *= n;\n    }\n    // return tmp == x\n    return tmp == x;\n}\n",
            "bool isCube(int a) {\n    // a = abs(a)\n    a = a.abs();\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    var root = (pow(a, 1.0 / 3.0)).round();\n    // return root * root * root == a\n    return root * root * root == a;\n}\n",
            "int hexKey(String num) {\n    // return len([x for x in num if x in \"2357BD\"])\n    return num.split(\"\").where((x) => \"2357BD\".contains(x)).length;\n}\n",
            "String decimalToBinary(int dec) {\n    // binary = bin(dec)[2:]\n    var binary = dec.toRadixString(2).substring(2);\n    // return f\"db{binary}db\"\n    return \"db$binary\" + \"db\";\n}\n",
            "bool isHappy(String s) {\n    // if len(s) < 3:\n    if (s.length < 3) {\n        // return False\n        return false;\n    }\n    // for i in range(len(s) - 2):\n    for (int i = 0; i < s.length - 2; i++) {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "List<String> numericalLetterGrade(List<double> grades) {\n    // result = []\n    var result = <String>[];\n    // for g in grades:\n    for (double g in grades) {\n        // if g == 4.0:\n        if (g == 4.0) {\n            // result.append(\"A+\")\n            result.add(\"A+\");\n        }\n        // elif g > 3.7:\n        else if (g > 3.7) {\n            // result.append(\"A\")\n            result.add(\"A\");\n        }\n        // elif g > 3.3:\n        else if (g > 3.3) {\n            // result.append(\"A-\")\n            result.add(\"A-\");\n        }\n        // elif g > 3.0:\n        else if (g > 3.0) {\n            // result.append(\"B+\")\n            result.add(\"B+\");\n        }\n        // elif g > 2.7:\n        else if (g > 2.7) {\n            // result.append(\"B\")\n            result.add(\"B\");\n        }\n        // elif g > 2.3:\n        else if (g > 2.3) {\n            // result.append(\"B-\")\n            result.add(\"B-\");\n        }\n        // elif g > 2.0:\n        else if (g > 2.0) {\n            // result.append(\"C+\")\n            result.add(\"C+\");\n        }\n        // elif g > 1.7:\n        else if (g > 1.7) {\n            // result.append(\"C\")\n            result.add(\"C\");\n        }\n        // elif g > 1.3:\n        else if (g > 1.3) {\n            // result.append(\"C-\")\n            result.add(\"C-\");\n        }\n        // elif g > 1.0:\n        else if (g > 1.0) {\n            // result.append(\"D+\")\n            result.add(\"D+\");\n        }\n        // elif g > 0.7:\n        else if (g > 0.7) {\n            // result.append(\"D\")\n            result.add(\"D\");\n        }\n        // elif g > 0.0:\n        else if (g > 0.0) {\n            // result.append(\"D-\")\n            result.add(\"D-\");\n        }\n        // else:\n        else {\n            // result.append(\"E\")\n            result.add(\"E\");\n        }\n    }\n    // return result\n    return result;\n}\n",
            "bool primeLength(String s) {\n    // length = len(s)\n    int length = s.length;\n    // if length < 2:\n    if (length < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for (int i = 2; i <= (sqrt(length) + 1).floor(); i++) {\n        // if length % i == 0:\n        if (length % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "int startsOneEnds(int n) {\n    // if n == 1:\n    if (n == 1) {\n        // return 1\n        return 1;\n    }\n    // return 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * (10 ** (n - 2));\n}\n",
            "String solve(int n) {\n    // digits_sum = sum(int(d) for d in str(n))\n    var digitsSum = 0;\n    for (var d in n.toString().split('')) {\n        digitsSum += int.parse(d);\n    }\n    // return bin(digits_sum)[2:]\n    return digitsSum.toRadixString(2).substring(2);\n}\n",
            "int add(List<int> lst) {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    return lst.asMap().entries.where((e) => e.key % 2 == 1 && e.value % 2 == 0).map((e) => e.value).reduce((a, b) => a + b);\n}\n",
            "String antiShuffle(String s) {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    var words = s.split(\" \").map((word) => word.split(\"\")..sort()).join(\" \");\n    // return \" \".join(words)\n    return words;\n}\n",
            "List<List<int>> getRow(List<List<int>> lst, int x) {\n    // coords = []\n    var coords = <List<int>>[];\n    // for i in range(len(lst)):\n    for (int i = 0; i < lst.length; i++) {\n        // for j in range(len(lst[i])):\n        for (int j = 0; j < lst[i].length; j++) {\n            // if lst[i][j] == x:\n            if (lst[i][j] == x) {\n                // coords.append([i, j])\n                coords.add([i, j]);\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    return coords.sorted((a, b) => a[0].compareTo(b[0]) * 1000 + b[1].compareTo(a[1]));\n}\n",
            "List<int> sortArray(List<int> arr) {\n    // if len(arr) == 0:\n    if (arr.isEmpty) {\n        // return []\n        return [];\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if ((arr[0] + arr.last) % 2 == 0) {\n        // return sorted(arr, reverse=True)\n        return arr.reversed.toList();\n    } else {\n        // return sorted(arr)\n        return arr;\n    }\n}\n",
            "String encrypt(String s) {\n    // result = []\n    var result = <String>[];\n    // for ch in s:\n    for (var ch in s.split('')) {\n        // shifted = ord(ch) + 4\n        var shifted = ch.codeUnitAt(0) + 4;\n        // if shifted > ord('z'):\n        if (shifted > 'z'.codeUnitAt(0)) {\n            // shifted -= 26\n            shifted -= 26;\n        }\n        // result.append(chr(shifted))\n        result.add(String.fromCharCode(shifted));\n    }\n    // return \"\".join(result)\n    return result.join();\n}\n",
            "int? nextSmallest(List<int> lst) {\n    // sl = sorted(set(lst))\n    var sl = List<int>.from(Set<int>.from(lst).toList()..sort());\n    // if len(sl) < 2:\n    if (sl.length < 2) {\n        // return None\n        return null;\n    }\n    // return sl[1]\n    return sl[1];\n}\n",
            "int isBored(String s) {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    var sentences = s.split(RegExp(r\"[.!?]\\s*\"));\n    // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    return sentences.where((sentence) => sentence.length >= 2).map((sentence) => sentence.substring(0, 2) == \"I \").sum();\n}\n",
            "bool anyInt(dynamic x, dynamic y, dynamic z) {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if (x is int && y is int && z is int) {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if (x + y == z || x + z == y || y + z == x) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "String encode(String message) {\n    // vowels = \"aeiouAEIOU\"\n    var vowels = \"aeiouAEIOU\";\n    // result = []\n    var result = <String>[];\n    // for ch in message:\n    for (var ch in message.split(\"\")) {\n        // if ch.isalpha():\n        if (ch.isAlphabetic) {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            var ch1 = ch.toUpperCase();\n            if (ch.isLowerCase) {\n                ch1 = ch1.toLowerCase();\n            }\n            // if ch1 in vowels:\n            if (vowels.contains(ch1)) {\n                // ch1 = chr(ord(ch1) + 2)\n                ch1 = String.fromCharCode(ch1.codeUnitAt(0) + 2);\n            }\n            // result.append(ch1)\n            result.add(ch1);\n        } else {\n            // result.append(ch)\n            result.add(ch);\n        }\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= (sqrt(n) + 1).floor(); i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nint skjkasdkd(List<int> lst) {\n    // primes = [n for n in lst if is_prime(n)]\n    var primes = lst.where((n) => isPrime(n)).toList();\n    // if len(primes) == 0:\n    if (primes.isEmpty) {\n        // return 0\n        return 0;\n    }\n    // largest = str(max(primes))\n    var largest = max(primes).toString();\n    // return sum(int(digit) for digit in largest)\n    return largest.codeUnits.map((c) => c - 48).reduce((a, b) => a + b);\n}\n",
            "bool checkDictCase(Map<String, String> d) {\n    // if not d:\n    if (d.isEmpty) {\n        // return False\n        return false;\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    return d.keys.every((c) => c.isLowerCase) || d.keys.every((c) => c.isUpperCase);\n}\n",
            "List<int> countUpTo(int n) {\n    // primes = []\n    var primes = <int>[];\n    // for num in range(2, n):\n    for (int num in range(2, n)) {\n        // if all(num % p != 0 for p in primes):\n        if (primes.every((p) => num % p != 0)) {\n            // primes.append(num)\n            primes.add(num);\n        }\n    }\n    // return primes\n    return primes;\n}\n",
            "int multiply(int a, int b) {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    return (a.abs() % 10) * (b.abs() % 10);\n}\n",
            "int countUpper(String s) {\n    // vowels = \"AEIOU\"\n    var vowels = \"AEIOU\";\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    return s.split(\"\").asMap().entries.where((e) => e.key % 2 == 0 && vowels.contains(e.value)).length;\n}\n",
            "int closestInteger(String value) {\n    // num = float(value)\n    double num = double.parse(value);\n    // if num >= 0:\n    if (num >= 0) {\n        // return int(num + 0.5)\n        return (num + 0.5).toInt();\n    } else {\n        // return int(num - 0.5)\n        return (num - 0.5).toInt();\n    }\n}\n",
            "List<int> makeAPile(int n) {\n    // return [n + 2 * i for i in range(n)]\n    return List.generate(n, (i) => n + 2 * i);\n}\n",
            "List<String> wordsString(String s) {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    return re.split(r\"[, ]\", s).where((w) => w.length > 0).toList();\n}\n",
            "int chooseNum(int x, int y) {\n    // if x > y:\n    if (x > y) {\n        // return -1\n        return -1;\n    }\n    // if y % 2 == 0:\n    if (y % 2 == 0) {\n        // return y\n        return y;\n    }\n    // return y - 1 if x != y else -1\n    return y - 1;\n}\n",
            "String? roundedAvg(int n, int m) {\n    // if n > m:\n    if (n > m) {\n        // return None\n        return null;\n    }\n    // r_avg = int((m + n) / 2.0 + 0.5)\n    var rAvg = (m + n) ~/ 2 + 1;\n    // return bin(r_avg)[2:]\n    return rAvg.toRadixString(2).substring(1);\n}\n",
            "bool allDigitsOdd(String s) {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    return s.codeUnits.every((digit) => digit % 2 != 0);\n}\nList<int> uniqueDigits(List<int> x) {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    return x.where((num) => allDigitsOdd(num.toString())).toList()..sort();\n}\n",
            "List<String> byLength(List<int> arr) {\n    // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    var digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n    var sortedArr = arr.where((x) => 1 <= x && x <= 9).toList()..sort((a, b) => b.compareTo(a));\n    // return [digit_names[x-1] for x in sorted_arr]\n    return sortedArr.map((x) => digitNames[x - 1]).toList();\n}\n",
            "List<int> f(int n) {\n    // nums = list(range(1, n + 1))\n    var nums = List<int>.generate(n + 1, (i) => i + 1);\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    return nums.map((i) => i % 2 != 0 ? nums.sublist(0, i).reduce((x, y) => x + y) : nums.sublist(0, i).reduce((x, y) => x * y)).toList();\n}\n",
            "bool isPalindrome(String txt) {\n    return txt == txt.split('').reversed.join();\n}\nList<int> evenOddPalindrome(int n) {\n    // cnt = [0, 0]\n    var cnt = [0, 0];\n    // for i in range(1, n + 1):\n    for (int i = 1; i <= n; i++) {\n        // if is_palindrome(str(i)):\n        if (isPalindrome(i.toString())) {\n            // cnt[i % 2] += 1\n            cnt[i % 2] += 1;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "int digitsSum(int n) {\n    // n_str = str(n)\n    var nStr = n.toString();\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.split('').map((d) => int.parse(d)).reduce((a, b) => a + b);\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return int.parse(nStr.substring(0, 2)) * 2 + digitsSum(n.abs());\n    }\n}\nint countNums(List<int> arr) {\n    // return len([n for n in arr if digits_sum(n) > 0])\n    return arr.where((n) => digitsSum(n) > 0).length;\n}\n",
            "bool moveOneBall(List<int> arr) {\n    // if len(arr) == 0:\n    if (arr.isEmpty) {\n        // return True\n        return true;\n    }\n    // sorted_arr = sorted(arr)\n    var sortedArr = arr.toList()..sort();\n    // for i in range(0, len(arr)):\n    for (int i = 0; i < arr.length; i++) {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if (arr.sublist(i) == sortedArr.sublist(0, arr.length - i) &&\n            arr.sublist(0, i) == sortedArr.sublist(arr.length - i)) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "String canExchange(List<int> lst1, List<int> lst2) {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    int oddCnt = lst1.where((num) => num % 2 != 0).length;\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    int evenCnt = lst2.where((num) => num % 2 == 0).length;\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    return evenCnt >= oddCnt ? \"YES\" : \"NO\";\n}\n",
            "Map<String, int> histogram(String test) {\n    // freq = {}\n    var freq = <String, int>{};\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    var words = test.split(\" \").where((w) => w.length > 0).toList();\n    // for w in words:\n    for (var w in words) {\n        // freq[w] = freq.get(w, 0) + 1\n        freq[w] = (freq[w] ?? 0) + 1;\n    }\n    // result = {}\n    var result = <String, int>{};\n    // if len(freq) > 0:\n    if (freq.isNotEmpty) {\n        // max_freq = max(freq.values())\n        var maxFreq = max(freq.values);\n        // for k, v in freq.items():\n        for (var k in freq.keys) {\n            // if v == max_freq:\n            if (freq[k] == maxFreq) {\n                // result[k] = v\n                result[k] = freq[k];\n            }\n        }\n    }\n    // return result\n    return result;\n}\n",
            "bool isPalindrome(String s) {\n    // return s == s[::-1]\n    return s == s.split('').reversed.join();\n}\nList<String> reverseDelete(String s, String c) {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    var s1 = s.split('').where((ch) => !c.contains(ch)).join();\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    return [s1, isPalindrome(s1) ? \"yes\" : \"no\"];\n}\n",
            "List<String> oddCount(List<String> lst) {\n    // result = []\n    var result = <String>[];\n    // for num in lst:\n    for (String num in lst) {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        var n = 0;\n        for (int i = 0; i < num.length; i++) {\n            n += (num.codeUnitAt(i) % 2 == 1) ? 1 : 0;\n        }\n        // rs = \"the number of odd elements in the string i of the input.\"\n        var rs = \"the number of odd elements in the string $n of the input.\";\n        // result.append(rs.replace(\"i\", str(n)))\n        result.add(rs.replaceAll(\"i\", n.toString()));\n    }\n    // return result\n    return result;\n}\n",
            "int minSubArraySum(List<int> nums) {\n    // min_sum = 0\n    int minSum = 0;\n    // cur_sum = 0\n    int curSum = 0;\n    // for n in nums:\n    for (int n in nums) {\n        // cur_sum = min(cur_sum + n, 0)\n        curSum = min(curSum + n, 0);\n        // min_sum = min(cur_sum, min_sum)\n        minSum = min(curSum, minSum);\n    }\n    // if min_sum == 0:\n    if (minSum == 0) {\n        // min_sum = min(nums)\n        minSum = min(nums);\n    }\n    // return min_sum\n    return minSum;\n}\n",
            "int maxFill(List<List<int>> grid, int capacity) {\n    // return sum([ceil(sum(arr) / capacity) for arr in grid])\n    return grid.map((arr) => ceil(arr.reduce((a, b) => a + b) / capacity)).reduce((a, b) => a + b);\n}\n",
            "int countOnes(int num) {\n    // return bin(num).count(\"1\")\n    return int.parse(num.toRadixString(2), radix: 2).toString().length;\n}\nList<int> sortArray(List<int> arr) {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    return arr.toList()..sort((a, b) => countOnes(a).compareTo(countOnes(b)) ?? a.compareTo(b));\n}\n",
            "List<String> selectWords(String s, int n) {\n    // consonants = \"bcdfghjklmnpqrstvwxyz\"\n    var consonants = \"bcdfghjklmnpqrstvwxyz\";\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    var words = s.split(\" \").where((w) => w.length > 0).toList();\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    return words.where((w) => w.length == n).toList();\n}\n",
            "String getClosestVowel(String word) {\n    // vowels = \"aeiouAEIOU\"\n    var vowels = \"aeiouAEIOU\";\n    // for i in range(len(word) - 2, 0, -1):\n    for (int i = word.length - 2; i >= 0; i--) {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if (vowels.contains(word[i]) && !vowels.contains(word[i - 1]) && !vowels.contains(word[i + 1])) {\n            // return word[i]\n            return word[i];\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "bool check(String s) {\n    int depth = 0;\n    for (var ch in s.split('')) {\n        if (ch == '(') {\n            depth += 1;\n        } else {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth == 0;\n}\nString matchParens(List<String> lst) {\n    var s1 = lst[0] + lst[1];\n    var s2 = lst[1] + lst[0];\n    return 'Yes' if (check(s1) || check(s2)) else 'No';\n}\n",
            "List<int> maximum(List<int> arr, int k) {\n    // if k == 0:\n    if (k == 0) {\n        // return []\n        return [];\n    }\n    // return sorted(arr)[-k:]\n    return arr.sublist(arr.length - k);\n}\n",
            "int solution(List<int> lst) {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    return lst.asMap().entries.where((e) => e.key % 2 == 0 && e.value % 2 != 0).map((e) => e.value).reduce((a, b) => a + b);\n}\n",
            "int addElements(List<int> arr, int k) {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    return arr.sublist(0, k).where((n) => n.toString().length <= 2).reduce((a, b) => a + b);\n}\n",
            "List<int> getOddCollatz(int n) {\n    // collatz = [1]\n    var collatz = <int>[1];\n    // while n != 1:\n    while (n != 1) {\n        // if n % 2 != 0:\n        if (n % 2 != 0) {\n            // collatz.append(n)\n            collatz.add(n);\n            // n = 3 * n + 1\n            n = 3 * n + 1;\n        } else {\n            // n = n // 2\n            n = n ~/ 2;\n        }\n    }\n    // return sorted(collatz)\n    return collatz.toList()..sort();\n}\n",
            "bool validDate(String date) {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if (date.length != 10 || date[2] != \"-\" || date[5] != \"-\") {\n        return false;\n    }\n    // m = int(date[:2])\n    int m = int.parse(date.substring(0, 2));\n    // d = int(date[3:5])\n    int d = int.parse(date.substring(3, 5));\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) {\n        if (d >= 1 && d <= 31) {\n            return true;\n        }\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if (m == 4 || m == 6 || m == 9 || m == 11) {\n        if (d >= 1 && d <= 30) {\n            return true;\n        }\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if (m == 2) {\n        if (d >= 1 && d <= 29) {\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "List<String> splitWords(String txt) {\n    // if \" \" in txt:\n    if (txt.contains(\" \")) {\n        // return txt.split(\" \")\n        return txt.split(\" \");\n    }\n    // elif \",\" in txt:\n    else if (txt.contains(\",\")) {\n        // return txt.split(\",\")\n        return txt.split(\",\");\n    }\n    // else:\n    else {\n        // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        return [\n            (txt.runes.where((c) => c.isLowerCase && c % 2 == 0).length).toString()\n        ];\n    }\n}\n",
            "bool isSorted(List<int> lst) {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    if (!lst.asMap().entries.every((e) => e.value <= lst[e.key + 1])) {\n        return false;\n    }\n    // freq = {}\n    var freq = <int, int>{};\n    // for i in lst:\n    for (int i in lst) {\n        // freq[i] = freq.get(i, 0) + 1\n        freq[i] = (freq[i] ?? 0) + 1;\n    }\n    // return max(freq.values(), default=0) <= 2\n    return freq.values.reduce(max).clamp(0, 2) <= 2;\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= sqrt(n).floor() + 1; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nString intersection(List<int> interval1, List<int> interval2) {\n    // l = max(interval1[0], interval2[0])\n    int l = max(interval1[0], interval2[0]);\n    // r = min(interval1[1], interval2[1])\n    int r = min(interval1[1], interval2[1]);\n    // length = r - l\n    int length = r - l;\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n}\n",
            "int prodSigns(List<int> arr) {\n    // if not arr:\n    if (arr.isEmpty) {\n        // return None\n        return null;\n    }\n    // if 0 in arr:\n    if (arr.contains(0)) {\n        // return 0\n        return 0;\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    var sign = -1;\n    if ([for (int n in arr) if (n < 0)].length % 2 == 1) {\n        sign = 1;\n    }\n    // return sign * sum([abs(n) for n in arr])\n    return sign * [for (int n in arr) n.abs()].reduce((a, b) => a + b);\n}\n",
            "List<int> minPath(List<List<int>> grid, int k) {\n    // n = len(grid)\n    int n = grid.length;\n    // min_val = n * n + 1\n    int minVal = n * n + 1;\n    // for i in range(n):\n    for (int i = 0; i < n; i++) {\n        // for j in range(n):\n        for (int j = 0; j < n; j++) {\n            // if grid[i][j] == 1:\n            if (grid[i][j] == 1) {\n                // temp = []\n                var temp = <int>[];\n                // if i != 0:\n                if (i != 0) {\n                    // temp.append(grid[i - 1][j])\n                    temp.add(grid[i - 1][j]);\n                }\n                // if j != 0:\n                if (j != 0) {\n                    // temp.append(grid[i][j - 1])\n                    temp.add(grid[i][j - 1]);\n                }\n                // if i != n - 1:\n                if (i != n - 1) {\n                    // temp.append(grid[i + 1][j])\n                    temp.add(grid[i + 1][j]);\n                }\n                // if j != n - 1:\n                if (j != n - 1) {\n                    // temp.append(grid[i][j + 1])\n                    temp.add(grid[i][j + 1]);\n                }\n                // min_val = min(temp)\n                minVal = min(temp);\n            }\n        }\n    }\n    // result = []\n    var result = <int>[];\n    // for i in range(k):\n    for (int i = 0; i < k; i++) {\n        // result.append(1 if i % 2 == 0 else min_val)\n        result.add(i % 2 == 0 ? 1 : minVal);\n    }\n    // return result\n    return result;\n}\n",
            "List<int> tri(int n) {\n    // if n == 0:\n    if (n == 0) {\n        // return [1]\n        return [1];\n    }\n    // seq = [1, 3]\n    var seq = [1, 3];\n    // for i in range(2, n + 1):\n    for (int i = 2; i <= n + 1; i++) {\n        // if i % 2 == 0:\n        if (i % 2 == 0) {\n            // seq.append(i / 2 + 1)\n            seq.add(i ~/ 2 + 1);\n        } else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq.add(seq[i - 1] + seq[i - 2] + (i + 3) ~/ 2);\n        }\n    }\n    // return seq\n    return seq;\n}\n",
            "int digits(int n) {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    var odds = str(n).split('').map((d) => int.parse(d)).where((d) => d % 2 == 1).toList();\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    return odds.fold(1, (x, y) => x * y) if odds.isNotEmpty else 0;\n}\n",
            "bool isNested(String s) {\n    // open_idx = []\n    var openIdx = <int>[];\n    // close_idx = []\n    var closeIdx = <int>[];\n    // for i, ch in enumerate(s):\n    for (int i = 0; i < s.length; i++) {\n        var ch = s[i];\n        // if ch == '[':\n        if (ch == '[') {\n            // open_idx.append(i)\n            openIdx.add(i);\n        }\n        // elif ch == ']':\n        else if (ch == ']') {\n            // close_idx.append(i)\n            closeIdx.add(i);\n        }\n    }\n    // close_idx.reverse()\n    closeIdx.reversed;\n    // cnt = 0\n    var cnt = 0;\n    // i = 0\n    var i = 0;\n    // l = len(close_idx)\n    var l = closeIdx.length;\n    // for idx in open_idx:\n    for (var idx in openIdx) {\n        // if i < l and idx < close_idx[i]:\n        if (i < l && idx < closeIdx[i]) {\n            // cnt += 1\n            cnt += 1;\n            // i += 1\n            i += 1;\n        }\n    }\n    // return cnt >= 2\n    return cnt >= 2;\n}\n",
            "int sumSquares(List<double> lst) {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    return lst.map((n) => pow(ceil(n), 2).toInt()).reduce((a, b) => a + b);\n}\n",
            "bool checkIfLastCharIsALetter(String txt) {\n    // if not txt:\n    if (txt.isEmpty) {\n        // return False\n        return false;\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    String last = txt.substring(txt.lastIndexOf(' ') + 1);\n    // return len(last) == 1 and last[0].isalpha()\n    return last.length == 1 && last[0].isLetter;\n}\n",
            "int canArrange(List<int> arr) {\n    // if len (arr) <= 1:\n    if (arr.length <= 1) {\n        // return -1\n        return -1;\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    var idx = <int>[];\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] < arr[i - 1]) {\n            idx.add(i);\n        }\n    }\n    // return max(idx, default=-1)\n    return idx.isEmpty ? -1 : idx.reduce(max);\n}\n",
            "List<int?> largestSmallestIntegers(List<int> lst) {\n    // neg = [i for i in lst if i < 0]\n    var neg = lst.where((i) => i < 0).toList();\n    // pos = [i for i in lst if i > 0]\n    var pos = lst.where((i) => i > 0).toList();\n    // max_neg = max(neg) if len(neg) > 0 else None\n    var maxNeg = neg.isNotEmpty ? neg.reduce(max) : null;\n    // min_pos = min(pos) if len(pos) > 0 else None\n    var minPos = pos.isNotEmpty ? pos.reduce(min) : null;\n    // return [max_neg, min_pos]\n    return [maxNeg, minPos];\n}\n",
            "double anyToReal(dynamic o) {\n    if (o is String) {\n        return double.parse(o.replaceAll(',', '.'));\n    } else if (o is int) {\n        return o.toDouble();\n    } else if (o is double) {\n        return o;\n    }\n    throw RuntimeError(\"Type Error\");\n}\ndynamic compareOne(dynamic a, dynamic b) {\n    var a1 = anyToReal(a);\n    var b1 = anyToReal(b);\n    if (a1 == b1) {\n        return null;\n    } else if (a1 > b1) {\n        return a1;\n    } else {\n        return b1;\n    }\n}\n",
            "bool isEqualToSumEven(int n) {\n    // return n % 2 == 0 and n >= 8\n    return n % 2 == 0 && n >= 8;\n}\n",
            "int specialFactorial(int n) {\n    // fact = 1\n    int fact = 1;\n    // result = 1\n    int result = 1;\n    // for i in range(1, n + 1):\n    for (int i = 1; i <= n; i++) {\n        // fact *= i\n        fact *= i;\n        // result *= fact\n        result *= fact;\n    }\n    // return result\n    return result;\n}\n",
            "String fixSpaces(String txt) {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    return txt.replaceAll(RegExp(r\"\\s{3,}\"), \"-\").replaceAll(\" \", \"_\");\n}\n",
            "String fileNameCheck(String fileName) {\n    var suf = [\"txt\", \"exe\", \"dll\"];\n    var lst = fileName.split(\".\");\n    if (lst.length != 2 || !suf.contains(lst[1]) || lst[0].isEmpty || !lst[0][0].isLetter() || lst[0].length > 3) {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n",
            "int sumSquares(List<int> lst) {\n    // result = 0\n    var result = 0;\n    // for i in range(len(lst)):\n    for (int i = 0; i < lst.length; i++) {\n        // if i % 3 == 0:\n        if (i % 3 == 0) {\n            // result += pow(lst[i], 2)\n            result += pow(lst[i], 2).toInt();\n        }\n        // elif i % 4 == 0:\n        else if (i % 4 == 0) {\n            // result += pow(lst[i], 3)\n            result += pow(lst[i], 3).toInt();\n        }\n        // else:\n        else {\n            // result += lst[i]\n            result += lst[i];\n        }\n    }\n    // return result\n    return result;\n}\n",
            "bool isPrime(int n) {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nString wordsInSentence(String sentence) {\n    // words = sentence.split(\" \")\n    var words = sentence.split(\" \");\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    return words.where((w) => isPrime(w.length)).join(\" \");\n}\n",
            "bool simplify(String x, String n) {\n    // xs = x.split(\"/\")\n    var xs = x.split(\"/\");\n    // ns = n.split(\"/\")\n    var ns = n.split(\"/\");\n    // num = int(xs[0]) * int(ns[0])\n    var num = int.parse(xs[0]) * int.parse(ns[0]);\n    // den = int(xs[1]) * int(ns[1])\n    var den = int.parse(xs[1]) * int.parse(ns[1]);\n    // return num % den == 0\n    return num % den == 0;\n}\n",
            "int digitsSum(int n) {\n    // n_str = str(n)\n    var nStr = n.toString();\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.split('').map((d) => int.parse(d)).reduce((a, b) => a + b);\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return int.parse(nStr.substring(0, 2)) * 2 + digitsSum(n.abs());\n    }\n}\nList<int> orderByPoints(List<int> nums) {\n    // return sorted(nums, key=digits_sum)\n    return nums.sorted((a, b) => digitsSum(a).compareTo(digitsSum(b)));\n}\n",
            "int specialFilter(List<int> nums) {\n    // odds = \"13579\"\n    var odds = \"13579\";\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    return nums.where((n) => n > 10 && n % 2 == 1 && odds.contains(n.toString()[0])).length;\n}\n",
            "int getMaxTriples(int n) {\n    // c = [0, 0, 0]\n    var c = [0, 0, 0];\n    // for i in range(1, n + 1):\n    for (int i = 1; i <= n; i++) {\n        // a = i * i - i + 1\n        var a = i * i - i + 1;\n        // c[a % 3] += 1\n        c[a % 3] += 1;\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) ~/ 6;\n}\n",
            "List<String> bf(String planet1, String planet2) {\n    // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    var names = [\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    ];\n    // if planet1 not in names or planet2 not in names:\n    if (!names.contains(planet1) || !names.contains(planet2)) {\n        // return []\n        return [];\n    }\n    // l = names.index(planet1)\n    var l = names.indexOf(planet1);\n    // r = names.index(planet2)\n    var r = names.indexOf(planet2);\n    // if l > r:\n    if (l > r) {\n        // l, r = r, l\n        var tmp = l;\n        l = r;\n        r = tmp;\n    }\n    // if l == r:\n    if (l == r) {\n        // return []\n        return [];\n    }\n    // return names[l + 1 : r]\n    return names.sublist(l + 1, r);\n}\n",
            "List<String> sortedListSum(List<String> lst) {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    var result = lst.where((s) => s.length % 2 == 0).toList();\n    // return sorted(result, key=lambda x: (len(x), x))\n    return result.sorted((a, b) => a.length.compareTo(b.length));\n}\n",
            "int xOrY(int n, int x, int y) {\n    // if n < 2:\n    if (n < 2) {\n        // return y\n        return y;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (int i = 2; i <= (sqrt(n).floor() + 1); i++) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return y\n            return y;\n        }\n    }\n    // return x\n    return x;\n}\n",
            "int doubleTheDifference(List<double> lst) {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    return lst.where((n) => n >= 0 && n % 2 == 1).map((n) => n * n).reduce((a, b) => a + b);\n}\n",
            "List<int> compare(List<int> game, List<int> guess) {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    return [abs(x - y) for x, y in zip(game, guess)];\n}\n",
            "String strongestExtension(String className, List<String> extensions) {\n    // max_s = float(\"-inf\")\n    double maxS = double.negativeInfinity;\n    // max_ext = \"\"\n    String maxExt = \"\";\n    // for ext in extensions:\n    for (String ext in extensions) {\n        // upper = len([c for c in ext if c.isupper()])\n        int upper = ext.runes.where((r) => r.toUpperCase() == r).length;\n        // lower = len([c for c in ext if c.islower()])\n        int lower = ext.runes.where((r) => r.toLowerCase() == r).length;\n        // s = upper - lower\n        int s = upper - lower;\n        // if s > max_s:\n        if (s > maxS) {\n            // max_s = s\n            maxS = s;\n            // max_ext = ext\n            maxExt = ext;\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    return \"${className}.${maxExt}\";\n}\n",
            "bool cycpatternCheck(String a, String b) {\n    // if len(a) < len(b):\n    if (a.length < b.length) {\n        // return False\n        return false;\n    }\n    // for i in range(len(b)):\n    for (int i = 0; i < b.length; i++) {\n        // if b[i:] + b[:i] in a:\n        if (a.contains(b.substring(i) + b.substring(0, i))) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "List<int> evenOddCount(int num) {\n    // ds = str(abs(num))\n    var ds = (num.abs()).toString();\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    var even = ds.codeUnits.where((d) => d % 2 == 0).length;\n    // return [even, len(ds) - even]\n    return [even, ds.length - even];\n}\n",
            "String intToMiniRoman(int num) {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    var numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    // res = []\n    var res = <String>[];\n    // for i in range(len(values)):\n    for (int i = 0; i < values.length; i++) {\n        // while num >= values[i]:\n        while (num >= values[i]) {\n            // res.append(numerals[i])\n            res.add(numerals[i]);\n            // num -= values[i]\n            num -= values[i];\n        }\n    }\n    // return \"\".join(res)\n    return res.join();\n}\n",
            "bool rightAngleTriangle(int a, int b, int c) {\n    // s = sorted([a, b, c])\n    var s = [a, b, c].toList()..sort();\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2];\n}\n",
            "String findMax(List<String> words) {\n    // max_cnt = 0\n    int maxCnt = 0;\n    // max_w = \"\"\n    String maxW = \"\";\n    // for w in words:\n    for (String w in words) {\n        // cnt = len(set(w))\n        int cnt = Set.of(w.split(\"\")).length;\n        // if cnt > max_cnt:\n        if (cnt > maxCnt) {\n            // max_cnt = cnt\n            maxCnt = cnt;\n            // max_w = w\n            maxW = w;\n        }\n        // elif cnt == max_cnt:\n        else if (cnt == maxCnt) {\n            // max_w = min(max_w, w)\n            maxW = min(maxW, w);\n        }\n    }\n    // return max_w\n    return maxW;\n}\n",
            "List<int> eat(int num, int need, int remaining) {\n    // if need <= remaining:\n    if (need <= remaining) {\n        // return [num + need, remaining - need]\n        return [num + need, remaining - need];\n    } else {\n        // return [num + remaining, 0]\n        return [num + remaining, 0];\n    }\n}\n",
            "int doAlgebra(List<String> operators, List<int> operands) {\n    // ops = operators.copy()\n    var ops = operators.toList();\n    // nums = operands.copy()\n    var nums = operands.toList();\n    // i = len(ops) - 1\n    var i = ops.length - 1;\n    // while i >= 0:\n    while (i >= 0) {\n        // if ops[i] == \"**\":\n        if (ops[i] == \"**\") {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            nums[i] = pow(nums[i], nums[i + 1]).toInt();\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1);\n            // ops.pop(i)\n            ops.removeAt(i);\n        }\n        // i -= 1\n        i -= 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while (i < ops.length) {\n        // if ops[i] == \"*\":\n        if (ops[i] == \"*\") {\n            // nums[i] = nums[i] * nums[i + 1]\n            nums[i] = nums[i] * nums[i + 1];\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1);\n            // ops.pop(i)\n            ops.removeAt(i);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"//\":\n        else if (ops[i] == \"//\") {\n            // nums[i] = nums[i] // nums[i + 1]\n            nums[i] = nums[i] ~/ nums[i + 1];\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1);\n            // ops.pop(i)\n            ops.removeAt(i);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while (i < ops.length) {\n        // if ops[i] == \"+\":\n        if (ops[i] == \"+\") {\n            // nums[i] = nums[i] + nums[i + 1]\n            nums[i] = nums[i] + nums[i + 1];\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1);\n            // ops.pop(i)\n            ops.removeAt(i);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"-\":\n        else if (ops[i] == \"-\") {\n            // nums[i] = nums[i] - nums[i + 1]\n            nums[i] = nums[i] - nums[i + 1];\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1);\n            // ops.pop(i)\n            ops.removeAt(i);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // return nums[0]\n    return nums[0];\n}\n",
            "String solve(String s) {\n    // if not any(ch.isalpha() for ch in s):\n    if (!s.any((ch) => ch.isAlphabetic)) {\n        // return s[::-1]\n        return s.split('').reversed.join();\n    }\n    // result = []\n    var result = <String>[];\n    // for ch in s:\n    for (var ch in s.split('')) {\n        // if not ch.isalpha():\n        if (!ch.isAlphabetic) {\n            // result.append(ch)\n            result.add(ch);\n        }\n        // elif ch.isupper():\n        else if (ch.isUpperCase) {\n            // result.append(ch.lower())\n            result.add(ch.toLowerCase());\n        }\n        // elif ch.islower():\n        else if (ch.isLowerCase) {\n            // result.append(ch.upper())\n            result.add(ch.toUpperCase());\n        }\n    }\n    // return \"\".join(result)\n    return result.join();\n}\n",
            "String? stringToMd5(String txt) {\n    // if not txt:\n    if (txt.isEmpty) {\n        // return None\n        return null;\n    }\n    // md5_hash = hashlib.md5()\n    var md5Hash = md5;\n    // txt_bytes = txt.encode()\n    var txtBytes = utf8.encode(txt);\n    // md5_hash.update(txt_bytes)\n    md5Hash.update(txtBytes);\n    // md5_encoded = md5_hash.hexdigest()\n    var md5Encoded = md5Hash.convert(txtBytes).toString();\n    // return md5_encoded\n    return md5Encoded;\n}\n",
            "List<int> generateIntegers(int a, int b) {\n    // lower = max(2, min(a, b))\n    int lower = max(2, min(a, b));\n    // upper = min(8, max(a, b))\n    int upper = min(8, max(a, b));\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    return List.generate(upper - lower + 1, (i) => lower + i)\n        .where((i) => i % 2 == 0)\n        .toList();\n}\n"
        ],
        "go": [
            "func HasCloseElements(numbers []float64, threshold float64) bool {\n    // for i in range(len(numbers)):\n    for i := range numbers {\n        // for j in range(i + 1, len(numbers)):\n        for j := i + 1; j < len(numbers); j++ {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if math.Abs(numbers[i] - numbers[j]) < threshold {\n                // return True\n                return true\n            }\n        }\n    }\n    // return False\n    return false\n}\n",
            "func SeparateParenGroups(parenString string) []string {\n    // groups = []\n    groups := make([]string, 0)\n    // stk = []\n    stk := make([]string, 0)\n    // current_group = \"\"\n    currentGroup := \"\"\n    // parens = paren_string.replace(\" \", \"\")\n    parens := strings.Replace(parenString, \" \", \"\", -1)\n    // for ch in parens:\n    for _, ch := range parens {\n        // if ch == \"(\":\n        if ch == '(' {\n            // stk.append(ch)\n            stk = append(stk, string(ch))\n            // current_group += ch\n            currentGroup += string(ch)\n        } else if ch == ')' {\n            // stk.pop()\n            stk = stk[:len(stk)-1]\n            // current_group += ch\n            currentGroup += string(ch)\n            // if not stk:\n            if len(stk) == 0 {\n                // groups.append(current_group)\n                groups = append(groups, currentGroup)\n                // current_group = \"\"\n                currentGroup = \"\"\n            }\n        }\n    }\n    // return groups\n    return groups\n}\n",
            "func TruncateNumber(num float64) float64 {\n    // return num - floor(num)\n    return num - math.Floor(num)\n}\n",
            "func BelowZero(operations []int) bool {\n    // balance = 0\n    balance := 0\n    // for op in operations:\n    for _, op := range operations {\n        // balance += op\n        balance += op\n        // if balance < 0:\n        if balance < 0 {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "func MeanAbsoluteDeviation(numbers []float64) float64 {\n    // mean = sum(numbers) / len(numbers)\n    mean := 0.0\n    for _, n := range numbers {\n        mean += n\n    }\n    mean /= float64(len(numbers))\n    // deviation = sum(abs(x - mean) for x in numbers)\n    deviation := 0.0\n    for _, n := range numbers {\n        deviation += math.Abs(n - mean)\n    }\n    // return deviation / len(numbers)\n    return deviation / float64(len(numbers))\n}\n",
            "func Intersperse(numbers []int, delimiter int) []int {\n    // result = []\n    result := make([]int, 0)\n    // for i in range(len(numbers)):\n    for i := range numbers {\n        // if i != 0:\n        if i != 0 {\n            // result.append(delimiter)\n            result = append(result, delimiter)\n        }\n        // result.append(numbers[i])\n        result = append(result, numbers[i])\n    }\n    // return result\n    return result\n}\n",
            "func ParseNestedParens(parenString string) []int {\n    // result = []\n    result := make([]int, 0)\n    // paren_groups = paren_string.split()\n    parenGroups := strings.Split(parenString, \" \")\n    // for group in paren_groups:\n    for _, group := range parenGroups {\n        // max_depth = 0\n        maxDepth := 0\n        // depth = 0\n        depth := 0\n        // for ch in group:\n        for _, ch := range group {\n            // if ch == \"(\":\n            if ch == '(' {\n                // depth += 1\n                depth++\n                // max_depth = max(max_depth, depth)\n                maxDepth = max(maxDepth, depth)\n            }\n            // elif ch == \")\":\n            else if ch == ')' {\n                // depth -= 1\n                depth--\n            }\n        }\n        // result.append(max_depth)\n        result = append(result, maxDepth)\n    }\n    // return result\n    return result\n}\n",
            "func FilterBySubstring(strs []string, substring string) []string {\n    // return [s for s in strs if substring in s]\n    return []string{s for s in strs if strings.Contains(s, substring)}\n}\n",
            "func SumProduct(numbers []int) []int {\n    // n_sum = sum(numbers)\n    nSum := 0\n    for _, n := range numbers {\n        nSum += n\n    }\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    nProduct := 1\n    for _, n := range numbers {\n        nProduct *= n\n    }\n    // return [n_sum, n_product]\n    return []int{nSum, nProduct}\n}\n",
            "func RollingMax(numbers []int) []int {\n    // max_so_far = float(\"-inf\")\n    maxSoFar := float64(-math.MaxFloat64)\n    // result = []\n    result := make([]int, 0)\n    // for num in numbers:\n    for _, num := range numbers {\n        // max_so_far = max(max_so_far, num)\n        if maxSoFar < float64(num) {\n            maxSoFar = float64(num)\n        }\n        // result.append(max_so_far)\n        result = append(result, int(maxSoFar))\n    }\n    // return result\n    return result\n}\n",
            "func IsPalindrome(s string) bool {\n    // return s == s[::-1]\n    return s == string([]rune(s)[len(s)-1:0:-1])\n}\nfunc MakePalindrome(s string) string {\n    // if is_palindrome(s):\n    if IsPalindrome(s) {\n        // return s\n        return s\n    }\n    // for i in range(len(s)):\n    for i := 0; i < len(s); i++ {\n        // if is_palindrome(s[i:]):\n        if IsPalindrome(s[i:]) {\n            // return s + s[:i][::-1]\n            return s + string([]rune(s[:i])[len(s[:i])-1:0:-1])\n        }\n    }\n    // return \"\"\n    return \"\"\n}\n",
            "func StringXor(a, b string) string {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n    return result\n}\n",
            "func Longest(strs []string) *string {\n    // if not strs:\n    if len(strs) == 0 {\n        // return None\n        return nil\n    }\n    // longest_s = strs[0]\n    longestS := strs[0]\n    // for s in strs:\n    for _, s := range strs {\n        // if len(s) > len(longest_s):\n        if len(s) > len(longestS) {\n            // longest_s = s\n            longestS = s\n        }\n    }\n    // return longest_s\n    return &longestS\n}\n",
            "func GreatestCommonDivisor(a, b int) int {\n    // if b == 0:\n    if b == 0 {\n        // return a\n        return a\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        return GreatestCommonDivisor(b, a%b)\n    }\n}\n",
            "func AllPrefixes(s string) []string {\n    // prefixes = []\n    prefixes := make([]string, 0)\n    // for i in range(len(s)):\n    for i := 0; i < len(s); i++ {\n        // prefixes.append(s[: i + 1])\n        prefixes = append(prefixes, s[:i+1])\n    }\n    // return prefixes\n    return prefixes\n}\n",
            "func StringSequence(n int) string {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    return strings.Join([]string{strconv.Itoa(n)}, \" \")\n}\n",
            "func CountDistinctCharacters(s string) int {\n    // return len(set(s.lower()))\n    return len(map[rune]bool{})\n}\n",
            "func ParseMusic(musicString string) []int {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    durations := map[string]int{\n        \"o\":   4,\n        \"o|\":  2,\n        \".|\":  1,\n    }\n    // notes = music_string.split()\n    notes := strings.Split(musicString, \" \")\n    // return [durations[note] for note in notes]\n    result := make([]int, 0)\n    for _, note := range notes {\n        result = append(result, durations[note])\n    }\n    return result\n}\n",
            "func HowManyTimes(s string, substring string) int {\n    // times = 0\n    times := 0\n    // for i in range(len(s) - len(substring) + 1):\n    for i := 0; i < len(s)-len(substring)+1; i++ {\n        // if s[i : i + len(substring)] == substring:\n        if s[i:i+len(substring)] == substring {\n            // times += 1\n            times++\n        }\n    }\n    // return times\n    return times\n}\n",
            "func SortNumbers(numbers string) string {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    numDict := map[string]int{\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    numList := []string{}\n    for _, word := range strings.Split(numbers, \" \") {\n        if _, ok := numDict[word]; ok {\n            numList = append(numList, word)\n        }\n    }\n    // num_list.sort(key=lambda x: num_dict[x])\n    sort.Slice(numList, func(i, j int) bool {\n        return numDict[numList[i]] < numDict[numList[j]]\n    })\n    // return \" \".join(num_list)\n    return strings.Join(numList, \" \")\n}\n",
            "func FindClosestElements(numbers []float64) []float64 {\n    // sorted_numbers = sorted(numbers)\n    sort.Float64s(numbers)\n    // min_diff = float(\"inf\")\n    minDiff := math.MaxFloat64\n    // closest_pair = []\n    closestPair := []float64{}\n    // for i in range(1, len(sorted_numbers)):\n    for i := 1; i < len(numbers); i++ {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        diff := numbers[i] - numbers[i-1]\n        // if diff < min_diff:\n        if diff < minDiff {\n            // min_diff = diff\n            minDiff = diff\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closestPair = []float64{numbers[i-1], numbers[i]}\n        }\n    }\n    // return closest_pair\n    return closestPair\n}\n",
            "func RescaleToUnit(numbers []float64) []float64 {\n    // min_num = min(numbers)\n    minNum := numbers[0]\n    for _, num := range numbers {\n        if num < minNum {\n            minNum = num\n        }\n    }\n    // max_num = max(numbers)\n    maxNum := numbers[0]\n    for _, num := range numbers {\n        if num > maxNum {\n            maxNum = num\n        }\n    }\n    // if min_num == max_num:\n    if minNum == maxNum {\n        // return [0.0] * len(numbers)\n        return make([]float64, len(numbers))\n    }\n    // else:\n    //     return [(num - min_num) / (max_num - min_num) for num in numbers]\n    result := make([]float64, len(numbers))\n    for i, num := range numbers {\n        result[i] = (num - minNum) / (maxNum - minNum)\n    }\n    return result\n}\n",
            "func FilterIntegers(values []interface{}) []int {\n    // return [x for x in values if isinstance(x, int)]\n    result := make([]int, 0)\n    for _, x := range values {\n        if _, ok := x.(int); ok {\n            result = append(result, x.(int))\n        }\n    }\n    return result\n}\n",
            "func StrLength(s string) int {\n    // return len(s)\n    return len(s)\n}\n",
            "func LargestDivisor(n int) int {\n    // for i in range(2, n):\n    for i := 2; i < n; i++ {\n        // if n % i == 0:\n        if n%i == 0 {\n            // return n // i\n            return n / i\n        }\n    }\n    // return 1\n    return 1\n}\n",
            "func Factorize(n int) []int {\n    // factors = []\n    factors := make([]int, 0)\n    // divisor = 2\n    divisor := 2\n    // while divisor <= n:\n    for divisor <= n {\n        // if n % divisor == 0:\n        if n%divisor == 0 {\n            // factors.append(divisor)\n            factors = append(factors, divisor)\n            // n //= divisor\n            n /= divisor\n        } else {\n            // divisor += 1\n            divisor++\n        }\n    }\n    // return factors\n    return factors\n}\n",
            "func RemoveDuplicates(numbers []int) []int {\n    // counts = {}\n    counts := make(map[int]int)\n    // for num in numbers:\n    for _, num := range numbers {\n        // counts[num] = counts.get(num, 0) + 1\n        counts[num]++\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    res := make([]int, 0)\n    for _, num := range numbers {\n        if counts[num] == 1 {\n            res = append(res, num)\n        }\n    }\n    // return res\n    return res\n}\n",
            "func FlipCase(s string) string {\n    // flipped = []\n    flipped := make([]rune, 0)\n    // for ch in s:\n    for _, ch := range s {\n        // if not ch.isalpha():\n        if !unicode.IsLetter(ch) {\n            // flipped.append(ch)\n            flipped = append(flipped, ch)\n        } else if unicode.IsLower(ch) {\n            // flipped.append(ch.upper())\n            flipped = append(flipped, unicode.ToUpper(ch))\n        } else if unicode.IsUpper(ch) {\n            // flipped.append(ch.lower())\n            flipped = append(flipped, unicode.ToLower(ch))\n        }\n    }\n    // return ''.join(flipped)\n    return string(flipped)\n}\n",
            "func Concatenate(strs []string) string {\n    // return \"\".join(strs)\n    return strings.Join(strs, \"\")\n}\n",
            "func FilterByPrefix(strs []string, prefixStr string) []string {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    return []string{s for s in strs if strings.HasPrefix(s, prefixStr)}\n}\n",
            "func GetPositive(l []int) []int {\n    // return [num for num in l if num > 0]\n    result := make([]int, 0)\n    for _, num := range l {\n        if num > 0 {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n",
            "func IsPrime(n int) bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i := 2; i <= int(math.Floor(math.Sqrt(float64(n)))) + 1; i++ {\n        // if n % i == 0:\n        if n%i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\n",
            "func Poly(xs []int, x float64) float64 {\n    res := 0.0\n    for i := range xs {\n        res += float64(xs[i]) * math.Pow(x, float64(i))\n    }\n    return res\n}\nfunc FindZero(xs []int) float64 {\n    x1, x2 := 1.0, -1.0\n    for Poly(xs, x1)*Poly(xs, x2) > 0 {\n        x1 *= 2\n        x2 *= 2\n    }\n    for math.Abs(x1-x2) > 1e-10 {\n        mid := (x1 + x2) / 2\n        if Poly(xs, mid) == 0 {\n            return mid\n        }\n        if Poly(xs, mid)*Poly(xs, x1) < 0 {\n            x2 = mid\n        } else {\n            x1 = mid\n        }\n    }\n    return (x1 + x2) / 2\n}\n",
            "func SortThird(l []int) []int {\n    // sorted_third = sorted(l[::3])\n    sortedThird := make([]int, 0)\n    for i := 0; i < len(l); i += 3 {\n        sortedThird = append(sortedThird, l[i])\n    }\n    sort.Ints(sortedThird)\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    result := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            result[i] = sortedThird[i/3]\n        } else {\n            result[i] = l[i]\n        }\n    }\n    return result\n}\n",
            "func ListUnique(l []int) []int {\n    // return sorted(list(set(l)))\n    return sort.Ints(unique(l))\n}\nfunc unique(l []int) []int {\n    // return list(set(l))\n    m := make(map[int]struct{})\n    for _, e := range l {\n        m[e] = struct{}{}\n    }\n    result := make([]int, 0, len(m))\n    for e := range m {\n        result = append(result, e)\n    }\n    return result\n}\n",
            "func MaxElement(l []int) int {\n    // if not l:\n    if len(l) == 0 {\n        // return 0\n        return 0\n    }\n    // return max(l)\n    return Max(l)\n}\n",
            "func FizzBuzz(n int) int {\n    // cnt = 0\n    cnt := 0\n    // for i in range(n):\n    for i := 0; i < n; i++ {\n        // if i % 11 == 0 or i % 13 == 0:\n        if i%11 == 0 || i%13 == 0 {\n            // cnt += str(i).count(\"7\")\n            cnt += strings.Count(strconv.Itoa(i), \"7\")\n        }\n    }\n    // return cnt\n    return cnt\n}\n",
            "func SortEven(l []int) []int {\n    // sorted_even = sorted(l[::2])\n    sortedEven := make([]int, 0)\n    for _, e := range l[1::2] {\n        sortedEven = append(sortedEven, e)\n    }\n    sort.Ints(sortedEven)\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    result := make([]int, 0)\n    for i, e := range l {\n        if i%2 == 0 {\n            result = append(result, sortedEven[i/2])\n        } else {\n            result = append(result, e)\n        }\n    }\n    return result\n}\n",
            "func EncodeCyclic(s string) string {\n    // result = []\n    result := make([]string, 0)\n    // for i in range(0, len(s), 3):\n    for i := 0; i < len(s); i += 3 {\n        // if i + 3 > len(s):\n        if i+3 > len(s) {\n            // result.append(s[i:])\n            result = append(result, s[i:])\n        } else {\n            // result.append(s[i+1:i+3])\n            result = append(result, s[i+1:i+3])\n            // result.append(s[i])\n            result = append(result, s[i])\n        }\n    }\n    // return \"\".join(result)\n    return strings.Join(result, \"\")\n}\nfunc DecodeCyclic(s string) string {\n    return EncodeCyclic(EncodeCyclic(s))\n}\n",
            "func IsPrime(n int) bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i := 2; i <= int(math.Floor(math.Sqrt(float64(n))))+1; i++ {\n        // if n % i == 0:\n        if n%i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc PrimeFib(n int) int {\n    // f = [0, 1]\n    f := []int{0, 1}\n    // cnt = 0\n    cnt := 0\n    // while cnt < n:\n    for cnt < n {\n        // f = [f[1], f[0] + f[1]]\n        f = []int{f[1], f[0] + f[1]}\n        // if is_prime(f[1]):\n        if IsPrime(f[1]) {\n            // cnt += 1\n            cnt++\n        }\n    }\n    // return f[1]\n    return f[1]\n}\n",
            "func TriplesSumToZero(l []int) bool {\n    // for i in range(len(l)):\n    for i := 0; i < len(l); i++ {\n        // for j in range(i + 1, len(l)):\n        for j := i + 1; j < len(l); j++ {\n            // for k in range(j + 1, len(l)):\n            for k := j + 1; k < len(l); k++ {\n                // if l[i] + l[j] + l[k] == 0:\n                if l[i]+l[j]+l[k] == 0 {\n                    // return True\n                    return true\n                }\n            }\n        }\n    }\n    // return False\n    return false\n}\n",
            "func CarRaceCollision(n int) int {\n    // return n ** 2\n    return n * n\n}\n",
            "func IncrList(l []int) []int {\n    // return [i + 1 for i in l]\n    result := make([]int, len(l))\n    for i, v := range l {\n        result[i] = v + 1\n    }\n    return result\n}\n",
            "func PairsSumToZero(l []int) bool {\n    // seen = set()\n    seen := make(map[int]bool)\n    // for num in l:\n    for _, num := range l {\n        // if -num in seen:\n        if _, ok := seen[-num]; ok {\n            // return True\n            return true\n        }\n        // seen.add(num)\n        seen[num] = true\n    }\n    // return False\n    return false\n}\n",
            "func ChangeBase(x int, bas int) string {\n    // if x == 0:\n    if x == 0 {\n        // return \"0\"\n        return \"0\"\n    }\n    // digits = []\n    digits := make([]string, 0)\n    // while x > 0:\n    for x > 0 {\n        // digits.append(str(x % bas))\n        digits = append(digits, strconv.Itoa(x%bas))\n        // x //= bas\n        x /= bas\n    }\n    // return \"\".join(digits[::-1])\n    return strings.Join(digits[::-1], \"\")\n}\n",
            "func TriangleArea(a, h int) float64 {\n    // return a * h / 2\n    return float64(a) * float64(h) / 2\n}\n",
            "func Fib4(n int) int {\n    // fib = [0, 0, 2, 0]\n    fib := []int{0, 0, 2, 0}\n    // for i in range(4, n + 1):\n    for i := 4; i <= n; i++ {\n        // fib[i % 4] = sum(fib)\n        fib[i%4] = fib[0] + fib[1] + fib[2]\n    }\n    // return fib[n % 4]\n    return fib[n%4]\n}\n",
            "func Median(l []float64) float64 {\n    // sl = sorted(l)\n    sort.Float64s(l)\n    // if len(l) % 2 != 0:\n    if len(l)%2 != 0 {\n        // return sl[len(l) // 2]\n        return l[len(l)>>1]\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (l[len(l)>>1] + l[(len(l)>>1)-1]) / 2\n    }\n}\n",
            "func IsPalindrome(txt string) bool {\n    // return txt == txt[::-1]\n    return txt == Reverse(txt)\n}\nfunc Reverse(txt string) string {\n    // return txt[::-1]\n    return ReverseSlice([]rune(txt))\n}\nfunc ReverseSlice(txt []rune) string {\n    // return txt[::-1]\n    for i, j := 0, len(txt)-1; i < j; i, j = i+1, j-1 {\n        txt[i], txt[j] = txt[j], txt[i]\n    }\n    return string(txt)\n}\n",
            "func Modp(n, p int) int {\n    ret := 1\n    for i := 0; i < n; i++ {\n        ret = (ret * 2) % p\n    }\n    return ret\n}\n",
            "func EncodeShift(s string) string {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    result := make([]rune, 0)\n    for _, ch := range s {\n        // result.append(chr(((ord(ch) - 97 + 5) % 26) + 97))\n        result = append(result, rune(((int(ch) - 97 + 5) % 26) + 97))\n    }\n    // return \"\".join(result)\n    return string(result)\n}\nfunc DecodeShift(s string) string {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    result := make([]rune, 0)\n    for _, ch := range s {\n        // result.append(chr(((ord(ch) - 97 + 21) % 26) + 97))\n        result = append(result, rune(((int(ch) - 97 + 21) % 26) + 97))\n    }\n    // return \"\".join(result)\n    return string(result)\n}\n",
            "func RemoveVowels(txt string) string {\n    // vowels = \"aeiouAEIOU\"\n    vowels := \"aeiouAEIOU\"\n    // return \"\".join([char for char in txt if char not in vowels])\n    return strings.Join([]string{}, func(char string) bool { return !strings.Contains(vowels, char) })\n}\n",
            "func BelowThreshold(l []int, t int) bool {\n    // return all(x < t for x in l)\n    for _, x := range l {\n        if x >= t {\n            return false\n        }\n    }\n    return true\n}\n",
            "func Add(x, y int) int {\n    // return x + y\n    return x + y\n}\n",
            "func SameChars(s0, s1 string) bool {\n    // return set(s0) == set(s1)\n    return len(s0) == len(s1) && strings.Map(func(r rune) rune { return r }, s0) == strings.Map(func(r rune) rune { return r }, s1)\n}\n",
            "func Fib(n int) int {\n    // if n <= 1:\n    if n <= 1 {\n        // return n\n        return n\n    } else {\n        // return fib(n - 1) + fib(n - 2)\n        return Fib(n - 1) + Fib(n - 2)\n    }\n}\n",
            "func CorrectBracketing(brackets string) bool {\n    // depth = 0\n    depth := 0\n    // for b in brackets:\n    for _, b := range brackets {\n        // if b == \"<\":\n        if b == '<' {\n            // depth += 1\n            depth += 1\n        }\n        // elif b == \">\":\n        else if b == '>' {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if depth < 0 {\n            // return False\n            return false\n        }\n    }\n    // return depth == 0\n    return depth == 0\n}\n",
            "func Monotonic(l []int) bool {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    diff := make([]int, len(l)-1)\n    for i := 0; i < len(l)-1; i++ {\n        diff[i] = l[i+1] - l[i]\n    }\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    for _, x := range diff {\n        if x > 0 {\n            return false\n        }\n    }\n    for _, x := range diff {\n        if x < 0 {\n            return false\n        }\n    }\n    return true\n}\n",
            "func Common(l1, l2 []int) []int {\n    // return sorted(list(set(l1) & set(l2)))\n    return sort.IntSlice(l1).Intersect(sort.IntSlice(l2))\n}\n",
            "func LargestPrimeFactor(n int) int {\n    // i = 2\n    i := 2\n    // while i * i <= n:\n    for i*i <= n {\n        // if n % i:\n        if n%i != 0 {\n            // i += 1\n            i++\n        } else {\n            // n //= i\n            n /= i\n        }\n    }\n    // return n\n    return n\n}\n",
            "func SumToN(n int) int {\n    // return sum(range(n + 1))\n    sum := 0\n    for i := 0; i <= n; i++ {\n        sum += i\n    }\n    return sum\n}\n",
            "func CorrectBracketing(brackets string) bool {\n    // depth = 0\n    depth := 0\n    // for b in brackets:\n    for _, b := range brackets {\n        // if b == \"(\":\n        if b == '(' {\n            // depth += 1\n            depth += 1\n        }\n        // elif b == \")\":\n        else if b == ')' {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if depth < 0 {\n            // return False\n            return false\n        }\n    }\n    // return depth == 0\n    return depth == 0\n}\n",
            "func Derivative(xs []int) []int {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    result := make([]int, 0)\n    for i := 1; i < len(xs); i++ {\n        result = append(result, xs[i]*i)\n    }\n    return result\n}\n",
            "func Fibfib(n int) int {\n    // if n <= 1:\n    if n <= 1 {\n        // return 0 \n        return 0\n    }\n    // a, b, c = 0, 0, 1\n    a, b, c := 0, 0, 1\n    // while n > 2:\n    for n > 2 {\n        // a, b, c = b, c, a + b + c\n        a, b, c = b, c, a+b+c\n        // n -= 1\n        n -= 1\n    }\n    // return c\n    return c\n}\n",
            "func VowelsCount(s string) int {\n    // vowels = \"aeiou\"\n    vowels := \"aeiou\"\n    // cnt = 0\n    cnt := 0\n    // for i in range(len(s)):\n    for i := 0; i < len(s); i++ {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if strings.ContainsRune(vowels, unicode.ToLower(rune(s[i]))) || (i == len(s)-1 && unicode.ToLower(rune(s[i])) == 'y') {\n            // cnt += 1\n            cnt++\n        }\n    }\n    // return cnt\n    return cnt\n}\n",
            "func CircularShift(x int, shift int) string {\n    // x_str = str(x)\n    x_str := strconv.Itoa(x)\n    // if shift > len(x_str):\n    if shift > len(x_str) {\n        // return x_str[::-1]\n        return Reverse(x_str)\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return x_str[len(x_str)-shift:] + x_str[:len(x_str)-shift]\n    }\n}\n",
            "func DigitSum(s string) int {\n    // return sum(ord(c) for c in s if c.isupper())\n    var sum int\n    for _, c := range s {\n        if 'A' <= c && c <= 'Z' {\n            sum += int(c)\n        }\n    }\n    return sum\n}\n",
            "func FruitDistribution(s string, n int) int {\n    // words = s.split(' ')\n    words := strings.Split(s, \" \")\n    // apples = int(words[words.index(\"apples\") - 1])\n    apples, _ := strconv.Atoi(words[words.Index(\"apples\") - 1])\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    oranges, _ := strconv.Atoi(words[words.Index(\"oranges\") - 1])\n    // return n - apples - oranges\n    return n - apples - oranges\n}\n",
            "func Pluck(arr []int) []int {\n    // evens = [n for n in arr if n % 2 == 0]\n    evens := make([]int, 0)\n    for _, n := range arr {\n        if n%2 == 0 {\n            evens = append(evens, n)\n        }\n    }\n    // if len(evens) == 0:\n    if len(evens) == 0 {\n        // return []\n        return []int{}\n    }\n    // min_even = min(evens)\n    minEven := evens[0]\n    for _, n := range evens {\n        if n < minEven {\n            minEven = n\n        }\n    }\n    // return [min_even, arr.index(min_even)]\n    return []int{minEven, IndexOf(arr, minEven)}\n}\n",
            "func Search(lst []int) int {\n    // freqs = {}\n    freqs := make(map[int]int)\n    // for n in lst:\n    for _, n := range lst {\n        // freqs[n] = freqs.get(n, 0) + 1\n        freqs[n] = freqs[n] + 1\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    goodVals := []int{}\n    for k, v := range freqs {\n        if v >= k {\n            goodVals = append(goodVals, k)\n        }\n    }\n    // return max(good_vals, default=-1)\n    return max(goodVals, -1)\n}\n",
            "func StrangeSortList(lst []int) []int {\n    // sl = sorted(lst)\n    sl := make([]int, len(lst))\n    copy(sl, lst)\n    sort.Ints(sl)\n    // result = []\n    result := make([]int, 0)\n    // left, right = 0, len(sl) - 1\n    left, right := 0, len(sl)-1\n    // while left <= right:\n    for left <= right {\n        // result.append(sl[left])\n        result = append(result, sl[left])\n        left++\n        // if left <= right:\n        if left <= right {\n            // result.append(sl[right])\n            result = append(result, sl[right])\n            right--\n        }\n    }\n    // return result\n    return result\n}\n",
            "func TriangleArea(a, b, c int) float64 {\n    // if a + b > c and a + c > b and b + c > a:\n    if a+b > c && a+c > b && b+c > a {\n        // s = (a + b + c) / 2.0\n        s := float64(a+b+c) / 2.0\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))\n    }\n    // else:\n    return -1.0\n}\n",
            "func WillItFly(q []int, w int) bool {\n    // if len(q) == 0:\n    if len(q) == 0 {\n        // return False\n        return false\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    isPalin := true\n    for i := 0; i < len(q); i++ {\n        if q[i] != q[len(q)-i-1] {\n            isPalin = false\n            break\n        }\n    }\n    // total = sum(q)\n    total := 0\n    for _, e := range q {\n        total += e\n    }\n    // return is_palin and total <= w\n    return isPalin && total <= w\n}\n",
            "func SmallestChange(arr []int) int {\n    // ans = 0\n    ans := 0\n    // for i in range(len(arr) // 2):\n    for i := 0; i < len(arr)/2; i++ {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if arr[i] != arr[len(arr)-i-1] {\n            // ans += 1\n            ans++\n        }\n    }\n    // return ans\n    return ans\n}\n",
            "func TotalMatch(lst1 []string, lst2 []string) []string {\n    // cnt1 = sum(len(s) for s in lst1)\n    cnt1 := 0\n    for _, s := range lst1 {\n        cnt1 += len(s)\n    }\n    // cnt2 = sum(len(s) for s in lst2)\n    cnt2 := 0\n    for _, s := range lst2 {\n        cnt2 += len(s)\n    }\n    // return lst1 if cnt1 <= cnt2 else lst2\n    if cnt1 <= cnt2 {\n        return lst1\n    }\n    return lst2\n}\n",
            "func IsPrime(n int) bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i := 2; i <= int(math.Floor(math.Sqrt(float64(n))))+1; i++ {\n        // if n % i == 0:\n        if n%i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc IsMultiplyPrime(a int) bool {\n    // cnt = 0\n    cnt := 0\n    // for i in range(2, a + 1):\n    for i := 2; i <= a+1; i++ {\n        // if is_prime(i):\n        if IsPrime(i) {\n            // while a % i == 0:\n            for a%i == 0 {\n                // cnt += 1\n                cnt++\n                // a /= i\n                a /= i\n            }\n        }\n    }\n    // return cnt == 3\n    return cnt == 3\n}\n",
            "func IsSimplePower(x int, n int) bool {\n    // if n < 2:\n    if n < 2 {\n        // return x == n\n        return x == n\n    }\n    // tmp = 1\n    tmp := 1\n    // while tmp < x:\n    for tmp < x {\n        // tmp *= n\n        tmp *= n\n    }\n    // return tmp == x\n    return tmp == x\n}\n",
            "func IsCube(a int) bool {\n    // a = abs(a)\n    a = int(math.Abs(float64(a)))\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    root := int(math.Round(math.Pow(float64(a), 1.0/3.0)))\n    // return root * root * root == a\n    return root*root*root == a\n}\n",
            "func HexKey(num string) int {\n    // return len([x for x in num if x in \"2357BD\"])\n    return len([]rune(num)) - len([]rune(num)[func(r rune) bool { return r != '2' && r != '3' && r != '5' && r != '7' && r != 'B' && r != 'D' }])\n}\n",
            "func DecimalToBinary(dec int) string {\n    // binary = bin(dec)[2:]\n    binary := strconv.FormatInt(int64(dec), 2)[2:]\n    // return f\"db{binary}db\"\n    return \"db\" + binary + \"db\"\n}\n",
            "func IsHappy(s string) bool {\n    // if len(s) < 3:\n    if len(s) < 3 {\n        // return False\n        return false\n    }\n    // for i in range(len(s) - 2):\n    for i := 0; i < len(s)-2; i++ {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\n",
            "func NumericalLetterGrade(grades []float64) []string {\n    // result = []\n    result := make([]string, 0)\n    // for g in grades:\n    for _, g := range grades {\n        // if g == 4.0:\n        if g == 4.0 {\n            // result.append(\"A+\")\n            result = append(result, \"A+\")\n        } else {\n            // elif g > 3.7:\n            if g > 3.7 {\n                // result.append(\"A\")\n                result = append(result, \"A\")\n            } else {\n                // elif g > 3.3:\n                if g > 3.3 {\n                    // result.append(\"A-\")\n                    result = append(result, \"A-\")\n                } else {\n                    // elif g > 3.0:\n                    if g > 3.0 {\n                        // result.append(\"B+\")\n                        result = append(result, \"B+\")\n                    } else {\n                        // elif g > 2.7:\n                        if g > 2.7 {\n                            // result.append(\"B\")\n                            result = append(result, \"B\")\n                        } else {\n                            // elif g > 2.3:\n                            if g > 2.3 {\n                                // result.append(\"B-\")\n                                result = append(result, \"B-\")\n                            } else {\n                                // elif g > 2.0:\n                                if g > 2.0 {\n                                    // result.append(\"C+\")\n                                    result = append(result, \"C+\")\n                                } else {\n                                    // elif g > 1.7:\n                                    if g > 1.7 {\n                                        // result.append(\"C\")\n                                        result = append(result, \"C\")\n                                    } else {\n                                        // elif g > 1.3:\n                                        if g > 1.3 {\n                                            // result.append(\"C-\")\n                                            result = append(result, \"C-\")\n                                        } else {\n                                            // elif g > 1.0:\n                                            if g > 1.0 {\n                                                // result.append(\"D+\")\n                                                result = append(result, \"D+\")\n                                            } else {\n                                                // elif g > 0.7:\n                                                if g > 0.7 {\n                                                    // result.append(\"D\")\n                                                    result = append(result, \"D\")\n                                                } else {\n                                                    // elif g > 0.0:\n                                                    if g > 0.0 {\n                                                        // result.append(\"D-\")\n                                                        result = append(result, \"D-\")\n                                                    } else {\n                                                        // else:\n                                                        // result.append(\"E\")\n                                                        result = append(result, \"E\")\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // return result\n    return result\n}\n",
            "func PrimeLength(s string) bool {\n    // length = len(s)\n    length := len(s)\n    // if length < 2:\n    if length < 2 {\n        return false\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for i := 2; i <= int(math.Floor(math.Sqrt(float64(length))))+1; i++ {\n        // if length % i == 0:\n        if length%i == 0 {\n            return false\n        }\n    }\n    // return True\n    return true\n}\n",
            "func StartsOneEnds(n int) int {\n    // if n == 1:\n    if n == 1 {\n        // return 1\n        return 1\n    }\n    // return 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * (10 ** (n - 2))\n}\n",
            "func Solve(n int) string {\n    // digits_sum = sum(int(d) for d in str(n))\n    digits_sum := 0\n    for _, d := range strconv.Itoa(n) {\n        digits_sum += int(d - '0')\n    }\n    // return bin(digits_sum)[2:]\n    return strconv.FormatInt(int64(digits_sum), 2)[2:]\n}\n",
            "func Add(lst []int) int {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    var sum int\n    for i, x := range lst {\n        if i%2 == 1 && x%2 == 0 {\n            sum += x\n        }\n    }\n    return sum\n}\n",
            "func AntiShuffle(s string) string {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    words := make([]string, 0)\n    for _, word := range strings.Split(s, \" \") {\n        words = append(words, strings.Join(sort.StringSlice(word), \"\"))\n    }\n    // return \" \".join(words)\n    return strings.Join(words, \" \")\n}\n",
            "func GetRow(lst [][]int, x int) [][]int {\n    // coords = []\n    coords := make([][]int, 0)\n    // for i in range(len(lst)):\n    for i := range lst {\n        // for j in range(len(lst[i])):\n        for j := range lst[i] {\n            // if lst[i][j] == x:\n            if lst[i][j] == x {\n                // coords.append([i, j])\n                coords = append(coords, []int{i, j})\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    sort.Slice(coords, func(i, j int) bool {\n        return coords[i][0] < coords[j][0] || (coords[i][0] == coords[j][0] && coords[i][1] > coords[j][1])\n    })\n    return coords\n}\n",
            "func SortArray(arr []int) []int {\n    // if len(arr) == 0:\n    if len(arr) == 0 {\n        // return []\n        return []\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if (arr[0] + arr[len(arr)-1])%2 == 0 {\n        // return sorted(arr, reverse=True)\n        return sort.Slice(arr, func(i, j int) bool { return arr[i] > arr[j] })\n    } else {\n        // return sorted(arr)\n        return sort.Slice(arr, func(i, j int) bool { return arr[i] < arr[j] })\n    }\n}\n",
            "func Encrypt(s string) string {\n    // result = []\n    result := make([]rune, 0)\n    // for ch in s:\n    for _, ch := range s {\n        // shifted = ord(ch) + 4\n        shifted := ch + 4\n        // if shifted > ord('z'):\n        if shifted > 'z' {\n            // shifted -= 26\n            shifted -= 26\n        }\n        // result.append(chr(shifted))\n        result = append(result, shifted)\n    }\n    // return \"\".join(result)\n    return string(result)\n}\n",
            "func NextSmallest(lst []int) *int {\n    // sl = sorted(set(lst))\n    sl := make([]int, 0)\n    for _, e := range lst {\n        sl = append(sl, e)\n    }\n    sort.Ints(sl)\n    sl = sl[:len(sl):len(sl)]\n    // if len(sl) < 2:\n    if len(sl) < 2 {\n        // return None\n        return nil\n    }\n    // return sl[1]\n    return &sl[1]\n}\n",
            "func IsBored(s string) int {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    sentences := regexp.MustCompile(`[.!?]\\s*`).Split(s, -1)\n    // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    var sum int\n    for _, sentence := range sentences {\n        if len(sentence) >= 2 && sentence[:2] == \"I \" {\n            sum += 1\n        }\n    }\n    return sum\n}\n",
            "func AnyInt(x, y, z interface{}) bool {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if _, ok := x.(int); ok && _, ok := y.(int); ok && _, ok := z.(int); ok {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if x.(int) + y.(int) == z.(int) || x.(int) + z.(int) == y.(int) || y.(int) + z.(int) == x.(int) {\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "func Encode(message string) string {\n    // vowels = \"aeiouAEIOU\"\n    vowels := \"aeiouAEIOU\"\n    // result = []\n    result := make([]rune, 0)\n    // for ch in message:\n    for _, ch := range message {\n        // if ch.isalpha():\n        if unicode.IsLetter(ch) {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            ch1 := ch\n            if unicode.IsLower(ch) {\n                ch1 = unicode.ToUpper(ch)\n            } else {\n                ch1 = unicode.ToLower(ch)\n            }\n            // if ch1 in vowels:\n            if strings.ContainsRune(vowels, ch1) {\n                // ch1 = chr(ord(ch1) + 2)\n                ch1 = rune(int(ch1) + 2)\n            }\n            // result.append(ch1)\n            result = append(result, ch1)\n        } else {\n            // result.append(ch)\n            result = append(result, ch)\n        }\n    }\n    // return \"\".join(result)\n    return string(result)\n}\n",
            "func IsPrime(n int) bool {\n    // if n < 2:\n    if n < 2 {\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i := 2; i <= int(math.Floor(math.Sqrt(float64(n))))+1; i++ {\n        // if n % i == 0:\n        if n%i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc Skjkasdkd(lst []int) int {\n    // primes = [n for n in lst if is_prime(n)]\n    primes := make([]int, 0)\n    for _, n := range lst {\n        if IsPrime(n) {\n            primes = append(primes, n)\n        }\n    }\n    // if len(primes) == 0:\n    if len(primes) == 0 {\n        // return 0\n        return 0\n    }\n    // largest = str(max(primes))\n    largest := strconv.Itoa(max(primes))\n    // return sum(int(digit) for digit in largest)\n    sum := 0\n    for _, digit := range largest {\n        sum += int(digit)\n    }\n    return sum\n}\n",
            "func CheckDictCase(d map[string]string) bool {\n    // if not d:\n    if len(d) == 0 {\n        return false\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    for k := range d {\n        if !(strings.ToLower(k) == k || strings.ToUpper(k) == k) {\n            return false\n        }\n    }\n    return true\n}\n",
            "func CountUpTo(n int) []int {\n    // primes = []\n    primes := make([]int, 0)\n    // for num in range(2, n):\n    for num := 2; num < n; num++ {\n        // if all(num % p != 0 for p in primes):\n        all := true\n        for _, p := range primes {\n            if num%p == 0 {\n                all = false\n                break\n            }\n        }\n        if all {\n            // primes.append(num)\n            primes = append(primes, num)\n        }\n    }\n    // return primes\n    return primes\n}\n",
            "func Multiply(a, b int) int {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    return (int(math.Abs(float64(a))) % 10) * (int(math.Abs(float64(b))) % 10)\n}\n",
            "func CountUpper(s string) int {\n    // vowels = \"AEIOU\"\n    vowels := \"AEIOU\"\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    var result int\n    for i, c := range s {\n        if i%2 == 0 && strings.ContainsRune(vowels, c) {\n            result++\n        }\n    }\n    return result\n}\n",
            "func ClosestInteger(value string) int {\n    // num = float(value)\n    num, _ := strconv.ParseFloat(value, 64)\n    // if num >= 0:\n    if num >= 0 {\n        // return int(num + 0.5)\n        return int(num + 0.5)\n    }\n    // else:\n    //     return int(num - 0.5)\n    return int(num - 0.5)\n}\n",
            "func MakeAPile(n int) []int {\n    // return [n + 2 * i for i in range(n)]\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = n + 2*i\n    }\n    return result\n}\n",
            "func WordsString(s string) []string {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    re := regexp.MustCompile(`[, ]`)\n    words := re.Split(s, -1)\n    result := make([]string, 0)\n    for _, w := range words {\n        if len(w) > 0 {\n            result = append(result, w)\n        }\n    }\n    return result\n}\n",
            "func ChooseNum(x, y int) int {\n    // if x > y:\n    if x > y {\n        // return -1\n        return -1\n    }\n    // if y % 2 == 0:\n    if y%2 == 0 {\n        // return y\n        return y\n    }\n    // return y - 1 if x != y else -1\n    if x != y {\n        return y - 1\n    }\n    return -1\n}\n",
            "func RoundedAvg(n, m int) (string, error) {\n    // if n > m:\n    if n > m {\n        // return None\n        return \"\", errors.New(\"n > m\")\n    }\n    // r_avg = int((m + n) / 2.0 + 0.5)\n    rAvg := int((m + n) / 2)\n    // return bin(r_avg)[2:]\n    return strconv.FormatInt(int64(rAvg), 2), nil\n}\n",
            "func AllDigitsOdd(s string) bool {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    for _, r := range s {\n        if utf8.RuneLen(r) != 1 {\n            return false\n        }\n        if r%2 != 0 {\n            return false\n        }\n    }\n    return true\n}\nfunc UniqueDigits(x []int) []int {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    result := make([]int, 0)\n    for _, num := range x {\n        if AllDigitsOdd(strconv.Itoa(num)) {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n",
            "func ByLength(arr []int) []string {\n    // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    digitNames := []string{\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}\n    // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n    sortedArr := make([]int, 0)\n    for _, x := range arr {\n        if 1 <= x && x <= 9 {\n            sortedArr = append(sortedArr, x)\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(sortedArr)))\n    // return [digit_names[x-1] for x in sorted_arr]\n    result := make([]string, 0)\n    for _, x := range sortedArr {\n        result = append(result, digitNames[x-1])\n    }\n    return result\n}\n",
            "func F(n int) []int {\n    // nums = list(range(1, n + 1))\n    nums := make([]int, n)\n    for i := 0; i < n; i++ {\n        nums[i] = i + 1\n    }\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    result := make([]int, n)\n    for i, num := range nums {\n        if i%2 != 0 {\n            result[i] = sum(nums[:i])\n        } else {\n            result[i] = reduce(func(x, y int) int { return x * y }, nums[:i], 1)\n        }\n    }\n    return result\n}\n",
            "func IsPalindrome(txt string) bool {\n    // return txt == txt[::-1]\n    return txt == Reverse(txt)\n}\nfunc EvenOddPalindrome(n int) []int {\n    // cnt = [0, 0]\n    cnt := []int{0, 0}\n    // for i in range(1, n + 1):\n    for i := 1; i <= n; i++ {\n        // if is_palindrome(str(i)):\n        if IsPalindrome(strconv.Itoa(i)) {\n            // cnt[i % 2] += 1\n            cnt[i%2]++\n        }\n    }\n    // return cnt\n    return cnt\n}\n",
            "func DigitsSum(n int) int {\n    // n_str = str(n)\n    n_str := strconv.Itoa(n)\n    // if n >= 0:\n    if n >= 0 {\n        // return sum(int(d) for d in n_str)\n        var sum int\n        for _, d := range n_str {\n            sum += int(d - '0')\n        }\n        return sum\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return int(n_str[:2]) * 2 + DigitsSum(abs(n))\n    }\n}\nfunc CountNums(arr []int) int {\n    // return len([n for n in arr if digits_sum(n) > 0])\n    var count int\n    for _, n := range arr {\n        if DigitsSum(n) > 0 {\n            count++\n        }\n    }\n    return count\n}\n",
            "func MoveOneBall(arr []int) bool {\n    // if len(arr) == 0:\n    if len(arr) == 0 {\n        // return True\n        return true\n    }\n    // sorted_arr = sorted(arr)\n    sortedArr := make([]int, len(arr))\n    copy(sortedArr, arr)\n    sort.Ints(sortedArr)\n    // for i in range(0, len(arr)):\n    for i := 0; i < len(arr); i++ {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if arr[i:] == sortedArr[:len(arr)-i] && arr[:i] == sortedArr[len(arr)-i:] {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "func CanExchange(lst1 []int, lst2 []int) string {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    oddCnt := 0\n    for _, num := range lst1 {\n        if num%2 != 0 {\n            oddCnt++\n        }\n    }\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    evenCnt := 0\n    for _, num := range lst2 {\n        if num%2 == 0 {\n            evenCnt++\n        }\n    }\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    if evenCnt >= oddCnt {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n",
            "func Histogram(test string) map.Map[string, int] {\n    // freq = {}\n    freq := map.New[string, int]()\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    words := strings.Fields(test)\n    // for w in words:\n    for _, w := range words {\n        // freq[w] = freq.get(w, 0) + 1\n        freq.Set(w, freq.Get(w, 0)+1)\n    }\n    // result = {}\n    result := map.New[string, int]()\n    // if len(freq) > 0:\n    if freq.Len() > 0 {\n        // max_freq = max(freq.values())\n        max_freq := 0\n        for _, v := range freq.Values() {\n            if v > max_freq {\n                max_freq = v\n            }\n        }\n        // for k, v in freq.items():\n        for k, v := range freq.Items() {\n            // if v == max_freq:\n            if v == max_freq {\n                // result[k] = v\n                result.Set(k, v)\n            }\n        }\n    }\n    // return result\n    return result\n}\n",
            "func IsPalindrome(s string) bool {\n    // return s == s[::-1]\n    return s == strings.Reverse(s)\n}\nfunc ReverseDelete(s, c string) []string {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    s1 := \"\"\n    for _, ch := range s {\n        if !strings.ContainsRune(c, ch) {\n            s1 += string(ch)\n        }\n    }\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    return []string{s1, \"yes\" if IsPalindrome(s1) else \"no\"}\n}\n",
            "func OddCount(lst []string) []string {\n    // result = []\n    result := make([]string, 0)\n    // for num in lst:\n    for _, num := range lst {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        n := 0\n        for _, d := range num {\n            if d%2 == 1 {\n                n++\n            }\n        }\n        // rs = \"the number of odd elements in the string i of the input.\"\n        rs := \"the number of odd elements in the string %d of the input.\"\n        // result.append(rs.replace(\"i\", str(n)))\n        result = append(result, fmt.Sprintf(rs, n))\n    }\n    // return result\n    return result\n}\n",
            "func MinSubArraySum(nums []int) int {\n    // min_sum = 0\n    minSum := 0\n    // cur_sum = 0\n    curSum := 0\n    // for n in nums:\n    for _, n := range nums {\n        // cur_sum = min(cur_sum + n, 0)\n        if curSum+n < 0 {\n            curSum = 0\n        } else {\n            curSum += n\n        }\n        // min_sum = min(cur_sum, min_sum)\n        if curSum < minSum {\n            minSum = curSum\n        }\n    }\n    // if min_sum == 0:\n    if minSum == 0 {\n        // min_sum = min(nums)\n        minSum = math.MinInt\n        for _, n := range nums {\n            if n < minSum {\n                minSum = n\n            }\n        }\n    }\n    // return min_sum\n    return minSum\n}\n",
            "func MaxFill(grid [][]int, capacity int) int {\n    // return sum([ceil(sum(arr) / capacity) for arr in grid])\n    return sum(ceil(sum(arr) / capacity) for arr in grid)\n}\n",
            "func CountOnes(num int) int {\n    // return bin(num).count(\"1\")\n    return strings.Count(strconv.FormatInt(int64(num), 2), \"1\")\n}\nfunc SortArray(arr []int) []int {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    sort.Slice(arr, func(i, j int) bool {\n        return CountOnes(arr[i]) < CountOnes(arr[j]) || (CountOnes(arr[i]) == CountOnes(arr[j]) && arr[i] < arr[j])\n    })\n    return arr\n}\n",
            "func SelectWords(s string, n int) []string {\n    // consonants = \"bcdfghjklmnpqrstvwxyz\"\n    consonants := \"bcdfghjklmnpqrstvwxyz\"\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    words := []string{}\n    for _, w := range strings.Split(s, \" \") {\n        if len(w) > 0 {\n            words = append(words, w)\n        }\n    }\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    return []string{}\n}\n",
            "func GetClosestVowel(word string) string {\n    // vowels = \"aeiouAEIOU\"\n    vowels := \"aeiouAEIOU\"\n    // for i in range(len(word) - 2, 0, -1):\n    for i := len(word) - 2; i >= 0; i-- {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if strings.ContainsRune(vowels, rune(word[i])) && !strings.ContainsRune(vowels, rune(word[i-1])) && !strings.ContainsRune(vowels, rune(word[i+1])) {\n            // return word[i]\n            return word[i:i+1]\n        }\n    }\n    // return \"\"\n    return \"\"\n}\n",
            "func Check(s string) bool {\n    // depth = 0\n    depth := 0\n    // for ch in s:\n    for _, ch := range s {\n        // if ch == \"(\":\n        if ch == '(' {\n            // depth += 1\n            depth++\n        } else {\n            // depth -= 1\n            depth--\n        }\n        // if depth < 0:\n        if depth < 0 {\n            // return False\n            return false\n        }\n    }\n    // return True if depth == 0 else False\n    return depth == 0\n}\nfunc MatchParens(lst []string) string {\n    // s1 = lst[0] + lst[1]\n    s1 := lst[0] + lst[1]\n    // s2 = lst[1] + lst[0]\n    s2 := lst[1] + lst[0]\n    // return \"Yes\" if check(s1) or check(s2) else \"No\"\n    if Check(s1) || Check(s2) {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n",
            "func Maximum(arr []int, k int) []int {\n    // if k == 0:\n    if k == 0 {\n        // return []\n        return []int{}\n    }\n    // return sorted(arr)[-k:]\n    return sort.Slice(arr, func(i, j int) bool { return arr[i] < arr[j] })[len(arr)-k:]\n}\n",
            "func Solution(lst []int) int {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    var result int\n    for i, x := range lst {\n        if i%2 == 0 && x%2 != 0 {\n            result += x\n        }\n    }\n    return result\n}\n",
            "func AddElements(arr []int, k int) int {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    sum := 0\n    for _, n := range arr[:k] {\n        if len(strconv.Itoa(n)) <= 2 {\n            sum += n\n        }\n    }\n    return sum\n}\n",
            "func GetOddCollatz(n int) []int {\n    // collatz = [1]\n    collatz := []int{1}\n    // while n != 1:\n    for n != 1 {\n        // if n % 2 != 0:\n        if n%2 != 0 {\n            // collatz.append(n)\n            collatz = append(collatz, n)\n            // n = 3 * n + 1\n            n = 3*n + 1\n        } else {\n            // n = n // 2\n            n = n / 2\n        }\n    }\n    // return sorted(collatz)\n    return collatz\n}\n",
            "func ValidDate(date string) bool {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if len(date) != 10 || date[2] != '-' || date[5] != '-' {\n        return false\n    }\n    // m = int(date[:2])\n    m, _ := strconv.Atoi(date[:2])\n    // d = int(date[3:5])\n    d, _ := strconv.Atoi(date[3:5])\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 {\n        if d >= 1 && d <= 31 {\n            return true\n        }\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if m == 4 || m == 6 || m == 9 || m == 11 {\n        if d >= 1 && d <= 30 {\n            return true\n        }\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if m == 2 {\n        if d >= 1 && d <= 29 {\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "func SplitWords(txt string) []string {\n    // if \" \" in txt:\n    if strings.Contains(txt, \" \") {\n        // return txt.split(\" \")\n        return strings.Split(txt, \" \")\n    }\n    // elif \",\" in txt:\n    if strings.Contains(txt, \",\") {\n        // return txt.split(\",\")\n        return strings.Split(txt, \",\")\n    }\n    // else:\n    //     return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n    return []string{strconv.Itoa(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))}\n}\n",
            "func IsSorted(lst []int) bool {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    for i := 1; i < len(lst); i++ {\n        if lst[i-1] > lst[i] {\n            return false\n        }\n    }\n    // freq = {}\n    freq := make(map[int]int)\n    // for i in lst:\n    for _, i := range lst {\n        // freq[i] = freq.get(i, 0) + 1\n        freq[i] = freq[i] + 1\n    }\n    // return max(freq.values(), default=0) <= 2\n    max := 0\n    for _, v := range freq {\n        if v > max {\n            max = v\n        }\n    }\n    return max <= 2\n}\n",
            "func IsPrime(n int) bool {\n    // if n < 2:\n    if n < 2 {\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i := 2; i <= int(math.Floor(math.Sqrt(float64(n))))+1; i++ {\n        // if n % i == 0:\n        if n%i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc Intersection(interval1 []int, interval2 []int) string {\n    // l = max(interval1[0], interval2[0])\n    l := interval1[0]\n    if interval2[0] > l {\n        l = interval2[0]\n    }\n    // r = min(interval1[1], interval2[1])\n    r := interval1[1]\n    if interval2[1] < r {\n        r = interval2[1]\n    }\n    // length = r - l\n    length := r - l\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    if length > 0 && IsPrime(length) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n",
            "func ProdSigns(arr []int) *int {\n    // if not arr:\n    if len(arr) == 0 {\n        // return None\n        return nil\n    }\n    // if 0 in arr:\n    for _, n := range arr {\n        if n == 0 {\n            // return 0\n            return new(int)\n        }\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    sign := -1\n    if len([n for n in arr if n < 0])%2 == 1 {\n        sign = 1\n    }\n    // return sign * sum([abs(n) for n in arr])\n    sum := 0\n    for _, n := range arr {\n        sum += abs(n)\n    }\n    return new(int)\n}\n",
            "func MinPath(grid [][]int, k int) []int {\n    // n = len(grid)\n    n := len(grid)\n    // min_val = n * n + 1\n    minVal := n * n + 1\n    // for i in range(n):\n    for i := 0; i < n; i++ {\n        // for j in range(n):\n        for j := 0; j < n; j++ {\n            // if grid[i][j] == 1:\n            if grid[i][j] == 1 {\n                // temp = []\n                temp := []int{}\n                // if i != 0:\n                if i != 0 {\n                    // temp.append(grid[i - 1][j])\n                    temp = append(temp, grid[i - 1][j])\n                }\n                // if j != 0:\n                if j != 0 {\n                    // temp.append(grid[i][j - 1])\n                    temp = append(temp, grid[i][j - 1])\n                }\n                // if i != n - 1:\n                if i != n - 1 {\n                    // temp.append(grid[i + 1][j])\n                    temp = append(temp, grid[i + 1][j])\n                }\n                // if j != n - 1:\n                if j != n - 1 {\n                    // temp.append(grid[i][j + 1])\n                    temp = append(temp, grid[i][j + 1])\n                }\n                // min_val = min(temp)\n                minVal = min(temp)\n            }\n        }\n    }\n    // result = []\n    result := []int{}\n    // for i in range(k):\n    for i := 0; i < k; i++ {\n        // result.append(1 if i % 2 == 0 else min_val)\n        if i%2 == 0 {\n            result = append(result, 1)\n        } else {\n            result = append(result, minVal)\n        }\n    }\n    // return result\n    return result\n}\n",
            "func Tri(n int) []int {\n    // if n == 0:\n    if n == 0 {\n        // return [1]\n        return []int{1}\n    }\n    // seq = [1, 3]\n    seq := []int{1, 3}\n    // for i in range(2, n + 1):\n    for i := 2; i <= n; i++ {\n        // if i % 2 == 0:\n        if i%2 == 0 {\n            // seq.append(i / 2 + 1)\n            seq = append(seq, i/2+1)\n        } else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq = append(seq, seq[i-1]+seq[i-2]+(i+3)/2)\n        }\n    }\n    // return seq\n    return seq\n}\n",
            "func Digits(n int) int {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    odds := []int{}\n    for _, d := range strconv.Itoa(n) {\n        if int(d)%2 == 1 {\n            odds = append(odds, int(d))\n        }\n    }\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    if len(odds) > 0 {\n        return reduce(func(x, y int) int { return x * y }, odds, 1)\n    }\n    return 0\n}\n",
            "func IsNested(s string) bool {\n    // open_idx = []\n    openIdx := make([]int, 0)\n    // close_idx = []\n    closeIdx := make([]int, 0)\n    // for i, ch in enumerate(s):\n    for i, ch := range s {\n        // if ch == '[':\n        if ch == '[' {\n            // open_idx.append(i)\n            openIdx = append(openIdx, i)\n        }\n        // elif ch == ']':\n        if ch == ']' {\n            // close_idx.append(i)\n            closeIdx = append(closeIdx, i)\n        }\n    }\n    // close_idx.reverse()\n    for i, j := 0, len(closeIdx)-1; i < j; i, j = i+1, j-1 {\n        closeIdx[i], closeIdx[j] = closeIdx[j], closeIdx[i]\n    }\n    // cnt = 0\n    cnt := 0\n    // i = 0\n    i := 0\n    // l = len(close_idx)\n    l := len(closeIdx)\n    // for idx in open_idx:\n    for _, idx := range openIdx {\n        // if i < l and idx < close_idx[i]:\n        if i < l && idx < closeIdx[i] {\n            // cnt += 1\n            cnt += 1\n            // i += 1\n            i += 1\n        }\n    }\n    // return cnt >= 2\n    return cnt >= 2\n}\n",
            "func SumSquares(lst []float64) int {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    return sum(pow(ceil(n), 2) for n in lst)\n}\n",
            "func CheckIfLastCharIsALetter(txt string) bool {\n    // if not txt:\n    if txt == \"\" {\n        // return False\n        return false\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    last := txt[strings.LastIndex(txt, \" \") + 1:]\n    // return len(last) == 1 and last[0].isalpha()\n    return len(last) == 1 && last[0] >= 'a' && last[0] <= 'z'\n}\n",
            "func CanArrange(arr []int) int {\n    // if len (arr) <= 1:\n    if len(arr) <= 1 {\n        // return -1\n        return -1\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    idx := make([]int, 0)\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n            idx = append(idx, i)\n        }\n    }\n    // return max(idx, default=-1)\n    if len(idx) == 0 {\n        return -1\n    }\n    return idx[len(idx)-1]\n}\n",
            "func LargestSmallestIntegers(lst []int) []*int {\n    // neg = [i for i in lst if i < 0]\n    neg := make([]int, 0)\n    for _, i := range lst {\n        if i < 0 {\n            neg = append(neg, i)\n        }\n    }\n    // pos = [i for i in lst if i > 0]\n    pos := make([]int, 0)\n    for _, i := range lst {\n        if i > 0 {\n            pos = append(pos, i)\n        }\n    }\n    // max_neg = max(neg) if len(neg) > 0 else None\n    var maxNeg *int\n    if len(neg) > 0 {\n        maxNeg = &neg[0]\n        for _, i := range neg {\n            if i > *maxNeg {\n                maxNeg = &i\n            }\n        }\n    }\n    // min_pos = min(pos) if len(pos) > 0 else None\n    var minPos *int\n    if len(pos) > 0 {\n        minPos = &pos[0]\n        for _, i := range pos {\n            if i < *minPos {\n                minPos = &i\n            }\n        }\n    }\n    // return [max_neg, min_pos]\n    return []*int{maxNeg, minPos}\n}\n",
            "func AnyToReal(o interface{}) float64 {\n    // if isinstance(o, str): \n    if s, ok := o.(string); ok {\n        // return float(o.replace(',','.'))\n        return strconv.ParseFloat(strings.Replace(s, \",\", \".\", -1), 64)\n    }\n    // elif isinstance(o, int):\n    if i, ok := o.(int); ok {\n        // return float(o)\n        return float64(i)\n    }\n    // elif isinstance(o, float):\n    if f, ok := o.(float64); ok {\n        // return o\n        return f\n    }\n    // raise RuntimeError(\"Type Error\");\n    panic(\"Type Error\")\n}\nfunc CompareOne(a interface{}, b interface{}) interface{} {\n    // a1 = any_to_real(a)\n    a1 := AnyToReal(a)\n    // b1 = any_to_real(b)\n    b1 := AnyToReal(b)\n    // if a1 == b1:\n    if a1 == b1 {\n        // return None\n        return nil\n    }\n    // elif a1 > b1:\n    if a1 > b1 {\n        // return a1\n        return a1\n    }\n    // else:\n    // return b1\n    return b1\n}\n",
            "func IsEqualToSumEven(n int) bool {\n    // return n % 2 == 0 and n >= 8\n    return n%2 == 0 && n >= 8\n}\n",
            "func SpecialFactorial(n int) int {\n    // fact = 1\n    fact := 1\n    // result = 1\n    result := 1\n    // for i in range(1, n + 1):\n    for i := 1; i <= n; i++ {\n        // fact *= i\n        fact *= i\n        // result *= fact\n        result *= fact\n    }\n    // return result\n    return result\n}\n",
            "func FixSpaces(txt string) string {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    return regexp.MustCompile(`\\s{3,}`).ReplaceAllString(txt, \"-\")\n}\n",
            "func FileNameCheck(fileName string) string {\n    // suf = [\"txt\", \"exe\", \"dll\"]\n    suf := []string{\"txt\", \"exe\", \"dll\"}\n    // lst = file_name.split(\".\")\n    lst := strings.Split(fileName, \".\")\n    // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n    if len(lst) != 2 || !contains(suf, lst[1]) || len(lst[0]) == 0 || !isAlpha(lst[0][0]) || len(filter(func(x rune) bool { return isDigit(x) }, []rune(lst[0]))) > 3 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n",
            "func SumSquares(lst []int) int {\n    // result = 0\n    result := 0\n    // for i in range(len(lst)):\n    for i := range lst {\n        // if i % 3 == 0:\n        if i%3 == 0 {\n            // result += pow(lst[i], 2)\n            result += pow(lst[i], 2)\n        } else if i%4 == 0 {\n            // result += pow(lst[i], 3)\n            result += pow(lst[i], 3)\n        } else {\n            // result += lst[i]\n            result += lst[i]\n        }\n    }\n    // return result\n    return result\n}\n",
            "func IsPrime(n int) bool {\n    // if n < 2:\n    if n < 2 {\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i := 2; i <= int(math.Floor(math.Sqrt(float64(n))))+1; i++ {\n        // if n % i == 0:\n        if n%i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc WordsInSentence(sentence string) string {\n    // words = sentence.split(\" \")\n    words := strings.Split(sentence, \" \")\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    return strings.Join(\n        []string{},\n        func(i int) string {\n            w := words[i]\n            if IsPrime(len(w)) {\n                return w\n            }\n            return \"\"\n        },\n    )\n}\n",
            "func Simplify(x, n string) bool {\n    xs := strings.Split(x, \"/\")\n    ns := strings.Split(n, \"/\")\n    num, _ := strconv.Atoi(xs[0])\n    den, _ := strconv.Atoi(xs[1])\n    num *= ns[0]\n    den *= ns[1]\n    return num%den == 0\n}\n",
            "func DigitsSum(n int) int {\n    // n_str = str(n)\n    n_str := strconv.Itoa(n)\n    // if n >= 0:\n    if n >= 0 {\n        // return sum(int(d) for d in n_str)\n        var sum int\n        for _, d := range n_str {\n            sum += int(d - '0')\n        }\n        return sum\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return int(n_str[:2]) * 2 + DigitsSum(abs(n))\n    }\n}\nfunc OrderByPoints(nums []int) []int {\n    // return sorted(nums, key=digits_sum)\n    sort.Slice(nums, func(i, j int) bool {\n        return DigitsSum(nums[i]) < DigitsSum(nums[j])\n    })\n    return nums\n}\n",
            "func SpecialFilter(nums []int) int {\n    // odds = \"13579\"\n    odds := \"13579\"\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    return len([]int{n for n in nums if n > 10 && n%2 == 1 && strings.Contains(string(n), odds)})\n}\n",
            "func GetMaxTriples(n int) int {\n    // c = [0, 0, 0]\n    c := [3]int{0, 0, 0}\n    // for i in range(1, n + 1):\n    for i := 1; i <= n; i++ {\n        // a = i * i - i + 1\n        a := i*i - i + 1\n        // c[a % 3] += 1\n        c[a%3] += 1\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    return c[0]*c[1]*c[2] + (c[0]*(c[0]-1)*(c[0]-2) + c[1]*(c[1]-1)*(c[1]-2) + c[2]*(c[2]-1)*(c[2]-2)) // 6\n}\n",
            "func BF(planet1 string, planet2 string) []string {\n    // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    names := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    // if planet1 not in names or planet2 not in names:\n    if !contains(names, planet1) || !contains(names, planet2) {\n        // return []\n        return []string{}\n    }\n    // l = names.index(planet1)\n    l := index(names, planet1)\n    // r = names.index(planet2)\n    r := index(names, planet2)\n    // if l > r:\n    if l > r {\n        // l, r = r, l\n        l, r = r, l\n    }\n    // if l == r:\n    if l == r {\n        // return []\n        return []string{}\n    }\n    // return names[l + 1 : r]\n    return names[l+1 : r]\n}\nfunc contains(s []string, e string) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\nfunc index(s []string, e string) int {\n    for i, a := range s {\n        if a == e {\n            return i\n        }\n    }\n    return -1\n}\n",
            "func SortedListSum(lst []string) []string {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    result := make([]string, 0)\n    for _, s := range lst {\n        if len(s)%2 == 0 {\n            result = append(result, s)\n        }\n    }\n    // return sorted(result, key=lambda x: (len(x), x))\n    sort.Slice(result, func(i, j int) bool {\n        if len(result[i]) == len(result[j]) {\n            return result[i] < result[j]\n        }\n        return len(result[i]) < len(result[j])\n    })\n    return result\n}\n",
            "func XOrY(n int, x int, y int) int {\n    // if n < 2:\n    if n < 2 {\n        // return y\n        return y\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i := 2; i <= int(math.Floor(math.Sqrt(float64(n))))+1; i++ {\n        // if n % i == 0:\n        if n%i == 0 {\n            // return y\n            return y\n        }\n    }\n    // return x\n    return x\n}\n",
            "func DoubleTheDifference(lst []float64) int {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    var sum int\n    for _, n := range lst {\n        if n >= 0 && n%2 == 1 {\n            sum += int(n * n)\n        }\n    }\n    return sum\n}\n",
            "func Compare(game, guess []int) []int {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    result := make([]int, 0)\n    for i := range game {\n        result = append(result, abs(game[i]-guess[i]))\n    }\n    return result\n}\n",
            "func StrongestExtension(className string, extensions []string) string {\n    // max_s = float(\"-inf\")\n    maxS := float64(-math.MaxFloat64)\n    // max_ext = \"\"\n    maxExt := \"\"\n    // for ext in extensions:\n    for _, ext := range extensions {\n        // upper = len([c for c in ext if c.isupper()])\n        upper := 0\n        for _, c := range ext {\n            if unicode.IsUpper(c) {\n                upper++\n            }\n        }\n        // lower = len([c for c in ext if c.islower()])\n        lower := 0\n        for _, c := range ext {\n            if unicode.IsLower(c) {\n                lower++\n            }\n        }\n        // s = upper - lower\n        s := upper - lower\n        // if s > max_s:\n        if s > maxS {\n            // max_s = s\n            maxS = s\n            // max_ext = ext\n            maxExt = ext\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    return fmt.Sprintf(\"%s.%s\", className, maxExt)\n}\n",
            "func CycpatternCheck(a, b string) bool {\n    // if len(a) < len(b):\n    if len(a) < len(b) {\n        // return False\n        return false\n    }\n    // for i in range(len(b)):\n    for i := 0; i < len(b); i++ {\n        // if b[i:] + b[:i] in a:\n        if strings.Contains(a, b[i:]+b[:i]) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "func EvenOddCount(num int) []int {\n    // ds = str(abs(num))\n    ds := strconv.Itoa(abs(num))\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    even := 0\n    for _, d := range ds {\n        if d%2 == 0 {\n            even++\n        }\n    }\n    // return [even, len(ds) - even]\n    return []int{even, len(ds) - even}\n}\n",
            "func IntToMiniRoman(num int) string {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    numerals := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n    // res = []\n    res := make([]string, 0)\n    // for i in range(len(values)):\n    for i := 0; i < len(values); i++ {\n        // while num >= values[i]:\n        for num >= values[i] {\n            // res.append(numerals[i])\n            res = append(res, numerals[i])\n            // num -= values[i]\n            num -= values[i]\n        }\n    }\n    // return \"\".join(res)\n    return strings.Join(res, \"\")\n}\n",
            "func RightAngleTriangle(a, b, c int) bool {\n    // s = sorted([a, b, c])\n    s := []int{a, b, c}\n    sort.Ints(s)\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0]*s[0] + s[1]*s[1] == s[2]*s[2]\n}\n",
            "func FindMax(words []string) string {\n    // max_cnt = 0\n    maxCnt := 0\n    // max_w = \"\"\n    maxW := \"\"\n    // for w in words:\n    for _, w := range words {\n        // cnt = len(set(w))\n        cnt := len(map[rune]bool(w))\n        // if cnt > max_cnt:\n        if cnt > maxCnt {\n            // max_cnt = cnt\n            maxCnt = cnt\n            // max_w = w\n            maxW = w\n        }\n        // elif cnt == max_cnt:\n        else if cnt == maxCnt {\n            // max_w = min(max_w, w)\n            if w < maxW {\n                maxW = w\n            }\n        }\n    }\n    // return max_w\n    return maxW\n}\n",
            "func Eat(num, need, remaining int) (int, int) {\n    // if need <= remaining:\n    if need <= remaining {\n        // return [num + need, remaining - need]\n        return num + need, remaining - need\n    } else {\n        // return [num + remaining, 0]\n        return num + remaining, 0\n    }\n}\n",
            "func DoAlgebra(operators []string, operands []int) int {\n    // ops = operators.copy()\n    ops := make([]string, len(operators))\n    copy(ops, operators)\n    // nums = operands.copy()\n    nums := make([]int, len(operands))\n    copy(nums, operands)\n    // i = len(ops) - 1\n    i := len(ops) - 1\n    // while i >= 0:\n    for i >= 0 {\n        // if ops[i] == \"**\":\n        if ops[i] == \"**\" {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            nums[i] = int(math.Pow(float64(nums[i]), float64(nums[i+1])))\n            // nums.pop(i + 1)\n            nums = append(nums[:i+1], nums[i+2:]...)\n            // ops.pop(i)\n            ops = append(ops[:i], ops[i+1:]...)\n        }\n        // i -= 1\n        i -= 1\n    }\n    // i = 0\n    i = 0\n    // while i < len(ops):\n    for i < len(ops) {\n        // if ops[i] == \"*\":\n        if ops[i] == \"*\" {\n            // nums[i] = nums[i] * nums[i + 1]\n            nums[i] *= nums[i+1]\n            // nums.pop(i + 1)\n            nums = append(nums[:i+1], nums[i+2:]...)\n            // ops.pop(i)\n            ops = append(ops[:i], ops[i+1:]...)\n            // i -= 1\n            i -= 1\n        }\n        // elif ops[i] == \"//\":\n        else if ops[i] == \"//\" {\n            // nums[i] = nums[i] // nums[i + 1]\n            nums[i] /= nums[i+1]\n            // nums.pop(i + 1)\n            nums = append(nums[:i+1], nums[i+2:]...)\n            // ops.pop(i)\n            ops = append(ops[:i], ops[i+1:]...)\n            // i -= 1\n            i -= 1\n        }\n        // i += 1\n        i += 1\n    }\n    // i = 0\n    i = 0\n    // while i < len(ops):\n    for i < len(ops) {\n        // if ops[i] == \"+\":\n        if ops[i] == \"+\" {\n            // nums[i] = nums[i] + nums[i + 1]\n            nums[i] += nums[i+1]\n            // nums.pop(i + 1)\n            nums = append(nums[:i+1], nums[i+2:]...)\n            // ops.pop(i)\n            ops = append(ops[:i], ops[i+1:]...)\n            // i -= 1\n            i -= 1\n        }\n        // elif ops[i] == \"-\":\n        else if ops[i] == \"-\" {\n            // nums[i] = nums[i] - nums[i + 1]\n            nums[i] -= nums[i+1]\n            // nums.pop(i + 1)\n            nums = append(nums[:i+1], nums[i+2:]...)\n            // ops.pop(i)\n            ops = append(ops[:i], ops[i+1:]...)\n            // i -= 1\n            i -= 1\n        }\n        // i += 1\n        i += 1\n    }\n    // return nums[0]\n    return nums[0]\n}\n",
            "func Solve(s string) string {\n    // if not any(ch.isalpha() for ch in s):\n    if !any(func(ch rune) bool { return ch.isalpha() }, s) {\n        // return s[::-1]\n        return reverse(s)\n    }\n    // result = []\n    result := make([]rune, 0)\n    // for ch in s:\n    for _, ch := range s {\n        // if not ch.isalpha():\n        if !ch.isalpha() {\n            // result.append(ch)\n            result = append(result, ch)\n        } else if ch.isupper() {\n            // result.append(ch.lower())\n            result = append(result, ch.lower())\n        } else if ch.islower() {\n            // result.append(ch.upper())\n            result = append(result, ch.upper())\n        }\n    }\n    // return \"\".join(result)\n    return string(result)\n}\n",
            "func StringToMD5(txt string) string {\n    // if not txt:\n    if txt == \"\" {\n        // return None\n        return \"\"\n    }\n    // md5_hash = hashlib.md5()\n    md5_hash := md5.New()\n    // txt_bytes = txt.encode()\n    txt_bytes := []byte(txt)\n    // md5_hash.update(txt_bytes)\n    md5_hash.Write(txt_bytes)\n    // md5_encoded = md5_hash.hexdigest()\n    md5_encoded := md5_hash.Sum(nil)\n    // return md5_encoded\n    return fmt.Sprintf(\"%x\", md5_encoded)\n}\n",
            "func GenerateIntegers(a, b int) []int {\n    // lower = max(2, min(a, b))\n    lower := a\n    if lower < 2 {\n        lower = 2\n    }\n    if lower > b {\n        lower = b\n    }\n    // upper = min(8, max(a, b))\n    upper := b\n    if upper > 8 {\n        upper = 8\n    }\n    if upper < a {\n        upper = a\n    }\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    result := make([]int, 0)\n    for i := lower; i <= upper; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n"
        ],
        "java": [
            "class Global {\n    public static boolean hasCloseElements(List<Float> numbers, float threshold) {\n        // for i in range(len(numbers)):\n        for (int i = 0; i < numbers.size(); i++) {\n            // for j in range(i + 1, len(numbers)):\n            for (int j = i + 1; j < numbers.size(); j++) {\n                // if abs(numbers[i] - numbers[j]) < threshold:\n                if (Math.abs(numbers.get(i) - numbers.get(j)) < threshold) {\n                    // return True\n                    return true;\n                }\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static List<String> separateParenGroups(String parenString) {\n        // groups = []\n        var groups = new ArrayList<String>();\n        // stk = []\n        var stk = new ArrayList<Character>();\n        // current_group = \"\"\n        var currentGroup = \"\";\n        // parens = paren_string.replace(\" \", \"\")\n        var parens = parenString.replace(\" \", \"\");\n        // for ch in parens:\n        for (Character ch : parens.toCharArray()) {\n            // if ch == \"(\":\n            if (ch == '(') {\n                // stk.append(ch)\n                stk.add(ch);\n                // current_group += ch\n                currentGroup += ch;\n            }\n            // elif ch == \")\":\n            else if (ch == ')') {\n                // stk.pop()\n                stk.remove(stk.size() - 1);\n                // current_group += ch\n                currentGroup += ch;\n                // if not stk:\n                if (stk.isEmpty()) {\n                    // groups.append(current_group)\n                    groups.add(currentGroup);\n                    // current_group = \"\"\n                    currentGroup = \"\";\n                }\n            }\n        }\n        // return groups\n        return groups;\n    }\n}\n",
            "class Global {\n    public static float truncateNumber(float num) {\n        // return num - floor(num)\n        return num - (float) Math.floor(num);\n    }\n}\n",
            "class Global {\n    public static boolean belowZero(List<Integer> operations) {\n        // balance = 0\n        int balance = 0;\n        // for op in operations:\n        for (Integer op : operations) {\n            // balance += op\n            balance += op;\n            // if balance < 0:\n            if (balance < 0) {\n                // return True\n                return true;\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static double meanAbsoluteDeviation(List<Double> numbers) {\n        // mean = sum(numbers) / len(numbers)\n        double mean = numbers.stream().mapToDouble(x -> x).sum() / numbers.size();\n        // deviation = sum(abs(x - mean) for x in numbers)\n        double deviation = numbers.stream().mapToDouble(x -> Math.abs(x - mean)).sum();\n        // return deviation / len(numbers)\n        return deviation / numbers.size();\n    }\n}\n",
            "class Global {\n    public static List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        // result = []\n        var result = new ArrayList<Integer>();\n        // for i in range(len(numbers)):\n        for (int i = 0; i < numbers.size(); i++) {\n            // if i != 0:\n            if (i != 0) {\n                // result.append(delimiter)\n                result.add(delimiter);\n            }\n            // result.append(numbers[i])\n            result.add(numbers.get(i));\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static List<Integer> parseNestedParens(String parenString) {\n        // result = []\n        var result = new ArrayList<Integer>();\n        // paren_groups = paren_string.split()\n        var parenGroups = parenString.split(\" \");\n        // for group in paren_groups:\n        for (String group : parenGroups) {\n            // max_depth = 0\n            int maxDepth = 0;\n            // depth = 0\n            int depth = 0;\n            // for ch in group:\n            for (char ch : group.toCharArray()) {\n                // if ch == \"(\":\n                if (ch == '(') {\n                    // depth += 1\n                    depth += 1;\n                    // max_depth = max(max_depth, depth)\n                    maxDepth = Math.max(maxDepth, depth);\n                }\n                // elif ch == \")\":\n                else if (ch == ')') {\n                    // depth -= 1\n                    depth -= 1;\n                }\n            }\n            // result.append(max_depth)\n            result.add(maxDepth);\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static List<String> filterBySubstring(List<String> strs, String substring) {\n        // return [s for s in strs if substring in s]\n        return strs.stream().filter(s -> s.contains(substring)).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static List<Integer> sumProduct(List<Integer> numbers) {\n        // n_sum = sum(numbers)\n        int nSum = 0;\n        for (Integer n : numbers) {\n            nSum += n;\n        }\n        // n_product = reduce(lambda x, y: x * y, numbers, 1)\n        int nProduct = 1;\n        for (Integer n : numbers) {\n            nProduct *= n;\n        }\n        // return [n_sum, n_product]\n        return Arrays.asList(nSum, nProduct);\n    }\n}\n",
            "class Global {\n    public static List<Integer> rollingMax(List<Integer> numbers) {\n        // max_so_far = float(\"-inf\")\n        double maxSoFar = Double.NEGATIVE_INFINITY;\n        // result = []\n        var result = new ArrayList<Integer>();\n        // for num in numbers:\n        for (Integer num : numbers) {\n            // max_so_far = max(max_so_far, num)\n            maxSoFar = Math.max(maxSoFar, num);\n            // result.append(max_so_far)\n            result.add((int) maxSoFar);\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static boolean isPalindrome(String s) {\n        // return s == s[::-1]\n        return s.equals(new StringBuilder(s).reverse().toString());\n    }\n    public static String makePalindrome(String s) {\n        // if is_palindrome(s):\n        if (isPalindrome(s)) {\n            // return s\n            return s;\n        }\n        // for i in range(len(s)):\n        for (int i = 0; i < s.length(); i++) {\n            // if is_palindrome(s[i:]):\n            if (isPalindrome(s.substring(i))) {\n                // return s + s[:i][::-1]\n                return s + new StringBuilder(s.substring(0, i)).reverse().toString();\n            }\n        }\n        // return \"\"\n        return \"\";\n    }\n}\n",
            "class Global {\n    public static String stringXor(String a, String b) {\n        // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n        return String.join(\"\", new ArrayList<String>() {{\n            for (int i = 0; i < a.length(); i++) {\n                add(a.charAt(i) == b.charAt(i) ? \"0\" : \"1\");\n            }\n        }});\n    }\n}\n",
            "class Global {\n    public static Optional<String> longest(List<String> strs) {\n        // if not strs:\n        if (strs.isEmpty()) {\n            // return None\n            return Optional.empty();\n        }\n        // longest_s = strs[0]\n        String longest_s = strs.get(0);\n        // for s in strs:\n        for (String s : strs) {\n            // if len(s) > len(longest_s):\n            if (s.length() > longest_s.length()) {\n                // longest_s = s\n                longest_s = s;\n            }\n        }\n        // return longest_s\n        return Optional.of(longest_s);\n    }\n}\n",
            "class Global {\n    public static int greatestCommonDivisor(int a, int b) {\n        // if b == 0:\n        if (b == 0) {\n            // return a\n            return a;\n        } else {\n            // return greatest_common_divisor(b, a % b)\n            return greatestCommonDivisor(b, a % b);\n        }\n    }\n}\n",
            "class Global {\n    public static List<String> allPrefixes(String s) {\n        // prefixes = []\n        var prefixes = new ArrayList<String>();\n        // for i in range(len(s)):\n        for (int i = 0; i < s.length(); i++) {\n            // prefixes.append(s[: i + 1])\n            prefixes.add(s.substring(0, i + 1));\n        }\n        // return prefixes\n        return prefixes;\n    }\n}\n",
            "class Global {\n    public static String stringSequence(int n) {\n        // return \" \".join([str(i) for i in range(n + 1)])\n        return String.join(\" \", Arrays.stream(new int[n + 1]).mapToObj(String::valueOf).toArray(String[]::new));\n    }\n}\n",
            "class Global {\n    public static int countDistinctCharacters(String s) {\n        // return len(set(s.lower()))\n        return new HashSet<>(s.toLowerCase().chars().boxed().collect(Collectors.toList())).size();\n    }\n}\n",
            "class Global {\n    public static List<Integer> parseMusic(String musicString) {\n        // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n        var durations = new HashMap<String, Integer>();\n        durations.put(\"o\", 4);\n        durations.put(\"o|\", 2);\n        durations.put(\".|\", 1);\n        // notes = music_string.split()\n        var notes = musicString.split(\" \");\n        // return [durations[note] for note in notes]\n        var result = new ArrayList<Integer>();\n        for (String note : notes) {\n            result.add(durations.get(note));\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static int howManyTimes(String s, String substring) {\n        // times = 0\n        int times = 0;\n        // for i in range(len(s) - len(substring) + 1):\n        for (int i = 0; i < s.length() - substring.length() + 1; i++) {\n            // if s[i : i + len(substring)] == substring:\n            if (s.substring(i, i + substring.length()).equals(substring)) {\n                // times += 1\n                times += 1;\n            }\n        }\n        // return times\n        return times;\n    }\n}\n",
            "class Global {\n    public static String sortNumbers(String numbers) {\n        // num_dict = {\n        //     \"zero\": 0,\n        //     \"one\": 1,\n        //     \"two\": 2,\n        //     \"three\": 3,\n        //     \"four\": 4,\n        //     \"five\": 5,\n        //     \"six\": 6,\n        //     \"seven\": 7,\n        //     \"eight\": 8,\n        //     \"nine\": 9,\n        // }\n        var numDict = new HashMap<String, Integer>();\n        numDict.put(\"zero\", 0);\n        numDict.put(\"one\", 1);\n        numDict.put(\"two\", 2);\n        numDict.put(\"three\", 3);\n        numDict.put(\"four\", 4);\n        numDict.put(\"five\", 5);\n        numDict.put(\"six\", 6);\n        numDict.put(\"seven\", 7);\n        numDict.put(\"eight\", 8);\n        numDict.put(\"nine\", 9);\n        // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n        var numList = new ArrayList<String>();\n        for (String x : numbers.split(\" \")) {\n            if (numDict.containsKey(x)) {\n                numList.add(x);\n            }\n        }\n        // num_list.sort(key=lambda x: num_dict[x])\n        numList.sort(Comparator.comparing(x -> numDict.get(x)));\n        // return \" \".join(num_list)\n        return String.join(\" \", numList);\n    }\n}\n",
            "class Global {\n    public static List<Float> findClosestElements(List<Float> numbers) {\n        // sorted_numbers = sorted(numbers)\n        var sortedNumbers = new ArrayList<Float>(numbers);\n        Collections.sort(sortedNumbers);\n        // min_diff = float(\"inf\")\n        var minDiff = Float.POSITIVE_INFINITY;\n        // closest_pair = []\n        var closestPair = new ArrayList<Float>();\n        // for i in range(1, len(sorted_numbers)):\n        for (int i = 1; i < sortedNumbers.size(); i++) {\n            // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n            var diff = sortedNumbers.get(i) - sortedNumbers.get(i - 1);\n            // if diff < min_diff:\n            if (diff < minDiff) {\n                // min_diff = diff\n                minDiff = diff;\n                // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n                closestPair.clear();\n                closestPair.add(sortedNumbers.get(i - 1));\n                closestPair.add(sortedNumbers.get(i));\n            }\n        }\n        // return closest_pair\n        return closestPair;\n    }\n}\n",
            "class Global {\n    public static List<Double> rescaleToUnit(List<Double> numbers) {\n        // min_num = min(numbers)\n        double minNum = Double.MAX_VALUE;\n        for (Double num : numbers) {\n            if (num < minNum) {\n                minNum = num;\n            }\n        }\n        // max_num = max(numbers)\n        double maxNum = Double.MIN_VALUE;\n        for (Double num : numbers) {\n            if (num > maxNum) {\n                maxNum = num;\n            }\n        }\n        // if min_num == max_num:\n        if (minNum == maxNum) {\n            // return [0.0] * len(numbers)\n            var result = new ArrayList<Double>();\n            for (int i = 0; i < numbers.size(); i++) {\n                result.add(0.0);\n            }\n            return result;\n        } else {\n            // return [(num - min_num) / (max_num - min_num) for num in numbers]\n            var result = new ArrayList<Double>();\n            for (Double num : numbers) {\n                result.add((num - minNum) / (maxNum - minNum));\n            }\n            return result;\n        }\n    }\n}\n",
            "class Global {\n    public static List<Integer> filterIntegers(List<Object> values) {\n        // return [x for x in values if isinstance(x, int)]\n        return values.stream().filter(x -> x instanceof Integer).map(x -> (Integer) x).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static int strLength(String s) {\n        // return len(s)\n        return s.length();\n    }\n}\n",
            "class Global {\n    public static int largestDivisor(int n) {\n        // for i in range(2, n):\n        for (int i = 2; i < n; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return n // i\n                return n / i;\n            }\n        }\n        // return 1\n        return 1;\n    }\n}\n",
            "class Global {\n    public static List<Integer> factorize(int n) {\n        // factors = []\n        var factors = new ArrayList<Integer>();\n        // divisor = 2\n        int divisor = 2;\n        // while divisor <= n:\n        while (divisor <= n) {\n            // if n % divisor == 0:\n            if (n % divisor == 0) {\n                // factors.append(divisor)\n                factors.add(divisor);\n                // n //= divisor\n                n /= divisor;\n            } else {\n                // divisor += 1\n                divisor++;\n            }\n        }\n        // return factors\n        return factors;\n    }\n}\n",
            "class Global {\n    public static List<Integer> removeDuplicates(List<Integer> numbers) {\n        // counts = {}\n        var counts = new HashMap<Integer, Integer>();\n        // for num in numbers:\n        for (Integer num : numbers) {\n            // counts[num] = counts.get(num, 0) + 1\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\n        }\n        // res = [num for num in numbers if counts[num] == 1]\n        var res = new ArrayList<Integer>();\n        for (Integer num : numbers) {\n            if (counts.get(num) == 1) {\n                res.add(num);\n            }\n        }\n        // return res\n        return res;\n    }\n}\n",
            "class Global {\n    public static String flipCase(String s) {\n        // flipped = []\n        var flipped = new ArrayList<Character>();\n        // for ch in s:\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            // if not ch.isalpha():\n            if (!Character.isAlphabetic(ch)) {\n                // flipped.append(ch)\n                flipped.add(ch);\n            }\n            // elif ch.islower():\n            else if (Character.isLowerCase(ch)) {\n                // flipped.append(ch.upper())\n                flipped.add(Character.toUpperCase(ch));\n            }\n            // elif ch.isupper():\n            else if (Character.isUpperCase(ch)) {\n                // flipped.append(ch.lower())\n                flipped.add(Character.toLowerCase(ch));\n            }\n        }\n        // return ''.join(flipped)\n        return String.join(\"\", flipped);\n    }\n}\n",
            "class Global {\n    public static String concatenate(List<String> strs) {\n        // return \"\".join(strs)\n        return String.join(\"\", strs);\n    }\n}\n",
            "class Global {\n    public static List<String> filterByPrefix(List<String> strs, String prefixStr) {\n        // return [s for s in strs if s.startswith(prefix_str)]\n        return strs.stream().filter(s -> s.startsWith(prefixStr)).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static List<Integer> getPositive(List<Integer> l) {\n        // return [num for num in l if num > 0]\n        return l.stream().filter(num -> num > 0).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static boolean isPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= Math.floor(Math.sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n}\n",
            "class Global {\n    public static double poly(List<Integer> xs, double x) {\n        // res = 0.0\n        double res = 0.0;\n        // for i in range(len(xs)):\n        for (int i = 0; i < xs.size(); i++) {\n            // res += xs[i] * x**i\n            res += xs.get(i) * Math.pow(x, i);\n        }\n        // return res\n        return res;\n    }\n    public static double findZero(List<Integer> xs) {\n        // x1, x2 = 1.0, -1.0\n        double x1 = 1.0, x2 = -1.0;\n        // while poly(xs, x1) * poly(xs, x2) > 0:\n        while (poly(xs, x1) * poly(xs, x2) > 0) {\n            // x1 *= 2\n            x1 *= 2;\n            // x2 *= 2\n            x2 *= 2;\n        }\n        // while abs(x1 - x2) > 1e-10:\n        while (Math.abs(x1 - x2) > 1e-10) {\n            // mid = (x1 + x2) / 2\n            double mid = (x1 + x2) / 2;\n            // if poly(xs, mid) == 0:\n            if (poly(xs, mid) == 0) {\n                // return mid\n                return mid;\n            }\n            // elif poly(xs, mid) * poly(xs, x1) < 0:\n            else if (poly(xs, mid) * poly(xs, x1) < 0) {\n                // x2 = mid\n                x2 = mid;\n            }\n            // else:\n            else {\n                // x1 = mid\n                x1 = mid;\n            }\n        }\n        // return (x1 + x2) / 2\n        return (x1 + x2) / 2;\n    }\n}\n",
            "class Global {\n    public static List<Integer> sortThird(List<Integer> l) {\n        // sorted_third = sorted(l[::3])\n        var sortedThird = new ArrayList<Integer>();\n        for (int i = 0; i < l.size(); i += 3) {\n            sortedThird.add(l.get(i));\n        }\n        Collections.sort(sortedThird);\n        // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n        var result = new ArrayList<Integer>();\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                result.add(sortedThird.get(i / 3));\n            } else {\n                result.add(l.get(i));\n            }\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static List<Integer> listUnique(List<Integer> l) {\n        // return sorted(list(set(l)))\n        return new ArrayList<>(new TreeSet<>(l));\n    }\n}\n",
            "class Global {\n    public static int maxElement(List<Integer> l) {\n        // if not l:\n        if (l.isEmpty()) {\n            // return 0\n            return 0;\n        }\n        // return max(l)\n        return Collections.max(l);\n    }\n}\n",
            "class Global {\n    public static int fizzBuzz(int n) {\n        // cnt = 0\n        int cnt = 0;\n        // for i in range(n):\n        for (int i = 0; i < n; i++) {\n            // if i % 11 == 0 or i % 13 == 0:\n            if (i % 11 == 0 || i % 13 == 0) {\n                // cnt += str(i).count(\"7\")\n                cnt += String.valueOf(i).chars().filter(c -> c == '7').count();\n            }\n        }\n        // return cnt\n        return cnt;\n    }\n}\n",
            "class Global {\n    public static List<Integer> sortEven(List<Integer> l) {\n        // sorted_even = sorted(l[::2])\n        var sortedEven = new ArrayList<Integer>(l.size() / 2);\n        for (int i = 0; i < l.size(); i += 2) {\n            sortedEven.add(l.get(i));\n        }\n        Collections.sort(sortedEven);\n        // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n        var result = new ArrayList<Integer>(l.size());\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                result.add(sortedEven.get(i / 2));\n            } else {\n                result.add(l.get(i));\n            }\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static String encodeCyclic(String s) {\n        // result = []\n        var result = new ArrayList<String>();\n        // for i in range(0, len(s), 3):\n        for (int i = 0; i < s.length(); i += 3) {\n            // if i + 3 > len(s):\n            if (i + 3 > s.length()) {\n                // result.append(s[i:])\n                result.add(s.substring(i));\n            } else {\n                // result.append(s[i+1:i+3])\n                result.add(s.substring(i + 1, i + 3));\n                // result.append(s[i])\n                result.add(s.substring(i, i + 1));\n            }\n        }\n        // return \"\".join(result)\n        return String.join(\"\", result);\n    }\n    public static String decodeCyclic(String s) {\n        return encodeCyclic(encodeCyclic(s));\n    }\n}\n",
            "class Global {\n    public static boolean isPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= Math.floor(Math.sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static int primeFib(int n) {\n        // f = [0, 1]\n        var f = new int[] { 0, 1 };\n        // cnt = 0\n        int cnt = 0;\n        // while cnt < n:\n        while (cnt < n) {\n            // f = [f[1], f[0] + f[1]]\n            f = new int[] { f[1], f[0] + f[1] };\n            // if is_prime(f[1]):\n            if (isPrime(f[1])) {\n                // cnt += 1\n                cnt++;\n            }\n        }\n        // return f[1]\n        return f[1];\n    }\n}\n",
            "class Global {\n    public static boolean triplesSumToZero(List<Integer> l) {\n        // for i in range(len(l)):\n        for (int i = 0; i < l.size(); i++) {\n            // for j in range(i + 1, len(l)):\n            for (int j = i + 1; j < l.size(); j++) {\n                // for k in range(j + 1, len(l)):\n                for (int k = j + 1; k < l.size(); k++) {\n                    // if l[i] + l[j] + l[k] == 0:\n                    if (l.get(i) + l.get(j) + l.get(k) == 0) {\n                        // return True\n                        return true;\n                    }\n                }\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static int carRaceCollision(int n) {\n        // return n ** 2\n        return (int) Math.pow(n, 2);\n    }\n}\n",
            "class Global {\n    public static List<Integer> incrList(List<Integer> l) {\n        // return [i + 1 for i in l]\n        return l.stream().map(i -> i + 1).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static boolean pairsSumToZero(List<Integer> l) {\n        // seen = set()\n        var seen = new HashSet<Integer>();\n        // for num in l:\n        for (Integer num : l) {\n            // if -num in seen:\n            if (seen.contains(-num)) {\n                // return True\n                return true;\n            }\n            // seen.add(num)\n            seen.add(num);\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static String changeBase(int x, int bas) {\n        // if x == 0:\n        if (x == 0) {\n            // return \"0\"\n            return \"0\";\n        }\n        // digits = []\n        var digits = new ArrayList<String>();\n        // while x > 0:\n        while (x > 0) {\n            // digits.append(str(x % bas))\n            digits.add(String.valueOf(x % bas));\n            // x //= bas\n            x /= bas;\n        }\n        // return \"\".join(digits[::-1])\n        return String.join(\"\", digits.subList(0, digits.size()).reverse());\n    }\n}\n",
            "class Global {\n    public static double triangleArea(int a, int h) {\n        // return a * h / 2\n        return a * h / 2.0;\n    }\n}\n",
            "class Global {\n    public static int fib4(int n) {\n        // fib = [0, 0, 2, 0]\n        var fib = new int[] { 0, 0, 2, 0 };\n        // for i in range(4, n + 1):\n        for (int i = 4; i <= n; i++) {\n            // fib[i % 4] = sum(fib)\n            fib[i % 4] = fib[0] + fib[1] + fib[2];\n        }\n        // return fib[n % 4]\n        return fib[n % 4];\n    }\n}\n",
            "class Global {\n    public static double median(List<Double> l) {\n        // sl = sorted(l)\n        var sl = new ArrayList<Double>(l);\n        Collections.sort(sl);\n        // if len(l) % 2 != 0:\n        if (l.size() % 2 != 0) {\n            // return sl[len(l) // 2]\n            return sl.get(l.size() / 2);\n        } else {\n            // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n            return (sl.get(l.size() / 2) + sl.get(l.size() / 2 - 1)) / 2;\n        }\n    }\n}\n",
            "class Global {\n    public static boolean isPalindrome(String txt) {\n        // return txt == txt[::-1]\n        return txt.equals(new StringBuilder(txt).reverse().toString());\n    }\n}\n",
            "class Global {\n    public static int modp(int n, int p) {\n        // ret = 1\n        int ret = 1;\n        // for _ in range(n):\n        for (int _ = 0; _ < n; _++) {\n            // ret = (ret * 2) % p\n            ret = (ret * 2) % p;\n        }\n        // return ret\n        return ret;\n    }\n}\n",
            "class Global {\n    public static String encodeShift(String s) {\n        // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n        var result = new ArrayList<Character>();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            result.add((char) (((ch - 97 + 5) % 26) + 97));\n        }\n        // return \"\".join(result)\n        return String.join(\"\", result);\n    }\n    public static String decodeShift(String s) {\n        // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n        var result = new ArrayList<Character>();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            result.add((char) (((ch - 97 + 21) % 26) + 97));\n        }\n        // return \"\".join(result)\n        return String.join(\"\", result);\n    }\n}\n",
            "class Global {\n    public static String removeVowels(String txt) {\n        // vowels = \"aeiouAEIOU\"\n        String vowels = \"aeiouAEIOU\";\n        // return \"\".join([char for char in txt if char not in vowels])\n        return String.join(\"\", txt.chars().filter(c -> !vowels.contains(String.valueOf((char) c))).mapToObj(c -> String.valueOf((char) c)).toArray(String[]::new));\n    }\n}\n",
            "class Global {\n    public static boolean belowThreshold(List<Integer> l, int t) {\n        // return all(x < t for x in l)\n        for (Integer x : l) {\n            if (x >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
            "class Global {\n    public static int add(int x, int y) {\n        // return x + y\n        return x + y;\n    }\n}\n",
            "class Global {\n    public static boolean sameChars(String s0, String s1) {\n        // return set(s0) == set(s1)\n        return new HashSet<>(s0.toCharArray()).equals(new HashSet<>(s1.toCharArray()));\n    }\n}\n",
            "class Global {\n    public static int fib(int n) {\n        // if n <= 1:\n        if (n <= 1) {\n            // return n\n            return n;\n        } else {\n            // return fib(n - 1) + fib(n - 2)\n            return fib(n - 1) + fib(n - 2);\n        }\n    }\n}\n",
            "class Global {\n    public static boolean correctBracketing(String brackets) {\n        // depth = 0\n        int depth = 0;\n        // for b in brackets:\n        for (int i = 0; i < brackets.length(); i++) {\n            // b = brackets[i]\n            char b = brackets.charAt(i);\n            // if b == \"<\":\n            if (b == '<') {\n                // depth += 1\n                depth++;\n            }\n            // elif b == \">\":\n            else if (b == '>') {\n                // depth -= 1\n                depth--;\n            }\n            // if depth < 0:\n            if (depth < 0) {\n                // return False\n                return false;\n            }\n        }\n        // return depth == 0\n        return depth == 0;\n    }\n}\n",
            "class Global {\n    public static boolean monotonic(List<Integer> l) {\n        // diff = [y - x for x, y in zip(l, l[1:])]\n        var diff = new ArrayList<Integer>();\n        for (int i = 0; i < l.size() - 1; i++) {\n            diff.add(l.get(i + 1) - l.get(i));\n        }\n        // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n        return diff.stream().allMatch(x -> x <= 0) || diff.stream().allMatch(x -> x >= 0);\n    }\n}\n",
            "class Global {\n    public static List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // return sorted(list(set(l1) & set(l2)))\n        return new ArrayList<>(new TreeSet<>(l1).retainAll(new TreeSet<>(l2)));\n    }\n}\n",
            "class Global {\n    public static int largestPrimeFactor(int n) {\n        // i = 2\n        int i = 2;\n        // while i * i <= n:\n        while (i * i <= n) {\n            // if n % i:\n            if (n % i != 0) {\n                // i += 1\n                i += 1;\n            } else {\n                // n //= i\n                n /= i;\n            }\n        }\n        // return n\n        return n;\n    }\n}\n",
            "class Global {\n    public static int sumToN(int n) {\n        // return sum(range(n + 1))\n        return IntStream.rangeClosed(1, n).sum();\n    }\n}\n",
            "class Global {\n    public static boolean correctBracketing(String brackets) {\n        // depth = 0\n        int depth = 0;\n        // for b in brackets:\n        for (char b : brackets.toCharArray()) {\n            // if b == \"(\":\n            if (b == '(') {\n                // depth += 1\n                depth += 1;\n            }\n            // elif b == \")\":\n            else if (b == ')') {\n                // depth -= 1\n                depth -= 1;\n            }\n            // if depth < 0:\n            if (depth < 0) {\n                // return False\n                return false;\n            }\n        }\n        // return depth == 0\n        return depth == 0;\n    }\n}\n",
            "class Global {\n    public static List<Integer> derivative(List<Integer> xs) {\n        // return [xs[i] * i for i in range(1, len(xs))]\n        var result = new ArrayList<Integer>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static int fibfib(int n) {\n        // if n <= 1:\n        if (n <= 1) {\n            // return 0 \n            return 0;\n        }\n        // a, b, c = 0, 0, 1\n        int a = 0, b = 0, c = 1;\n        // while n > 2:\n        while (n > 2) {\n            // a, b, c = b, c, a + b + c\n            a = b;\n            b = c;\n            c = a + b + c;\n            // n -= 1\n            n -= 1;\n        }\n        // return c\n        return c;\n    }\n}\n",
            "class Global {\n    public static int vowelsCount(String s) {\n        // vowels = \"aeiou\"\n        String vowels = \"aeiou\";\n        // cnt = 0\n        int cnt = 0;\n        // for i in range(len(s)):\n        for (int i = 0; i < s.length(); i++) {\n            // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n            if (vowels.indexOf(s.charAt(i)) >= 0 || (i == s.length() - 1 && s.charAt(i) == 'y')) {\n                // cnt += 1\n                cnt += 1;\n            }\n        }\n        // return cnt\n        return cnt;\n    }\n}\n",
            "class Global {\n    public static String circularShift(int x, int shift) {\n        // x_str = str(x)\n        String x_str = String.valueOf(x);\n        // if shift > len(x_str):\n        if (shift > x_str.length()) {\n            // return x_str[::-1]\n            return new StringBuilder(x_str).reverse().toString();\n        } else {\n            // return x_str[-shift:] + x_str[:-shift]\n            return x_str.substring(x_str.length() - shift) + x_str.substring(0, x_str.length() - shift);\n        }\n    }\n}\n",
            "class Global {\n    public static int digitSum(String s) {\n        // return sum(ord(c) for c in s if c.isupper())\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                sum += (int) c;\n            }\n        }\n        return sum;\n    }\n}\n",
            "class Global {\n    public static int fruitDistribution(String s, int n) {\n        // words = s.split(' ')\n        var words = s.split(\" \");\n        // apples = int(words[words.index(\"apples\") - 1])\n        var apples = Integer.parseInt(words[words.indexOf(\"apples\") - 1]);\n        // oranges = int(words[words.index(\"oranges\") - 1])\n        var oranges = Integer.parseInt(words[words.indexOf(\"oranges\") - 1]);\n        // return n - apples - oranges\n        return n - apples - oranges;\n    }\n}\n",
            "class Global {\n    public static List<Integer> pluck(List<Integer> arr) {\n        // evens = [n for n in arr if n % 2 == 0]\n        var evens = new ArrayList<Integer>();\n        for (Integer n : arr) {\n            if (n % 2 == 0) {\n                evens.add(n);\n            }\n        }\n        // if len(evens) == 0:\n        if (evens.size() == 0) {\n            // return []\n            return new ArrayList<Integer>();\n        }\n        // min_even = min(evens)\n        var min_even = Collections.min(evens);\n        // return [min_even, arr.index(min_even)]\n        return Arrays.asList(min_even, arr.indexOf(min_even));\n    }\n}\n",
            "class Global {\n    public static int search(List<Integer> lst) {\n        // freqs = {}\n        var freqs = new HashMap<Integer, Integer>();\n        // for n in lst:\n        for (Integer n : lst) {\n            // freqs[n] = freqs.get(n, 0) + 1\n            freqs.put(n, freqs.getOrDefault(n, 0) + 1);\n        }\n        // good_vals = [k for k, v in freqs.items() if v >= k]\n        var goodVals = new ArrayList<Integer>();\n        for (Map.Entry<Integer, Integer> entry : freqs.entrySet()) {\n            if (entry.getValue() >= entry.getKey()) {\n                goodVals.add(entry.getKey());\n            }\n        }\n        // return max(good_vals, default=-1)\n        return Collections.max(goodVals, (a, b) -> a - b);\n    }\n}\n",
            "class Global {\n    public static List<Integer> strangeSortList(List<Integer> lst) {\n        // sl = sorted(lst)\n        var sl = new ArrayList<Integer>(lst);\n        Collections.sort(sl);\n        // result = []\n        var result = new ArrayList<Integer>();\n        // left, right = 0, len(sl) - 1\n        int left = 0, right = sl.size() - 1;\n        // while left <= right:\n        while (left <= right) {\n            // result.append(sl[left])\n            result.add(sl.get(left));\n            // left += 1\n            left += 1;\n            // if left <= right:\n            if (left <= right) {\n                // result.append(sl[right])\n                result.add(sl.get(right));\n                // right -= 1\n                right -= 1;\n            }\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static double triangleArea(int a, int b, int c) {\n        // if a + b > c and a + c > b and b + c > a:\n        if (a + b > c && a + c > b && b + c > a) {\n            // s = (a + b + c) / 2.0\n            double s = (a + b + c) / 2.0;\n            // return sqrt(s * (s - a) * (s - b) * (s - c))\n            return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        } else {\n            // return -1.0\n            return -1.0;\n        }\n    }\n}\n",
            "class Global {\n    public static boolean willItFly(List<Integer> q, int w) {\n        // if len(q) == 0:\n        if (q.size() == 0) {\n            // return False\n            return false;\n        }\n        // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n        boolean isPalin = true;\n        for (int i = 0; i < q.size(); i++) {\n            if (q.get(i) != q.get(q.size() - i - 1)) {\n                isPalin = false;\n                break;\n            }\n        }\n        // total = sum(q)\n        int total = 0;\n        for (int e : q) {\n            total += e;\n        }\n        // return is_palin and total <= w\n        return isPalin && total <= w;\n    }\n}\n",
            "class Global {\n    public static int smallestChange(List<Integer> arr) {\n        // ans = 0\n        int ans = 0;\n        // for i in range(len(arr) // 2):\n        for (int i = 0; i < arr.size() / 2; i++) {\n            // if arr[i] != arr[len(arr) - i - 1]:\n            if (!arr.get(i).equals(arr.get(arr.size() - i - 1))) {\n                // ans += 1\n                ans += 1;\n            }\n        }\n        // return ans\n        return ans;\n    }\n}\n",
            "class Global {\n    public static List<String> totalMatch(List<String> lst1, List<String> lst2) {\n        // cnt1 = sum(len(s) for s in lst1)\n        int cnt1 = 0;\n        for (String s : lst1) {\n            cnt1 += s.length();\n        }\n        // cnt2 = sum(len(s) for s in lst2)\n        int cnt2 = 0;\n        for (String s : lst2) {\n            cnt2 += s.length();\n        }\n        // return lst1 if cnt1 <= cnt2 else lst2\n        return cnt1 <= cnt2 ? lst1 : lst2;\n    }\n}\n",
            "class Global {\n    public static boolean isPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= (int) Math.floor(Math.sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static boolean isMultiplyPrime(int a) {\n        // cnt = 0\n        int cnt = 0;\n        // for i in range(2, a + 1):\n        for (int i = 2; i <= a + 1; i++) {\n            // if is_prime(i):\n            if (isPrime(i)) {\n                // while a % i == 0:\n                while (a % i == 0) {\n                    // cnt += 1\n                    cnt += 1;\n                    // a /= i\n                    a /= i;\n                }\n            }\n        }\n        // return cnt == 3\n        return cnt == 3;\n    }\n}\n",
            "class Global {\n    public static boolean isSimplePower(int x, int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return x == n\n            return x == n;\n        }\n        // tmp = 1\n        int tmp = 1;\n        // while tmp < x:\n        while (tmp < x) {\n            // tmp *= n\n            tmp *= n;\n        }\n        // return tmp == x\n        return tmp == x;\n    }\n}\n",
            "class Global {\n    public static boolean isCube(int a) {\n        // a = abs(a)\n        a = Math.abs(a);\n        // root = int(round(pow(a, 1.0 / 3.0)))\n        int root = (int) Math.round(Math.pow(a, 1.0 / 3.0));\n        // return root * root * root == a\n        return root * root * root == a;\n    }\n}\n",
            "class Global {\n    public static int hexKey(String num) {\n        // return len([x for x in num if x in \"2357BD\"])\n        return (int) num.chars().filter(x -> \"2357BD\".indexOf(x) != -1).count();\n    }\n}\n",
            "class Global {\n    public static String decimalToBinary(int dec) {\n        // binary = bin(dec)[2:]\n        var binary = Integer.toBinaryString(dec);\n        // return f\"db{binary}db\"\n        return \"db\" + binary + \"db\";\n    }\n}\n",
            "class Global {\n    public static boolean isHappy(String s) {\n        // if len(s) < 3:\n        if (s.length() < 3) {\n            // return False\n            return false;\n        }\n        // for i in range(len(s) - 2):\n        for (int i = 0; i < s.length() - 2; i++) {\n            // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i) == s.charAt(i + 2) || s.charAt(i + 1) == s.charAt(i + 2)) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n}\n",
            "class Global {\n    public static List<String> numericalLetterGrade(List<Float> grades) {\n        // result = []\n        var result = new ArrayList<String>();\n        // for g in grades:\n        for (Float g : grades) {\n            // if g == 4.0:\n            if (g == 4.0) {\n                // result.append(\"A+\")\n                result.add(\"A+\");\n            }\n            // elif g > 3.7:\n            else if (g > 3.7) {\n                // result.append(\"A\")\n                result.add(\"A\");\n            }\n            // elif g > 3.3:\n            else if (g > 3.3) {\n                // result.append(\"A-\")\n                result.add(\"A-\");\n            }\n            // elif g > 3.0:\n            else if (g > 3.0) {\n                // result.append(\"B+\")\n                result.add(\"B+\");\n            }\n            // elif g > 2.7:\n            else if (g > 2.7) {\n                // result.append(\"B\")\n                result.add(\"B\");\n            }\n            // elif g > 2.3:\n            else if (g > 2.3) {\n                // result.append(\"B-\")\n                result.add(\"B-\");\n            }\n            // elif g > 2.0:\n            else if (g > 2.0) {\n                // result.append(\"C+\")\n                result.add(\"C+\");\n            }\n            // elif g > 1.7:\n            else if (g > 1.7) {\n                // result.append(\"C\")\n                result.add(\"C\");\n            }\n            // elif g > 1.3:\n            else if (g > 1.3) {\n                // result.append(\"C-\")\n                result.add(\"C-\");\n            }\n            // elif g > 1.0:\n            else if (g > 1.0) {\n                // result.append(\"D+\")\n                result.add(\"D+\");\n            }\n            // elif g > 0.7:\n            else if (g > 0.7) {\n                // result.append(\"D\")\n                result.add(\"D\");\n            }\n            // elif g > 0.0:\n            else if (g > 0.0) {\n                // result.append(\"D-\")\n                result.add(\"D-\");\n            }\n            // else:\n            else {\n                // result.append(\"E\")\n                result.add(\"E\");\n            }\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static boolean primeLength(String s) {\n        // length = len(s)\n        int length = s.length();\n        // if length < 2:\n        if (length < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(length)) + 1):\n        for (int i = 2; i <= Math.floor(Math.sqrt(length)) + 1; i++) {\n            // if length % i == 0:\n            if (length % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n}\n",
            "class Global {\n    public static int startsOneEnds(int n) {\n        // if n == 1:\n        if (n == 1) {\n            // return 1\n            return 1;\n        }\n        // return 2 * 9 * (10 ** (n - 2))\n        return 2 * 9 * (int) Math.pow(10, n - 2);\n    }\n}\n",
            "class Global {\n    public static String solve(int n) {\n        // digits_sum = sum(int(d) for d in str(n))\n        int digitsSum = 0;\n        for (char d : String.valueOf(n).toCharArray()) {\n            digitsSum += Integer.parseInt(String.valueOf(d));\n        }\n        // return bin(digits_sum)[2:]\n        return Integer.toBinaryString(digitsSum).substring(2);\n    }\n}\n",
            "class Global {\n    public static int add(List<Integer> lst) {\n        // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n        return lst.stream().filter(x -> (x % 2 == 0) && (x % 2 == 1)).mapToInt(x -> x).sum();\n    }\n}\n",
            "class Global {\n    public static String antiShuffle(String s) {\n        // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n        var words = new ArrayList<String>();\n        for (String word : s.split(\" \")) {\n            words.add(\"\".join(sorted(word.split(\"\"))));\n        }\n        // return \" \".join(words)\n        return String.join(\" \", words);\n    }\n}\n",
            "class Global {\n    public static List<List<Integer>> getRow(List<List<Integer>> lst, int x) {\n        // coords = []\n        var coords = new ArrayList<List<Integer>>();\n        // for i in range(len(lst)):\n        for (int i = 0; i < lst.size(); i++) {\n            // for j in range(len(lst[i])):\n            for (int j = 0; j < lst.get(i).size(); j++) {\n                // if lst[i][j] == x:\n                if (lst.get(i).get(j) == x) {\n                    // coords.append([i, j])\n                    coords.add(Arrays.asList(i, j));\n                }\n            }\n        }\n        // return sorted(coords, key=lambda a: (a[0], -a[1]))\n        return coords.stream().sorted(Comparator.comparing(a -> a.get(0)).thenComparing(a -> -a.get(1))).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static List<Integer> sortArray(List<Integer> arr) {\n        // if len(arr) == 0:\n        if (arr.size() == 0) {\n            // return []\n            return new ArrayList<Integer>();\n        }\n        // if (arr[0] + arr[-1]) % 2 == 0:\n        if ((arr.get(0) + arr.get(arr.size() - 1)) % 2 == 0) {\n            // return sorted(arr, reverse=True)\n            return new ArrayList<Integer>(arr);\n        } else {\n            // return sorted(arr)\n            return new ArrayList<Integer>(arr);\n        }\n    }\n}\n",
            "class Global {\n    public static String encrypt(String s) {\n        // result = []\n        var result = new ArrayList<Character>();\n        // for ch in s:\n        for (Character ch : s.toCharArray()) {\n            // shifted = ord(ch) + 4\n            int shifted = (int) ch + 4;\n            // if shifted > ord('z'):\n            if (shifted > 'z') {\n                // shifted -= 26\n                shifted -= 26;\n            }\n            // result.append(chr(shifted))\n            result.add((char) shifted);\n        }\n        // return \"\".join(result)\n        return String.join(\"\", result);\n    }\n}\n",
            "class Global {\n    public static Optional<Integer> nextSmallest(List<Integer> lst) {\n        // sl = sorted(set(lst))\n        var sl = new ArrayList<Integer>(new HashSet<>(lst));\n        Collections.sort(sl);\n        // if len(sl) < 2:\n        if (sl.size() < 2) {\n            // return None\n            return Optional.empty();\n        }\n        // return sl[1]\n        return Optional.of(sl.get(1));\n    }\n}\n",
            "class Global {\n    public static int isBored(String s) {\n        // sentences = re.split(r\"[.!?]\\s*\", s)\n        var sentences = Arrays.asList(s.split(\"[.!?]\\\\s*\"));\n        // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n        return (int) sentences.stream().filter(sentence -> sentence.length() >= 2).map(sentence -> sentence.substring(0, 2)).filter(sentence -> sentence.equals(\"I \")).count();\n    }\n}\n",
            "class Global {\n    public static boolean anyInt(Object x, Object y, Object z) {\n        // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            // if (x + y == z) or (x + z == y) or (y + z == x):\n            if (((Integer) x + (Integer) y == (Integer) z) || ((Integer) x + (Integer) z == (Integer) y) || ((Integer) y + (Integer) z == (Integer) x)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
            "class Global {\n    public static String encode(String message) {\n        // vowels = \"aeiouAEIOU\"\n        String vowels = \"aeiouAEIOU\";\n        // result = []\n        var result = new ArrayList<Character>();\n        // for ch in message:\n        for (char ch : message.toCharArray()) {\n            // if ch.isalpha():\n            if (Character.isAlphabetic(ch)) {\n                // ch1 = ch.upper() if ch.islower() else ch.lower()\n                char ch1 = Character.isLowerCase(ch) ? Character.toUpperCase(ch) : Character.toLowerCase(ch);\n                // if ch1 in vowels:\n                if (vowels.indexOf(ch1) >= 0) {\n                    // ch1 = chr(ord(ch1) + 2)\n                    ch1 = (char) (ch1 + 2);\n                }\n                // result.append(ch1)\n                result.add(ch1);\n            } else {\n                // result.append(ch)\n                result.add(ch);\n            }\n        }\n        // return \"\".join(result)\n        return String.join(\"\", result);\n    }\n}\n",
            "class Global {\n    public static boolean isPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= Math.floor(Math.sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static int skjkasdkd(List<Integer> lst) {\n        // primes = [n for n in lst if is_prime(n)]\n        var primes = new ArrayList<Integer>();\n        for (Integer n : lst) {\n            if (isPrime(n)) {\n                primes.add(n);\n            }\n        }\n        // if len(primes) == 0:\n        if (primes.size() == 0) {\n            // return 0\n            return 0;\n        }\n        // largest = str(max(primes))\n        var largest = String.valueOf(Collections.max(primes));\n        // return sum(int(digit) for digit in largest)\n        return largest.chars().map(c -> (int) c).sum();\n    }\n}\n",
            "class Global {\n    public static boolean checkDictCase(Map<String, String> d) {\n        // if not d:\n        if (d == null || d.isEmpty()) {\n            // return False\n            return false;\n        }\n        // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n        return d.keySet().stream().allMatch(c -> c.toLowerCase().equals(c)) || d.keySet().stream().allMatch(c -> c.toUpperCase().equals(c));\n    }\n}\n",
            "class Global {\n    public static List<Integer> countUpTo(int n) {\n        // primes = []\n        var primes = new ArrayList<Integer>();\n        // for num in range(2, n):\n        for (int num = 2; num < n; num++) {\n            // if all(num % p != 0 for p in primes):\n            if (primes.stream().allMatch(p -> num % p != 0)) {\n                // primes.append(num)\n                primes.add(num);\n            }\n        }\n        // return primes\n        return primes;\n    }\n}\n",
            "class Global {\n    public static int multiply(int a, int b) {\n        // return (abs(a) % 10) * (abs(b) % 10)\n        return Math.abs(a) % 10 * Math.abs(b) % 10;\n    }\n}\n",
            "class Global {\n    public static int countUpper(String s) {\n        // vowels = \"AEIOU\"\n        var vowels = \"AEIOU\";\n        // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n        return (int) s.chars().filter(c -> c % 2 == 0 && vowels.indexOf(c) != -1).count();\n    }\n}\n",
            "class Global {\n    public static int closestInteger(String value) {\n        // num = float(value)\n        double num = Double.parseDouble(value);\n        // if num >= 0:\n        if (num >= 0) {\n            // return int(num + 0.5)\n            return (int) (num + 0.5);\n        } else {\n            // return int(num - 0.5)\n            return (int) (num - 0.5);\n        }\n    }\n}\n",
            "class Global {\n    public static List<Integer> makeAPile(int n) {\n        // return [n + 2 * i for i in range(n)]\n        var result = new ArrayList<Integer>();\n        for (int i = 0; i < n; i++) {\n            result.add(n + 2 * i);\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static List<String> wordsString(String s) {\n        // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n        return Arrays.stream(s.split(\"[, ]\"))\n            .filter(w -> w.length() > 0)\n            .collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static int chooseNum(int x, int y) {\n        // if x > y:\n        if (x > y) {\n            // return -1\n            return -1;\n        }\n        // if y % 2 == 0:\n        if (y % 2 == 0) {\n            // return y\n            return y;\n        }\n        // return y - 1 if x != y else -1\n        return x != y ? y - 1 : -1;\n    }\n}\n",
            "class Global {\n    public static Optional<String> roundedAvg(int n, int m) {\n        // if n > m:\n        if (n > m) {\n            // return None\n            return Optional.empty();\n        }\n        // r_avg = int((m + n) / 2.0 + 0.5)\n        int r_avg = (int) Math.round((m + n) / 2.0 + 0.5);\n        // return bin(r_avg)[2:]\n        return Optional.of(Integer.toBinaryString(r_avg).substring(2));\n    }\n}\n",
            "class Global {\n    public static boolean allDigitsOdd(String s) {\n        // return all(ord(digit) % 2 != 0 for digit in s)\n        for (char digit : s.toCharArray()) {\n            if (digit % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static List<Integer> uniqueDigits(List<Integer> x) {\n        // return sorted([num for num in x if all_digits_odd(str(num))])\n        var result = new ArrayList<Integer>();\n        for (Integer num : x) {\n            if (allDigitsOdd(String.valueOf(num))) {\n                result.add(num);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n}\n",
            "class Global {\n    public static List<String> byLength(List<Integer> arr) {\n        // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        var digitNames = new String[] {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n        var sortedArr = new ArrayList<Integer>();\n        for (Integer x : arr) {\n            if (1 <= x && x <= 9) {\n                sortedArr.add(x);\n            }\n        }\n        Collections.sort(sortedArr, Collections.reverseOrder());\n        // return [digit_names[x-1] for x in sorted_arr]\n        var result = new ArrayList<String>();\n        for (Integer x : sortedArr) {\n            result.add(digitNames[x-1]);\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static List<Integer> f(int n) {\n        // nums = list(range(1, n + 1))\n        var nums = new ArrayList<Integer>();\n        for (int i = 1; i <= n; i++) {\n            nums.add(i);\n        }\n        // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n        var result = new ArrayList<Integer>();\n        for (int i : nums) {\n            if (i % 2 != 0) {\n                result.add(sum(nums.subList(0, i)));\n            } else {\n                result.add(reduce(nums.subList(0, i)));\n            }\n        }\n        return result;\n    }\n    public static int sum(List<Integer> nums) {\n        int result = 0;\n        for (int i : nums) {\n            result += i;\n        }\n        return result;\n    }\n    public static int reduce(List<Integer> nums) {\n        int result = 1;\n        for (int i : nums) {\n            result *= i;\n        }\n        return result;\n    }\n}\n",
            "class Global {\n    public static boolean isPalindrome(String txt) {\n        // return txt == txt[::-1]\n        return txt.equals(new StringBuilder(txt).reverse().toString());\n    }\n    public static List<Integer> evenOddPalindrome(int n) {\n        // cnt = [0, 0]\n        var cnt = new int[2];\n        // for i in range(1, n + 1):\n        for (int i = 1; i <= n; i++) {\n            // if is_palindrome(str(i)):\n            if (isPalindrome(String.valueOf(i))) {\n                // cnt[i % 2] += 1\n                cnt[i % 2]++;\n            }\n        }\n        // return cnt\n        return Arrays.asList(cnt);\n    }\n}\n",
            "class Global {\n    public static int digitsSum(int n) {\n        // n_str = str(n)\n        var nStr = String.valueOf(n);\n        // if n >= 0:\n        if (n >= 0) {\n            // return sum(int(d) for d in n_str)\n            return Arrays.stream(nStr.split(\"\")).mapToInt(Integer::parseInt).sum();\n        } else {\n            // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n            return Integer.parseInt(nStr.substring(0, 2)) * 2 + digitsSum(Math.abs(n));\n        }\n    }\n    public static int countNums(List<Integer> arr) {\n        // return len([n for n in arr if digits_sum(n) > 0])\n        return (int) arr.stream().filter(n -> digitsSum(n) > 0).count();\n    }\n}\n",
            "class Global {\n    public static boolean moveOneBall(List<Integer> arr) {\n        // if len(arr) == 0:\n        if (arr.size() == 0) {\n            // return True\n            return true;\n        }\n        // sorted_arr = sorted(arr)\n        var sortedArr = new ArrayList<Integer>(arr);\n        Collections.sort(sortedArr);\n        // for i in range(0, len(arr)):\n        for (int i = 0; i < arr.size(); i++) {\n            // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n            if (arr.subList(i, arr.size()).equals(sortedArr.subList(0, arr.size() - i)) && arr.subList(0, i).equals(sortedArr.subList(arr.size() - i, arr.size()))) {\n                // return True\n                return true;\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static String canExchange(List<Integer> lst1, List<Integer> lst2) {\n        // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n        int odd_cnt = 0;\n        for (Integer num : lst1) {\n            if (num % 2 != 0) {\n                odd_cnt++;\n            }\n        }\n        // even_cnt = len([num for num in lst2 if num % 2 == 0])\n        int even_cnt = 0;\n        for (Integer num : lst2) {\n            if (num % 2 == 0) {\n                even_cnt++;\n            }\n        }\n        // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n        return even_cnt >= odd_cnt ? \"YES\" : \"NO\";\n    }\n}\n",
            "class Global {\n    public static Map<String, Integer> histogram(String test) {\n        // freq = {}\n        var freq = new HashMap<String, Integer>();\n        // words = [w for w in test.split(\" \") if len(w) > 0]\n        var words = Arrays.stream(test.split(\" \")).filter(w -> w.length() > 0).toArray(String[]::new);\n        // for w in words:\n        for (String w : words) {\n            // freq[w] = freq.get(w, 0) + 1\n            freq.put(w, freq.getOrDefault(w, 0) + 1);\n        }\n        // result = {}\n        var result = new HashMap<String, Integer>();\n        // if len(freq) > 0:\n        if (freq.size() > 0) {\n            // max_freq = max(freq.values())\n            var max_freq = Collections.max(freq.values());\n            // for k, v in freq.items():\n            for (Map.Entry<String, Integer> entry : freq.entrySet()) {\n                // if v == max_freq:\n                if (entry.getValue() == max_freq) {\n                    // result[k] = v\n                    result.put(entry.getKey(), entry.getValue());\n                }\n            }\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static boolean isPalindrome(String s) {\n        // return s == s[::-1]\n        return s.equals(new StringBuilder(s).reverse().toString());\n    }\n    public static List<String> reverseDelete(String s, String c) {\n        // s1 = \"\".join([ch for ch in s if ch not in c])\n        var s1 = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (c.indexOf(s.charAt(i)) == -1) {\n                s1.append(s.charAt(i));\n            }\n        }\n        // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n        return Arrays.asList(s1.toString(), isPalindrome(s1.toString()) ? \"yes\" : \"no\");\n    }\n}\n",
            "class Global {\n    public static List<String> oddCount(List<String> lst) {\n        // result = []\n        var result = new ArrayList<String>();\n        // for num in lst:\n        for (String num : lst) {\n            // n = sum(ord(d) % 2 == 1 for d in num)\n            int n = 0;\n            for (char d : num.toCharArray()) {\n                n += (d % 2 == 1) ? 1 : 0;\n            }\n            // rs = \"the number of odd elements in the string i of the input.\"\n            String rs = \"the number of odd elements in the string \" + n + \" of the input.\";\n            // result.append(rs.replace(\"i\", str(n)))\n            result.add(rs.replace(\"i\", String.valueOf(n)));\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static int minSubArraySum(List<Integer> nums) {\n        // min_sum = 0\n        int minSum = 0;\n        // cur_sum = 0\n        int curSum = 0;\n        // for n in nums:\n        for (Integer n : nums) {\n            // cur_sum = min(cur_sum + n, 0)\n            curSum = Math.min(curSum + n, 0);\n            // min_sum = min(cur_sum, min_sum)\n            minSum = Math.min(curSum, minSum);\n        }\n        // if min_sum == 0:\n        if (minSum == 0) {\n            // min_sum = min(nums)\n            minSum = Collections.min(nums);\n        }\n        // return min_sum\n        return minSum;\n    }\n}\n",
            "class Global {\n    public static int maxFill(List<List<Integer>> grid, int capacity) {\n        // return sum([ceil(sum(arr) / capacity) for arr in grid])\n        return (int) Math.ceil(grid.stream().mapToInt(arr -> sum(arr) / capacity).sum());\n    }\n}\n",
            "class Global {\n    public static int countOnes(int num) {\n        // return bin(num).count(\"1\")\n        return Integer.bitCount(num);\n    }\n    public static List<Integer> sortArray(List<Integer> arr) {\n        // return sorted(arr, key=lambda x: (count_ones(x), x))\n        return arr.stream().sorted(Comparator.comparing(Global::countOnes).thenComparing(Integer::compareTo)).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static List<String> selectWords(String s, int n) {\n        // consonants = \"bcdfghjklmnpqrstvwxyz\"\n        var consonants = \"bcdfghjklmnpqrstvwxyz\";\n        // words = [w for w in s.split(\" \") if len(w) > 0]\n        var words = new ArrayList<String>();\n        for (String w : s.split(\" \")) {\n            if (w.length() > 0) {\n                words.add(w);\n            }\n        }\n        // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n        return words.stream().filter(w -> {\n            return w.chars().filter(c -> {\n                return consonants.indexOf(Character.toLowerCase(c)) >= 0;\n            }).count() == n;\n        }).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static String getClosestVowel(String word) {\n        // vowels = \"aeiouAEIOU\"\n        String vowels = \"aeiouAEIOU\";\n        // for i in range(len(word) - 2, 0, -1):\n        for (int i = word.length() - 2; i >= 0; i--) {\n            // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            if (vowels.indexOf(word.charAt(i)) >= 0 && vowels.indexOf(word.charAt(i - 1)) < 0 && vowels.indexOf(word.charAt(i + 1)) < 0) {\n                // return word[i]\n                return String.valueOf(word.charAt(i));\n            }\n        }\n        // return \"\"\n        return \"\";\n    }\n}\n",
            "class Global {\n    public static boolean check(String s) {\n        // depth = 0\n        int depth = 0;\n        // for ch in s:\n        for (int i = 0; i < s.length(); i++) {\n            // if ch == \"(\":\n            if (s.charAt(i) == '(') {\n                // depth += 1\n                depth++;\n            } else {\n                // depth -= 1\n                depth--;\n            }\n            // if depth < 0:\n            if (depth < 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True if depth == 0 else False\n        return depth == 0;\n    }\n    public static String matchParens(List<String> lst) {\n        // s1 = lst[0] + lst[1]\n        String s1 = lst.get(0) + lst.get(1);\n        // s2 = lst[1] + lst[0]\n        String s2 = lst.get(1) + lst.get(0);\n        // return \"Yes\" if check(s1) or check(s2) else \"No\"\n        return check(s1) || check(s2) ? \"Yes\" : \"No\";\n    }\n}\n",
            "class Global {\n    public static List<Integer> maximum(List<Integer> arr, int k) {\n        // if k == 0:\n        if (k == 0) {\n            // return []\n            return new ArrayList<Integer>();\n        }\n        // return sorted(arr)[-k:]\n        return Arrays.stream(arr.toArray(new Integer[0])).sorted().limit(k).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static int solution(List<Integer> lst) {\n        // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n        return lst.stream().filter(x -> x % 2 != 0).filter(x -> x % 2 == 0).mapToInt(x -> x).sum();\n    }\n}\n",
            "class Global {\n    public static int addElements(List<Integer> arr, int k) {\n        // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n        return Arrays.stream(arr.subList(0, k).toArray(new Integer[0]))\n            .filter(n -> String.valueOf(n).length() <= 2)\n            .mapToInt(Integer::intValue)\n            .sum();\n    }\n}\n",
            "class Global {\n    public static List<Integer> getOddCollatz(int n) {\n        // collatz = [1]\n        var collatz = new ArrayList<Integer>();\n        collatz.add(1);\n        // while n != 1:\n        while (n != 1) {\n            // if n % 2 != 0:\n            if (n % 2 != 0) {\n                // collatz.append(n)\n                collatz.add(n);\n                // n = 3 * n + 1\n                n = 3 * n + 1;\n            } else {\n                // n = n // 2\n                n = n / 2;\n            }\n        }\n        // return sorted(collatz)\n        Collections.sort(collatz);\n        return collatz;\n    }\n}\n",
            "class Global {\n    public static boolean validDate(String date) {\n        // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n        if (date.length() != 10 || date.charAt(2) != '-' || date.charAt(5) != '-') {\n            return false;\n        }\n        // m = int(date[:2])\n        int m = Integer.parseInt(date.substring(0, 2));\n        // d = int(date[3:5])\n        int d = Integer.parseInt(date.substring(3, 5));\n        // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n        if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) {\n            if (d >= 1 && d <= 31) {\n                return true;\n            }\n        }\n        // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n        if (m == 4 || m == 6 || m == 9 || m == 11) {\n            if (d >= 1 && d <= 30) {\n                return true;\n            }\n        }\n        // if m == 2 and d >= 1 and d <= 29:\n        if (m == 2) {\n            if (d >= 1 && d <= 29) {\n                return true;\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static List<String> splitWords(String txt) {\n        // if \" \" in txt:\n        if (txt.contains(\" \")) {\n            // return txt.split(\" \")\n            return Arrays.asList(txt.split(\" \"));\n        }\n        // elif \",\" in txt:\n        else if (txt.contains(\",\")) {\n            // return txt.split(\",\")\n            return Arrays.asList(txt.split(\",\"));\n        }\n        // else:\n        else {\n            // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n            return Arrays.asList(String.valueOf(txt.chars().filter(c -> Character.isLowerCase(c) && c % 2 == 0).count()));\n        }\n    }\n}\n",
            "class Global {\n    public static boolean isSorted(List<Integer> lst) {\n        // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1) > lst.get(i)) {\n                return false;\n            }\n        }\n        // freq = {}\n        var freq = new HashMap<Integer, Integer>();\n        // for i in lst:\n        for (Integer i : lst) {\n            // freq[i] = freq.get(i, 0) + 1\n            freq.put(i, freq.getOrDefault(i, 0) + 1);\n        }\n        // return max(freq.values(), default=0) <= 2\n        return Collections.max(freq.values()) <= 2;\n    }\n}\n",
            "class Global {\n    public static boolean isPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= Math.floor(Math.sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static String intersection(List<Integer> interval1, List<Integer> interval2) {\n        // l = max(interval1[0], interval2[0])\n        int l = Math.max(interval1.get(0), interval2.get(0));\n        // r = min(interval1[1], interval2[1])\n        int r = Math.min(interval1.get(1), interval2.get(1));\n        // length = r - l\n        int length = r - l;\n        // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n        return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n    }\n}\n",
            "class Global {\n    public static Integer prodSigns(List<Integer> arr) {\n        // if not arr:\n        if (arr == null || arr.isEmpty()) {\n            // return None\n            return null;\n        }\n        // if 0 in arr:\n        if (arr.contains(0)) {\n            // return 0\n            return 0;\n        }\n        // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n        int sign = -1;\n        if (arr.stream().filter(n -> n < 0).count() % 2 == 1) {\n            sign = 1;\n        }\n        // return sign * sum([abs(n) for n in arr])\n        return sign * arr.stream().map(Math::abs).reduce(0, Integer::sum);\n    }\n}\n",
            "class Global {\n    public static List<Integer> minPath(List<List<Integer>> grid, int k) {\n        // n = len(grid)\n        int n = grid.size();\n        // min_val = n * n + 1\n        int min_val = n * n + 1;\n        // for i in range(n):\n        for (int i = 0; i < n; i++) {\n            // for j in range(n):\n            for (int j = 0; j < n; j++) {\n                // if grid[i][j] == 1:\n                if (grid.get(i).get(j) == 1) {\n                    // temp = []\n                    var temp = new ArrayList<Integer>();\n                    // if i != 0:\n                    if (i != 0) {\n                        // temp.append(grid[i - 1][j])\n                        temp.add(grid.get(i - 1).get(j));\n                    }\n                    // if j != 0:\n                    if (j != 0) {\n                        // temp.append(grid[i][j - 1])\n                        temp.add(grid.get(i).get(j - 1));\n                    }\n                    // if i != n - 1:\n                    if (i != n - 1) {\n                        // temp.append(grid[i + 1][j])\n                        temp.add(grid.get(i + 1).get(j));\n                    }\n                    // if j != n - 1:\n                    if (j != n - 1) {\n                        // temp.append(grid[i][j + 1])\n                        temp.add(grid.get(i).get(j + 1));\n                    }\n                    // min_val = min(temp)\n                    min_val = Math.min(min_val, Collections.min(temp));\n                }\n            }\n        }\n        // result = []\n        var result = new ArrayList<Integer>();\n        // for i in range(k):\n        for (int i = 0; i < k; i++) {\n            // result.append(1 if i % 2 == 0 else min_val)\n            result.add(i % 2 == 0 ? 1 : min_val);\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static List<Integer> tri(int n) {\n        // if n == 0:\n        if (n == 0) {\n            // return [1]\n            return Arrays.asList(1);\n        }\n        // seq = [1, 3]\n        var seq = new ArrayList<Integer>();\n        seq.add(1);\n        seq.add(3);\n        // for i in range(2, n + 1):\n        for (int i = 2; i <= n; i++) {\n            // if i % 2 == 0:\n            if (i % 2 == 0) {\n                // seq.append(i / 2 + 1)\n                seq.add(i / 2 + 1);\n            } else {\n                // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n                seq.add(seq.get(i - 1) + seq.get(i - 2) + (i + 3) / 2);\n            }\n        }\n        // return seq\n        return seq;\n    }\n}\n",
            "class Global {\n    public static int digits(int n) {\n        // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n        var odds = new ArrayList<Integer>();\n        for (int d : String.valueOf(n).split(\"\")) {\n            if (Integer.parseInt(d) % 2 == 1) {\n                odds.add(Integer.parseInt(d));\n            }\n        }\n        // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n        return odds.stream().reduce(1, (x, y) -> x * y) * (odds.size() > 0 ? 1 : 0);\n    }\n}\n",
            "class Global {\n    public static boolean isNested(String s) {\n        // open_idx = []\n        var openIdx = new ArrayList<Integer>();\n        // close_idx = []\n        var closeIdx = new ArrayList<Integer>();\n        // for i, ch in enumerate(s):\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            // if ch == '[':\n            if (ch == '[') {\n                // open_idx.append(i)\n                openIdx.add(i);\n            }\n            // elif ch == ']':\n            else if (ch == ']') {\n                // close_idx.append(i)\n                closeIdx.add(i);\n            }\n        }\n        // close_idx.reverse()\n        Collections.reverse(closeIdx);\n        // cnt = 0\n        int cnt = 0;\n        // i = 0\n        int i = 0;\n        // l = len(close_idx)\n        int l = closeIdx.size();\n        // for idx in open_idx:\n        for (Integer idx : openIdx) {\n            // if i < l and idx < close_idx[i]:\n            if (i < l && idx < closeIdx.get(i)) {\n                // cnt += 1\n                cnt += 1;\n                // i += 1\n                i += 1;\n            }\n        }\n        // return cnt >= 2\n        return cnt >= 2;\n    }\n}\n",
            "class Global {\n    public static int sumSquares(List<Float> lst) {\n        // return sum([pow(ceil(n), 2) for n in lst])\n        return (int) lst.stream().map(n -> Math.pow(Math.ceil(n), 2)).reduce(0, (a, b) -> a + b);\n    }\n}\n",
            "class Global {\n    public static boolean checkIfLastCharIsALetter(String txt) {\n        // if not txt:\n        if (txt == null || txt.isEmpty()) {\n            // return False\n            return false;\n        }\n        // last = txt[txt.rfind(' ') + 1:]\n        String last = txt.substring(txt.lastIndexOf(' ') + 1);\n        // return len(last) == 1 and last[0].isalpha()\n        return last.length() == 1 && Character.isLetter(last.charAt(0));\n    }\n}\n",
            "class Global {\n    public static int canArrange(List<Integer> arr) {\n        // if len (arr) <= 1:\n        if (arr.size() <= 1) {\n            // return -1\n            return -1;\n        }\n        // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n        var idx = new ArrayList<Integer>();\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                idx.add(i);\n            }\n        }\n        // return max(idx, default=-1)\n        return Collections.max(idx, (a, b) -> a - b);\n    }\n}\n",
            "class Global {\n    public static List<Integer> largestSmallestIntegers(List<Integer> lst) {\n        // neg = [i for i in lst if i < 0]\n        var neg = new ArrayList<Integer>();\n        for (Integer i : lst) {\n            if (i < 0) {\n                neg.add(i);\n            }\n        }\n        // pos = [i for i in lst if i > 0]\n        var pos = new ArrayList<Integer>();\n        for (Integer i : lst) {\n            if (i > 0) {\n                pos.add(i);\n            }\n        }\n        // max_neg = max(neg) if len(neg) > 0 else None\n        var maxNeg = neg.size() > 0 ? Collections.max(neg) : null;\n        // min_pos = min(pos) if len(pos) > 0 else None\n        var minPos = pos.size() > 0 ? Collections.min(pos) : null;\n        // return [max_neg, min_pos]\n        return Arrays.asList(maxNeg, minPos);\n    }\n}\n",
            "class Global {\n    public static float anyToReal(Object o) {\n        // if isinstance(o, str): \n        if (o instanceof String) {\n            // return float(o.replace(',','.'))\n            return Float.parseFloat(((String) o).replace(',', '.'));\n        }\n        // elif isinstance(o, int):\n        else if (o instanceof Integer) {\n            // return float(o)\n            return (float) (int) o;\n        }\n        // elif isinstance(o, float):\n        else if (o instanceof Float) {\n            // return o\n            return (float) o;\n        }\n        // raise RuntimeError(\"Type Error\");\n        throw new RuntimeException(\"Type Error\");\n    }\n    public static Object compareOne(Object a, Object b) {\n        // a1 = any_to_real(a)\n        float a1 = anyToReal(a);\n        // b1 = any_to_real(b)\n        float b1 = anyToReal(b);\n        // if a1 == b1:\n        if (a1 == b1) {\n            // return None\n            return null;\n        }\n        // elif a1 > b1:\n        else if (a1 > b1) {\n            // return a1\n            return a1;\n        }\n        // else:\n        else {\n            // return b1\n            return b1;\n        }\n    }\n}\n",
            "class Global {\n    public static boolean isEqualToSumEven(int n) {\n        // return n % 2 == 0 and n >= 8\n        return n % 2 == 0 && n >= 8;\n    }\n}\n",
            "class Global {\n    public static int specialFactorial(int n) {\n        // fact = 1\n        int fact = 1;\n        // result = 1\n        int result = 1;\n        // for i in range(1, n + 1):\n        for (int i = 1; i <= n; i++) {\n            // fact *= i\n            fact *= i;\n            // result *= fact\n            result *= fact;\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static String fixSpaces(String txt) {\n        // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n        return txt.replaceAll(\"\\\\s{3,}\", \"-\").replace(\" \", \"_\");\n    }\n}\n",
            "class Global {\n    public static String fileNameCheck(String fileName) {\n        // suf = [\"txt\", \"exe\", \"dll\"]\n        var suf = new ArrayList<String>();\n        suf.add(\"txt\");\n        suf.add(\"exe\");\n        suf.add(\"dll\");\n        // lst = file_name.split(\".\")\n        var lst = fileName.split(\"\\\\.\");\n        // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n        if (lst.length != 2 || !suf.contains(lst[1]) || lst[0].length() == 0 || !Character.isLetter(lst[0].charAt(0)) || lst[0].replaceAll(\"\\\\d\", \"\").length() > 3) {\n            return \"No\";\n        }\n        return \"Yes\";\n    }\n}\n",
            "class Global {\n    public static int sumSquares(List<Integer> lst) {\n        // result = 0\n        int result = 0;\n        // for i in range(len(lst)):\n        for (int i = 0; i < lst.size(); i++) {\n            // if i % 3 == 0:\n            if (i % 3 == 0) {\n                // result += pow(lst[i], 2)\n                result += (int) Math.pow(lst.get(i), 2);\n            }\n            // elif i % 4 == 0:\n            else if (i % 4 == 0) {\n                // result += pow(lst[i], 3)\n                result += (int) Math.pow(lst.get(i), 3);\n            }\n            // else:\n            else {\n                // result += lst[i]\n                result += lst.get(i);\n            }\n        }\n        // return result\n        return result;\n    }\n}\n",
            "class Global {\n    public static boolean isPrime(int n) {\n        // if n < 2:\n        if (n < 2) {\n            // return False\n            return false;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= Math.floor(Math.sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return False\n                return false;\n            }\n        }\n        // return True\n        return true;\n    }\n    public static String wordsInSentence(String sentence) {\n        // words = sentence.split(\" \")\n        var words = sentence.split(\" \");\n        // return \" \".join([w for w in words if is_prime(len(w))])\n        return String.join(\" \", Arrays.stream(words).filter(w -> isPrime(w.length())).toArray(String[]::new));\n    }\n}\n",
            "class Global {\n    public static boolean simplify(String x, String n) {\n        // xs = x.split(\"/\")\n        var xs = x.split(\"/\");\n        // ns = n.split(\"/\")\n        var ns = n.split(\"/\");\n        // num = int(xs[0]) * int(ns[0])\n        int num = Integer.parseInt(xs[0]) * Integer.parseInt(ns[0]);\n        // den = int(xs[1]) * int(ns[1])\n        int den = Integer.parseInt(xs[1]) * Integer.parseInt(ns[1]);\n        // return num % den == 0\n        return num % den == 0;\n    }\n}\n",
            "class Global {\n    public static int digitsSum(int n) {\n        // n_str = str(n)\n        var nStr = String.valueOf(n);\n        // if n >= 0:\n        if (n >= 0) {\n            // return sum(int(d) for d in n_str)\n            return Arrays.stream(nStr.split(\"\")).mapToInt(Integer::parseInt).sum();\n        } else {\n            // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n            return Integer.parseInt(nStr.substring(0, 2)) * 2 + digitsSum(Math.abs(n));\n        }\n    }\n    public static List<Integer> orderByPoints(List<Integer> nums) {\n        // return sorted(nums, key=digits_sum)\n        return nums.stream().sorted(Comparator.comparingInt(Global::digitsSum)).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static int specialFilter(List<Integer> nums) {\n        // odds = \"13579\"\n        var odds = \"13579\";\n        // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n        return (int) nums.stream().filter(n -> n > 10 && n % 2 == 1 && odds.contains(String.valueOf(n).charAt(0))).count();\n    }\n}\n",
            "class Global {\n    public static int getMaxTriples(int n) {\n        // c = [0, 0, 0]\n        var c = new int[3];\n        // for i in range(1, n + 1):\n        for (int i = 1; i <= n; i++) {\n            // a = i * i - i + 1\n            int a = i * i - i + 1;\n            // c[a % 3] += 1\n            c[a % 3] += 1;\n        }\n        // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n        return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2));\n    }\n}\n",
            "class Global {\n    public static List<String> bf(String planet1, String planet2) {\n        // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        var names = new ArrayList<String>();\n        names.add(\"Mercury\");\n        names.add(\"Venus\");\n        names.add(\"Earth\");\n        names.add(\"Mars\");\n        names.add(\"Jupiter\");\n        names.add(\"Saturn\");\n        names.add(\"Uranus\");\n        names.add(\"Neptune\");\n        // if planet1 not in names or planet2 not in names:\n        if (!names.contains(planet1) || !names.contains(planet2)) {\n            return new ArrayList<String>();\n        }\n        // l = names.index(planet1)\n        int l = names.indexOf(planet1);\n        // r = names.index(planet2)\n        int r = names.indexOf(planet2);\n        // if l > r:\n        if (l > r) {\n            // l, r = r, l\n            int t = l;\n            l = r;\n            r = t;\n        }\n        // if l == r:\n        if (l == r) {\n            return new ArrayList<String>();\n        }\n        // return names[l + 1 : r]\n        return names.subList(l + 1, r);\n    }\n}\n",
            "class Global {\n    public static List<String> sortedListSum(List<String> lst) {\n        // result = [s for s in lst if len(s) % 2 == 0]\n        var result = new ArrayList<String>();\n        for (String s : lst) {\n            if (s.length() % 2 == 0) {\n                result.add(s);\n            }\n        }\n        // return sorted(result, key=lambda x: (len(x), x))\n        return result.stream().sorted(Comparator.comparing(String::length).thenComparing(x -> x)).collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static int xOrY(int n, int x, int y) {\n        // if n < 2:\n        if (n < 2) {\n            // return y\n            return y;\n        }\n        // for i in range(2, floor(sqrt(n)) + 1):\n        for (int i = 2; i <= Math.floor(Math.sqrt(n)) + 1; i++) {\n            // if n % i == 0:\n            if (n % i == 0) {\n                // return y\n                return y;\n            }\n        }\n        // return x\n        return x;\n    }\n}\n",
            "class Global {\n    public static int doubleTheDifference(List<Float> lst) {\n        // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n        return lst.stream().filter(n -> n >= 0 && n % 2 == 1).map(n -> n * n).reduce(0, (a, b) -> a + b);\n    }\n}\n",
            "class Global {\n    public static List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        // return [abs(x - y) for x, y in zip(game, guess)]\n        return IntStream.range(0, game.size())\n            .mapToObj(i -> Math.abs(game.get(i) - guess.get(i)))\n            .collect(Collectors.toList());\n    }\n}\n",
            "class Global {\n    public static String strongestExtension(String className, List<String> extensions) {\n        // max_s = float(\"-inf\")\n        double maxS = Double.NEGATIVE_INFINITY;\n        // max_ext = \"\"\n        String maxExt = \"\";\n        // for ext in extensions:\n        for (String ext : extensions) {\n            // upper = len([c for c in ext if c.isupper()])\n            int upper = 0;\n            for (char c : ext.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    upper++;\n                }\n            }\n            // lower = len([c for c in ext if c.islower()])\n            int lower = 0;\n            for (char c : ext.toCharArray()) {\n                if (Character.isLowerCase(c)) {\n                    lower++;\n                }\n            }\n            // s = upper - lower\n            double s = upper - lower;\n            // if s > max_s:\n            if (s > maxS) {\n                // max_s = s\n                maxS = s;\n                // max_ext = ext\n                maxExt = ext;\n            }\n        }\n        // return f\"{class_name}.{max_ext}\"\n        return className + \".\" + maxExt;\n    }\n}\n",
            "class Global {\n    public static boolean cycpatternCheck(String a, String b) {\n        // if len(a) < len(b):\n        if (a.length() < b.length()) {\n            // return False\n            return false;\n        }\n        // for i in range(len(b)):\n        for (int i = 0; i < b.length(); i++) {\n            // if b[i:] + b[:i] in a:\n            if (a.contains(b.substring(i) + b.substring(0, i))) {\n                // return True\n                return true;\n            }\n        }\n        // return False\n        return false;\n    }\n}\n",
            "class Global {\n    public static List<Integer> evenOddCount(int num) {\n        // ds = str(abs(num))\n        var ds = String.valueOf(Math.abs(num));\n        // even = len([d for d in ds if ord(d) % 2 == 0])\n        var even = 0;\n        for (int i = 0; i < ds.length(); i++) {\n            if (ds.charAt(i) % 2 == 0) {\n                even++;\n            }\n        }\n        // return [even, len(ds) - even]\n        return Arrays.asList(even, ds.length() - even);\n    }\n}\n",
            "class Global {\n    public static String intToMiniRoman(int num) {\n        // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        var values = new int[] {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n        var numerals = new String[] {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n        // res = []\n        var res = new ArrayList<String>();\n        // for i in range(len(values)):\n        for (int i = 0; i < values.length; i++) {\n            // while num >= values[i]:\n            while (num >= values[i]) {\n                // res.append(numerals[i])\n                res.add(numerals[i]);\n                // num -= values[i]\n                num -= values[i];\n            }\n        }\n        // return \"\".join(res)\n        return String.join(\"\", res);\n    }\n}\n",
            "class Global {\n    public static boolean rightAngleTriangle(int a, int b, int c) {\n        // s = sorted([a, b, c])\n        var s = new ArrayList<Integer>();\n        s.add(a);\n        s.add(b);\n        s.add(c);\n        Collections.sort(s);\n        // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n        return s.get(0) * s.get(0) + s.get(1) * s.get(1) == s.get(2) * s.get(2);\n    }\n}\n",
            "class Global {\n    public static String findMax(List<String> words) {\n        // max_cnt = 0\n        int maxCnt = 0;\n        // max_w = \"\"\n        String maxW = \"\";\n        // for w in words:\n        for (String w : words) {\n            // cnt = len(set(w))\n            int cnt = new HashSet<>(w).size();\n            // if cnt > max_cnt:\n            if (cnt > maxCnt) {\n                // max_cnt = cnt\n                maxCnt = cnt;\n                // max_w = w\n                maxW = w;\n            }\n            // elif cnt == max_cnt:\n            else if (cnt == maxCnt) {\n                // max_w = min(max_w, w)\n                maxW = min(maxW, w);\n            }\n        }\n        // return max_w\n        return maxW;\n    }\n}\n",
            "class Global {\n    public static List<Integer> eat(int num, int need, int remaining) {\n        // if need <= remaining:\n        if (need <= remaining) {\n            // return [num + need, remaining - need]\n            return Arrays.asList(num + need, remaining - need);\n        } else {\n            // return [num + remaining, 0]\n            return Arrays.asList(num + remaining, 0);\n        }\n    }\n}\n",
            "class Global {\n    public static int doAlgebra(List<String> operators, List<Integer> operands) {\n        // ops = operators.copy()\n        var ops = new ArrayList<String>(operators);\n        // nums = operands.copy()\n        var nums = new ArrayList<Integer>(operands);\n        // i = len(ops) - 1\n        int i = ops.size() - 1;\n        // while i >= 0:\n        while (i >= 0) {\n            // if ops[i] == \"**\":\n            if (ops.get(i).equals(\"**\")) {\n                // nums[i] = pow(nums[i], nums[i + 1])\n                nums.set(i, (int) Math.pow(nums.get(i), nums.get(i + 1)));\n                // nums.pop(i + 1)\n                nums.remove(i + 1);\n                // ops.pop(i)\n                ops.remove(i);\n            }\n            // i -= 1\n            i -= 1;\n        }\n        // i = 0\n        i = 0;\n        // while i < len(ops):\n        while (i < ops.size()) {\n            // if ops[i] == \"*\":\n            if (ops.get(i).equals(\"*\")) {\n                // nums[i] = nums[i] * nums[i + 1]\n                nums.set(i, nums.get(i) * nums.get(i + 1));\n                // nums.pop(i + 1)\n                nums.remove(i + 1);\n                // ops.pop(i)\n                ops.remove(i);\n                // i -= 1\n                i -= 1;\n            }\n            // elif ops[i] == \"//\":\n            else if (ops.get(i).equals(\"//\")) {\n                // nums[i] = nums[i] // nums[i + 1]\n                nums.set(i, nums.get(i) / nums.get(i + 1));\n                // nums.pop(i + 1)\n                nums.remove(i + 1);\n                // ops.pop(i)\n                ops.remove(i);\n                // i -= 1\n                i -= 1;\n            }\n            // i += 1\n            i += 1;\n        }\n        // i = 0\n        i = 0;\n        // while i < len(ops):\n        while (i < ops.size()) {\n            // if ops[i] == \"+\":\n            if (ops.get(i).equals(\"+\")) {\n                // nums[i] = nums[i] + nums[i + 1]\n                nums.set(i, nums.get(i) + nums.get(i + 1));\n                // nums.pop(i + 1)\n                nums.remove(i + 1);\n                // ops.pop(i)\n                ops.remove(i);\n                // i -= 1\n                i -= 1;\n            }\n            // elif ops[i] == \"-\":\n            else if (ops.get(i).equals(\"-\")) {\n                // nums[i] = nums[i] - nums[i + 1]\n                nums.set(i, nums.get(i) - nums.get(i + 1));\n                // nums.pop(i + 1)\n                nums.remove(i + 1);\n                // ops.pop(i)\n                ops.remove(i);\n                // i -= 1\n                i -= 1;\n            }\n            // i += 1\n            i += 1;\n        }\n        // return nums[0]\n        return nums.get(0);\n    }\n}\n",
            "class Global {\n    public static String solve(String s) {\n        // if not any(ch.isalpha() for ch in s):\n        if (!s.chars().anyMatch(Character::isAlphabetic)) {\n            // return s[::-1]\n            return new StringBuilder(s).reverse().toString();\n        }\n        // result = []\n        var result = new ArrayList<Character>();\n        // for ch in s:\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            // if not ch.isalpha():\n            if (!Character.isAlphabetic(ch)) {\n                // result.append(ch)\n                result.add(ch);\n            }\n            // elif ch.isupper():\n            else if (Character.isUpperCase(ch)) {\n                // result.append(ch.lower())\n                result.add(Character.toLowerCase(ch));\n            }\n            // elif ch.islower():\n            else if (Character.isLowerCase(ch)) {\n                // result.append(ch.upper())\n                result.add(Character.toUpperCase(ch));\n            }\n        }\n        // return \"\".join(result)\n        return result.stream().map(Object::toString).collect(Collectors.joining());\n    }\n}\n",
            "class Global {\n    public static String stringToMd5(String txt) {\n        // if not txt:\n        if (txt == null) {\n            // return None\n            return null;\n        }\n        // md5_hash = hashlib.md5()\n        var md5_hash = MessageDigest.getInstance(\"MD5\");\n        // txt_bytes = txt.encode()\n        var txt_bytes = txt.getBytes();\n        // md5_hash.update(txt_bytes)\n        md5_hash.update(txt_bytes);\n        // md5_encoded = md5_hash.hexdigest()\n        var md5_encoded = new BigInteger(1, md5_hash.digest()).toString(16);\n        // return md5_encoded\n        return md5_encoded;\n    }\n}\n",
            "class Global {\n    public static List<Integer> generateIntegers(int a, int b) {\n        // lower = max(2, min(a, b))\n        int lower = Math.max(2, Math.min(a, b));\n        // upper = min(8, max(a, b))\n        int upper = Math.min(8, Math.max(a, b));\n        // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n        return IntStream.range(lower, upper + 1)\n            .filter(i -> i % 2 == 0)\n            .boxed()\n            .collect(Collectors.toList());\n    }\n}\n"
        ],
        "javascript": [
            "export const hasCloseElements = (numbers, threshold) => {\n    // for i in range(len(numbers)):\n    for (let i = 0; i < numbers.length; i++) {\n        // for j in range(i + 1, len(numbers)):\n        for (let j = i + 1; j < numbers.length; j++) {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n                // return True\n                return true;\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const separateParenGroups = (parenString) => {\n    // groups = []\n    const groups = [];\n    // stk = []\n    const stk = [];\n    // current_group = \"\"\n    let currentGroup = \"\";\n    // parens = paren_string.replace(\" \", \"\")\n    const parens = parenString.replace(\" \", \"\");\n    // for ch in parens:\n    for (const ch of parens) {\n        // if ch == \"(\":\n        if (ch === \"(\") {\n            // stk.append(ch)\n            stk.push(ch);\n            // current_group += ch\n            currentGroup += ch;\n        }\n        // elif ch == \")\":\n        else if (ch === \")\") {\n            // stk.pop()\n            stk.pop();\n            // current_group += ch\n            currentGroup += ch;\n            // if not stk:\n            if (!stk.length) {\n                // groups.append(current_group)\n                groups.push(currentGroup);\n                // current_group = \"\"\n                currentGroup = \"\";\n            }\n        }\n    }\n    // return groups\n    return groups;\n}\n",
            "export const truncateNumber = (num) => {\n    // return num - floor(num)\n    return num - Math.floor(num);\n}\n",
            "export const belowZero = (operations) => {\n    // balance = 0\n    let balance = 0;\n    // for op in operations:\n    for (const op of operations) {\n        // balance += op\n        balance += op;\n        // if balance < 0:\n        if (balance < 0) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const meanAbsoluteDeviation = (numbers) => {\n    // mean = sum(numbers) / len(numbers)\n    const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;\n    // deviation = sum(abs(x - mean) for x in numbers)\n    const deviation = numbers.reduce((a, b) => a + Math.abs(b - mean), 0);\n    // return deviation / len(numbers)\n    return deviation / numbers.length;\n}\n",
            "export const intersperse = (numbers, delimiter) => {\n    // result = []\n    const result = [];\n    // for i in range(len(numbers)):\n    for (let i = 0; i < numbers.length; i++) {\n        // if i != 0:\n        if (i !== 0) {\n            // result.append(delimiter)\n            result.push(delimiter);\n        }\n        // result.append(numbers[i])\n        result.push(numbers[i]);\n    }\n    // return result\n    return result;\n}\n",
            "export const parseNestedParens = (parenString) => {\n    // result = []\n    const result = [];\n    // paren_groups = paren_string.split()\n    const parenGroups = parenString.split(\" \");\n    // for group in paren_groups:\n    for (const group of parenGroups) {\n        // max_depth = 0\n        let maxDepth = 0;\n        // depth = 0\n        let depth = 0;\n        // for ch in group:\n        for (const ch of group) {\n            // if ch == \"(\":\n            if (ch === \"(\") {\n                // depth += 1\n                depth += 1;\n                // max_depth = max(max_depth, depth)\n                maxDepth = Math.max(maxDepth, depth);\n            }\n            // elif ch == \")\":\n            else if (ch === \")\") {\n                // depth -= 1\n                depth -= 1;\n            }\n        }\n        // result.append(max_depth)\n        result.push(maxDepth);\n    }\n    // return result\n    return result;\n}\n",
            "export const filterBySubstring = (strs, substring) => {\n    // return [s for s in strs if substring in s]\n    return strs.filter(s => s.includes(substring));\n}\n",
            "export const sumProduct = (numbers) => {\n    // n_sum = sum(numbers)\n    const nSum = numbers.reduce((a, b) => a + b);\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    const nProduct = reduce(numbers, (x, y) => x * y, 1);\n    // return [n_sum, n_product]\n    return [nSum, nProduct];\n}\n",
            "export const rollingMax = (numbers) => {\n    // max_so_far = float(\"-inf\")\n    let maxSoFar = Number.NEGATIVE_INFINITY;\n    // result = []\n    const result = [];\n    // for num in numbers:\n    for (const num of numbers) {\n        // max_so_far = max(max_so_far, num)\n        maxSoFar = Math.max(maxSoFar, num);\n        // result.append(max_so_far)\n        result.push(maxSoFar);\n    }\n    // return result\n    return result;\n}\n",
            "export const isPalindrome = (s) => {\n    // return s == s[::-1]\n    return s === s.split(\"\").reverse().join(\"\");\n}\nexport const makePalindrome = (s) => {\n    // if is_palindrome(s):\n    if (isPalindrome(s)) {\n        // return s\n        return s;\n    }\n    // for i in range(len(s)):\n    for (let i = 0; i < s.length; i++) {\n        // if is_palindrome(s[i:]):\n        if (isPalindrome(s.slice(i))) {\n            // return s + s[:i][::-1]\n            return s + s.slice(0, i).split(\"\").reverse().join(\"\");\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "export const stringXor = (a, b) => {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    return [...a].map((x, i) => (x === b[i] ? \"0\" : \"1\")).join(\"\");\n}\n",
            "export const longest = (strs) => {\n    // if not strs:\n    if (!strs) {\n        // return None\n        return null;\n    }\n    // longest_s = strs[0]\n    let longestS = strs[0];\n    // for s in strs:\n    for (const s of strs) {\n        // if len(s) > len(longest_s):\n        if (s.length > longestS.length) {\n            // longest_s = s\n            longestS = s;\n        }\n    }\n    // return longest_s\n    return longestS;\n}\n",
            "export const greatestCommonDivisor = (a, b) => {\n    // if b == 0:\n    if (b === 0) {\n        // return a\n        return a;\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        return greatestCommonDivisor(b, a % b);\n    }\n}\n",
            "export const allPrefixes = (s) => {\n    // prefixes = []\n    const prefixes = [];\n    // for i in range(len(s)):\n    for (let i = 0; i < s.length; i++) {\n        // prefixes.append(s[: i + 1])\n        prefixes.push(s.slice(0, i + 1));\n    }\n    // return prefixes\n    return prefixes;\n}\n",
            "export const stringSequence = (n) => {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    return Array.from(Array(n + 1).keys()).map(i => i.toString()).join(\" \");\n}\n",
            "export const countDistinctCharacters = (s) => {\n    // return len(set(s.lower()))\n    return [...new Set(s.toLowerCase())].length;\n}\n",
            "export const parseMusic = (musicString) => {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    const durations = {\n        o: 4,\n        \"o|\": 2,\n        \".|\": 1,\n    };\n    // notes = music_string.split()\n    const notes = musicString.split(\" \");\n    // return [durations[note] for note in notes]\n    return notes.map((note) => durations[note]);\n}\n",
            "export const howManyTimes = (s, substring) => {\n    // times = 0\n    let times = 0;\n    // for i in range(len(s) - len(substring) + 1):\n    for (let i = 0; i < s.length - substring.length + 1; i++) {\n        // if s[i : i + len(substring)] == substring:\n        if (s.slice(i, i + substring.length) === substring) {\n            // times += 1\n            times += 1;\n        }\n    }\n    // return times\n    return times;\n}\n",
            "const sortNumbers = (numbers) => {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    const numDict = {\n        zero: 0,\n        one: 1,\n        two: 2,\n        three: 3,\n        four: 4,\n        five: 5,\n        six: 6,\n        seven: 7,\n        eight: 8,\n        nine: 9,\n    };\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    const numList = numbers\n        .split(\" \")\n        .filter((x) => Object.keys(numDict).includes(x));\n    // num_list.sort(key=lambda x: num_dict[x])\n    numList.sort((a, b) => numDict[a] - numDict[b]);\n    // return \" \".join(num_list)\n    return numList.join(\" \");\n};\n",
            "export const findClosestElements = (numbers) => {\n    // sorted_numbers = sorted(numbers)\n    const sortedNumbers = numbers.slice().sort((a, b) => a - b);\n    // min_diff = float(\"inf\")\n    let minDiff = Number.POSITIVE_INFINITY;\n    // closest_pair = []\n    let closestPair = [];\n    // for i in range(1, len(sorted_numbers)):\n    for (let i = 1; i < sortedNumbers.length; i++) {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        const diff = sortedNumbers[i] - sortedNumbers[i - 1];\n        // if diff < min_diff:\n        if (diff < minDiff) {\n            // min_diff = diff\n            minDiff = diff;\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closestPair = [sortedNumbers[i - 1], sortedNumbers[i]];\n        }\n    }\n    // return closest_pair\n    return closestPair;\n}\n",
            "export const rescaleToUnit = (numbers) => {\n    // min_num = min(numbers)\n    const minNum = Math.min(...numbers);\n    // max_num = max(numbers)\n    const maxNum = Math.max(...numbers);\n    // if min_num == max_num:\n    if (minNum === maxNum) {\n        // return [0.0] * len(numbers)\n        return Array(numbers.length).fill(0.0);\n    } else {\n        // return [(num - min_num) / (max_num - min_num) for num in numbers]\n        return numbers.map((num) => (num - minNum) / (maxNum - minNum));\n    }\n}\n",
            "export const filterIntegers = (values) => {\n    // return [x for x in values if isinstance(x, int)]\n    return values.filter((x) => typeof x === \"number\");\n}\n",
            "export const strLength = (s) => {\n    // return len(s)\n    return s.length;\n}\n",
            "export const largestDivisor = (n) => {\n    // for i in range(2, n):\n    for (let i = 2; i < n; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return n // i\n            return n / i;\n        }\n    }\n    // return 1\n    return 1;\n}\n",
            "export const factorize = (n) => {\n    // factors = []\n    const factors = [];\n    // divisor = 2\n    let divisor = 2;\n    // while divisor <= n:\n    while (divisor <= n) {\n        // if n % divisor == 0:\n        if (n % divisor === 0) {\n            // factors.append(divisor)\n            factors.push(divisor);\n            // n //= divisor\n            n /= divisor;\n        } else {\n            // divisor += 1\n            divisor++;\n        }\n    }\n    // return factors\n    return factors;\n}\n",
            "export const removeDuplicates = (numbers) => {\n    // counts = {}\n    const counts = {};\n    // for num in numbers:\n    for (const num of numbers) {\n        // counts[num] = counts.get(num, 0) + 1\n        counts[num] = (counts[num] || 0) + 1;\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    const res = numbers.filter((num) => counts[num] === 1);\n    // return res\n    return res;\n}\n",
            "export const flipCase = (s) => {\n    // flipped = []\n    const flipped = [];\n    // for ch in s:\n    for (const ch of s) {\n        // if not ch.isalpha():\n        if (!ch.match(/[a-zA-Z]/)) {\n            // flipped.append(ch)\n            flipped.push(ch);\n        }\n        // elif ch.islower():\n        else if (ch.match(/[a-z]/)) {\n            // flipped.append(ch.upper())\n            flipped.push(ch.toUpperCase());\n        }\n        // elif ch.isupper():\n        else if (ch.match(/[A-Z]/)) {\n            // flipped.append(ch.lower())\n            flipped.push(ch.toLowerCase());\n        }\n    }\n    // return ''.join(flipped)\n    return flipped.join('');\n}\n",
            "export const concatenate = (strs) => {\n    // return \"\".join(strs)\n    return strs.join(\"\");\n}\n",
            "export const filterByPrefix = (strs, prefixStr) => {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    return strs.filter(s => s.startsWith(prefixStr));\n}\n",
            "export const getPositive = (l) => {\n    // return [num for num in l if num > 0]\n    return l.filter((num) => num > 0);\n}\n",
            "export const isPrime = (n) => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "export const poly = (xs, x) => {\n    // res = 0.0\n    let res = 0.0;\n    // for i in range(len(xs)):\n    for (let i = 0; i < xs.length; i++) {\n        // res += xs[i] * x**i\n        res += xs[i] * Math.pow(x, i);\n    }\n    // return res\n    return res;\n}\nexport const findZero = (xs) => {\n    // x1, x2 = 1.0, -1.0\n    let x1 = 1.0, x2 = -1.0;\n    // while poly(xs, x1) * poly(xs, x2) > 0:\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        // x1 *= 2\n        x1 *= 2;\n        // x2 *= 2\n        x2 *= 2;\n    }\n    // while abs(x1 - x2) > 1e-10:\n    while (Math.abs(x1 - x2) > 1e-10) {\n        // mid = (x1 + x2) / 2\n        const mid = (x1 + x2) / 2;\n        // if poly(xs, mid) == 0:\n        if (poly(xs, mid) === 0) {\n            // return mid\n            return mid;\n        }\n        // elif poly(xs, mid) * poly(xs, x1) < 0:\n        else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            // x2 = mid\n            x2 = mid;\n        }\n        // else:\n        else {\n            // x1 = mid\n            x1 = mid;\n        }\n    }\n    // return (x1 + x2) / 2\n    return (x1 + x2) / 2;\n}\n",
            "export const sortThird = (l) => {\n    // sorted_third = sorted(l[::3])\n    const sortedThird = l.filter((_, i) => i % 3 === 0).sort((a, b) => a - b);\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    return l.map((e, i) => i % 3 === 0 ? sortedThird[i / 3] : e);\n}\n",
            "export const listUnique = (l) => {\n    // return sorted(list(set(l)))\n    return [...new Set(l)].sort();\n}\n",
            "export const maxElement = (l) => {\n    // if not l:\n    if (!l.length) {\n        // return 0\n        return 0;\n    }\n    // return max(l)\n    return Math.max(...l);\n}\n",
            "export const fizzBuzz = (n) => {\n    // cnt = 0\n    let cnt = 0;\n    // for i in range(n):\n    for (let i = 0; i < n; i++) {\n        // if i % 11 == 0 or i % 13 == 0:\n        if (i % 11 === 0 || i % 13 === 0) {\n            // cnt += str(i).count(\"7\")\n            cnt += (i + \"\").split(\"7\").length - 1;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "export const sortEven = (l) => {\n    // sorted_even = sorted(l[::2])\n    const sortedEven = l.filter((_, i) => i % 2 === 0).sort((a, b) => a - b);\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    return l.map((e, i) => i % 2 === 0 ? sortedEven[i / 2] : e);\n}\n",
            "export const encodeCyclic = (s) => {\n    // result = []\n    const result = [];\n    // for i in range(0, len(s), 3):\n    for (let i = 0; i < s.length; i += 3) {\n        // if i + 3 > len(s):\n        if (i + 3 > s.length) {\n            // result.append(s[i:])\n            result.push(s.slice(i));\n        } else {\n            // result.append(s[i+1:i+3])\n            result.push(s.slice(i + 1, i + 3));\n            // result.append(s[i])\n            result.push(s[i]);\n        }\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\nexport const decodeCyclic = (s) => {\n    return encodeCyclic(encodeCyclic(s));\n}\n",
            "export const isPrime = (n) => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const primeFib = (n) => {\n    // f = [0, 1]\n    let f = [0, 1];\n    // cnt = 0\n    let cnt = 0;\n    // while cnt < n:\n    while (cnt < n) {\n        // f = [f[1], f[0] + f[1]]\n        f = [f[1], f[0] + f[1]];\n        // if is_prime(f[1]):\n        if (isPrime(f[1])) {\n            // cnt += 1\n            cnt += 1;\n        }\n    }\n    // return f[1]\n    return f[1];\n}\n",
            "export const triplesSumToZero = (l) => {\n    // for i in range(len(l)):\n    for (let i = 0; i < l.length; i++) {\n        // for j in range(i + 1, len(l)):\n        for (let j = i + 1; j < l.length; j++) {\n            // for k in range(j + 1, len(l)):\n            for (let k = j + 1; k < l.length; k++) {\n                // if l[i] + l[j] + l[k] == 0:\n                if (l[i] + l[j] + l[k] === 0) {\n                    // return True\n                    return true;\n                }\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const carRaceCollision = (n) => {\n    // return n ** 2\n    return n ** 2;\n}\n",
            "export const incrList = (l) => {\n    // return [i + 1 for i in l]\n    return l.map((i) => i + 1);\n}\n",
            "export const pairsSumToZero = (l) => {\n    // seen = set()\n    const seen = new Set();\n    // for num in l:\n    for (const num of l) {\n        // if -num in seen:\n        if (seen.has(-num)) {\n            // return True\n            return true;\n        }\n        // seen.add(num)\n        seen.add(num);\n    }\n    // return False\n    return false;\n}\n",
            "export const changeBase = (x, bas) => {\n    // if x == 0:\n    if (x === 0) {\n        // return \"0\"\n        return \"0\";\n    }\n    // digits = []\n    const digits = [];\n    // while x > 0:\n    while (x > 0) {\n        // digits.append(str(x % bas))\n        digits.push(String(x % bas));\n        // x //= bas\n        x = Math.floor(x / bas);\n    }\n    // return \"\".join(digits[::-1])\n    return digits.reverse().join(\"\");\n}\n",
            "export const triangleArea = (a, h) => {\n    // return a * h / 2\n    return a * h / 2;\n}\n",
            "export const fib4 = (n) => {\n    // fib = [0, 0, 2, 0]\n    const fib = [0, 0, 2, 0];\n    // for i in range(4, n + 1):\n    for (let i = 4; i <= n + 1; i++) {\n        // fib[i % 4] = sum(fib)\n        fib[i % 4] = fib.reduce((a, b) => a + b);\n    }\n    // return fib[n % 4]\n    return fib[n % 4];\n}\n",
            "export const median = (l) => {\n    // sl = sorted(l)\n    const sl = l.slice().sort((a, b) => a - b);\n    // if len(l) % 2 != 0:\n    if (l.length % 2 !== 0) {\n        // return sl[len(l) // 2]\n        return sl[l.length / 2];\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (sl[l.length / 2] + sl[l.length / 2 - 1]) / 2;\n    }\n}\n",
            "export const isPalindrome = (txt) => {\n    // return txt == txt[::-1]\n    return txt === txt.split(\"\").reverse().join(\"\");\n}\n",
            "export const modp = (n, p) => {\n    // ret = 1\n    let ret = 1;\n    // for _ in range(n):\n    for (let _ = 0; _ < n; _++) {\n        // ret = (ret * 2) % p\n        ret = (ret * 2) % p;\n    }\n    // return ret\n    return ret;\n}\n",
            "export const encodeShift = (s) => {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    const result = [...s].map((ch) => String.fromCharCode(((ch.charCodeAt(0) - 97 + 5) % 26) + 97));\n    // return \"\".join(result)\n    return result.join(\"\");\n}\nexport const decodeShift = (s) => {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    const result = [...s].map((ch) => String.fromCharCode(((ch.charCodeAt(0) - 97 + 21) % 26) + 97));\n    // return \"\".join(result)\n    return result.join(\"\");\n}\n",
            "export const removeVowels = (txt) => {\n    // vowels = \"aeiouAEIOU\"\n    const vowels = \"aeiouAEIOU\";\n    // return \"\".join([char for char in txt if char not in vowels])\n    return [...txt].filter((char) => !vowels.includes(char)).join(\"\");\n}\n",
            "export const belowThreshold = (l, t) => {\n    // return all(x < t for x in l)\n    return l.every(x => x < t);\n}\n",
            "export const add = (x, y) => {\n    // return x + y\n    return x + y;\n}\n",
            "export const sameChars = (s0, s1) => {\n    // return set(s0) == set(s1)\n    return new Set(s0) === new Set(s1);\n}\n",
            "export const fib = (n) => {\n    // if n <= 1:\n    if (n <= 1) {\n        // return n\n        return n;\n    } else {\n        // return fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n",
            "export const correctBracketing = (brackets) => {\n    // depth = 0\n    let depth = 0;\n    // for b in brackets:\n    for (const b of brackets) {\n        // if b == \"<\":\n        if (b === \"<\") {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \">\":\n        else if (b === \">\") {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return depth === 0;\n}\n",
            "export const monotonic = (l) => {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    const diff = l.slice(1).map((y, i) => y - l[i]);\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    return diff.every(x => x <= 0) || diff.every(x => x >= 0);\n}\n",
            "export const common = (l1, l2) => {\n    // return sorted(list(set(l1) & set(l2)))\n    return [...new Set(l1)].filter(e => l2.includes(e)).sort();\n}\n",
            "export const largestPrimeFactor = (n) => {\n    // i = 2\n    let i = 2;\n    // while i * i <= n:\n    while (i * i <= n) {\n        // if n % i:\n        if (n % i) {\n            // i += 1\n            i += 1;\n        } else {\n            // n //= i\n            n /= i;\n        }\n    }\n    // return n\n    return n;\n}\n",
            "export const sumToN = (n) => {\n    // return sum(range(n + 1))\n    return Array.from({ length: n + 1 }).reduce((acc, _, i) => acc + i, 0);\n}\n",
            "export const correctBracketing = (brackets) => {\n    // depth = 0\n    let depth = 0;\n    // for b in brackets:\n    for (const b of brackets) {\n        // if b == \"(\":\n        if (b === \"(\") {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \")\":\n        else if (b === \")\") {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return depth === 0;\n}\n",
            "export const derivative = (xs) => {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    return xs.slice(1).map((x, i) => x * (i + 1));\n}\n",
            "export const fibfib = (n) => {\n    // if n <= 1:\n    if (n <= 1) {\n        // return 0 \n        return 0;\n    }\n    // a, b, c = 0, 0, 1\n    let a = 0, b = 0, c = 1;\n    // while n > 2:\n    while (n > 2) {\n        // a, b, c = b, c, a + b + c\n        [a, b, c] = [b, c, a + b + c];\n        // n -= 1\n        n -= 1;\n    }\n    // return c\n    return c;\n}\n",
            "export const vowelsCount = (s) => {\n    // vowels = \"aeiou\"\n    const vowels = \"aeiou\";\n    // cnt = 0\n    let cnt = 0;\n    // for i in range(len(s)):\n    for (let i = 0; i < s.length; i++) {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if (vowels.includes(s[i].toLowerCase()) || (i === s.length - 1 && s[i].toLowerCase() === \"y\")) {\n            // cnt += 1\n            cnt += 1;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "export const circularShift = (x, shift) => {\n    // x_str = str(x)\n    const x_str = x.toString();\n    // if shift > len(x_str):\n    if (shift > x_str.length) {\n        // return x_str[::-1]\n        return x_str.split(\"\").reverse().join(\"\");\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return x_str.slice(-shift) + x_str.slice(0, -shift);\n    }\n}\n",
            "export const digitSum = (s) => {\n    // return sum(ord(c) for c in s if c.isupper())\n    return [...s].reduce((sum, c) => sum + c.charCodeAt(0), 0);\n}\n",
            "export const fruitDistribution = (s, n) => {\n    // words = s.split(' ')\n    const words = s.split(\" \");\n    // apples = int(words[words.index(\"apples\") - 1])\n    const apples = parseInt(words[words.indexOf(\"apples\") - 1]);\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    const oranges = parseInt(words[words.indexOf(\"oranges\") - 1]);\n    // return n - apples - oranges\n    return n - apples - oranges;\n}\n",
            "export const pluck = (arr) => {\n    // evens = [n for n in arr if n % 2 == 0]\n    const evens = arr.filter((n) => n % 2 === 0);\n    // if len(evens) == 0:\n    if (evens.length === 0) {\n        // return []\n        return [];\n    }\n    // min_even = min(evens)\n    const minEven = Math.min(...evens);\n    // return [min_even, arr.index(min_even)]\n    return [minEven, arr.indexOf(minEven)];\n}\n",
            "export const search = (lst) => {\n    // freqs = {}\n    const freqs = {};\n    // for n in lst:\n    for (const n of lst) {\n        // freqs[n] = freqs.get(n, 0) + 1\n        freqs[n] = (freqs[n] || 0) + 1;\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    const goodVals = Object.entries(freqs).filter(([k, v]) => v >= k).map(([k]) => k);\n    // return max(good_vals, default=-1)\n    return Math.max(...goodVals, -1);\n}\n",
            "export const strangeSortList = (lst) => {\n    // sl = sorted(lst)\n    const sl = lst.slice().sort((a, b) => a - b);\n    // result = []\n    const result = [];\n    // left, right = 0, len(sl) - 1\n    let left = 0, right = sl.length - 1;\n    // while left <= right:\n    while (left <= right) {\n        // result.append(sl[left])\n        result.push(sl[left]);\n        // left += 1\n        left += 1;\n        // if left <= right:\n        if (left <= right) {\n            // result.append(sl[right])\n            result.push(sl[right]);\n            // right -= 1\n            right -= 1;\n        }\n    }\n    // return result\n    return result;\n}\n",
            "export const triangleArea = (a, b, c) => {\n    // if a + b > c and a + c > b and b + c > a:\n    if (a + b > c && a + c > b && b + c > a) {\n        // s = (a + b + c) / 2.0\n        const s = (a + b + c) / 2.0;\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // return -1.0\n        return -1.0;\n    }\n}\n",
            "export const willItFly = (q, w) => {\n    // if len(q) == 0:\n    if (q.length === 0) {\n        // return False\n        return false;\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    const isPalin = q.every((_, i) => q[i] === q[q.length - i - 1]);\n    // total = sum(q)\n    const total = q.reduce((a, b) => a + b);\n    // return is_palin and total <= w\n    return isPalin && total <= w;\n}\n",
            "export const smallestChange = (arr) => {\n    // ans = 0\n    let ans = 0;\n    // for i in range(len(arr) // 2):\n    for (let i = 0; i < arr.length / 2; i++) {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if (arr[i] !== arr[arr.length - i - 1]) {\n            // ans += 1\n            ans += 1;\n        }\n    }\n    // return ans\n    return ans;\n}\n",
            "export const totalMatch = (lst1, lst2) => {\n    // cnt1 = sum(len(s) for s in lst1)\n    const cnt1 = lst1.reduce((acc, s) => acc + s.length, 0);\n    // cnt2 = sum(len(s) for s in lst2)\n    const cnt2 = lst2.reduce((acc, s) => acc + s.length, 0);\n    // return lst1 if cnt1 <= cnt2 else lst2\n    return cnt1 <= cnt2 ? lst1 : lst2;\n}\n",
            "export const isPrime = (n) => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const isMultiplyPrime = (a) => {\n    // cnt = 0\n    let cnt = 0;\n    // for i in range(2, a + 1):\n    for (let i = 2; i <= a + 1; i++) {\n        // if is_prime(i):\n        if (isPrime(i)) {\n            // while a % i == 0:\n            while (a % i === 0) {\n                // cnt += 1\n                cnt += 1;\n                // a /= i\n                a /= i;\n            }\n        }\n    }\n    // return cnt == 3\n    return cnt === 3;\n}\n",
            "export const isSimplePower = (x, n) => {\n    // if n < 2:\n    if (n < 2) {\n        // return x == n\n        return x === n;\n    }\n    // tmp = 1\n    let tmp = 1;\n    // while tmp < x:\n    while (tmp < x) {\n        // tmp *= n\n        tmp *= n;\n    }\n    // return tmp == x\n    return tmp === x;\n}\n",
            "export const isCube = (a) => {\n    // a = abs(a)\n    a = Math.abs(a);\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    const root = Math.round(Math.pow(a, 1.0 / 3.0));\n    // return root * root * root == a\n    return root * root * root === a;\n}\n",
            "export const hexKey = (num) => {\n    // return len([x for x in num if x in \"2357BD\"])\n    return [...num].filter((x) => \"2357BD\".includes(x)).length;\n}\n",
            "export const decimalToBinary = (dec) => {\n    // binary = bin(dec)[2:]\n    const binary = dec.toString(2);\n    // return f\"db{binary}db\"\n    return `db${binary}db`;\n}\n",
            "export const isHappy = (s) => {\n    // if len(s) < 3:\n    if (s.length < 3) {\n        // return False\n        return false;\n    }\n    // for i in range(len(s) - 2):\n    for (let i = 0; i < s.length - 2; i++) {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "export const numericalLetterGrade = (grades) => {\n    // result = []\n    const result = [];\n    // for g in grades:\n    for (const g of grades) {\n        // if g == 4.0:\n        if (g === 4.0) {\n            // result.append(\"A+\")\n            result.push(\"A+\");\n        }\n        // elif g > 3.7:\n        else if (g > 3.7) {\n            // result.append(\"A\")\n            result.push(\"A\");\n        }\n        // elif g > 3.3:\n        else if (g > 3.3) {\n            // result.append(\"A-\")\n            result.push(\"A-\");\n        }\n        // elif g > 3.0:\n        else if (g > 3.0) {\n            // result.append(\"B+\")\n            result.push(\"B+\");\n        }\n        // elif g > 2.7:\n        else if (g > 2.7) {\n            // result.append(\"B\")\n            result.push(\"B\");\n        }\n        // elif g > 2.3:\n        else if (g > 2.3) {\n            // result.append(\"B-\")\n            result.push(\"B-\");\n        }\n        // elif g > 2.0:\n        else if (g > 2.0) {\n            // result.append(\"C+\")\n            result.push(\"C+\");\n        }\n        // elif g > 1.7:\n        else if (g > 1.7) {\n            // result.append(\"C\")\n            result.push(\"C\");\n        }\n        // elif g > 1.3:\n        else if (g > 1.3) {\n            // result.append(\"C-\")\n            result.push(\"C-\");\n        }\n        // elif g > 1.0:\n        else if (g > 1.0) {\n            // result.append(\"D+\")\n            result.push(\"D+\");\n        }\n        // elif g > 0.7:\n        else if (g > 0.7) {\n            // result.append(\"D\")\n            result.push(\"D\");\n        }\n        // elif g > 0.0:\n        else if (g > 0.0) {\n            // result.append(\"D-\")\n            result.push(\"D-\");\n        }\n        // else:\n        else {\n            // result.append(\"E\")\n            result.push(\"E\");\n        }\n    }\n    // return result\n    return result;\n}\n",
            "export const primeLength = (s) => {\n    // length = len(s)\n    const length = s.length;\n    // if length < 2:\n    if (length < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for (let i = 2; i <= floor(sqrt(length)) + 1; i++) {\n        // if length % i == 0:\n        if (length % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "export const startsOneEnds = (n) => {\n    // if n == 1:\n    if (n === 1) {\n        // return 1\n        return 1;\n    }\n    // return 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * (10 ** (n - 2));\n}\n",
            "export const solve = (n) => {\n    // digits_sum = sum(int(d) for d in str(n))\n    const digitsSum = [...String(n)].reduce((acc, d) => acc + parseInt(d), 0);\n    // return bin(digits_sum)[2:]\n    return parseInt(digitsSum).toString(2).slice(1);\n}\n",
            "export const add = (lst) => {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    return lst.reduce((acc, x, i) => {\n        if (i % 2 === 1 && x % 2 === 0) {\n            return acc + x;\n        }\n        return acc;\n    }, 0);\n}\n",
            "export const antiShuffle = (s) => {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    const words = s.split(\" \").map((word) => {\n        // return \"\".join(sorted(list(word)))\n        return [...word].sort().join(\"\");\n    });\n    // return \" \".join(words)\n    return words.join(\" \");\n}\n",
            "export const getRow = (lst, x) => {\n    // coords = []\n    const coords = [];\n    // for i in range(len(lst)):\n    for (let i = 0; i < lst.length; i++) {\n        // for j in range(len(lst[i])):\n        for (let j = 0; j < lst[i].length; j++) {\n            // if lst[i][j] == x:\n            if (lst[i][j] === x) {\n                // coords.append([i, j])\n                coords.push([i, j]);\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    return coords.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n}\n",
            "export const sortArray = (arr) => {\n    // if len(arr) == 0:\n    if (arr.length === 0) {\n        // return []\n        return [];\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if ((arr[0] + arr[arr.length - 1]) % 2 === 0) {\n        // return sorted(arr, reverse=True)\n        return arr.sort().reverse();\n    } else {\n        // return sorted(arr)\n        return arr.sort();\n    }\n}\n",
            "export const encrypt = (s) => {\n    // result = []\n    const result = [];\n    // for ch in s:\n    for (const ch of s) {\n        // shifted = ord(ch) + 4\n        const shifted = ch.charCodeAt(0) + 4;\n        // if shifted > ord('z'):\n        if (shifted > \"z\".charCodeAt(0)) {\n            // shifted -= 26\n            shifted -= 26;\n        }\n        // result.append(chr(shifted))\n        result.push(String.fromCharCode(shifted));\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\n",
            "export const nextSmallest = (lst) => {\n    // sl = sorted(set(lst))\n    const sl = [...new Set(lst)].sort();\n    // if len(sl) < 2:\n    if (sl.length < 2) {\n        // return None\n        return null;\n    }\n    // return sl[1]\n    return sl[1];\n}\n",
            "export const isBored = (s) => {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    const sentences = re.split(/\\.|\\!|\\?\\s*/, s);\n    // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    return sentences.reduce((acc, sentence) => {\n        if (sentence.length >= 2 && sentence.slice(0, 2) === \"I \") {\n            return acc + 1;\n        }\n        return acc;\n    }, 0);\n}\n",
            "export const anyInt = (x, y, z) => {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if (typeof x === \"number\" && typeof y === \"number\" && typeof z === \"number\") {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if (x + y === z || x + z === y || y + z === x) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const encode = (message) => {\n    // vowels = \"aeiouAEIOU\"\n    const vowels = \"aeiouAEIOU\";\n    // result = []\n    const result = [];\n    // for ch in message:\n    for (const ch of message) {\n        // if ch.isalpha():\n        if (/[a-zA-Z]/.test(ch)) {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            const ch1 = ch.toUpperCase() === ch ? ch.toLowerCase() : ch.toUpperCase();\n            // if ch1 in vowels:\n            if (vowels.includes(ch1)) {\n                // ch1 = chr(ord(ch1) + 2)\n                result.push(String.fromCharCode(ch1.charCodeAt(0) + 2));\n            } else {\n                // result.append(ch1)\n                result.push(ch1);\n            }\n        } else {\n            // result.append(ch)\n            result.push(ch);\n        }\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\n",
            "export const isPrime = (n) => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const skjkasdkd = (lst) => {\n    // primes = [n for n in lst if is_prime(n)]\n    const primes = lst.filter(isPrime);\n    // if len(primes) == 0:\n    if (primes.length === 0) {\n        // return 0\n        return 0;\n    }\n    // largest = str(max(primes))\n    const largest = String(Math.max(...primes));\n    // return sum(int(digit) for digit in largest)\n    return largest.split(\"\").reduce((acc, digit) => acc + parseInt(digit), 0);\n}\n",
            "export const checkDictCase = (d) => {\n    // if not d:\n    if (!d) {\n        // return False\n        return false;\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    return Object.keys(d).every((c) => c.toLowerCase() === c) || Object.keys(d).every((c) => c.toUpperCase() === c);\n}\n",
            "export const countUpTo = (n) => {\n    // primes = []\n    const primes = [];\n    // for num in range(2, n):\n    for (let num = 2; num < n; num++) {\n        // if all(num % p != 0 for p in primes):\n        if (primes.every(p => num % p !== 0)) {\n            // primes.append(num)\n            primes.push(num);\n        }\n    }\n    // return primes\n    return primes;\n}\n",
            "export const multiply = (a, b) => {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    return Math.abs(a) % 10 * Math.abs(b) % 10;\n}\n",
            "export const countUpper = (s) => {\n    // vowels = \"AEIOU\"\n    const vowels = \"AEIOU\";\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    return [...s].filter((c, i) => i % 2 === 0 && vowels.includes(c)).length;\n}\n",
            "export const closestInteger = (value) => {\n    // num = float(value)\n    const num = parseFloat(value);\n    // if num >= 0:\n    if (num >= 0) {\n        // return int(num + 0.5)\n        return Math.round(num);\n    } else {\n        // return int(num - 0.5)\n        return Math.round(num - 0.5);\n    }\n}\n",
            "export const makeAPile = (n) => {\n    // return [n + 2 * i for i in range(n)]\n    return Array.from({ length: n }, (_, i) => n + 2 * i);\n}\n",
            "export const wordsString = (s) => {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    return re.split(r\"[, ]\", s).filter((w) => w.length > 0);\n}\n",
            "export const chooseNum = (x, y) => {\n    // if x > y:\n    if (x > y) {\n        // return -1\n        return -1;\n    }\n    // if y % 2 == 0:\n    if (y % 2 === 0) {\n        // return y\n        return y;\n    }\n    // return y - 1 if x != y else -1\n    return x !== y ? y - 1 : -1;\n}\n",
            "export const roundedAvg = (n, m) => {\n    // if n > m:\n    if (n > m) {\n        // return None\n        return null;\n    }\n    // r_avg = int((m + n) / 2.0 + 0.5)\n    const rAvg = Math.floor((m + n) / 2.0 + 0.5);\n    // return bin(r_avg)[2:]\n    return rAvg.toString(2).slice(1);\n}\n",
            "export const allDigitsOdd = (s) => {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    return [...s].every((digit) => digit.charCodeAt(0) % 2 !== 0);\n}\nexport const uniqueDigits = (x) => {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    return [...x].filter((num) => allDigitsOdd(num.toString())).sort((a, b) => a - b);\n}\n",
            "const digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\nexport const byLength = (arr) => {\n    // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n    const sortedArr = arr.filter(x => 1 <= x && x <= 9).sort((a, b) => b - a);\n    // return [digit_names[x-1] for x in sorted_arr]\n    return sortedArr.map(x => digitNames[x - 1]);\n}\n",
            "export const f = (n) => {\n    // nums = list(range(1, n + 1))\n    const nums = Array.from({ length: n + 1 }, (_, i) => i + 1);\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    return nums.map((i) => {\n        if (i % 2 !== 0) {\n            return nums.slice(0, i).reduce((a, b) => a + b, 0);\n        }\n        return nums.slice(0, i).reduce((a, b) => a * b, 1);\n    });\n}\n",
            "export const evenOddPalindrome = (n) => {\n    // cnt = [0, 0]\n    const cnt = [0, 0];\n    // for i in range(1, n + 1):\n    for (let i = 1; i <= n; i++) {\n        // if is_palindrome(str(i)):\n        if (isPalindrome(i.toString())) {\n            // cnt[i % 2] += 1\n            cnt[i % 2] += 1;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "export const digitsSum = (n) => {\n    // n_str = str(n)\n    const nStr = n.toString();\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.split(\"\").reduce((acc, cur) => acc + parseInt(cur), 0);\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return parseInt(nStr.slice(0, 2)) * 2 + digitsSum(Math.abs(n));\n    }\n}\nexport const countNums = (arr) => {\n    // return len([n for n in arr if digits_sum(n) > 0])\n    return arr.filter((n) => digitsSum(n) > 0).length;\n}\n",
            "export const moveOneBall = (arr) => {\n    // if len(arr) == 0:\n    if (arr.length === 0) {\n        // return True\n        return true;\n    }\n    // sorted_arr = sorted(arr)\n    const sortedArr = arr.slice().sort((a, b) => a - b);\n    // for i in range(0, len(arr)):\n    for (let i = 0; i < arr.length; i++) {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if (arr.slice(i).join(\"\") === sortedArr.slice(0, arr.length - i).join(\"\") && arr.slice(0, i).join(\"\") === sortedArr.slice(arr.length - i).join(\"\")) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const canExchange = (lst1, lst2) => {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    const oddCnt = lst1.filter(num => num % 2 !== 0).length;\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    const evenCnt = lst2.filter(num => num % 2 === 0).length;\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    return evenCnt >= oddCnt ? \"YES\" : \"NO\";\n}\n",
            "export const histogram = (test) => {\n    // freq = {}\n    const freq = {};\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    const words = test.split(\" \").filter((w) => w.length > 0);\n    // for w in words:\n    for (const w of words) {\n        // freq[w] = freq.get(w, 0) + 1\n        freq[w] = (freq[w] || 0) + 1;\n    }\n    // result = {}\n    const result = {};\n    // if len(freq) > 0:\n    if (Object.keys(freq).length > 0) {\n        // max_freq = max(freq.values())\n        const maxFreq = Math.max(...Object.values(freq));\n        // for k, v in freq.items():\n        for (const [k, v] of Object.entries(freq)) {\n            // if v == max_freq:\n            if (v === maxFreq) {\n                // result[k] = v\n                result[k] = v;\n            }\n        }\n    }\n    // return result\n    return result;\n}\n",
            "export const isPalindrome = (s) => {\n    // return s == s[::-1]\n    return s === s.split(\"\").reverse().join(\"\");\n}\nexport const reverseDelete = (s, c) => {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    const s1 = s.split(\"\").filter((ch) => !c.includes(ch)).join(\"\");\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    return [s1, isPalindrome(s1) ? \"yes\" : \"no\"];\n}\n",
            "export const oddCount = (lst) => {\n    // result = []\n    const result = [];\n    // for num in lst:\n    for (const num of lst) {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        const n = [...num].reduce((acc, d) => acc + (d.charCodeAt(0) % 2 === 1 ? 1 : 0), 0);\n        // rs = \"the number of odd elements in the string i of the input.\"\n        const rs = \"the number of odd elements in the string i of the input.\";\n        // result.append(rs.replace(\"i\", str(n)))\n        result.push(rs.replace(\"i\", String(n)));\n    }\n    // return result\n    return result;\n}\n",
            "export const minSubArraySum = (nums) => {\n    // min_sum = 0\n    let minSum = 0;\n    // cur_sum = 0\n    let curSum = 0;\n    // for n in nums:\n    for (const n of nums) {\n        // cur_sum = min(cur_sum + n, 0)\n        curSum = Math.min(curSum + n, 0);\n        // min_sum = min(cur_sum, min_sum)\n        minSum = Math.min(curSum, minSum);\n    }\n    // if min_sum == 0:\n    if (minSum === 0) {\n        // min_sum = min(nums)\n        minSum = Math.min(...nums);\n    }\n    // return min_sum\n    return minSum;\n}\n",
            "export const maxFill = (grid, capacity) => {\n    // return sum([ceil(sum(arr) / capacity) for arr in grid])\n    return grid.reduce((acc, arr) => acc + ceil(arr.reduce((a, b) => a + b) / capacity), 0);\n}\n",
            "export const countOnes = (num) => {\n    // return bin(num).count(\"1\")\n    return bin(num).split(\"\").filter((x) => x === \"1\").length;\n}\nexport const sortArray = (arr) => {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    return arr.sort((a, b) => {\n        const aCount = countOnes(a);\n        const bCount = countOnes(b);\n        if (aCount === bCount) {\n            return a - b;\n        }\n        return aCount - bCount;\n    });\n}\n",
            "const consonants = \"bcdfghjklmnpqrstvwxyz\";\nexport const selectWords = (s, n) => {\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    const words = s.split(\" \").filter(w => w.length > 0);\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    return words.filter(w => [...w].filter(c => consonants.includes(c.toLowerCase())).length === n);\n}\n",
            "export const getClosestVowel = (word) => {\n    // vowels = \"aeiouAEIOU\"\n    const vowels = \"aeiouAEIOU\";\n    // for i in range(len(word) - 2, 0, -1):\n    for (let i = word.length - 2; i >= 0; i--) {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if (vowels.includes(word[i]) && !vowels.includes(word[i - 1]) && !vowels.includes(word[i + 1])) {\n            // return word[i]\n            return word[i];\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "export const check = (s) => {\n    // depth = 0\n    let depth = 0;\n    // for ch in s:\n    for (const ch of s) {\n        // if ch == \"(\":\n        if (ch === \"(\") {\n            // depth += 1\n            depth += 1;\n        } else {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True if depth == 0 else False\n    return depth === 0;\n}\nexport const matchParens = (lst) => {\n    // s1 = lst[0] + lst[1]\n    const s1 = lst[0] + lst[1];\n    // s2 = lst[1] + lst[0]\n    const s2 = lst[1] + lst[0];\n    // return \"Yes\" if check(s1) or check(s2) else \"No\"\n    return check(s1) || check(s2) ? \"Yes\" : \"No\";\n}\n",
            "export const maximum = (arr, k) => {\n    // if k == 0:\n    if (k === 0) {\n        // return []\n        return [];\n    }\n    // return sorted(arr)[-k:]\n    return arr.sort().slice(-k);\n}\n",
            "export const solution = (lst) => {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    return lst.reduce((acc, x, i) => {\n        if (i % 2 === 0 && x % 2 !== 0) {\n            return acc + x;\n        }\n        return acc;\n    }, 0);\n}\n",
            "export const addElements = (arr, k) => {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    return arr.slice(0, k).reduce((acc, n) => {\n        return acc + (n.toString().length <= 2 ? n : 0);\n    }, 0);\n}\n",
            "export const getOddCollatz = (n) => {\n    // collatz = [1]\n    const collatz = [1];\n    // while n != 1:\n    while (n !== 1) {\n        // if n % 2 != 0:\n        if (n % 2 !== 0) {\n            // collatz.append(n)\n            collatz.push(n);\n            // n = 3 * n + 1\n            n = 3 * n + 1;\n        } else {\n            // n = n // 2\n            n = n / 2;\n        }\n    }\n    // return sorted(collatz)\n    return collatz.sort();\n}\n",
            "export const validDate = (date) => {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if (date.length !== 10 || date[2] !== \"-\" || date[5] !== \"-\") {\n        return false;\n    }\n    // m = int(date[:2])\n    const m = parseInt(date.slice(0, 2));\n    // d = int(date[3:5])\n    const d = parseInt(date.slice(3, 5));\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if ([1, 3, 5, 7, 8, 10, 12].includes(m) && d >= 1 && d <= 31) {\n        return true;\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if ([4, 6, 9, 11].includes(m) && d >= 1 && d <= 30) {\n        return true;\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if (m === 2 && d >= 1 && d <= 29) {\n        return true;\n    }\n    // return False\n    return false;\n}\n",
            "export const splitWords = (txt) => {\n    // if \" \" in txt:\n    if (txt.includes(\" \")) {\n        // return txt.split(\" \")\n        return txt.split(\" \");\n    }\n    // elif \",\" in txt:\n    else if (txt.includes(\",\")) {\n        // return txt.split(\",\")\n        return txt.split(\",\");\n    }\n    // else:\n    else {\n        // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        return [String(txt.split(\"\").filter(c => c.toLowerCase() && c.charCodeAt(0) % 2 === 0).length)];\n    }\n}\n",
            "export const isSorted = (lst) => {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    if (!lst.every((e, i) => i === 0 || lst[i - 1] <= e)) {\n        return false;\n    }\n    // freq = {}\n    const freq = {};\n    // for i in lst:\n    for (const i of lst) {\n        // freq[i] = freq.get(i, 0) + 1\n        freq[i] = (freq[i] || 0) + 1;\n    }\n    // return max(freq.values(), default=0) <= 2\n    return Math.max(...Object.values(freq)) <= 2;\n}\n",
            "export const isPrime = (n) => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const intersection = (interval1, interval2) => {\n    // l = max(interval1[0], interval2[0])\n    const l = Math.max(interval1[0], interval2[0]);\n    // r = min(interval1[1], interval2[1])\n    const r = Math.min(interval1[1], interval2[1]);\n    // length = r - l\n    const length = r - l;\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n}\n",
            "export const prodSigns = (arr) => {\n    // if not arr:\n    if (!arr) {\n        // return None\n        return null;\n    }\n    // if 0 in arr:\n    if (arr.includes(0)) {\n        // return 0\n        return 0;\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    const sign = [...arr].filter(n => n < 0).length % 2 === 1 ? -1 : 1;\n    // return sign * sum([abs(n) for n in arr])\n    return sign * [...arr].map(Math.abs).reduce((a, b) => a + b);\n}\n",
            "export const minPath = (grid, k) => {\n    // n = len(grid)\n    const n = grid.length;\n    // min_val = n * n + 1\n    let min_val = n * n + 1;\n    // for i in range(n):\n    for (let i = 0; i < n; i++) {\n        // for j in range(n):\n        for (let j = 0; j < n; j++) {\n            // if grid[i][j] == 1:\n            if (grid[i][j] === 1) {\n                // temp = []\n                const temp = [];\n                // if i != 0:\n                if (i !== 0) {\n                    // temp.append(grid[i - 1][j])\n                    temp.push(grid[i - 1][j]);\n                }\n                // if j != 0:\n                if (j !== 0) {\n                    // temp.append(grid[i][j - 1])\n                    temp.push(grid[i][j - 1]);\n                }\n                // if i != n - 1:\n                if (i !== n - 1) {\n                    // temp.append(grid[i + 1][j])\n                    temp.push(grid[i + 1][j]);\n                }\n                // if j != n - 1:\n                if (j !== n - 1) {\n                    // temp.append(grid[i][j + 1])\n                    temp.push(grid[i][j + 1]);\n                }\n                // min_val = min(temp)\n                min_val = Math.min(...temp);\n            }\n        }\n    }\n    // result = []\n    const result = [];\n    // for i in range(k):\n    for (let i = 0; i < k; i++) {\n        // result.append(1 if i % 2 == 0 else min_val)\n        result.push(i % 2 === 0 ? 1 : min_val);\n    }\n    // return result\n    return result;\n}\n",
            "export const tri = (n) => {\n    // if n == 0:\n    if (n === 0) {\n        // return [1]\n        return [1];\n    }\n    // seq = [1, 3]\n    const seq = [1, 3];\n    // for i in range(2, n + 1):\n    for (let i = 2; i <= n + 1; i++) {\n        // if i % 2 == 0:\n        if (i % 2 === 0) {\n            // seq.append(i / 2 + 1)\n            seq.push(i / 2 + 1);\n        } else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq.push(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n        }\n    }\n    // return seq\n    return seq;\n}\n",
            "export const digits = (n) => {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    const odds = [parseInt(d) for (const d of String(n)) if (parseInt(d) % 2 === 1)];\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    return odds.reduce((x, y) => x * y, 1) if (odds.length > 0) else 0;\n}\n",
            "export const isNested = (s) => {\n    // open_idx = []\n    const openIdx = [];\n    // close_idx = []\n    const closeIdx = [];\n    // for i, ch in enumerate(s):\n    for (let i = 0; i < s.length; i++) {\n        const ch = s[i];\n        // if ch == '[':\n        if (ch === \"[\") {\n            // open_idx.append(i)\n            openIdx.push(i);\n        }\n        // elif ch == ']':\n        else if (ch === \"]\") {\n            // close_idx.append(i)\n            closeIdx.push(i);\n        }\n    }\n    // close_idx.reverse()\n    closeIdx.reverse();\n    // cnt = 0\n    let cnt = 0;\n    // i = 0\n    let i = 0;\n    // l = len(close_idx)\n    const l = closeIdx.length;\n    // for idx in open_idx:\n    for (const idx of openIdx) {\n        // if i < l and idx < close_idx[i]:\n        if (i < l && idx < closeIdx[i]) {\n            // cnt += 1\n            cnt += 1;\n            // i += 1\n            i += 1;\n        }\n    }\n    // return cnt >= 2\n    return cnt >= 2;\n}\n",
            "export const sumSquares = (lst) => {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    return lst.reduce((acc, n) => acc + Math.pow(Math.ceil(n), 2), 0);\n}\n",
            "export const checkIfLastCharIsALetter = (txt) => {\n    // if not txt:\n    if (!txt) {\n        // return False\n        return false;\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    const last = txt.slice(txt.lastIndexOf(\" \") + 1);\n    // return len(last) == 1 and last[0].isalpha()\n    return last.length === 1 && last[0].isalpha();\n}\n",
            "export const canArrange = (arr) => {\n    // if len (arr) <= 1:\n    if (arr.length <= 1) {\n        // return -1\n        return -1;\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    const idx = [];\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] < arr[i - 1]) {\n            idx.push(i);\n        }\n    }\n    // return max(idx, default=-1)\n    return Math.max(...idx, -1);\n}\n",
            "export const largestSmallestIntegers = (lst) => {\n    // neg = [i for i in lst if i < 0]\n    const neg = lst.filter((i) => i < 0);\n    // pos = [i for i in lst if i > 0]\n    const pos = lst.filter((i) => i > 0);\n    // max_neg = max(neg) if len(neg) > 0 else None\n    const maxNeg = neg.length > 0 ? Math.max(...neg) : null;\n    // min_pos = min(pos) if len(pos) > 0 else None\n    const minPos = pos.length > 0 ? Math.min(...pos) : null;\n    // return [max_neg, min_pos]\n    return [maxNeg, minPos];\n}\n",
            "export const anyToReal = (o) => {\n    if (isString(o)) {\n        return parseFloat(o.replace(\",\", \".\"));\n    }\n    else if (isNumber(o)) {\n        return parseFloat(o);\n    }\n    else if (isFloat(o)) {\n        return o;\n    }\n    throw new Error(\"Type Error\");\n}\nexport const compareOne = (a, b) => {\n    const a1 = anyToReal(a);\n    const b1 = anyToReal(b);\n    if (a1 === b1) {\n        return null;\n    }\n    else if (a1 > b1) {\n        return a1;\n    }\n    else {\n        return b1;\n    }\n}\n",
            "export const isEqualToSumEven = (n) => {\n    // return n % 2 == 0 and n >= 8\n    return n % 2 === 0 && n >= 8;\n}\n",
            "export const specialFactorial = (n) => {\n    // fact = 1\n    let fact = 1;\n    // result = 1\n    let result = 1;\n    // for i in range(1, n + 1):\n    for (let i = 1; i <= n; i++) {\n        // fact *= i\n        fact *= i;\n        // result *= fact\n        result *= fact;\n    }\n    // return result\n    return result;\n}\n",
            "export const fixSpaces = (txt) => {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    return re.sub(/\\s{3,}/, \"-\", txt).replace(\" \", \"_\");\n}\n",
            "export const fileNameCheck = (fileName) => {\n    // suf = [\"txt\", \"exe\", \"dll\"]\n    const suf = [\"txt\", \"exe\", \"dll\"];\n    // lst = file_name.split(\".\")\n    const lst = fileName.split(\".\");\n    // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n    if (lst.length !== 2 || !suf.includes(lst[1]) || lst[0].length === 0 || !lst[0][0].isAlpha() || lst[0].split(\"\").filter((x) => x.isDigit()).length > 3) {\n        return \"No\";\n    }\n    // return \"Yes\"\n    return \"Yes\";\n}\n",
            "export const sumSquares = (lst) => {\n    // result = 0\n    let result = 0;\n    // for i in range(len(lst)):\n    for (let i = 0; i < lst.length; i++) {\n        // if i % 3 == 0:\n        if (i % 3 === 0) {\n            // result += pow(lst[i], 2)\n            result += Math.pow(lst[i], 2);\n        }\n        // elif i % 4 == 0:\n        else if (i % 4 === 0) {\n            // result += pow(lst[i], 3)\n            result += Math.pow(lst[i], 3);\n        }\n        // else:\n        else {\n            // result += lst[i]\n            result += lst[i];\n        }\n    }\n    // return result\n    return result;\n}\n",
            "export const isPrime = (n) => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const wordsInSentence = (sentence) => {\n    // words = sentence.split(\" \")\n    const words = sentence.split(\" \");\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    return words.filter(w => isPrime(w.length)).join(\" \");\n}\n",
            "export const simplify = (x, n) => {\n    // xs = x.split(\"/\")\n    const xs = x.split(\"/\");\n    // ns = n.split(\"/\")\n    const ns = n.split(\"/\");\n    // num = int(xs[0]) * int(ns[0])\n    const num = parseInt(xs[0]) * parseInt(ns[0]);\n    // den = int(xs[1]) * int(ns[1])\n    const den = parseInt(xs[1]) * parseInt(ns[1]);\n    // return num % den == 0\n    return num % den === 0;\n}\n",
            "export const digitsSum = (n) => {\n    // n_str = str(n)\n    const nStr = n.toString();\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.split(\"\").reduce((acc, cur) => acc + parseInt(cur), 0);\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return parseInt(nStr.slice(0, 2)) * 2 + digitsSum(Math.abs(n));\n    }\n}\nexport const orderByPoints = (nums) => {\n    // return sorted(nums, key=digits_sum)\n    return nums.sort((a, b) => digitsSum(a) - digitsSum(b));\n}\n",
            "export const specialFilter = (nums) => {\n    // odds = \"13579\"\n    const odds = \"13579\";\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    return nums.filter(n => n > 10 && n % 2 === 1 && odds.includes(n.toString()[0])).length;\n}\n",
            "export const getMaxTriples = (n) => {\n    // c = [0, 0, 0]\n    const c = [0, 0, 0];\n    // for i in range(1, n + 1):\n    for (let i = 1; i <= n; i++) {\n        // a = i * i - i + 1\n        const a = i * i - i + 1;\n        // c[a % 3] += 1\n        c[a % 3] += 1;\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n}\n",
            "export const bf = (planet1, planet2) => {\n    // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    const names = [\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\",\n    ];\n    // if planet1 not in names or planet2 not in names:\n    if (names.indexOf(planet1) === -1 || names.indexOf(planet2) === -1) {\n        return [];\n    }\n    // l = names.index(planet1)\n    let l = names.indexOf(planet1);\n    // r = names.index(planet2)\n    let r = names.indexOf(planet2);\n    // if l > r:\n    if (l > r) {\n        // l, r = r, l\n        [l, r] = [r, l];\n    }\n    // if l == r:\n    if (l === r) {\n        return [];\n    }\n    // return names[l + 1 : r]\n    return names.slice(l + 1, r);\n};\n",
            "export const sortedListSum = (lst) => {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    const result = lst.filter((s) => s.length % 2 === 0);\n    // return sorted(result, key=lambda x: (len(x), x))\n    return result.sort((a, b) => {\n        if (a.length === b.length) {\n            return a.localeCompare(b);\n        }\n        return a.length - b.length;\n    });\n}\n",
            "export const xOrY = (n, x, y) => {\n    // if n < 2:\n    if (n < 2) {\n        // return y\n        return y;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return y\n            return y;\n        }\n    }\n    // return x\n    return x;\n}\n",
            "export const doubleTheDifference = (lst) => {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    return lst.reduce((acc, n) => {\n        if (n >= 0 && n % 2 === 1) {\n            return acc + n * n;\n        }\n        return acc;\n    }, 0);\n}\n",
            "export const compare = (game, guess) => {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    return game.map((x, i) => Math.abs(x - guess[i]));\n}\n",
            "export const strongestExtension = (className, extensions) => {\n    // max_s = float(\"-inf\")\n    let maxS = Number.NEGATIVE_INFINITY;\n    // max_ext = \"\"\n    let maxExt = \"\";\n    // for ext in extensions:\n    for (const ext of extensions) {\n        // upper = len([c for c in ext if c.isupper()])\n        const upper = [...ext].filter(c => c.toUpperCase() === c).length;\n        // lower = len([c for c in ext if c.islower()])\n        const lower = [...ext].filter(c => c.toLowerCase() === c).length;\n        // s = upper - lower\n        const s = upper - lower;\n        // if s > max_s:\n        if (s > maxS) {\n            // max_s = s\n            maxS = s;\n            // max_ext = ext\n            maxExt = ext;\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    return `${className}.${maxExt}`;\n}\n",
            "export const cycpatternCheck = (a, b) => {\n    // if len(a) < len(b):\n    if (a.length < b.length) {\n        // return False\n        return false;\n    }\n    // for i in range(len(b)):\n    for (let i = 0; i < b.length; i++) {\n        // if b[i:] + b[:i] in a:\n        if (a.includes(b.slice(i) + b.slice(0, i))) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const evenOddCount = (num) => {\n    // ds = str(abs(num))\n    const ds = String(Math.abs(num));\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    const even = [...ds].filter((d) => d.charCodeAt(0) % 2 === 0).length;\n    // return [even, len(ds) - even]\n    return [even, ds.length - even];\n}\n",
            "export const intToMiniRoman = (num) => {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    const numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    // res = []\n    const res = [];\n    // for i in range(len(values)):\n    for (let i = 0; i < values.length; i++) {\n        // while num >= values[i]:\n        while (num >= values[i]) {\n            // res.append(numerals[i])\n            res.push(numerals[i]);\n            // num -= values[i]\n            num -= values[i];\n        }\n    }\n    // return \"\".join(res)\n    return res.join(\"\");\n}\n",
            "export const rightAngleTriangle = (a, b, c) => {\n    // s = sorted([a, b, c])\n    const s = [a, b, c].sort((a, b) => a - b);\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] === s[2] * s[2];\n}\n",
            "export const findMax = (words) => {\n    // max_cnt = 0\n    let maxCnt = 0;\n    // max_w = \"\"\n    let maxW = \"\";\n    // for w in words:\n    for (const w of words) {\n        // cnt = len(set(w))\n        const cnt = [...new Set(w)].length;\n        // if cnt > max_cnt:\n        if (cnt > maxCnt) {\n            // max_cnt = cnt\n            maxCnt = cnt;\n            // max_w = w\n            maxW = w;\n        }\n        // elif cnt == max_cnt:\n        else if (cnt === maxCnt) {\n            // max_w = min(max_w, w)\n            maxW = Math.min(maxW, w);\n        }\n    }\n    // return max_w\n    return maxW;\n}\n",
            "export const eat = (num, need, remaining) => {\n    // if need <= remaining:\n    if (need <= remaining) {\n        // return [num + need, remaining - need]\n        return [num + need, remaining - need];\n    } else {\n        // return [num + remaining, 0]\n        return [num + remaining, 0];\n    }\n}\n",
            "export const doAlgebra = (operators, operands) => {\n    // ops = operators.copy()\n    const ops = [...operators];\n    // nums = operands.copy()\n    const nums = [...operands];\n    // i = len(ops) - 1\n    let i = ops.length - 1;\n    // while i >= 0:\n    while (i >= 0) {\n        // if ops[i] == \"**\":\n        if (ops[i] === \"**\") {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            nums[i] = Math.pow(nums[i], nums[i + 1]);\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n        }\n        // i -= 1\n        i -= 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while (i < ops.length) {\n        // if ops[i] == \"*\":\n        if (ops[i] === \"*\") {\n            // nums[i] = nums[i] * nums[i + 1]\n            nums[i] = nums[i] * nums[i + 1];\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"//\":\n        else if (ops[i] === \"//\") {\n            // nums[i] = nums[i] // nums[i + 1]\n            nums[i] = Math.floor(nums[i] / nums[i + 1]);\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while (i < ops.length) {\n        // if ops[i] == \"+\":\n        if (ops[i] === \"+\") {\n            // nums[i] = nums[i] + nums[i + 1]\n            nums[i] = nums[i] + nums[i + 1];\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"-\":\n        else if (ops[i] === \"-\") {\n            // nums[i] = nums[i] - nums[i + 1]\n            nums[i] = nums[i] - nums[i + 1];\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // return nums[0]\n    return nums[0];\n}\n",
            "export const solve = (s) => {\n    // if not any(ch.isalpha() for ch in s):\n    if (!s.split(\"\").some((ch) => ch.match(/[a-zA-Z]/))) {\n        // return s[::-1]\n        return s.split(\"\").reverse().join(\"\");\n    }\n    // result = []\n    const result = [];\n    // for ch in s:\n    for (const ch of s) {\n        // if not ch.isalpha():\n        if (!ch.match(/[a-zA-Z]/)) {\n            // result.append(ch)\n            result.push(ch);\n        }\n        // elif ch.isupper():\n        else if (ch.match(/[A-Z]/)) {\n            // result.append(ch.lower())\n            result.push(ch.toLowerCase());\n        }\n        // elif ch.islower():\n        else if (ch.match(/[a-z]/)) {\n            // result.append(ch.upper())\n            result.push(ch.toUpperCase());\n        }\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\n",
            "export const stringToMd5 = (txt) => {\n    // if not txt:\n    if (!txt) {\n        // return None\n        return null;\n    }\n    // md5_hash = hashlib.md5()\n    const md5_hash = crypto.createHash(\"md5\");\n    // txt_bytes = txt.encode()\n    const txt_bytes = Buffer.from(txt);\n    // md5_hash.update(txt_bytes)\n    md5_hash.update(txt_bytes);\n    // md5_encoded = md5_hash.hexdigest()\n    const md5_encoded = md5_hash.digest(\"hex\");\n    // return md5_encoded\n    return md5_encoded;\n}\n",
            "export const generateIntegers = (a, b) => {\n    // lower = max(2, min(a, b))\n    const lower = Math.max(2, Math.min(a, b));\n    // upper = min(8, max(a, b))\n    const upper = Math.min(8, Math.max(a, b));\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    return Array.from(Array(upper - lower + 1).keys()).map(i => i + lower).filter(i => i % 2 === 0);\n}\n"
        ],
        "kotlin": [
            "fun hasCloseElements(numbers: List<Float>, threshold: Float): Boolean {\n    // for i in range(len(numbers)):\n    for (i in numbers.indices) {\n        // for j in range(i + 1, len(numbers)):\n        for (j in i + 1 until numbers.size) {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                // return True\n                return true\n            }\n        }\n    }\n    // return False\n    return false\n}\n",
            "fun separateParenGroups(parenString: String): List<String> {\n    // groups = []\n    val groups = mutableListOf<String>()\n    // stk = []\n    val stk = mutableListOf<Char>()\n    // current_group = \"\"\n    var currentGroup = \"\"\n    // parens = paren_string.replace(\" \", \"\")\n    val parens = parenString.replace(\" \", \"\")\n    // for ch in parens:\n    for (ch in parens) {\n        // if ch == \"(\":\n        if (ch == '(') {\n            // stk.append(ch)\n            stk.add(ch)\n            // current_group += ch\n            currentGroup += ch\n        }\n        // elif ch == \")\":\n        else if (ch == ')') {\n            // stk.pop()\n            stk.removeAt(stk.lastIndex)\n            // current_group += ch\n            currentGroup += ch\n            // if not stk:\n            if (stk.isEmpty()) {\n                // groups.append(current_group)\n                groups.add(currentGroup)\n                // current_group = \"\"\n                currentGroup = \"\"\n            }\n        }\n    }\n    // return groups\n    return groups\n}\n",
            "fun truncateNumber(num: Float): Float {\n    // return num - floor(num)\n    return num - floor(num)\n}\n",
            "fun belowZero(operations: List<Int>): Boolean {\n    // balance = 0\n    var balance = 0\n    // for op in operations:\n    for (op in operations) {\n        // balance += op\n        balance += op\n        // if balance < 0:\n        if (balance < 0) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "fun meanAbsoluteDeviation(numbers: List<Float>): Float {\n    // mean = sum(numbers) / len(numbers)\n    val mean = numbers.sum() / numbers.size\n    // deviation = sum(abs(x - mean) for x in numbers)\n    val deviation = numbers.sumByDouble { abs(it - mean) }\n    // return deviation / len(numbers)\n    return deviation / numbers.size\n}\n",
            "fun intersperse(numbers: List<Int>, delimiter: Int): List<Int> {\n    // result = []\n    val result = mutableListOf<Int>()\n    // for i in range(len(numbers)):\n    for (i in numbers.indices) {\n        // if i != 0:\n        if (i != 0) {\n            // result.append(delimiter)\n            result.add(delimiter)\n        }\n        // result.append(numbers[i])\n        result.add(numbers[i])\n    }\n    // return result\n    return result\n}\n",
            "fun parseNestedParens(parenString: String): List<Int> {\n    // result = []\n    val result = mutableListOf<Int>()\n    // paren_groups = paren_string.split()\n    val parenGroups = parenString.split(\" \")\n    // for group in paren_groups:\n    for (group in parenGroups) {\n        // max_depth = 0\n        var maxDepth = 0\n        // depth = 0\n        var depth = 0\n        // for ch in group:\n        for (ch in group) {\n            // if ch == \"(\":\n            if (ch == \"(\") {\n                // depth += 1\n                depth += 1\n                // max_depth = max(max_depth, depth)\n                maxDepth = maxOf(maxDepth, depth)\n            }\n            // elif ch == \")\":\n            else if (ch == \")\") {\n                // depth -= 1\n                depth -= 1\n            }\n        }\n        // result.append(max_depth)\n        result.add(maxDepth)\n    }\n    // return result\n    return result\n}\n",
            "fun filterBySubstring(strs: List<String>, substring: String): List<String> {\n    // return [s for s in strs if substring in s]\n    return strs.filter { substring in it }\n}\n",
            "fun sumProduct(numbers: List<Int>): List<Int> {\n    // n_sum = sum(numbers)\n    val nSum = numbers.sum()\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    val nProduct = numbers.reduce { x, y -> x * y }\n    // return [n_sum, n_product]\n    return listOf(nSum, nProduct)\n}\n",
            "fun rollingMax(numbers: List<Int>): List<Int> {\n    // max_so_far = float(\"-inf\")\n    var maxSoFar = Double.NEGATIVE_INFINITY\n    // result = []\n    val result = mutableListOf<Int>()\n    // for num in numbers:\n    for (num in numbers) {\n        // max_so_far = max(max_so_far, num)\n        maxSoFar = maxOf(maxSoFar, num.toDouble())\n        // result.append(max_so_far)\n        result.add(maxSoFar.toInt())\n    }\n    // return result\n    return result\n}\n",
            "fun isPalindrome(s: String): Boolean {\n    // return s == s[::-1]\n    return s == s.reversed()\n}\nfun makePalindrome(s: String): String {\n    // if is_palindrome(s):\n    if (isPalindrome(s)) {\n        // return s\n        return s\n    }\n    // for i in range(len(s)):\n    for (i in 0 until s.length) {\n        // if is_palindrome(s[i:]):\n        if (isPalindrome(s.substring(i))) {\n            // return s + s[:i][::-1]\n            return s + s.substring(0, i).reversed()\n        }\n    }\n    // return \"\"\n    return \"\"\n}\n",
            "fun stringXor(a: String, b: String): String {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    return a.zip(b).joinToString(\"\") { if (it.first == it.second) \"0\" else \"1\" }\n}\n",
            "fun longest(strs: List<String>): String? {\n    // if not strs:\n    if (strs.isEmpty()) {\n        // return None\n        return null\n    }\n    // longest_s = strs[0]\n    var longestS = strs[0]\n    // for s in strs:\n    for (s in strs) {\n        // if len(s) > len(longest_s):\n        if (s.length > longestS.length) {\n            // longest_s = s\n            longestS = s\n        }\n    }\n    // return longest_s\n    return longestS\n}\n",
            "fun greatestCommonDivisor(a: Int, b: Int): Int {\n    // if b == 0:\n    if (b == 0) {\n        // return a\n        return a\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        return greatestCommonDivisor(b, a % b)\n    }\n}\n",
            "fun allPrefixes(s: String): List<String> {\n    // prefixes = []\n    val prefixes = mutableListOf<String>()\n    // for i in range(len(s)):\n    for (i in 0 until s.length) {\n        // prefixes.append(s[: i + 1])\n        prefixes.add(s.substring(0, i + 1))\n    }\n    // return prefixes\n    return prefixes\n}\n",
            "fun stringSequence(n: Int): String {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    return (0..n).joinToString(\" \") { it.toString() }\n}\n",
            "fun countDistinctCharacters(s: String): Int {\n    // return len(set(s.lower()))\n    return s.toLowerCase().toSet().size\n}\n",
            "fun parseMusic(musicString: String): List<Int> {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    val durations = mapOf(\"o\" to 4, \"o|\" to 2, \".|\" to 1)\n    // notes = music_string.split()\n    val notes = musicString.split(\" \")\n    // return [durations[note] for note in notes]\n    return notes.map { durations[it]!! }\n}\n",
            "fun howManyTimes(s: String, substring: String): Int {\n    // times = 0\n    var times = 0\n    // for i in range(len(s) - len(substring) + 1):\n    for (i in 0 until s.length - substring.length + 1) {\n        // if s[i : i + len(substring)] == substring:\n        if (s.substring(i, i + substring.length) == substring) {\n            // times += 1\n            times += 1\n        }\n    }\n    // return times\n    return times\n}\n",
            "fun sortNumbers(numbers: String): String {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    val numDict = mapOf(\n        \"zero\" to 0,\n        \"one\" to 1,\n        \"two\" to 2,\n        \"three\" to 3,\n        \"four\" to 4,\n        \"five\" to 5,\n        \"six\" to 6,\n        \"seven\" to 7,\n        \"eight\" to 8,\n        \"nine\" to 9,\n    )\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    val numList = numbers.split(\" \").filter { numDict.containsKey(it) }\n    // num_list.sort(key=lambda x: num_dict[x])\n    numList.sortBy { numDict[it] }\n    // return \" \".join(num_list)\n    return numList.joinToString(\" \")\n}\n",
            "fun findClosestElements(numbers: List<Float>): List<Float> {\n    // sorted_numbers = sorted(numbers)\n    val sortedNumbers = numbers.sorted()\n    // min_diff = float(\"inf\")\n    var minDiff = Float.POSITIVE_INFINITY\n    // closest_pair = []\n    var closestPair = mutableListOf<Float>()\n    // for i in range(1, len(sorted_numbers)):\n    for (i in 1 until sortedNumbers.size) {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        val diff = sortedNumbers[i] - sortedNumbers[i - 1]\n        // if diff < min_diff:\n        if (diff < minDiff) {\n            // min_diff = diff\n            minDiff = diff\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closestPair = mutableListOf(sortedNumbers[i - 1], sortedNumbers[i])\n        }\n    }\n    // return closest_pair\n    return closestPair\n}\n",
            "fun rescaleToUnit(numbers: List<Float>): List<Float> {\n    // min_num = min(numbers)\n    val minNum = numbers.min() ?: 0.0f\n    // max_num = max(numbers)\n    val maxNum = numbers.max() ?: 0.0f\n    // if min_num == max_num:\n    if (minNum == maxNum) {\n        // return [0.0] * len(numbers)\n        return List(numbers.size) { 0.0f }\n    } else {\n        // return [(num - min_num) / (max_num - min_num) for num in numbers]\n        return numbers.map { (it - minNum) / (maxNum - minNum) }\n    }\n}\n",
            "fun filterIntegers(values: List<Any>): List<Int> {\n    // return [x for x in values if isinstance(x, int)]\n    return values.filter { it is Int }\n}\n",
            "fun strLength(s: String): Int {\n    // return len(s)\n    return s.length\n}\n",
            "fun largestDivisor(n: Int): Int {\n    // for i in range(2, n):\n    for (i in 2..n) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return n // i\n            return n / i\n        }\n    }\n    // return 1\n    return 1\n}\n",
            "fun factorize(n: Int): List<Int> {\n    // factors = []\n    val factors = mutableListOf<Int>()\n    // divisor = 2\n    var divisor = 2\n    // while divisor <= n:\n    while (divisor <= n) {\n        // if n % divisor == 0:\n        if (n % divisor == 0) {\n            // factors.append(divisor)\n            factors.add(divisor)\n            // n //= divisor\n            n /= divisor\n        } else {\n            // divisor += 1\n            divisor++\n        }\n    }\n    // return factors\n    return factors\n}\n",
            "fun removeDuplicates(numbers: List<Int>): List<Int> {\n    // counts = {}\n    val counts = mutableMapOf<Int, Int>()\n    // for num in numbers:\n    for (num in numbers) {\n        // counts[num] = counts.get(num, 0) + 1\n        counts[num] = counts.getOrDefault(num, 0) + 1\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    val res = numbers.filter { counts[it] == 1 }\n    // return res\n    return res\n}\n",
            "fun flipCase(s: String): String {\n    // flipped = []\n    val flipped = mutableListOf<Char>()\n    // for ch in s:\n    for (ch in s) {\n        // if not ch.isalpha():\n        if (!ch.isLetter()) {\n            // flipped.append(ch)\n            flipped.add(ch)\n        }\n        // elif ch.islower():\n        else if (ch.isLowerCase()) {\n            // flipped.append(ch.upper())\n            flipped.add(ch.uppercase())\n        }\n        // elif ch.isupper():\n        else if (ch.isUpperCase()) {\n            // flipped.append(ch.lower())\n            flipped.add(ch.lowercase())\n        }\n    }\n    // return ''.join(flipped)\n    return flipped.joinToString(\"\")\n}\n",
            "fun concatenate(strs: List<String>): String {\n    // return \"\".join(strs)\n    return strs.joinToString(\"\")\n}\n",
            "fun filterByPrefix(strs: List<String>, prefixStr: String): List<String> {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    return strs.filter { it.startsWith(prefixStr) }\n}\n",
            "fun getPositive(l: List<Int>): List<Int> {\n    // return [num for num in l if num > 0]\n    return l.filter { it > 0 }\n}\n",
            "fun isPrime(n: Int): Boolean {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i in 2..Math.floor(Math.sqrt(n.toDouble())).toInt() + 1) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\n",
            "fun poly(xs: List<Int>, x: Double): Double {\n    var res = 0.0\n    for (i in xs.indices) {\n        res += xs[i] * x.pow(i)\n    }\n    return res\n}\nfun findZero(xs: List<Int>): Double {\n    var x1 = 1.0\n    var x2 = -1.0\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        x1 *= 2\n        x2 *= 2\n    }\n    while (abs(x1 - x2) > 1e-10) {\n        val mid = (x1 + x2) / 2\n        if (poly(xs, mid) == 0.0) {\n            return mid\n        } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            x2 = mid\n        } else {\n            x1 = mid\n        }\n    }\n    return (x1 + x2) / 2\n}\n",
            "fun sortThird(l: List<Int>): List<Int> {\n    // sorted_third = sorted(l[::3])\n    val sortedThird = l.sorted().filterIndexed { index, _ -> index % 3 == 0 }\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    return l.mapIndexed { index, value -> if (index % 3 == 0) sortedThird[index / 3] else value }\n}\n",
            "fun listUnique(l: List<Int>): List<Int> {\n    // return sorted(list(set(l)))\n    return l.toSet().toList().sorted()\n}\n",
            "fun maxElement(l: List<Int>): Int {\n    // if not l:\n    if (l.isEmpty()) {\n        // return 0\n        return 0\n    }\n    // return max(l)\n    return l.max()!!\n}\n",
            "fun fizzBuzz(n: Int): Int {\n    // cnt = 0\n    var cnt = 0\n    // for i in range(n):\n    for (i in 0 until n) {\n        // if i % 11 == 0 or i % 13 == 0:\n        if (i % 11 == 0 || i % 13 == 0) {\n            // cnt += str(i).count(\"7\")\n            cnt += i.toString().count { it == '7' }\n        }\n    }\n    // return cnt\n    return cnt\n}\n",
            "fun sortEven(l: List<Int>): List<Int> {\n    // sorted_even = sorted(l[::2])\n    val sortedEven = l.filterIndexed { index, _ -> index % 2 == 0 }.sorted()\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    return l.mapIndexed { index, value -> if (index % 2 == 0) sortedEven[index / 2] else value }\n}\n",
            "fun encodeCyclic(s: String): String {\n    // result = []\n    val result = mutableListOf<String>()\n    // for i in range(0, len(s), 3):\n    for (i in 0 until s.length step 3) {\n        // if i + 3 > len(s):\n        if (i + 3 > s.length) {\n            // result.append(s[i:])\n            result.add(s.substring(i))\n        } else {\n            // result.append(s[i+1:i+3])\n            result.add(s.substring(i + 1, i + 3))\n            // result.append(s[i])\n            result.add(s[i].toString())\n        }\n    }\n    // return \"\".join(result)\n    return result.joinToString(\"\")\n}\nfun decodeCyclic(s: String): String {\n    return encodeCyclic(encodeCyclic(s))\n}\n",
            "fun isPrime(n: Int): Boolean {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i in 2..floor(sqrt(n)).toInt() + 1) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfun primeFib(n: Int): Int {\n    // f = [0, 1]\n    var f = listOf(0, 1)\n    // cnt = 0\n    var cnt = 0\n    // while cnt < n:\n    while (cnt < n) {\n        // f = [f[1], f[0] + f[1]]\n        f = listOf(f[1], f[0] + f[1])\n        // if is_prime(f[1]):\n        if (isPrime(f[1])) {\n            // cnt += 1\n            cnt += 1\n        }\n    }\n    // return f[1]\n    return f[1]\n}\n",
            "fun triplesSumToZero(l: List<Int>): Boolean {\n    // for i in range(len(l)):\n    for (i in l.indices) {\n        // for j in range(i + 1, len(l)):\n        for (j in i + 1 until l.size) {\n            // for k in range(j + 1, len(l)):\n            for (k in j + 1 until l.size) {\n                // if l[i] + l[j] + l[k] == 0:\n                if (l[i] + l[j] + l[k] == 0) {\n                    // return True\n                    return true\n                }\n            }\n        }\n    }\n    // return False\n    return false\n}\n",
            "fun carRaceCollision(n: Int): Int {\n    // return n ** 2\n    return n * n\n}\n",
            "fun incrList(l: List<Int>): List<Int> {\n    // return [i + 1 for i in l]\n    return l.map { it + 1 }\n}\n",
            "fun pairsSumToZero(l: List<Int>): Boolean {\n    // seen = set()\n    val seen = mutableSetOf<Int>()\n    // for num in l:\n    for (num in l) {\n        // if -num in seen:\n        if (-num in seen) {\n            // return True\n            return true\n        }\n        // seen.add(num)\n        seen.add(num)\n    }\n    // return False\n    return false\n}\n",
            "fun changeBase(x: Int, bas: Int): String {\n    // if x == 0:\n    if (x == 0) {\n        // return \"0\"\n        return \"0\"\n    }\n    // digits = []\n    val digits = mutableListOf<String>()\n    // while x > 0:\n    while (x > 0) {\n        // digits.append(str(x % bas))\n        digits.add(x % bas)\n        // x //= bas\n        x /= bas\n    }\n    // return \"\".join(digits[::-1])\n    return digits.reversed().joinToString(\"\")\n}\n",
            "fun triangleArea(a: Int, h: Int): Double {\n    // return a * h / 2\n    return a.toDouble() * h / 2\n}\n",
            "fun fib4(n: Int): Int {\n    // fib = [0, 0, 2, 0]\n    val fib = intArrayOf(0, 0, 2, 0)\n    // for i in range(4, n + 1):\n    for (i in 4..n) {\n        // fib[i % 4] = sum(fib)\n        fib[(i % 4)] = fib.sum()\n    }\n    // return fib[n % 4]\n    return fib[n % 4]\n}\n",
            "fun median(l: List<Float>): Float {\n    // sl = sorted(l)\n    val sl = l.sorted()\n    // if len(l) % 2 != 0:\n    if (l.size % 2 != 0) {\n        // return sl[len(l) // 2]\n        return sl[l.size / 2]\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (sl[l.size / 2] + sl[l.size / 2 - 1]) / 2\n    }\n}\n",
            "fun isPalindrome(txt: String): Boolean {\n    // return txt == txt[::-1]\n    return txt == txt.reversed()\n}\n",
            "fun modp(n: Int, p: Int): Int {\n    // ret = 1\n    var ret = 1\n    // for _ in range(n):\n    for (i in 0 until n) {\n        // ret = (ret * 2) % p\n        ret = (ret * 2) % p\n    }\n    // return ret\n    return ret\n}\n",
            "fun encodeShift(s: String): String {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    val result = s.map { (((it.toInt() - 97 + 5) % 26) + 97).toChar() }\n    // return \"\".join(result)\n    return result.joinToString(\"\")\n}\nfun decodeShift(s: String): String {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    val result = s.map { (((it.toInt() - 97 + 21) % 26) + 97).toChar() }\n    // return \"\".join(result)\n    return result.joinToString(\"\")\n}\n",
            "fun removeVowels(txt: String): String {\n    // vowels = \"aeiouAEIOU\"\n    val vowels = \"aeiouAEIOU\"\n    // return \"\".join([char for char in txt if char not in vowels])\n    return txt.filter { !vowels.contains(it) }\n}\n",
            "fun belowThreshold(l: List<Int>, t: Int): Boolean {\n    // return all(x < t for x in l)\n    return l.all { x -> x < t }\n}\n",
            "fun add(x: Int, y: Int): Int {\n    // return x + y\n    return x + y\n}\n",
            "fun sameChars(s0: String, s1: String): Boolean {\n    // return set(s0) == set(s1)\n    return s0.toSet() == s1.toSet()\n}\n",
            "fun fib(n: Int): Int {\n    // if n <= 1:\n    if (n <= 1) {\n        // return n\n        return n\n    } else {\n        // return fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2)\n    }\n}\n",
            "fun correctBracketing(brackets: String): Boolean {\n    // depth = 0\n    var depth = 0\n    // for b in brackets:\n    for (b in brackets) {\n        // if b == \"<\":\n        if (b == '<') {\n            // depth += 1\n            depth += 1\n        }\n        // elif b == \">\":\n        else if (b == '>') {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false\n        }\n    }\n    // return depth == 0\n    return depth == 0\n}\n",
            "fun monotonic(l: List<Int>): Boolean {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    val diff = l.zip(l.drop(1)).map { it.second - it.first }\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    return diff.all { it <= 0 } || diff.all { it >= 0 }\n}\n",
            "fun common(l1: List<Int>, l2: List<Int>): List<Int> {\n    // return sorted(list(set(l1) & set(l2)))\n    return sorted(list(set(l1) intersect set(l2)))\n}\n",
            "fun largestPrimeFactor(n: Int): Int {\n    // i = 2\n    var i = 2\n    // while i * i <= n:\n    while (i * i <= n) {\n        // if n % i:\n        if (n % i != 0) {\n            // i += 1\n            i++\n        } else {\n            // n //= i\n            n /= i\n        }\n    }\n    // return n\n    return n\n}\n",
            "fun sumToN(n: Int): Int {\n    // return sum(range(n + 1))\n    return (1..n).sum()\n}\n",
            "fun correctBracketing(brackets: String): Boolean {\n    // depth = 0\n    var depth = 0\n    // for b in brackets:\n    for (b in brackets) {\n        // if b == \"(\":\n        if (b == '(') {\n            // depth += 1\n            depth += 1\n        }\n        // elif b == \")\":\n        else if (b == ')') {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false\n        }\n    }\n    // return depth == 0\n    return depth == 0\n}\n",
            "fun derivative(xs: List<Int>): List<Int> {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    return xs.mapIndexed { i, x -> x * i }\n}\n",
            "fun fibfib(n: Int): Int {\n    // if n <= 1:\n    if (n <= 1) {\n        // return 0 \n        return 0\n    }\n    // a, b, c = 0, 0, 1\n    var a = 0\n    var b = 0\n    var c = 1\n    // while n > 2:\n    while (n > 2) {\n        // a, b, c = b, c, a + b + c\n        a = b\n        b = c\n        c = a + b + c\n        // n -= 1\n        n -= 1\n    }\n    // return c\n    return c\n}\n",
            "fun vowelsCount(s: String): Int {\n    // vowels = \"aeiou\"\n    val vowels = \"aeiou\"\n    // cnt = 0\n    var cnt = 0\n    // for i in range(len(s)):\n    for (i in 0 until s.length) {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if (s[i].lowercaseChar() in vowels || (i == s.length - 1 && s[i].lowercaseChar() == 'y')) {\n            // cnt += 1\n            cnt += 1\n        }\n    }\n    // return cnt\n    return cnt\n}\n",
            "fun circularShift(x: Int, shift: Int): String {\n    // x_str = str(x)\n    val xStr = x.toString()\n    // if shift > len(x_str):\n    if (shift > xStr.length) {\n        // return x_str[::-1]\n        return xStr.reversed()\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return xStr.substring(xStr.length - shift) + xStr.substring(0, xStr.length - shift)\n    }\n}\n",
            "fun digitSum(s: String): Int {\n    // return sum(ord(c) for c in s if c.isupper())\n    return s.filter { it.isUpperCase() }.sumBy { it.toInt() }\n}\n",
            "fun fruitDistribution(s: String, n: Int): Int {\n    // words = s.split(' ')\n    val words = s.split(' ')\n    // apples = int(words[words.index(\"apples\") - 1])\n    val apples = words.indexOf(\"apples\") - 1\n    val applesValue = words[apples].toInt()\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    val oranges = words.indexOf(\"oranges\") - 1\n    val orangesValue = words[oranges].toInt()\n    // return n - apples - oranges\n    return n - applesValue - orangesValue\n}\n",
            "fun pluck(arr: List<Int>): List<Int> {\n    // evens = [n for n in arr if n % 2 == 0]\n    val evens = arr.filter { it % 2 == 0 }\n    // if len(evens) == 0:\n    if (evens.isEmpty()) {\n        // return []\n        return emptyList()\n    }\n    // min_even = min(evens)\n    val minEven = evens.min()!!\n    // return [min_even, arr.index(min_even)]\n    return listOf(minEven, arr.indexOf(minEven))\n}\n",
            "fun search(lst: List<Int>): Int {\n    // freqs = {}\n    val freqs = mutableMapOf<Int, Int>()\n    // for n in lst:\n    for (n in lst) {\n        // freqs[n] = freqs.get(n, 0) + 1\n        freqs[n] = freqs.getOrDefault(n, 0) + 1\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    val goodVals = freqs.filter { it.value >= it.key }.keys\n    // return max(good_vals, default=-1)\n    return goodVals.maxOrNull() ?: -1\n}\n",
            "fun strangeSortList(lst: List<Int>): List<Int> {\n    // sl = sorted(lst)\n    val sl = lst.sorted()\n    // result = []\n    val result = mutableListOf<Int>()\n    // left, right = 0, len(sl) - 1\n    var left = 0\n    var right = sl.size - 1\n    // while left <= right:\n    while (left <= right) {\n        // result.append(sl[left])\n        result.add(sl[left])\n        // left += 1\n        left += 1\n        // if left <= right:\n        if (left <= right) {\n            // result.append(sl[right])\n            result.add(sl[right])\n            // right -= 1\n            right -= 1\n        }\n    }\n    // return result\n    return result\n}\n",
            "fun triangleArea(a: Int, b: Int, c: Int): Double {\n    // if a + b > c and a + c > b and b + c > a:\n    if (a + b > c && a + c > b && b + c > a) {\n        // s = (a + b + c) / 2.0\n        val s = (a + b + c) / 2.0\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return sqrt(s * (s - a) * (s - b) * (s - c))\n    } else {\n        // return -1.0\n        return -1.0\n    }\n}\n",
            "fun willItFly(q: List<Int>, w: Int): Boolean {\n    // if len(q) == 0:\n    if (q.isEmpty()) {\n        // return False\n        return false\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    val isPalin = q.indices.all { q[it] == q[q.size - it - 1] }\n    // total = sum(q)\n    val total = q.sum()\n    // return is_palin and total <= w\n    return isPalin && total <= w\n}\n",
            "fun smallestChange(arr: List<Int>): Int {\n    // ans = 0\n    var ans = 0\n    // for i in range(len(arr) // 2):\n    for (i in 0 until arr.size / 2) {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if (arr[i] != arr[arr.size - i - 1]) {\n            // ans += 1\n            ans += 1\n        }\n    }\n    // return ans\n    return ans\n}\n",
            "fun totalMatch(lst1: List<String>, lst2: List<String>): List<String> {\n    // cnt1 = sum(len(s) for s in lst1)\n    val cnt1 = lst1.sumBy { it.length }\n    // cnt2 = sum(len(s) for s in lst2)\n    val cnt2 = lst2.sumBy { it.length }\n    // return lst1 if cnt1 <= cnt2 else lst2\n    return if (cnt1 <= cnt2) lst1 else lst2\n}\n",
            "fun isPrime(n: Int): Boolean {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i in 2..floor(sqrt(n)).toInt() + 1) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfun isMultiplyPrime(a: Int): Boolean {\n    // cnt = 0\n    var cnt = 0\n    // for i in range(2, a + 1):\n    for (i in 2..a + 1) {\n        // if is_prime(i):\n        if (isPrime(i)) {\n            // while a % i == 0:\n            while (a % i == 0) {\n                // cnt += 1\n                cnt += 1\n                // a /= i\n                a /= i\n            }\n        }\n    }\n    // return cnt == 3\n    return cnt == 3\n}\n",
            "fun isSimplePower(x: Int, n: Int): Boolean {\n    // if n < 2:\n    if (n < 2) {\n        // return x == n\n        return x == n\n    }\n    // tmp = 1\n    var tmp = 1\n    // while tmp < x:\n    while (tmp < x) {\n        // tmp *= n\n        tmp *= n\n    }\n    // return tmp == x\n    return tmp == x\n}\n",
            "fun isCube(a: Int): Boolean {\n    // a = abs(a)\n    a = abs(a)\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    val root = Math.round(Math.pow(a.toDouble(), 1.0 / 3.0)).toInt()\n    // return root * root * root == a\n    return root * root * root == a\n}\n",
            "fun hexKey(num: String): Int {\n    // return len([x for x in num if x in \"2357BD\"])\n    return num.count { \"2357BD\".contains(it) }\n}\n",
            "fun decimalToBinary(dec: Int): String {\n    // binary = bin(dec)[2:]\n    val binary = Integer.toBinaryString(dec).substring(2)\n    // return f\"db{binary}db\"\n    return \"db$binary\"\n}\n",
            "fun isHappy(s: String): Boolean {\n    // if len(s) < 3:\n    if (s.length < 3) {\n        // return False\n        return false\n    }\n    // for i in range(len(s) - 2):\n    for (i in 0 until s.length - 2) {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\n",
            "fun numericalLetterGrade(grades: List<Float>): List<String> {\n    // result = []\n    val result = mutableListOf<String>()\n    // for g in grades:\n    for (g in grades) {\n        // if g == 4.0:\n        if (g == 4.0f) {\n            // result.append(\"A+\")\n            result.add(\"A+\")\n        }\n        // elif g > 3.7:\n        else if (g > 3.7f) {\n            // result.append(\"A\")\n            result.add(\"A\")\n        }\n        // elif g > 3.3:\n        else if (g > 3.3f) {\n            // result.append(\"A-\")\n            result.add(\"A-\")\n        }\n        // elif g > 3.0:\n        else if (g > 3.0f) {\n            // result.append(\"B+\")\n            result.add(\"B+\")\n        }\n        // elif g > 2.7:\n        else if (g > 2.7f) {\n            // result.append(\"B\")\n            result.add(\"B\")\n        }\n        // elif g > 2.3:\n        else if (g > 2.3f) {\n            // result.append(\"B-\")\n            result.add(\"B-\")\n        }\n        // elif g > 2.0:\n        else if (g > 2.0f) {\n            // result.append(\"C+\")\n            result.add(\"C+\")\n        }\n        // elif g > 1.7:\n        else if (g > 1.7f) {\n            // result.append(\"C\")\n            result.add(\"C\")\n        }\n        // elif g > 1.3:\n        else if (g > 1.3f) {\n            // result.append(\"C-\")\n            result.add(\"C-\")\n        }\n        // elif g > 1.0:\n        else if (g > 1.0f) {\n            // result.append(\"D+\")\n            result.add(\"D+\")\n        }\n        // elif g > 0.7:\n        else if (g > 0.7f) {\n            // result.append(\"D\")\n            result.add(\"D\")\n        }\n        // elif g > 0.0:\n        else if (g > 0.0f) {\n            // result.append(\"D-\")\n            result.add(\"D-\")\n        }\n        // else:\n        else {\n            // result.append(\"E\")\n            result.add(\"E\")\n        }\n    }\n    // return result\n    return result\n}\n",
            "fun primeLength(s: String): Boolean {\n    // length = len(s)\n    val length = s.length\n    // if length < 2:\n    if (length < 2) {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for (i in 2..floor(sqrt(length.toDouble())).toInt() + 1) {\n        // if length % i == 0:\n        if (length % i == 0) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\n",
            "fun startsOneEnds(n: Int): Int {\n    // if n == 1:\n    if (n == 1) {\n        // return 1\n        return 1\n    }\n    // return 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * (10.0.pow(n - 2).toInt())\n}\n",
            "fun solve(n: Int): String {\n    // digits_sum = sum(int(d) for d in str(n))\n    val digitsSum = (n.toString().map { it.toString().toInt() }).sum()\n    // return bin(digits_sum)[2:]\n    return digitsSum.toString(2).substring(2)\n}\n",
            "fun add(lst: List<Int>): Int {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    return lst.filterIndexed { i, x -> i % 2 == 1 && x % 2 == 0 }.sum()\n}\n",
            "fun antiShuffle(s: String): String {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    val words = s.split(\" \").map { word -> word.toCharArray().sorted().joinToString(\"\") }\n    // return \" \".join(words)\n    return words.joinToString(\" \")\n}\n",
            "fun getRow(lst: List<List<Int>>, x: Int): List<List<Int>> {\n    // coords = []\n    val coords = mutableListOf<List<Int>>()\n    // for i in range(len(lst)):\n    for (i in lst.indices) {\n        // for j in range(len(lst[i])):\n        for (j in lst[i].indices) {\n            // if lst[i][j] == x:\n            if (lst[i][j] == x) {\n                // coords.append([i, j])\n                coords.add(listOf(i, j))\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    return coords.sortedWith(compareBy({ it[0] }, { -it[1] }))\n}\n",
            "fun sortArray(arr: List<Int>): List<Int> {\n    // if len(arr) == 0:\n    if (arr.isEmpty()) {\n        // return []\n        return emptyList()\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if ((arr[0] + arr[arr.lastIndex]) % 2 == 0) {\n        // return sorted(arr, reverse=True)\n        return arr.sortedDescending()\n    } else {\n        // return sorted(arr)\n        return arr.sorted()\n    }\n}\n",
            "fun encrypt(s: String): String {\n    // result = []\n    val result = mutableListOf<Char>()\n    // for ch in s:\n    for (ch in s) {\n        // shifted = ord(ch) + 4\n        val shifted = ch.toInt() + 4\n        // if shifted > ord('z'):\n        if (shifted > 'z'.toInt()) {\n            // shifted -= 26\n            shifted -= 26\n        }\n        // result.append(chr(shifted))\n        result.add(shifted.toChar())\n    }\n    // return \"\".join(result)\n    return result.joinToString(\"\")\n}\n",
            "fun nextSmallest(lst: List<Int>): Int? {\n    // sl = sorted(set(lst))\n    val sl = sorted(lst.toSet())\n    // if len(sl) < 2:\n    if (sl.size < 2) {\n        // return None\n        return null\n    }\n    // return sl[1]\n    return sl[1]\n}\n",
            "fun isBored(s: String): Int {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    val sentences = Pattern.compile(\"[.!?]\\\\s*\").split(s)\n    // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    return sentences.filter { it.length >= 2 }.count { it.substring(0, 2) == \"I \" }\n}\n",
            "fun anyInt(x: Any, y: Any, z: Any): Boolean {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if (x is Int && y is Int && z is Int) {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if (x + y == z || x + z == y || y + z == x) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "fun encode(message: String): String {\n    // vowels = \"aeiouAEIOU\"\n    val vowels = \"aeiouAEIOU\"\n    // result = []\n    val result = mutableListOf<Char>()\n    // for ch in message:\n    for (ch in message) {\n        // if ch.isalpha():\n        if (ch.isLetter()) {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            val ch1 = if (ch.isLowerCase()) ch.uppercaseChar() else ch.lowercaseChar()\n            // if ch1 in vowels:\n            if (vowels.contains(ch1)) {\n                // ch1 = chr(ord(ch1) + 2)\n                ch1 = (ch1.toInt() + 2).toChar()\n            }\n            // result.append(ch1)\n            result.add(ch1)\n        } else {\n            // result.append(ch)\n            result.add(ch)\n        }\n    }\n    // return \"\".join(result)\n    return result.joinToString(\"\")\n}\n",
            "fun isPrime(n: Int): Boolean {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i in 2..floor(sqrt(n)).toInt() + 1) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfun skjkasdkd(lst: List<Int>): Int {\n    // primes = [n for n in lst if is_prime(n)]\n    val primes = lst.filter { isPrime(it) }\n    // if len(primes) == 0:\n    if (primes.isEmpty()) {\n        // return 0\n        return 0\n    }\n    // largest = str(max(primes))\n    val largest = primes.max().toString()\n    // return sum(int(digit) for digit in largest)\n    return largest.map { it.toString().toInt() }.sum()\n}\n",
            "fun checkDictCase(d: Map<String, String>): Boolean {\n    // if not d:\n    if (d.isEmpty()) {\n        // return False\n        return false\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    return d.keys.all { it.isLowerCase() } || d.keys.all { it.isUpperCase() }\n}\n",
            "fun countUpTo(n: Int): List<Int> {\n    // primes = []\n    val primes = mutableListOf<Int>()\n    // for num in range(2, n):\n    for (num in 2..n) {\n        // if all(num % p != 0 for p in primes):\n        if (primes.all { num % it != 0 }) {\n            // primes.append(num)\n            primes.add(num)\n        }\n    }\n    // return primes\n    return primes\n}\n",
            "fun multiply(a: Int, b: Int): Int {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    return (abs(a) % 10) * (abs(b) % 10)\n}\n",
            "fun countUpper(s: String): Int {\n    // vowels = \"AEIOU\"\n    val vowels = \"AEIOU\"\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    return s.filterIndexed { i, c -> i % 2 == 0 && vowels.contains(c) }.length\n}\n",
            "fun closestInteger(value: String): Int {\n    // num = float(value)\n    val num = value.toFloat()\n    // if num >= 0:\n    if (num >= 0.0) {\n        // return int(num + 0.5)\n        return (num + 0.5).toInt()\n    } else {\n        // return int(num - 0.5)\n        return (num - 0.5).toInt()\n    }\n}\n",
            "fun makeAPile(n: Int): List<Int> {\n    // return [n + 2 * i for i in range(n)]\n    return (0 until n).map { n + 2 * it }\n}\n",
            "fun wordsString(s: String): List<String> {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    return Pattern.compile(\"[, ]\").split(s).filter { it.isNotEmpty() }\n}\n",
            "fun chooseNum(x: Int, y: Int): Int {\n    // if x > y:\n    if (x > y) {\n        // return -1\n        return -1\n    }\n    // if y % 2 == 0:\n    if (y % 2 == 0) {\n        // return y\n        return y\n    }\n    // return y - 1 if x != y else -1\n    return if (x != y) y - 1 else -1\n}\n",
            "fun roundedAvg(n: Int, m: Int): String? {\n    // if n > m:\n    if (n > m) {\n        // return None\n        return null\n    }\n    // r_avg = int((m + n) / 2.0 + 0.5)\n    val rAvg = (m + n) / 2.0 + 0.5\n    // return bin(r_avg)[2:]\n    return rAvg.toString(2).substring(2)\n}\n",
            "fun allDigitsOdd(s: String): Boolean {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    return s.all { digit -> digit.toInt() % 2 != 0 }\n}\nfun uniqueDigits(x: List<Int>): List<Int> {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    return x.filter { num -> allDigitsOdd(num.toString()) }.sorted()\n}\n",
            "fun byLength(arr: List<Int>): List<String> {\n    // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    val digitNames = listOf(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n    val sortedArr = arr.filter { 1 <= it && it <= 9 }.sortedDescending()\n    // return [digit_names[x-1] for x in sorted_arr]\n    return sortedArr.map { digitNames[it - 1] }\n}\n",
            "fun f(n: Int): List<Int> {\n    // nums = list(range(1, n + 1))\n    val nums = (1..n).toList()\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    return nums.map { i ->\n        if (i % 2 != 0) {\n            nums.subList(0, i).sum()\n        } else {\n            nums.subList(0, i).fold(1) { x, y -> x * y }\n        }\n    }\n}\n",
            "fun isPalindrome(txt: String): Boolean {\n    // return txt == txt[::-1]\n    return txt == txt.reversed()\n}\nfun evenOddPalindrome(n: Int): List<Int> {\n    // cnt = [0, 0]\n    val cnt = mutableListOf(0, 0)\n    // for i in range(1, n + 1):\n    for (i in 1..n) {\n        // if is_palindrome(str(i)):\n        if (isPalindrome(i.toString())) {\n            // cnt[i % 2] += 1\n            cnt[i % 2] += 1\n        }\n    }\n    // return cnt\n    return cnt\n}\n",
            "fun digitsSum(n: Int): Int {\n    // n_str = str(n)\n    val nStr = n.toString()\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.map { it.toInt() }.sum()\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return nStr.substring(0, 2).toInt() * 2 + digitsSum(n.absoluteValue)\n    }\n}\nfun countNums(arr: List<Int>): Int {\n    // return len([n for n in arr if digits_sum(n) > 0])\n    return arr.count { digitsSum(it) > 0 }\n}\n",
            "fun moveOneBall(arr: List<Int>): Boolean {\n    // if len(arr) == 0:\n    if (arr.isEmpty()) {\n        // return True\n        return true\n    }\n    // sorted_arr = sorted(arr)\n    val sortedArr = arr.sorted()\n    // for i in range(0, len(arr)):\n    for (i in 0 until arr.size) {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if (arr.subList(i, arr.size) == sortedArr.subList(0, arr.size - i) && arr.subList(0, i) == sortedArr.subList(arr.size - i, arr.size)) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "fun canExchange(lst1: List<Int>, lst2: List<Int>): String {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    val oddCnt = lst1.count { it % 2 != 0 }\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    val evenCnt = lst2.count { it % 2 == 0 }\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    return if (evenCnt >= oddCnt) \"YES\" else \"NO\"\n}\n",
            "fun histogram(test: String): Map<String, Int> {\n    // freq = {}\n    val freq = mutableMapOf<String, Int>()\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    val words = test.split(\" \").filter { it.isNotEmpty() }\n    // for w in words:\n    for (w in words) {\n        // freq[w] = freq.get(w, 0) + 1\n        freq[w] = freq.getOrDefault(w, 0) + 1\n    }\n    // result = {}\n    val result = mutableMapOf<String, Int>()\n    // if len(freq) > 0:\n    if (freq.isNotEmpty()) {\n        // max_freq = max(freq.values())\n        val maxFreq = freq.values.max()\n        // for k, v in freq.items():\n        for ((k, v) in freq) {\n            // if v == max_freq:\n            if (v == maxFreq) {\n                // result[k] = v\n                result[k] = v\n            }\n        }\n    }\n    // return result\n    return result\n}\n",
            "fun isPalindrome(s: String): Boolean {\n    // return s == s[::-1]\n    return s == s.reversed()\n}\nfun reverseDelete(s: String, c: String): List<String> {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    val s1 = s.filter { !c.contains(it) }\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    return listOf(s1, if (isPalindrome(s1)) \"yes\" else \"no\")\n}\n",
            "fun oddCount(lst: List<String>): List<String> {\n    // result = []\n    val result = mutableListOf<String>()\n    // for num in lst:\n    for (num in lst) {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        val n = num.sumBy { (it.toInt() and 1) == 1 }\n        // rs = \"the number of odd elements in the string i of the input.\"\n        val rs = \"the number of odd elements in the string $n of the input.\"\n        // result.append(rs.replace(\"i\", str(n)))\n        result.add(rs.replace(\"i\", n.toString()))\n    }\n    // return result\n    return result\n}\n",
            "fun minSubArraySum(nums: List<Int>): Int {\n    // min_sum = 0\n    var minSum = 0\n    // cur_sum = 0\n    var curSum = 0\n    // for n in nums:\n    for (n in nums) {\n        // cur_sum = min(cur_sum + n, 0)\n        curSum = min(curSum + n, 0)\n        // min_sum = min(cur_sum, min_sum)\n        minSum = min(curSum, minSum)\n    }\n    // if min_sum == 0:\n    if (minSum == 0) {\n        // min_sum = min(nums)\n        minSum = nums.min()!!\n    }\n    // return min_sum\n    return minSum\n}\n",
            "fun maxFill(grid: List<List<Int>>, capacity: Int): Int {\n    // return sum([ceil(sum(arr) / capacity) for arr in grid])\n    return grid.sumBy { ceil(it.sum().toDouble() / capacity) }\n}\n",
            "fun countOnes(num: Int): Int {\n    // return bin(num).count(\"1\")\n    return Integer.toBinaryString(num).count { it == '1' }\n}\nfun sortArray(arr: List<Int>): List<Int> {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    return arr.sortedWith(compareBy({ countOnes(it) }, { it }))\n}\n",
            "fun selectWords(s: String, n: Int): List<String> {\n    // consonants = \"bcdfghjklmnpqrstvwxyz\"\n    val consonants = \"bcdfghjklmnpqrstvwxyz\"\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    val words = s.split(\" \").filter { it.isNotEmpty() }\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    return words.filter { it.count { c -> c.lowercaseChar() in consonants } == n }\n}\n",
            "fun getClosestVowel(word: String): String {\n    // vowels = \"aeiouAEIOU\"\n    val vowels = \"aeiouAEIOU\"\n    // for i in range(len(word) - 2, 0, -1):\n    for (i in (word.length - 2) downTo 0) {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if (vowels.contains(word[i]) && !vowels.contains(word[i - 1]) && !vowels.contains(word[i + 1])) {\n            // return word[i]\n            return word[i].toString()\n        }\n    }\n    // return \"\"\n    return \"\"\n}\n",
            "fun check(s: String): Boolean {\n    // depth = 0\n    var depth = 0\n    // for ch in s:\n    for (ch in s) {\n        // if ch == \"(\":\n        if (ch == \"(\") {\n            // depth += 1\n            depth += 1\n        } else {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false\n        }\n    }\n    // return True if depth == 0 else False\n    return depth == 0\n}\nfun matchParens(lst: List<String>): String {\n    // s1 = lst[0] + lst[1]\n    val s1 = lst[0] + lst[1]\n    // s2 = lst[1] + lst[0]\n    val s2 = lst[1] + lst[0]\n    // return \"Yes\" if check(s1) or check(s2) else \"No\"\n    return if (check(s1) || check(s2)) \"Yes\" else \"No\"\n}\n",
            "fun maximum(arr: List<Int>, k: Int): List<Int> {\n    // if k == 0:\n    if (k == 0) {\n        // return []\n        return emptyList()\n    }\n    // return sorted(arr)[-k:]\n    return arr.sorted().takeLast(k)\n}\n",
            "fun solution(lst: List<Int>): Int {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    return lst.filterIndexed { i, x -> i % 2 == 0 && x % 2 != 0 }.sum()\n}\n",
            "fun addElements(arr: List<Int>, k: Int): Int {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    return arr.subList(0, k).filter { n -> n.toString().length <= 2 }.sum()\n}\n",
            "fun getOddCollatz(n: Int): List<Int> {\n    // collatz = [1]\n    val collatz = mutableListOf(1)\n    // while n != 1:\n    while (n != 1) {\n        // if n % 2 != 0:\n        if (n % 2 != 0) {\n            // collatz.append(n)\n            collatz.add(n)\n            // n = 3 * n + 1\n            n = 3 * n + 1\n        } else {\n            // n = n // 2\n            n /= 2\n        }\n    }\n    // return sorted(collatz)\n    return collatz.sorted()\n}\n",
            "fun validDate(date: String): Boolean {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if (date.length != 10 || date[2] != '-' || date[5] != '-') {\n        return false\n    }\n    // m = int(date[:2])\n    val m = date.substring(0, 2).toInt()\n    // d = int(date[3:5])\n    val d = date.substring(3, 5).toInt()\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if (m in 1..12 && d in 1..31) {\n        return true\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if (m in 4..9 && d in 1..30) {\n        return true\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if (m == 2 && d in 1..29) {\n        return true\n    }\n    // return False\n    return false\n}\n",
            "fun splitWords(txt: String): List<String> {\n    // if \" \" in txt:\n    if (\" \" in txt) {\n        // return txt.split(\" \")\n        return txt.split(\" \")\n    }\n    // elif \",\" in txt:\n    else if (\",\" in txt) {\n        // return txt.split(\",\")\n        return txt.split(\",\")\n    }\n    // else:\n    else {\n        // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        return listOf(txt.length.toString())\n    }\n}\n",
            "fun isSorted(lst: List<Int>): Boolean {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    if (!lst.indices.all { lst[it - 1] <= lst[it] }) {\n        return false\n    }\n    // freq = {}\n    val freq = mutableMapOf<Int, Int>()\n    // for i in lst:\n    for (i in lst) {\n        // freq[i] = freq.get(i, 0) + 1\n        freq[i] = freq.getOrDefault(i, 0) + 1\n    }\n    // return max(freq.values(), default=0) <= 2\n    return freq.values.maxOrNull() ?: 0 <= 2\n}\n",
            "fun isPrime(n: Int): Boolean {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i in 2..floor(sqrt(n)).toInt() + 1) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfun intersection(interval1: List<Int>, interval2: List<Int>): String {\n    // l = max(interval1[0], interval2[0])\n    val l = maxOf(interval1[0], interval2[0])\n    // r = min(interval1[1], interval2[1])\n    val r = minOf(interval1[1], interval2[1])\n    // length = r - l\n    val length = r - l\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    return if (length > 0 && isPrime(length)) \"YES\" else \"NO\"\n}\n",
            "fun prodSigns(arr: List<Int>): Int? {\n    // if not arr:\n    if (arr.isEmpty()) {\n        // return None\n        return null\n    }\n    // if 0 in arr:\n    if (arr.contains(0)) {\n        // return 0\n        return 0\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    val sign = if (arr.count { it < 0 } % 2 == 1) -1 else 1\n    // return sign * sum([abs(n) for n in arr])\n    return sign * arr.sumBy { Math.abs(it) }\n}\n",
            "fun minPath(grid: List<List<Int>>, k: Int): List<Int> {\n    // n = len(grid)\n    val n = grid.size\n    // min_val = n * n + 1\n    var minVal = n * n + 1\n    // for i in range(n):\n    for (i in 0 until n) {\n        // for j in range(n):\n        for (j in 0 until n) {\n            // if grid[i][j] == 1:\n            if (grid[i][j] == 1) {\n                // temp = []\n                val temp = mutableListOf<Int>()\n                // if i != 0:\n                if (i != 0) {\n                    // temp.append(grid[i - 1][j])\n                    temp.add(grid[i - 1][j])\n                }\n                // if j != 0:\n                if (j != 0) {\n                    // temp.append(grid[i][j - 1])\n                    temp.add(grid[i][j - 1])\n                }\n                // if i != n - 1:\n                if (i != n - 1) {\n                    // temp.append(grid[i + 1][j])\n                    temp.add(grid[i + 1][j])\n                }\n                // if j != n - 1:\n                if (j != n - 1) {\n                    // temp.append(grid[i][j + 1])\n                    temp.add(grid[i][j + 1])\n                }\n                // min_val = min(temp)\n                minVal = min(minVal, temp.minOrNull()!!)\n            }\n        }\n    }\n    // result = []\n    val result = mutableListOf<Int>()\n    // for i in range(k):\n    for (i in 0 until k) {\n        // result.append(1 if i % 2 == 0 else min_val)\n        result.add(if (i % 2 == 0) 1 else minVal)\n    }\n    // return result\n    return result\n}\n",
            "fun tri(n: Int): List<Int> {\n    // if n == 0:\n    if (n == 0) {\n        // return [1]\n        return listOf(1)\n    }\n    // seq = [1, 3]\n    val seq = mutableListOf(1, 3)\n    // for i in range(2, n + 1):\n    for (i in 2..n) {\n        // if i % 2 == 0:\n        if (i % 2 == 0) {\n            // seq.append(i / 2 + 1)\n            seq.add(i / 2 + 1)\n        } else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq.add(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n        }\n    }\n    // return seq\n    return seq\n}\n",
            "fun digits(n: Int): Int {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    val odds = str(n).map { it.toInt() }.filter { it % 2 == 1 }\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    return if (odds.isNotEmpty()) odds.reduce { x, y -> x * y } else 0\n}\n",
            "fun isNested(s: String): Boolean {\n    // open_idx = []\n    val openIdx = mutableListOf<Int>()\n    // close_idx = []\n    val closeIdx = mutableListOf<Int>()\n    // for i, ch in enumerate(s):\n    for (i in s.indices) {\n        val ch = s[i]\n        // if ch == '[':\n        if (ch == '[') {\n            // open_idx.append(i)\n            openIdx.add(i)\n        }\n        // elif ch == ']':\n        else if (ch == ']') {\n            // close_idx.append(i)\n            closeIdx.add(i)\n        }\n    }\n    // close_idx.reverse()\n    closeIdx.reverse()\n    // cnt = 0\n    var cnt = 0\n    // i = 0\n    var i = 0\n    // l = len(close_idx)\n    val l = closeIdx.size\n    // for idx in open_idx:\n    for (idx in openIdx) {\n        // if i < l and idx < close_idx[i]:\n        if (i < l && idx < closeIdx[i]) {\n            // cnt += 1\n            cnt += 1\n            // i += 1\n            i += 1\n        }\n    }\n    // return cnt >= 2\n    return cnt >= 2\n}\n",
            "fun sumSquares(lst: List<Float>): Int {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    return lst.map { ceil(it).toInt().pow(2) }.sum()\n}\n",
            "fun checkIfLastCharIsALetter(txt: String): Boolean {\n    // if not txt:\n    if (txt.isEmpty()) {\n        // return False\n        return false\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    val last = txt.substring(txt.lastIndexOf(' ') + 1)\n    // return len(last) == 1 and last[0].isalpha()\n    return last.length == 1 && last[0].isLetter()\n}\n",
            "fun canArrange(arr: List<Int>): Int {\n    // if len (arr) <= 1:\n    if (arr.size <= 1) {\n        // return -1\n        return -1\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    val idx = (1 until arr.size).filter { arr[it] < arr[it - 1] }\n    // return max(idx, default=-1)\n    return idx.maxOrNull() ?: -1\n}\n",
            "fun largestSmallestIntegers(lst: List<Int>): List<Int?> {\n    // neg = [i for i in lst if i < 0]\n    val neg = lst.filter { it < 0 }\n    // pos = [i for i in lst if i > 0]\n    val pos = lst.filter { it > 0 }\n    // max_neg = max(neg) if len(neg) > 0 else None\n    val maxNeg = if (neg.isNotEmpty()) neg.max() else null\n    // min_pos = min(pos) if len(pos) > 0 else None\n    val minPos = if (pos.isNotEmpty()) pos.min() else null\n    // return [max_neg, min_pos]\n    return listOf(maxNeg, minPos)\n}\n",
            "fun anyToReal(o: Any): Double {\n    // if isinstance(o, str): \n    if (o is String) {\n        // return float(o.replace(',','.'))\n        return o.replace(',', '.').toDouble()\n    }\n    // elif isinstance(o, int):\n    else if (o is Int) {\n        // return float(o)\n        return o.toDouble()\n    }\n    // elif isinstance(o, float):\n    else if (o is Float) {\n        // return o\n        return o\n    }\n    // raise RuntimeError(\"Type Error\");\n    throw RuntimeException(\"Type Error\")\n}\nfun compareOne(a: Any, b: Any): Any? {\n    // a1 = any_to_real(a)\n    val a1 = anyToReal(a)\n    // b1 = any_to_real(b)\n    val b1 = anyToReal(b)\n    // if a1 == b1:\n    if (a1 == b1) {\n        // return None\n        return null\n    }\n    // elif a1 > b1:\n    else if (a1 > b1) {\n        // return a1\n        return a1\n    }\n    // else:\n    else {\n        // return b1\n        return b1\n    }\n}\n",
            "fun isEqualToSumEven(n: Int): Boolean {\n    // return n % 2 == 0 and n >= 8\n    return n % 2 == 0 && n >= 8\n}\n",
            "fun specialFactorial(n: Int): Int {\n    // fact = 1\n    var fact = 1\n    // result = 1\n    var result = 1\n    // for i in range(1, n + 1):\n    for (i in 1..n) {\n        // fact *= i\n        fact *= i\n        // result *= fact\n        result *= fact\n    }\n    // return result\n    return result\n}\n",
            "fun fixSpaces(txt: String): String {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    return Pattern.compile(\"\\\\s{3,}\").matcher(txt).replaceAll(\"-\").replace(\" \", \"_\")\n}\n",
            "fun fileNameCheck(fileName: String): String {\n    // suf = [\"txt\", \"exe\", \"dll\"]\n    val suf = listOf(\"txt\", \"exe\", \"dll\")\n    // lst = file_name.split(\".\")\n    val lst = fileName.split(\".\")\n    // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n    if (lst.size != 2 || !suf.contains(lst[1]) || lst[0].isEmpty() || !lst[0][0].isLetter() || lst[0].count { it.isDigit() } > 3) {\n        // return \"No\"\n        return \"No\"\n    }\n    // return \"Yes\"\n    return \"Yes\"\n}\n",
            "fun sumSquares(lst: List<Int>): Int {\n    // result = 0\n    var result = 0\n    // for i in range(len(lst)):\n    for (i in lst.indices) {\n        // if i % 3 == 0:\n        if (i % 3 == 0) {\n            // result += pow(lst[i], 2)\n            result += Math.pow(lst[i].toDouble(), 2.0).toInt()\n        }\n        // elif i % 4 == 0:\n        else if (i % 4 == 0) {\n            // result += pow(lst[i], 3)\n            result += Math.pow(lst[i].toDouble(), 3.0).toInt()\n        }\n        // else:\n        else {\n            // result += lst[i]\n            result += lst[i]\n        }\n    }\n    // return result\n    return result\n}\n",
            "fun isPrime(n: Int): Boolean {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i in 2..floor(sqrt(n.toDouble())).toInt() + 1) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfun wordsInSentence(sentence: String): String {\n    // words = sentence.split(\" \")\n    val words = sentence.split(\" \")\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    return words.filter { isPrime(it.length) }.joinToString(\" \")\n}\n",
            "fun simplify(x: String, n: String): Boolean {\n    // xs = x.split(\"/\")\n    val xs = x.split(\"/\")\n    // ns = n.split(\"/\")\n    val ns = n.split(\"/\")\n    // num = int(xs[0]) * int(ns[0])\n    val num = xs[0].toInt() * ns[0].toInt()\n    // den = int(xs[1]) * int(ns[1])\n    val den = xs[1].toInt() * ns[1].toInt()\n    // return num % den == 0\n    return num % den == 0\n}\n",
            "fun digitsSum(n: Int): Int {\n    // n_str = str(n)\n    val nStr = n.toString()\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.map { it.toInt() }.sum()\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return nStr.substring(0, 2).toInt() * 2 + digitsSum(n.absoluteValue)\n    }\n}\nfun orderByPoints(nums: List<Int>): List<Int> {\n    // return sorted(nums, key=digits_sum)\n    return nums.sortedWith(compareBy { digitsSum(it) })\n}\n",
            "fun specialFilter(nums: List<Int>): Int {\n    // odds = \"13579\"\n    val odds = \"13579\"\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    return nums.count { n -> n > 10 && n % 2 == 1 && odds.contains(n.toString()[0]) }\n}\n",
            "fun getMaxTriples(n: Int): Int {\n    // c = [0, 0, 0]\n    val c = IntArray(3)\n    // for i in range(1, n + 1):\n    for (i in 1..n) {\n        // a = i * i - i + 1\n        val a = i * i - i + 1\n        // c[a % 3] += 1\n        c[a % 3] += 1\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2))\n}\n",
            "fun bf(planet1: String, planet2: String): List<String> {\n    val names = listOf(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if (planet1 !in names || planet2 !in names) {\n        return emptyList()\n    }\n    var l = names.indexOf(planet1)\n    var r = names.indexOf(planet2)\n    if (l > r) {\n        l = r.also { r = l }\n    }\n    if (l == r) {\n        return emptyList()\n    }\n    return names.subList(l + 1, r)\n}\n",
            "fun sortedListSum(lst: List<String>): List<String> {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    val result = lst.filter { len(it) % 2 == 0 }\n    // return sorted(result, key=lambda x: (len(x), x))\n    return result.sortedWith(compareBy({ len(it) }, { it }))\n}\n",
            "fun xOrY(n: Int, x: Int, y: Int): Int {\n    // if n < 2:\n    if (n < 2) {\n        // return y\n        return y\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i in 2..floor(sqrt(n)).toInt() + 1) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return y\n            return y\n        }\n    }\n    // return x\n    return x\n}\n",
            "fun doubleTheDifference(lst: List<Float>): Int {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    return lst.filter { it >= 0f && it % 2 == 1f }.map { it * it }.sum()\n}\n",
            "fun compare(game: List<Int>, guess: List<Int>): List<Int> {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    return game.zip(guess).map { abs(it.first - it.second) }\n}\n",
            "fun strongestExtension(className: String, extensions: List<String>): String {\n    // max_s = float(\"-inf\")\n    var maxS = Float.NEGATIVE_INFINITY\n    // max_ext = \"\"\n    var maxExt = \"\"\n    // for ext in extensions:\n    for (ext in extensions) {\n        // upper = len([c for c in ext if c.isupper()])\n        val upper = ext.count { it.isUpperCase() }\n        // lower = len([c for c in ext if c.islower()])\n        val lower = ext.count { it.isLowerCase() }\n        // s = upper - lower\n        val s = upper - lower\n        // if s > max_s:\n        if (s > maxS) {\n            // max_s = s\n            maxS = s\n            // max_ext = ext\n            maxExt = ext\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    return \"$className.$maxExt\"\n}\n",
            "fun cycpatternCheck(a: String, b: String): Boolean {\n    // if len(a) < len(b):\n    if (a.length < b.length) {\n        // return False\n        return false\n    }\n    // for i in range(len(b)):\n    for (i in 0 until b.length) {\n        // if b[i:] + b[:i] in a:\n        if (a.contains(b.substring(i) + b.substring(0, i))) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "fun evenOddCount(num: Int): List<Int> {\n    // ds = str(abs(num))\n    val ds = abs(num).toString()\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    val even = ds.count { it.toInt() % 2 == 0 }\n    // return [even, len(ds) - even]\n    return listOf(even, ds.length - even)\n}\n",
            "fun intToMiniRoman(num: Int): String {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    val values = listOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    val numerals = listOf(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n    // res = []\n    val res = mutableListOf<String>()\n    // for i in range(len(values)):\n    for (i in values.indices) {\n        // while num >= values[i]:\n        while (num >= values[i]) {\n            // res.append(numerals[i])\n            res.add(numerals[i])\n            // num -= values[i]\n            num -= values[i]\n        }\n    }\n    // return \"\".join(res)\n    return res.joinToString(\"\")\n}\n",
            "fun rightAngleTriangle(a: Int, b: Int, c: Int): Boolean {\n    // s = sorted([a, b, c])\n    val s = listOf(a, b, c).sorted()\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n}\n",
            "fun findMax(words: List<String>): String {\n    // max_cnt = 0\n    var maxCnt = 0\n    // max_w = \"\"\n    var maxW = \"\"\n    // for w in words:\n    for (w in words) {\n        // cnt = len(set(w))\n        val cnt = w.toSet().size\n        // if cnt > max_cnt:\n        if (cnt > maxCnt) {\n            // max_cnt = cnt\n            maxCnt = cnt\n            // max_w = w\n            maxW = w\n        }\n        // elif cnt == max_cnt:\n        else if (cnt == maxCnt) {\n            // max_w = min(max_w, w)\n            maxW = minOf(maxW, w)\n        }\n    }\n    // return max_w\n    return maxW\n}\n",
            "fun eat(num: Int, need: Int, remaining: Int): List<Int> {\n    // if need <= remaining:\n    if (need <= remaining) {\n        // return [num + need, remaining - need]\n        return listOf(num + need, remaining - need)\n    } else {\n        // return [num + remaining, 0]\n        return listOf(num + remaining, 0)\n    }\n}\n",
            "fun doAlgebra(operators: List<String>, operands: List<Int>): Int {\n    // ops = operators.copy()\n    val ops = operators.toMutableList()\n    // nums = operands.copy()\n    val nums = operands.toMutableList()\n    // i = len(ops) - 1\n    var i = ops.size - 1\n    // while i >= 0:\n    while (i >= 0) {\n        // if ops[i] == \"**\":\n        if (ops[i] == \"**\") {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            nums[i] = Math.pow(nums[i].toDouble(), nums[i + 1].toDouble()).toInt()\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1)\n            // ops.pop(i)\n            ops.removeAt(i)\n        }\n        // i -= 1\n        i -= 1\n    }\n    // i = 0\n    i = 0\n    // while i < len(ops):\n    while (i < ops.size) {\n        // if ops[i] == \"*\":\n        if (ops[i] == \"*\") {\n            // nums[i] = nums[i] * nums[i + 1]\n            nums[i] = nums[i] * nums[i + 1]\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1)\n            // ops.pop(i)\n            ops.removeAt(i)\n            // i -= 1\n            i -= 1\n        }\n        // elif ops[i] == \"//\":\n        else if (ops[i] == \"//\") {\n            // nums[i] = nums[i] // nums[i + 1]\n            nums[i] = nums[i] / nums[i + 1]\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1)\n            // ops.pop(i)\n            ops.removeAt(i)\n            // i -= 1\n            i -= 1\n        }\n        // i += 1\n        i += 1\n    }\n    // i = 0\n    i = 0\n    // while i < len(ops):\n    while (i < ops.size) {\n        // if ops[i] == \"+\":\n        if (ops[i] == \"+\") {\n            // nums[i] = nums[i] + nums[i + 1]\n            nums[i] = nums[i] + nums[i + 1]\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1)\n            // ops.pop(i)\n            ops.removeAt(i)\n            // i -= 1\n            i -= 1\n        }\n        // elif ops[i] == \"-\":\n        else if (ops[i] == \"-\") {\n            // nums[i] = nums[i] - nums[i + 1]\n            nums[i] = nums[i] - nums[i + 1]\n            // nums.pop(i + 1)\n            nums.removeAt(i + 1)\n            // ops.pop(i)\n            ops.removeAt(i)\n            // i -= 1\n            i -= 1\n        }\n        // i += 1\n        i += 1\n    }\n    // return nums[0]\n    return nums[0]\n}\n",
            "fun solve(s: String): String {\n    // if not any(ch.isalpha() for ch in s):\n    if (!s.any { it.isLetter() }) {\n        // return s[::-1]\n        return s.reversed()\n    }\n    // result = []\n    val result = mutableListOf<Char>()\n    // for ch in s:\n    for (ch in s) {\n        // if not ch.isalpha():\n        if (!ch.isLetter()) {\n            // result.append(ch)\n            result.add(ch)\n        }\n        // elif ch.isupper():\n        else if (ch.isUpperCase()) {\n            // result.append(ch.lower())\n            result.add(ch.toLowerCase())\n        }\n        // elif ch.islower():\n        else if (ch.isLowerCase()) {\n            // result.append(ch.upper())\n            result.add(ch.toUpperCase())\n        }\n    }\n    // return \"\".join(result)\n    return result.joinToString(\"\")\n}\n",
            "fun stringToMd5(txt: String): String? {\n    // if not txt:\n    if (txt.isEmpty()) {\n        // return None\n        return null\n    }\n    // md5_hash = hashlib.md5()\n    val md5_hash = MessageDigest.getInstance(\"MD5\")\n    // txt_bytes = txt.encode()\n    val txt_bytes = txt.toByteArray()\n    // md5_hash.update(txt_bytes)\n    md5_hash.update(txt_bytes)\n    // md5_encoded = md5_hash.hexdigest()\n    val md5_encoded = md5_hash.digest().toHexString()\n    // return md5_encoded\n    return md5_encoded\n}\n",
            "fun generateIntegers(a: Int, b: Int): List<Int> {\n    // lower = max(2, min(a, b))\n    val lower = maxOf(2, minOf(a, b))\n    // upper = min(8, max(a, b))\n    val upper = minOf(8, maxOf(a, b))\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    return (lower..upper).filter { it % 2 == 0 }\n}\n"
        ],
        "php": [
            "function hasCloseElements ($numbers, $threshold) {\n    // for i in range(len(numbers)):\n    for ($i = 0; $i < count($numbers); $i++) {\n        // for j in range(i + 1, len(numbers)):\n        for ($j = $i + 1; $j < count($numbers); $j++) {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if (abs($numbers[$i] - $numbers[$j]) < $threshold) {\n                // return True\n                return true;\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "function separateParenGroups ($parenString) {\n    // groups = []\n    $groups = [];\n    // stk = []\n    $stk = [];\n    // current_group = \"\"\n    $currentGroup = \"\";\n    // parens = paren_string.replace(\" \", \"\")\n    $parens = str_replace(\" \", \"\", $parenString);\n    // for ch in parens:\n    for ($i = 0; $i < strlen($parens); $i++) {\n        // if ch == \"(\":\n        if ($parens[$i] == \"(\") {\n            // stk.append(ch)\n            $stk[] = $parens[$i];\n            // current_group += ch\n            $currentGroup .= $parens[$i];\n        } elseif ($parens[$i] == \")\") {\n            // stk.pop()\n            array_pop($stk);\n            // current_group += ch\n            $currentGroup .= $parens[$i];\n            // if not stk:\n            if (!$stk) {\n                // groups.append(current_group)\n                $groups[] = $currentGroup;\n                // current_group = \"\"\n                $currentGroup = \"\";\n            }\n        }\n    }\n    // return groups\n    return $groups;\n}\n",
            "function truncateNumber($num) {\n    // return num - floor(num)\n    return $num - floor($num);\n}\n",
            "function belowZero($operations) {\n    // balance = 0\n    $balance = 0;\n    // for op in operations:\n    foreach ($operations as $op) {\n        // balance += op\n        $balance += $op;\n        // if balance < 0:\n        if ($balance < 0) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "function meanAbsoluteDeviation($numbers) {\n    // mean = sum(numbers) / len(numbers)\n    $mean = array_sum($numbers) / count($numbers);\n    // deviation = sum(abs(x - mean) for x in numbers)\n    $deviation = array_sum(array_map(function ($x) use ($mean) {\n        return abs($x - $mean);\n    }, $numbers));\n    // return deviation / len(numbers)\n    return $deviation / count($numbers);\n}\n",
            "function intersperse($numbers, $delimiter) {\n    // result = []\n    $result = [];\n    // for i in range(len(numbers)):\n    for ($i = 0; $i < count($numbers); $i++) {\n        // if i != 0:\n        if ($i != 0) {\n            // result.append(delimiter)\n            $result[] = $delimiter;\n        }\n        // result.append(numbers[i])\n        $result[] = $numbers[$i];\n    }\n    // return result\n    return $result;\n}\n",
            "function parseNestedParens($parenString) {\n    // result = []\n    $result = [];\n    // paren_groups = paren_string.split()\n    $parenGroups = explode(\" \", $parenString);\n    // for group in paren_groups:\n    foreach ($parenGroups as $group) {\n        // max_depth = 0\n        $maxDepth = 0;\n        // depth = 0\n        $depth = 0;\n        // for ch in group:\n        for ($i = 0; $i < strlen($group); $i++) {\n            // if ch == \"(\":\n            if ($group[$i] == \"(\") {\n                // depth += 1\n                $depth++;\n                // max_depth = max(max_depth, depth)\n                $maxDepth = max($maxDepth, $depth);\n            }\n            // elif ch == \")\":\n            elseif ($group[$i] == \")\") {\n                // depth -= 1\n                $depth--;\n            }\n        }\n        // result.append(max_depth)\n        $result[] = $maxDepth;\n    }\n    // return result\n    return $result;\n}\n",
            "function filterBySubstring($strs, $substring) {\n    // return [s for s in strs if substring in s]\n    return array_filter($strs, function ($s) use ($substring) {\n        return strpos($s, $substring) !== false;\n    });\n}\n",
            "function sumProduct($numbers) {\n    // n_sum = sum(numbers)\n    $nSum = array_sum($numbers);\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    $nProduct = array_reduce($numbers, function ($x, $y) {\n        return $x * $y;\n    }, 1);\n    // return [n_sum, n_product]\n    return [$nSum, $nProduct];\n}\n",
            "function rollingMax($numbers) {\n    // max_so_far = float(\"-inf\")\n    $maxSoFar = -INF;\n    // result = []\n    $result = [];\n    // for num in numbers:\n    foreach ($numbers as $num) {\n        // max_so_far = max(max_so_far, num)\n        $maxSoFar = max($maxSoFar, $num);\n        // result.append(max_so_far)\n        $result[] = $maxSoFar;\n    }\n    // return result\n    return $result;\n}\n",
            "function isPalindrome($s) {\n    // return s == s[::-1]\n    return $s == strrev($s);\n}\nfunction makePalindrome($s) {\n    // if is_palindrome(s):\n    if (isPalindrome($s)) {\n        // return s\n        return $s;\n    }\n    // for i in range(len(s)):\n    for ($i = 0; $i < strlen($s); $i++) {\n        // if is_palindrome(s[i:]):\n        if (isPalindrome(substr($s, $i))) {\n            // return s + s[:i][::-1]\n            return $s . strrev(substr($s, 0, $i));\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "function stringXor($a, $b) {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    return implode(\"\", array_map(function ($x, $y) {\n        return $x == $y ? \"0\" : \"1\";\n    }, str_split($a), str_split($b)));\n}\n",
            "function longest($strs) {\n    // if not strs:\n    if (!$strs) {\n        // return None\n        return null;\n    }\n    // longest_s = strs[0]\n    $longest_s = $strs[0];\n    // for s in strs:\n    foreach ($strs as $s) {\n        // if len(s) > len(longest_s):\n        if (strlen($s) > strlen($longest_s)) {\n            // longest_s = s\n            $longest_s = $s;\n        }\n    }\n    // return longest_s\n    return $longest_s;\n}\n",
            "function greatestCommonDivisor($a, $b) {\n    // if b == 0:\n    if ($b == 0) {\n        // return a\n        return $a;\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        return greatestCommonDivisor($b, $a % $b);\n    }\n}\n",
            "function allPrefixes($s) {\n    // prefixes = []\n    $prefixes = [];\n    // for i in range(len(s)):\n    for ($i = 0; $i < strlen($s); $i++) {\n        // prefixes.append(s[: i + 1])\n        $prefixes[] = substr($s, 0, $i + 1);\n    }\n    // return prefixes\n    return $prefixes;\n}\n",
            "function stringSequence($n) {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    return implode(' ', range(1, $n + 1));\n}\n",
            "function countDistinctCharacters($s) {\n    // return len(set(s.lower()))\n    return count(array_unique(str_split(strtolower($s))));\n}\n",
            "function parseMusic($musicString) {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    $durations = [\n        \"o\" => 4,\n        \"o|\" => 2,\n        \".|\" => 1,\n    ];\n    // notes = music_string.split()\n    $notes = explode(\" \", $musicString);\n    // return [durations[note] for note in notes]\n    return array_map(function ($note) use ($durations) {\n        return $durations[$note];\n    }, $notes);\n}\n",
            "function howManyTimes ($s, $substring) {\n    // times = 0\n    $times = 0;\n    // for i in range(len(s) - len(substring) + 1):\n    for ($i = 0; $i < strlen($s) - strlen($substring) + 1; $i++) {\n        // if s[i : i + len(substring)] == substring:\n        if (substr($s, $i, strlen($substring)) == $substring) {\n            // times += 1\n            $times++;\n        }\n    }\n    // return times\n    return $times;\n}\n",
            "function sortNumbers($numbers) {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    $numDict = [\n        \"zero\" => 0,\n        \"one\" => 1,\n        \"two\" => 2,\n        \"three\" => 3,\n        \"four\" => 4,\n        \"five\" => 5,\n        \"six\" => 6,\n        \"seven\" => 7,\n        \"eight\" => 8,\n        \"nine\" => 9,\n    ];\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    $numList = array_filter(explode(\" \", $numbers), function ($x) use ($numDict) {\n        return array_key_exists($x, $numDict);\n    });\n    // num_list.sort(key=lambda x: num_dict[x])\n    usort($numList, function ($x) use ($numDict) {\n        return $numDict[$x];\n    });\n    // return \" \".join(num_list)\n    return implode(\" \", $numList);\n}\n",
            "function findClosestElements ($numbers) {\n    // sorted_numbers = sorted(numbers)\n    $sortedNumbers = sort($numbers);\n    // min_diff = float(\"inf\")\n    $minDiff = INF;\n    // closest_pair = []\n    $closestPair = [];\n    // for i in range(1, len(sorted_numbers)):\n    for ($i = 1; $i < count($sortedNumbers); $i++) {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        $diff = $sortedNumbers[$i] - $sortedNumbers[$i - 1];\n        // if diff < min_diff:\n        if ($diff < $minDiff) {\n            // min_diff = diff\n            $minDiff = $diff;\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            $closestPair = [$sortedNumbers[$i - 1], $sortedNumbers[$i]];\n        }\n    }\n    // return closest_pair\n    return $closestPair;\n}\n",
            "function rescaleToUnit ($numbers) {\n    // min_num = min(numbers)\n    $minNum = min($numbers);\n    // max_num = max(numbers)\n    $maxNum = max($numbers);\n    // if min_num == max_num:\n    if ($minNum == $maxNum) {\n        // return [0.0] * len(numbers)\n        return array_fill(0, count($numbers), 0.0);\n    } else {\n        // return [(num - min_num) / (max_num - min_num) for num in numbers]\n        return array_map(function ($num) use ($minNum, $maxNum) {\n            return ($num - $minNum) / ($maxNum - $minNum);\n        }, $numbers);\n    }\n}\n",
            "function filterIntegers($values) {\n    // return [x for x in values if isinstance(x, int)]\n    return array_filter($values, function ($x) {\n        return is_int($x);\n    });\n}\n",
            "function strLength($s) {\n    // return len(s)\n    return strlen($s);\n}\n",
            "function largestDivisor($n) {\n    // for i in range(2, n):\n    for ($i = 2; $i < $n; $i++) {\n        // if n % i == 0:\n        if ($n % $i == 0) {\n            // return n // i\n            return $n / $i;\n        }\n    }\n    // return 1\n    return 1;\n}\n",
            "function factorize($n) {\n    // factors = []\n    $factors = [];\n    // divisor = 2\n    $divisor = 2;\n    // while divisor <= n:\n    while ($divisor <= $n) {\n        // if n % divisor == 0:\n        if ($n % $divisor == 0) {\n            // factors.append(divisor)\n            $factors[] = $divisor;\n            // n //= divisor\n            $n /= $divisor;\n        } else {\n            // divisor += 1\n            $divisor++;\n        }\n    }\n    // return factors\n    return $factors;\n}\n",
            "function removeDuplicates($numbers) {\n    // counts = {}\n    $counts = [];\n    // for num in numbers:\n    foreach ($numbers as $num) {\n        // counts[num] = counts.get(num, 0) + 1\n        $counts[$num] = isset($counts[$num]) ? $counts[$num] + 1 : 1;\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    $res = [];\n    foreach ($numbers as $num) {\n        if ($counts[$num] == 1) {\n            $res[] = $num;\n        }\n    }\n    // return res\n    return $res;\n}\n",
            "function flipCase($s) {\n    // flipped = []\n    $flipped = [];\n    // for ch in s:\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        // if not ch.isalpha():\n        if (!ctype_alpha($ch)) {\n            // flipped.append(ch)\n            $flipped[] = $ch;\n        }\n        // elif ch.islower():\n        elseif (ctype_lower($ch)) {\n            // flipped.append(ch.upper())\n            $flipped[] = strtoupper($ch);\n        }\n        // elif ch.isupper():\n        elseif (ctype_upper($ch)) {\n            // flipped.append(ch.lower())\n            $flipped[] = strtolower($ch);\n        }\n    }\n    // return ''.join(flipped)\n    return implode('', $flipped);\n}\n",
            "function concatenate($strs) {\n    // return \"\".join(strs)\n    return implode('', $strs);\n}\n",
            "function filterByPrefix($strs, $prefixStr) {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    return array_filter($strs, function ($s) use ($prefixStr) {\n        return strpos($s, $prefixStr) === 0;\n    });\n}\n",
            "function getPositive($l) {\n    // return [num for num in l if num > 0]\n    return array_filter($l, function ($num) {\n        return $num > 0;\n    });\n}\n",
            "function isPrime($n) {\n    // if n < 2:\n    if ($n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for ($i = 2; $i <= floor(sqrt($n)) + 1; $i++) {\n        // if n % i == 0:\n        if ($n % $i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "function poly($xs, $x) {\n    // res = 0.0\n    $res = 0.0;\n    // for i in range(len(xs)):\n    for ($i = 0; $i < count($xs); $i++) {\n        // res += xs[i] * x**i\n        $res += $xs[$i] * pow($x, $i);\n    }\n    // return res\n    return $res;\n}\nfunction findZero($xs) {\n    // x1, x2 = 1.0, -1.0\n    $x1 = 1.0;\n    $x2 = -1.0;\n    // while poly(xs, x1) * poly(xs, x2) > 0:\n    while (poly($xs, $x1) * poly($xs, $x2) > 0) {\n        // x1 *= 2\n        $x1 *= 2;\n        // x2 *= 2\n        $x2 *= 2;\n    }\n    // while abs(x1 - x2) > 1e-10:\n    while (abs($x1 - $x2) > 1e-10) {\n        // mid = (x1 + x2) / 2\n        $mid = ($x1 + $x2) / 2;\n        // if poly(xs, mid) == 0:\n        if (poly($xs, $mid) == 0) {\n            // return mid\n            return $mid;\n        }\n        // elif poly(xs, mid) * poly(xs, x1) < 0:\n        elseif (poly($xs, $mid) * poly($xs, $x1) < 0) {\n            // x2 = mid\n            $x2 = $mid;\n        }\n        // else:\n        else {\n            // x1 = mid\n            $x1 = $mid;\n        }\n    }\n    // return (x1 + x2) / 2\n    return ($x1 + $x2) / 2;\n}\n",
            "function sortThird($l) {\n    // sorted_third = sorted(l[::3])\n    $sortedThird = array_values(array_unique(array_filter($l, function ($v) {\n        return $v % 3 == 0;\n    })));\n    sort($sortedThird);\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    return array_map(function ($i) use ($sortedThird, $l) {\n        return $i % 3 == 0 ? $sortedThird[$i / 3] : $l[$i];\n    }, range(0, count($l) - 1));\n}\n",
            "function listUnique($l) {\n    // return sorted(list(set(l)))\n    return array_values(array_unique($l));\n}\n",
            "function maxElement($l) {\n    // if not l:\n    if (!$l) {\n        // return 0\n        return 0;\n    }\n    // return max(l)\n    return max($l);\n}\n",
            "function fizzBuzz ($n) {\n    // cnt = 0\n    $cnt = 0;\n    // for i in range(n):\n    for ($i = 0; $i < $n; $i++) {\n        // if i % 11 == 0 or i % 13 == 0:\n        if ($i % 11 == 0 || $i % 13 == 0) {\n            // cnt += str(i).count(\"7\")\n            $cnt += substr_count((string)$i, \"7\");\n        }\n    }\n    // return cnt\n    return $cnt;\n}\n",
            "function sortEven($l) {\n    // sorted_even = sorted(l[::2])\n    $sortedEven = array_values(array_filter($l, function ($i) {\n        return $i % 2 == 0;\n    }));\n    sort($sortedEven);\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    return array_map(function ($i) use ($sortedEven, $l) {\n        return $i % 2 == 0 ? $sortedEven[$i / 2] : $l[$i];\n    }, range(0, count($l) - 1));\n}\n",
            "function encodeCyclic($s) {\n    // result = []\n    $result = [];\n    // for i in range(0, len(s), 3):\n    for ($i = 0; $i < strlen($s); $i += 3) {\n        // if i + 3 > len(s):\n        if ($i + 3 > strlen($s)) {\n            // result.append(s[i:])\n            $result[] = substr($s, $i);\n        } else {\n            // result.append(s[i+1:i+3])\n            $result[] = substr($s, $i + 1, 2);\n            // result.append(s[i])\n            $result[] = substr($s, $i, 1);\n        }\n    }\n    // return \"\".join(result)\n    return implode(\"\", $result);\n}\nfunction decodeCyclic($s) {\n    return encodeCyclic(encodeCyclic($s));\n}\n",
            "function isPrime($n) {\n    // if n < 2:\n    if ($n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for ($i = 2; $i <= floor(sqrt($n)) + 1; $i++) {\n        // if n % i == 0:\n        if ($n % $i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nfunction primeFib($n) {\n    // f = [0, 1]\n    $f = [0, 1];\n    // cnt = 0\n    $cnt = 0;\n    // while cnt < n:\n    while ($cnt < $n) {\n        // f = [f[1], f[0] + f[1]]\n        $f = [$f[1], $f[0] + $f[1]];\n        // if is_prime(f[1]):\n        if (isPrime($f[1])) {\n            // cnt += 1\n            $cnt++;\n        }\n    }\n    // return f[1]\n    return $f[1];\n}\n",
            "function triplesSumToZero ($l) {\n    // for i in range(len(l)):\n    for ($i = 0; $i < count($l); $i++) {\n        // for j in range(i + 1, len(l)):\n        for ($j = $i + 1; $j < count($l); $j++) {\n            // for k in range(j + 1, len(l)):\n            for ($k = $j + 1; $k < count($l); $k++) {\n                // if l[i] + l[j] + l[k] == 0:\n                if ($l[$i] + $l[$j] + $l[$k] == 0) {\n                    // return True\n                    return true;\n                }\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "function carRaceCollision($n) {\n    // return n ** 2\n    return $n ** 2;\n}\n",
            "function incrList($l) {\n    // return [i + 1 for i in l]\n    return array_map(function ($i) {\n        return $i + 1;\n    }, $l);\n}\n",
            "function pairsSumToZero($l) {\n    // seen = set()\n    $seen = [];\n    // for num in l:\n    foreach ($l as $num) {\n        // if -num in seen:\n        if (in_array(-$num, $seen)) {\n            // return True\n            return true;\n        }\n        // seen.add(num)\n        $seen[] = $num;\n    }\n    // return False\n    return false;\n}\n",
            "function changeBase($x, $bas) {\n    // if x == 0:\n    if ($x == 0) {\n        // return \"0\"\n        return \"0\";\n    }\n    // digits = []\n    $digits = [];\n    // while x > 0:\n    while ($x > 0) {\n        // digits.append(str(x % bas))\n        $digits[] = (string)($x % $bas);\n        // x //= bas\n        $x = (int)($x / $bas);\n    }\n    // return \"\".join(digits[::-1])\n    return implode(\"\", array_reverse($digits));\n}\n",
            "function triangleArea($a, $h) {\n    // return a * h / 2\n    return $a * $h / 2;\n}\n",
            "function fib4($n) {\n    // fib = [0, 0, 2, 0]\n    $fib = [0, 0, 2, 0];\n    // for i in range(4, n + 1):\n    for ($i = 4; $i <= $n + 1; $i++) {\n        // fib[i % 4] = sum(fib)\n        $fib[$i % 4] = array_sum($fib);\n    }\n    // return fib[n % 4]\n    return $fib[$n % 4];\n}\n",
            "function median($l) {\n    // sl = sorted(l)\n    $sl = sort($l);\n    // if len(l) % 2 != 0:\n    if (count($l) % 2 != 0) {\n        // return sl[len(l) // 2]\n        return $sl[count($l) / 2];\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return ($sl[count($l) / 2] + $sl[count($l) / 2 - 1]) / 2;\n    }\n}\n",
            "function isPalindrome($txt) {\n    // return txt == txt[::-1]\n    return $txt == strrev($txt);\n}\n",
            "function modp($n, $p) {\n    // ret = 1\n    $ret = 1;\n    // for _ in range(n):\n    for ($i = 0; $i < $n; $i++) {\n        // ret = (ret * 2) % p\n        $ret = ($ret * 2) % $p;\n    }\n    // return ret\n    return $ret;\n}\n",
            "function encodeShift($s) {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    $result = [];\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        $result[] = chr(((ord($ch) - 97 + 5) % 26) + 97);\n    }\n    // return \"\".join(result)\n    return implode(\"\", $result);\n}\nfunction decodeShift($s) {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    $result = [];\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        $result[] = chr(((ord($ch) - 97 + 21) % 26) + 97);\n    }\n    // return \"\".join(result)\n    return implode(\"\", $result);\n}\n",
            "function removeVowels($txt) {\n    // vowels = \"aeiouAEIOU\"\n    $vowels = \"aeiouAEIOU\";\n    // return \"\".join([char for char in txt if char not in vowels])\n    return str_replace(str_split($vowels), \"\", $txt);\n}\n",
            "function belowThreshold($l, $t) {\n    // return all(x < t for x in l)\n    return all(function ($x) use ($t) {\n        return $x < $t;\n    }, $l);\n}\n",
            "function add($x, $y) {\n    // return x + y\n    return $x + $y;\n}\n",
            "function sameChars($s0, $s1) {\n    // return set(s0) == set(s1)\n    return count_chars($s0, 3) === count_chars($s1, 3);\n}\n",
            "function fib($n) {\n    // if n <= 1:\n    if ($n <= 1) {\n        // return n\n        return $n;\n    } else {\n        // return fib(n - 1) + fib(n - 2)\n        return fib($n - 1) + fib($n - 2);\n    }\n}\n",
            "function correctBracketing($brackets) {\n    // depth = 0\n    $depth = 0;\n    // for b in brackets:\n    for ($i = 0; $i < strlen($brackets); $i++) {\n        $b = $brackets[$i];\n        // if b == \"<\":\n        if ($b == \"<\") {\n            // depth += 1\n            $depth++;\n        }\n        // elif b == \">\":\n        elseif ($b == \">\") {\n            // depth -= 1\n            $depth--;\n        }\n        // if depth < 0:\n        if ($depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return $depth == 0;\n}\n",
            "function monotonic($l) {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    $diff = array_map(function ($x, $y) {\n        return $y - $x;\n    }, $l, array_slice($l, 1));\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    return all(function ($x) {\n        return $x <= 0;\n    }, $diff) || all(function ($x) {\n        return $x >= 0;\n    }, $diff);\n}\n",
            "function common($l1, $l2) {\n    // return sorted(list(set(l1) & set(l2)))\n    return array_values(array_intersect($l1, $l2));\n}\n",
            "function largestPrimeFactor ($n) {\n    // i = 2\n    $i = 2;\n    // while i * i <= n:\n    while ($i * $i <= $n) {\n        // if n % i:\n        if ($n % $i) {\n            // i += 1\n            $i++;\n        } else {\n            // n //= i\n            $n /= $i;\n        }\n    }\n    // return n\n    return $n;\n}\n",
            "function sumToN($n) {\n    // return sum(range(n + 1))\n    return array_sum(range(1, $n + 1));\n}\n",
            "function correctBracketing($brackets) {\n    // depth = 0\n    $depth = 0;\n    // for b in brackets:\n    for ($i = 0; $i < strlen($brackets); $i++) {\n        // b = brackets[$i]\n        $b = $brackets[$i];\n        // if b == \"(\":\n        if ($b == \"(\") {\n            // depth += 1\n            $depth++;\n        }\n        // elif b == \")\":\n        elseif ($b == \")\") {\n            // depth -= 1\n            $depth--;\n        }\n        // if depth < 0:\n        if ($depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return $depth == 0;\n}\n",
            "function derivative($xs) {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    return array_map(function ($i) use ($xs) {\n        return $xs[$i] * $i;\n    }, range(1, count($xs)));\n}\n",
            "function fibfib($n) {\n    // if n <= 1:\n    if ($n <= 1) {\n        // return 0 \n        return 0;\n    }\n    // a, b, c = 0, 0, 1\n    $a = 0;\n    $b = 0;\n    $c = 1;\n    // while n > 2:\n    while ($n > 2) {\n        // a, b, c = b, c, a + b + c\n        $a = $b;\n        $b = $c;\n        $c = $a + $b + $c;\n        // n -= 1\n        $n -= 1;\n    }\n    // return c\n    return $c;\n}\n",
            "function vowelsCount ($s) {\n    // vowels = \"aeiou\"\n    $vowels = \"aeiou\";\n    // cnt = 0\n    $cnt = 0;\n    // for i in range(len(s)):\n    for ($i = 0; $i < strlen($s); $i++) {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if (strpos(strtolower($vowels), $s[$i]) !== false || ($i == strlen($s) - 1 && strtolower($s[$i]) == \"y\")) {\n            // cnt += 1\n            $cnt++;\n        }\n    }\n    // return cnt\n    return $cnt;\n}\n",
            "function circularShift($x, $shift) {\n    // x_str = str(x)\n    $x_str = (string)$x;\n    // if shift > len(x_str):\n    if ($shift > strlen($x_str)) {\n        // return x_str[::-1]\n        return strrev($x_str);\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return substr($x_str, -$shift) . substr($x_str, 0, -$shift);\n    }\n}\n",
            "function digitSum($s) {\n    // return sum(ord(c) for c in s if c.isupper())\n    return array_sum(array_map(function ($c) {\n        return ord($c);\n    }, array_filter(str_split($s), function ($c) {\n        return ctype_upper($c);\n    })));\n}\n",
            "function fruitDistribution($s, $n) {\n    // words = s.split(' ')\n    $words = explode(' ', $s);\n    // apples = int(words[words.index(\"apples\") - 1])\n    $apples = intval($words[array_search('apples', $words) - 1]);\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    $oranges = intval($words[array_search('oranges', $words) - 1]);\n    // return n - apples - oranges\n    return $n - $apples - $oranges;\n}\n",
            "function pluck($arr) {\n    // evens = [n for n in arr if n % 2 == 0]\n    $evens = array_filter($arr, function ($n) {\n        return $n % 2 == 0;\n    });\n    // if len(evens) == 0:\n    if (count($evens) == 0) {\n        // return []\n        return [];\n    }\n    // min_even = min(evens)\n    $minEven = min($evens);\n    // return [min_even, arr.index(min_even)]\n    return [$minEven, array_search($minEven, $arr)];\n}\n",
            "function search($lst) {\n    // freqs = {}\n    $freqs = [];\n    // for n in lst:\n    foreach ($lst as $n) {\n        // freqs[n] = freqs.get(n, 0) + 1\n        $freqs[$n] = $freqs[$n] ?? 0 + 1;\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    $good_vals = [];\n    foreach ($freqs as $k => $v) {\n        if ($v >= $k) {\n            $good_vals[] = $k;\n        }\n    }\n    // return max(good_vals, default=-1)\n    return max($good_vals) ?? -1;\n}\n",
            "function strangeSortList($lst) {\n    // sl = sorted(lst)\n    $sl = sort($lst);\n    // result = []\n    $result = [];\n    // left, right = 0, len(sl) - 1\n    $left = 0;\n    $right = count($sl) - 1;\n    // while left <= right:\n    while ($left <= $right) {\n        // result.append(sl[left])\n        $result[] = $sl[$left];\n        $left += 1;\n        // if left <= right:\n        if ($left <= $right) {\n            // result.append(sl[right])\n            $result[] = $sl[$right];\n            $right -= 1;\n        }\n    }\n    // return result\n    return $result;\n}\n",
            "function triangleArea ($a, $b, $c) {\n    // if a + b > c and a + c > b and b + c > a:\n    if ($a + $b > $c && $a + $c > $b && $b + $c > $a) {\n        // s = (a + b + c) / 2.0\n        $s = ($a + $b + $c) / 2.0;\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return sqrt($s * ($s - $a) * ($s - $b) * ($s - $c));\n    } else {\n        // return -1.0\n        return -1.0;\n    }\n}\n",
            "function willItFly($q, $w) {\n    // if len(q) == 0:\n    if (count($q) == 0) {\n        // return False\n        return false;\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    $isPalin = true;\n    for ($i = 0; $i < count($q); $i++) {\n        if ($q[$i] != $q[count($q) - $i - 1]) {\n            $isPalin = false;\n            break;\n        }\n    }\n    // total = sum(q)\n    $total = array_sum($q);\n    // return is_palin and total <= w\n    return $isPalin && $total <= $w;\n}\n",
            "function smallestChange($arr) {\n    // ans = 0\n    $ans = 0;\n    // for i in range(len(arr) // 2):\n    for ($i = 0; $i < count($arr) / 2; $i++) {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if ($arr[$i] != $arr[count($arr) - $i - 1]) {\n            // ans += 1\n            $ans++;\n        }\n    }\n    // return ans\n    return $ans;\n}\n",
            "function totalMatch($lst1, $lst2) {\n    // cnt1 = sum(len(s) for s in lst1)\n    $cnt1 = array_sum(array_map(function ($s) {\n        return strlen($s);\n    }, $lst1));\n    // cnt2 = sum(len(s) for s in lst2)\n    $cnt2 = array_sum(array_map(function ($s) {\n        return strlen($s);\n    }, $lst2));\n    // return lst1 if cnt1 <= cnt2 else lst2\n    return $cnt1 <= $cnt2 ? $lst1 : $lst2;\n}\n",
            "function isPrime($n) {\n    // if n < 2:\n    if ($n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for ($i = 2; $i <= floor(sqrt($n)) + 1; $i++) {\n        // if n % i == 0:\n        if ($n % $i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nfunction isMultiplyPrime($a) {\n    // cnt = 0\n    $cnt = 0;\n    // for i in range(2, a + 1):\n    for ($i = 2; $i <= $a + 1; $i++) {\n        // if is_prime(i):\n        if (isPrime($i)) {\n            // while a % i == 0:\n            while ($a % $i == 0) {\n                // cnt += 1\n                $cnt++;\n                // a /= i\n                $a /= $i;\n            }\n        }\n    }\n    // return cnt == 3\n    return $cnt == 3;\n}\n",
            "function isSimplePower($x, $n) {\n    // if n < 2:\n    if ($n < 2) {\n        // return x == n\n        return $x == $n;\n    }\n    // tmp = 1\n    $tmp = 1;\n    // while tmp < x:\n    while ($tmp < $x) {\n        // tmp *= n\n        $tmp *= $n;\n    }\n    // return tmp == x\n    return $tmp == $x;\n}\n",
            "function isCube($a) {\n    // a = abs(a)\n    $a = abs($a);\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    $root = int(round(pow($a, 1.0 / 3.0)));\n    // return root * root * root == a\n    return $root * $root * $root == $a;\n}\n",
            "function hexKey($num) {\n    // return len([x for x in num if x in \"2357BD\"])\n    return strlen(preg_replace('/[^2357BD]/', '', $num));\n}\n",
            "function decimalToBinary($dec) {\n    // binary = bin(dec)[2:]\n    $binary = substr(decbin($dec), 2);\n    // return f\"db{binary}db\"\n    return \"db{$binary}db\";\n}\n",
            "function isHappy($s) {\n    // if len(s) < 3:\n    if (strlen($s) < 3) {\n        // return False\n        return false;\n    }\n    // for i in range(len(s) - 2):\n    for ($i = 0; $i < strlen($s) - 2; $i++) {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if ($s[$i] == $s[$i + 1] || $s[$i] == $s[$i + 2] || $s[$i + 1] == $s[$i + 2]) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "function numericalLetterGrade ($grades) {\n    // result = []\n    $result = [];\n    // for g in grades:\n    foreach ($grades as $g) {\n        // if g == 4.0:\n        if ($g == 4.0) {\n            // result.append(\"A+\")\n            $result[] = \"A+\";\n        }\n        // elif g > 3.7:\n        elseif ($g > 3.7) {\n            // result.append(\"A\")\n            $result[] = \"A\";\n        }\n        // elif g > 3.3:\n        elseif ($g > 3.3) {\n            // result.append(\"A-\")\n            $result[] = \"A-\";\n        }\n        // elif g > 3.0:\n        elseif ($g > 3.0) {\n            // result.append(\"B+\")\n            $result[] = \"B+\";\n        }\n        // elif g > 2.7:\n        elseif ($g > 2.7) {\n            // result.append(\"B\")\n            $result[] = \"B\";\n        }\n        // elif g > 2.3:\n        elseif ($g > 2.3) {\n            // result.append(\"B-\")\n            $result[] = \"B-\";\n        }\n        // elif g > 2.0:\n        elseif ($g > 2.0) {\n            // result.append(\"C+\")\n            $result[] = \"C+\";\n        }\n        // elif g > 1.7:\n        elseif ($g > 1.7) {\n            // result.append(\"C\")\n            $result[] = \"C\";\n        }\n        // elif g > 1.3:\n        elseif ($g > 1.3) {\n            // result.append(\"C-\")\n            $result[] = \"C-\";\n        }\n        // elif g > 1.0:\n        elseif ($g > 1.0) {\n            // result.append(\"D+\")\n            $result[] = \"D+\";\n        }\n        // elif g > 0.7:\n        elseif ($g > 0.7) {\n            // result.append(\"D\")\n            $result[] = \"D\";\n        }\n        // elif g > 0.0:\n        elseif ($g > 0.0) {\n            // result.append(\"D-\")\n            $result[] = \"D-\";\n        }\n        // else:\n        else {\n            // result.append(\"E\")\n            $result[] = \"E\";\n        }\n    }\n    // return result\n    return $result;\n}\n",
            "function primeLength($s) {\n    // length = len(s)\n    $length = strlen($s);\n    // if length < 2:\n    if ($length < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for ($i = 2; $i <= floor(sqrt($length)) + 1; $i++) {\n        // if length % i == 0:\n        if ($length % $i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "function startsOneEnds($n) {\n    // if n == 1:\n    if ($n == 1) {\n        // return 1\n        return 1;\n    }\n    // return 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * (10 ** ($n - 2));\n}\n",
            "function solve($n) {\n    // digits_sum = sum(int(d) for d in str(n))\n    $digits_sum = array_sum(array_map('intval', str_split($n)));\n    // return bin(digits_sum)[2:]\n    return substr(decbin($digits_sum), 2);\n}\n",
            "function add($lst) {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    return array_sum(array_filter($lst, function ($x, $i) {\n        return $i % 2 == 1 && $x % 2 == 0;\n    }, ARRAY_FILTER_USE_BOTH));\n}\n",
            "function antiShuffle($s) {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    $words = array_map(function ($word) {\n        return join(\"\", sort(str_split($word)));\n    }, explode(\" \", $s));\n    // return \" \".join(words)\n    return join(\" \", $words);\n}\n",
            "function getRow($lst, $x) {\n    $coords = [];\n    // for i in range(len(lst)):\n    for ($i = 0; $i < count($lst); $i++) {\n        // for j in range(len(lst[i])):\n        for ($j = 0; $j < count($lst[$i]); $j++) {\n            // if lst[i][j] == x:\n            if ($lst[$i][$j] == $x) {\n                // coords.append([i, j])\n                $coords[] = [$i, $j];\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    return array_map(function ($a) {\n        return [$a[0], -$a[1]];\n    }, $coords);\n}\n",
            "function sortArray ($arr) {\n    // if len(arr) == 0:\n    if (count($arr) == 0) {\n        // return []\n        return [];\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if (($arr[0] + $arr[count($arr) - 1]) % 2 == 0) {\n        // return sorted(arr, reverse=True)\n        return array_reverse(sort($arr));\n    } else {\n        // return sorted(arr)\n        return sort($arr);\n    }\n}\n",
            "function encrypt($s) {\n    // result = []\n    $result = [];\n    // for ch in s:\n    for ($i = 0; $i < strlen($s); $i++) {\n        // shifted = ord(ch) + 4\n        $shifted = ord($s[$i]) + 4;\n        // if shifted > ord('z'):\n        if ($shifted > ord('z')) {\n            // shifted -= 26\n            $shifted -= 26;\n        }\n        // result.append(chr(shifted))\n        $result[] = chr($shifted);\n    }\n    // return \"\".join(result)\n    return join($result);\n}\n",
            "function nextSmallest($lst) {\n    // sl = sorted(set(lst))\n    $sl = array_values(array_unique(sort($lst)));\n    // if len(sl) < 2:\n    if (count($sl) < 2) {\n        // return None\n        return null;\n    }\n    // return sl[1]\n    return $sl[1];\n}\n",
            "function isBored($s) {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    $sentences = preg_split(\"/[.!?]\\s*/\", $s);\n    // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    return array_sum(array_map(function ($sentence) {\n        return substr($sentence, 0, 2) == \"I \";\n    }, array_filter($sentences, function ($sentence) {\n        return strlen($sentence) >= 2;\n    })));\n}\n",
            "function anyInt($x, $y, $z) {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if (is_int($x) && is_int($y) && is_int($z)) {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if ($x + $y == $z || $x + $z == $y || $y + $z == $x) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "function encode($message) {\n    // vowels = \"aeiouAEIOU\"\n    $vowels = \"aeiouAEIOU\";\n    // result = []\n    $result = [];\n    // for ch in message:\n    for ($i = 0; $i < strlen($message); $i++) {\n        $ch = $message[$i];\n        // if ch.isalpha():\n        if (ctype_alpha($ch)) {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            $ch1 = ctype_lower($ch) ? strtoupper($ch) : strtolower($ch);\n            // if ch1 in vowels:\n            if (strpos($vowels, $ch1) !== false) {\n                // ch1 = chr(ord(ch1) + 2)\n                $ch1 = chr(ord($ch1) + 2);\n            }\n            // result.append(ch1)\n            $result[] = $ch1;\n        } else {\n            // result.append(ch)\n            $result[] = $ch;\n        }\n    }\n    // return \"\".join(result)\n    return implode(\"\", $result);\n}\n",
            "function isPrime($n) {\n    // if n < 2:\n    if ($n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for ($i = 2; $i <= floor(sqrt($n)) + 1; $i++) {\n        // if n % i == 0:\n        if ($n % $i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nfunction skjkasdkd($lst) {\n    // primes = [n for n in lst if is_prime(n)]\n    $primes = array_filter($lst, 'isPrime');\n    // if len(primes) == 0:\n    if (count($primes) == 0) {\n        // return 0\n        return 0;\n    }\n    // largest = str(max(primes))\n    $largest = str(max($primes));\n    // return sum(int(digit) for digit in largest)\n    return array_sum(array_map('intval', str_split($largest)));\n}\n",
            "function checkDictCase ($d) {\n    // if not d:\n    if (!$d) {\n        // return False\n        return false;\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    return all(function ($c) {\n        return ctype_lower($c);\n    }, array_keys($d)) || all(function ($c) {\n        return ctype_upper($c);\n    }, array_keys($d));\n}\n",
            "function countUpTo($n) {\n    // primes = []\n    $primes = [];\n    // for num in range(2, n):\n    for ($num = 2; $num <= $n; $num++) {\n        // if all(num % p != 0 for p in primes):\n        if (all(function ($p) use ($num, $primes) {\n            return $num % $p != 0;\n        }, $primes)) {\n            // primes.append(num)\n            $primes[] = $num;\n        }\n    }\n    // return primes\n    return $primes;\n}\n",
            "function multiply($a, $b) {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    return abs($a) % 10 * abs($b) % 10;\n}\n",
            "function countUpper($s) {\n    // vowels = \"AEIOU\"\n    $vowels = \"AEIOU\";\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    return count(array_filter(str_split($s), function ($c) use ($vowels) {\n        return $c % 2 == 0 && strpos($vowels, $c) !== false;\n    }));\n}\n",
            "function closestInteger($value) {\n    // num = float(value)\n    $num = floatval($value);\n    // if num >= 0:\n    if ($num >= 0) {\n        // return int(num + 0.5)\n        return intval($num + 0.5);\n    } else {\n        // return int(num - 0.5)\n        return intval($num - 0.5);\n    }\n}\n",
            "function makeAPile($n) {\n    // return [n + 2 * i for i in range(n)]\n    return array_map(function ($i) use ($n) {\n        return $n + 2 * $i;\n    }, range(0, $n - 1));\n}\n",
            "function wordsString($s) {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    return array_filter(preg_split(\"/[, ]/\", $s), function ($w) {\n        return strlen($w) > 0;\n    });\n}\n",
            "function chooseNum($x, $y) {\n    // if x > y:\n    if ($x > $y) {\n        // return -1\n        return -1;\n    }\n    // if y % 2 == 0:\n    if ($y % 2 == 0) {\n        // return y\n        return $y;\n    }\n    // return y - 1 if x != y else -1\n    return $x != $y ? $y - 1 : -1;\n}\n",
            "function roundedAvg($n, $m) {\n    // if n > m:\n    if ($n > $m) {\n        // return None\n        return null;\n    }\n    // r_avg = int((m + n) / 2.0 + 0.5)\n    $r_avg = int(($m + $n) / 2.0 + 0.5);\n    // return bin(r_avg)[2:]\n    return decbin($r_avg);\n}\n",
            "function allDigitsOdd($s) {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    return all(ord($digit) % 2 != 0 for $digit in $s);\n}\nfunction uniqueDigits($x) {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    return sorted([$num for $num in $x if allDigitsOdd(strval($num))]);\n}\n",
            "function byLength($arr) {\n    // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    $digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n    $sortedArr = array_map(function ($x) {\n        return $x;\n    }, array_filter($arr, function ($x) {\n        return 1 <= $x && $x <= 9;\n    }));\n    sort($sortedArr, SORT_NUMERIC | SORT_DESC);\n    // return [digit_names[x-1] for x in sorted_arr]\n    return array_map(function ($x) use ($digitNames) {\n        return $digitNames[$x - 1];\n    }, $sortedArr);\n}\n",
            "function f($n) {\n    // nums = list(range(1, n + 1))\n    $nums = range(1, $n + 1);\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    return array_map(function ($i) use ($nums) {\n        return $i % 2 != 0 ? array_sum(array_slice($nums, 0, $i)) : array_reduce(array_slice($nums, 0, $i), function ($x, $y) {\n            return $x * $y;\n        }, 1);\n    }, $nums);\n}\n",
            "function isPalindrome($txt) {\n    // return txt == txt[::-1]\n    return $txt == strrev($txt);\n}\nfunction evenOddPalindrome($n) {\n    // cnt = [0, 0]\n    $cnt = [0, 0];\n    // for i in range(1, n + 1):\n    for ($i = 1; $i <= $n; $i++) {\n        // if is_palindrome(str(i)):\n        if (isPalindrome((string)$i)) {\n            // cnt[i % 2] += 1\n            $cnt[$i % 2]++;\n        }\n    }\n    // return cnt\n    return $cnt;\n}\n",
            "function digitsSum($n) {\n    // n_str = str(n)\n    $n_str = (string)$n;\n    // if n >= 0:\n    if ($n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return array_sum(array_map('intval', str_split($n_str)));\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return intval(substr($n_str, 0, 2)) * 2 + digitsSum(abs($n));\n    }\n}\nfunction countNums($arr) {\n    // return len([n for n in arr if digits_sum(n) > 0])\n    return count(array_filter($arr, function ($n) {\n        return digitsSum($n) > 0;\n    }));\n}\n",
            "function moveOneBall($arr) {\n    // if len(arr) == 0:\n    if (count($arr) == 0) {\n        // return True\n        return true;\n    }\n    // sorted_arr = sorted(arr)\n    $sortedArr = sort($arr);\n    // for i in range(0, len(arr)):\n    for ($i = 0; $i < count($arr); $i++) {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if (array_slice($arr, $i) == array_slice($sortedArr, 0, count($arr) - $i) && array_slice($arr, 0, $i) == array_slice($sortedArr, count($arr) - $i)) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "function canExchange($lst1, $lst2) {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    $odd_cnt = count(array_filter($lst1, function ($num) {\n        return $num % 2 != 0;\n    }));\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    $even_cnt = count(array_filter($lst2, function ($num) {\n        return $num % 2 == 0;\n    }));\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    return $even_cnt >= $odd_cnt ? \"YES\" : \"NO\";\n}\n",
            "function histogram($test) {\n    // freq = {}\n    $freq = [];\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    $words = array_filter(explode(' ', $test), function ($w) {\n        return strlen($w) > 0;\n    });\n    // for w in words:\n    foreach ($words as $w) {\n        // freq[w] = freq.get(w, 0) + 1\n        $freq[$w] = isset($freq[$w]) ? $freq[$w] + 1 : 1;\n    }\n    // result = {}\n    $result = [];\n    // if len(freq) > 0:\n    if (count($freq) > 0) {\n        // max_freq = max(freq.values())\n        $max_freq = max($freq);\n        // for k, v in freq.items():\n        foreach ($freq as $k => $v) {\n            // if v == max_freq:\n            if ($v == $max_freq) {\n                // result[k] = v\n                $result[$k] = $v;\n            }\n        }\n    }\n    // return result\n    return $result;\n}\n",
            "function isPalindrome($s) {\n    // return s == s[::-1]\n    return $s == strrev($s);\n}\nfunction reverseDelete($s, $c) {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    $s1 = str_replace(str_split($c), '', $s);\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    return [$s1, isPalindrome($s1) ? 'yes' : 'no'];\n}\n",
            "function oddCount($lst) {\n    // result = []\n    $result = [];\n    // for num in lst:\n    foreach ($lst as $num) {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        $n = 0;\n        for ($i = 0; $i < strlen($num); $i++) {\n            $n += ord($num[$i]) % 2 == 1 ? 1 : 0;\n        }\n        // rs = \"the number of odd elements in the string i of the input.\"\n        $rs = \"the number of odd elements in the string i of the input.\";\n        // result.append(rs.replace(\"i\", str(n)))\n        $result[] = str_replace(\"i\", str($n), $rs);\n    }\n    // return result\n    return $result;\n}\n",
            "function minSubArraySum ($nums) {\n    // min_sum = 0\n    $minSum = 0;\n    // cur_sum = 0\n    $curSum = 0;\n    // for n in nums:\n    foreach ($nums as $n) {\n        // cur_sum = min(cur_sum + n, 0)\n        $curSum = min($curSum + $n, 0);\n        // min_sum = min(cur_sum, min_sum)\n        $minSum = min($curSum, $minSum);\n    }\n    // if min_sum == 0:\n    if ($minSum == 0) {\n        // min_sum = min(nums)\n        $minSum = min($nums);\n    }\n    // return min_sum\n    return $minSum;\n}\n",
            "function maxFill ($grid, $capacity) {\n    // return sum([ceil(sum(arr) / capacity) for arr in grid])\n    return array_sum(array_map(function ($arr) use ($capacity) {\n        return ceil(array_sum($arr) / $capacity);\n    }, $grid));\n}\n",
            "function countOnes($num) {\n    // return bin(num).count(\"1\")\n    return substr_count(decbin($num), '1');\n}\nfunction sortArray($arr) {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    return array_map(function ($x) {\n        return [countOnes($x), $x];\n    }, $arr);\n}\n",
            "function selectWords ($s, $n) {\n    // consonants = \"bcdfghjklmnpqrstvwxyz\"\n    $consonants = \"bcdfghjklmnpqrstvwxyz\";\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    $words = array_filter(explode(\" \", $s), function ($w) {\n        return strlen($w) > 0;\n    });\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    return array_filter($words, function ($w) use ($consonants, $n) {\n        return count(array_filter(str_split($w), function ($c) use ($consonants) {\n            return strpos($consonants, strtolower($c)) !== false;\n        })) == $n;\n    });\n}\n",
            "function getClosestVowel($word) {\n    // vowels = \"aeiouAEIOU\"\n    $vowels = \"aeiouAEIOU\";\n    // for i in range(len(word) - 2, 0, -1):\n    for ($i = strlen($word) - 2; $i >= 0; $i--) {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if (strpos($vowels, $word[$i]) !== false && strpos($vowels, $word[$i - 1]) === false && strpos($vowels, $word[$i + 1]) === false) {\n            // return word[i]\n            return $word[$i];\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "function check($s) {\n    // depth = 0\n    $depth = 0;\n    // for ch in s:\n    for ($i = 0; $i < strlen($s); $i++) {\n        // if ch == \"(\":\n        if ($s[$i] == \"(\") {\n            // depth += 1\n            $depth++;\n        } else {\n            // depth -= 1\n            $depth--;\n        }\n        // if depth < 0:\n        if ($depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True if depth == 0 else False\n    return $depth == 0;\n}\nfunction matchParens($lst) {\n    // s1 = lst[0] + lst[1]\n    $s1 = $lst[0] . $lst[1];\n    // s2 = lst[1] + lst[0]\n    $s2 = $lst[1] . $lst[0];\n    // return \"Yes\" if check(s1) or check(s2) else \"No\"\n    return check($s1) || check($s2) ? \"Yes\" : \"No\";\n}\n",
            "function maximum($arr, $k) {\n    // if k == 0:\n    if ($k == 0) {\n        // return []\n        return [];\n    }\n    // return sorted(arr)[-k:]\n    return array_slice(sort($arr), -$k);\n}\n",
            "function solution($lst) {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    return array_sum(array_filter($lst, function ($x, $i) {\n        return $i % 2 == 0 && $x % 2 != 0;\n    }, ARRAY_FILTER_USE_BOTH));\n}\n",
            "function addElements($arr, $k) {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    return array_sum(array_filter($arr, function ($n) use ($k) {\n        return strlen((string)$n) <= 2 && $n <= $k;\n    }));\n}\n",
            "function getOddCollatz($n) {\n    // collatz = [1]\n    $collatz = [1];\n    // while n != 1:\n    while ($n != 1) {\n        // if n % 2 != 0:\n        if ($n % 2 != 0) {\n            // collatz.append(n)\n            $collatz[] = $n;\n            // n = 3 * n + 1\n            $n = 3 * $n + 1;\n        } else {\n            // n = n // 2\n            $n = $n / 2;\n        }\n    }\n    // return sorted(collatz)\n    return sort($collatz);\n}\n",
            "function validDate($date) {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if (strlen($date) != 10 || $date[2] != \"-\" || $date[5] != \"-\") {\n        return false;\n    }\n    // m = int(date[:2])\n    $m = intval(substr($date, 0, 2));\n    // d = int(date[3:5])\n    $d = intval(substr($date, 3, 2));\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if (in_array($m, [1, 3, 5, 7, 8, 10, 12]) && $d >= 1 && $d <= 31) {\n        return true;\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if (in_array($m, [4, 6, 9, 11]) && $d >= 1 && $d <= 30) {\n        return true;\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if ($m == 2 && $d >= 1 && $d <= 29) {\n        return true;\n    }\n    // return False\n    return false;\n}\n",
            "function splitWords($txt) {\n    // if \" \" in txt:\n    if (strpos($txt, \" \") !== false) {\n        // return txt.split(\" \")\n        return explode(\" \", $txt);\n    }\n    // elif \",\" in txt:\n    elseif (strpos($txt, \",\") !== false) {\n        // return txt.split(\",\")\n        return explode(\",\", $txt);\n    }\n    // else:\n    else {\n        // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        return [str(count(array_filter(str_split($txt), function ($c) {\n            return ctype_lower($c) && ord($c) % 2 == 0;\n        })))];\n    }\n}\n",
            "function isSorted($lst) {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    if (!all(function ($i) use ($lst) {\n        return $lst[$i - 1] <= $lst[$i];\n    }, range(1, count($lst)))) {\n        return false;\n    }\n    // freq = {}\n    $freq = [];\n    // for i in lst:\n    foreach ($lst as $i) {\n        // freq[i] = freq.get(i, 0) + 1\n        $freq[$i] = $freq[$i] ?? 0 + 1;\n    }\n    // return max(freq.values(), default=0) <= 2\n    return max(array_values($freq)) <= 2;\n}\n",
            "function isPrime($n) {\n    // if n < 2:\n    if ($n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for ($i = 2; $i <= floor(sqrt($n)) + 1; $i++) {\n        // if n % i == 0:\n        if ($n % $i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nfunction intersection($interval1, $interval2) {\n    // l = max(interval1[0], interval2[0])\n    $l = max($interval1[0], $interval2[0]);\n    // r = min(interval1[1], interval2[1])\n    $r = min($interval1[1], $interval2[1]);\n    // length = r - l\n    $length = $r - $l;\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    return $length > 0 && isPrime($length) ? \"YES\" : \"NO\";\n}\n",
            "function prodSigns ($arr) {\n    // if not arr:\n    if (!$arr) {\n        // return None\n        return null;\n    }\n    // if 0 in arr:\n    if (in_array(0, $arr)) {\n        // return 0\n        return 0;\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    $sign = -1;\n    if (count(array_filter($arr, function ($n) { return $n < 0; })) % 2 == 1) {\n        $sign = 1;\n    }\n    // return sign * sum([abs(n) for n in arr])\n    return $sign * array_sum(array_map(function ($n) { return abs($n); }, $arr));\n}\n",
            "function minPath($grid, $k) {\n    // n = len(grid)\n    $n = count($grid);\n    // min_val = n * n + 1\n    $min_val = $n * $n + 1;\n    // for i in range(n):\n    for ($i = 0; $i < $n; $i++) {\n        // for j in range(n):\n        for ($j = 0; $j < $n; $j++) {\n            // if grid[i][j] == 1:\n            if ($grid[$i][$j] == 1) {\n                // temp = []\n                $temp = [];\n                // if i != 0:\n                if ($i != 0) {\n                    // temp.append(grid[i - 1][j])\n                    $temp[] = $grid[$i - 1][$j];\n                }\n                // if j != 0:\n                if ($j != 0) {\n                    // temp.append(grid[i][j - 1])\n                    $temp[] = $grid[$i][$j - 1];\n                }\n                // if i != n - 1:\n                if ($i != $n - 1) {\n                    // temp.append(grid[i + 1][j])\n                    $temp[] = $grid[$i + 1][$j];\n                }\n                // if j != n - 1:\n                if ($j != $n - 1) {\n                    // temp.append(grid[i][j + 1])\n                    $temp[] = $grid[$i][$j + 1];\n                }\n                // min_val = min(temp)\n                $min_val = min($temp);\n            }\n        }\n    }\n    // result = []\n    $result = [];\n    // for i in range(k):\n    for ($i = 0; $i < $k; $i++) {\n        // result.append(1 if i % 2 == 0 else min_val)\n        $result[] = $i % 2 == 0 ? 1 : $min_val;\n    }\n    // return result\n    return $result;\n}\n",
            "function tri($n) {\n    // if n == 0:\n    if ($n == 0) {\n        // return [1]\n        return [1];\n    }\n    // seq = [1, 3]\n    $seq = [1, 3];\n    // for i in range(2, n + 1):\n    for ($i = 2; $i <= $n + 1; $i++) {\n        // if i % 2 == 0:\n        if ($i % 2 == 0) {\n            // seq.append(i / 2 + 1)\n            $seq[] = $i / 2 + 1;\n        } else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            $seq[] = $seq[$i - 1] + $seq[$i - 2] + ($i + 3) / 2;\n        }\n    }\n    // return seq\n    return $seq;\n}\n",
            "function digits($n) {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    $odds = array_map(function ($d) {\n        return intval($d);\n    }, array_filter(str_split(strval($n)), function ($d) {\n        return intval($d) % 2 == 1;\n    }));\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    return count($odds) > 0 ? array_reduce($odds, function ($x, $y) {\n        return $x * $y;\n    }, 1) : 0;\n}\n",
            "function isNested($s) {\n    // open_idx = []\n    $open_idx = [];\n    // close_idx = []\n    $close_idx = [];\n    // for i, ch in enumerate(s):\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        // if ch == '[':\n        if ($ch == '[') {\n            // open_idx.append(i)\n            $open_idx[] = $i;\n        }\n        // elif ch == ']':\n        elseif ($ch == ']') {\n            // close_idx.append(i)\n            $close_idx[] = $i;\n        }\n    }\n    // close_idx.reverse()\n    $close_idx = array_reverse($close_idx);\n    // cnt = 0\n    $cnt = 0;\n    // i = 0\n    $i = 0;\n    // l = len(close_idx)\n    $l = count($close_idx);\n    // for idx in open_idx:\n    foreach ($open_idx as $idx) {\n        // if i < l and idx < close_idx[i]:\n        if ($i < $l && $idx < $close_idx[$i]) {\n            // cnt += 1\n            $cnt++;\n            // i += 1\n            $i++;\n        }\n    }\n    // return cnt >= 2\n    return $cnt >= 2;\n}\n",
            "function sumSquares($lst) {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    return array_sum(array_map(function ($n) {\n        return pow(ceil($n), 2);\n    }, $lst));\n}\n",
            "function checkIfLastCharIsALetter($txt) {\n    // if not txt:\n    if (!$txt) {\n        // return False\n        return false;\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    $last = substr($txt, strrpos($txt, ' ') + 1);\n    // return len(last) == 1 and last[0].isalpha()\n    return strlen($last) == 1 && ctype_alpha($last[0]);\n}\n",
            "function canArrange($arr) {\n    // if len (arr) <= 1:\n    if (count($arr) <= 1) {\n        // return -1\n        return -1;\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    $idx = array_filter(range(1, count($arr)), function ($i) use ($arr) {\n        return $arr[$i] < $arr[$i - 1];\n    });\n    // return max(idx, default=-1)\n    return max($idx, -1);\n}\n",
            "function largestSmallestIntegers ($lst) {\n    // neg = [i for i in lst if i < 0]\n    $neg = array_filter($lst, function ($i) {\n        return $i < 0;\n    });\n    // pos = [i for i in lst if i > 0]\n    $pos = array_filter($lst, function ($i) {\n        return $i > 0;\n    });\n    // max_neg = max(neg) if len(neg) > 0 else None\n    $maxNeg = count($neg) > 0 ? max($neg) : null;\n    // min_pos = min(pos) if len(pos) > 0 else None\n    $minPos = count($pos) > 0 ? min($pos) : null;\n    // return [max_neg, min_pos]\n    return [$maxNeg, $minPos];\n}\n",
            "function anyToReal($o) {\n    // if isinstance(o, str): \n    if (is_string($o)) {\n        // return float(o.replace(',','.'))\n        return float(str_replace(',', '.', $o));\n    }\n    // elif isinstance(o, int):\n    elseif (is_int($o)) {\n        // return float(o)\n        return float($o);\n    }\n    // elif isinstance(o, float):\n    elseif (is_float($o)) {\n        // return o\n        return $o;\n    }\n    // raise RuntimeError(\"Type Error\");\n    throw new RuntimeException(\"Type Error\");\n}\nfunction compareOne($a, $b) {\n    // a1 = any_to_real(a)\n    $a1 = anyToReal($a);\n    // b1 = any_to_real(b)\n    $b1 = anyToReal($b);\n    // if a1 == b1:\n    if ($a1 == $b1) {\n        // return None\n        return null;\n    }\n    // elif a1 > b1:\n    elseif ($a1 > $b1) {\n        // return a1\n        return $a1;\n    }\n    // else:\n    else {\n        // return b1\n        return $b1;\n    }\n}\n",
            "function isEqualToSumEven($n) {\n    // return n % 2 == 0 and n >= 8\n    return $n % 2 == 0 && $n >= 8;\n}\n",
            "function specialFactorial($n) {\n    // fact = 1\n    $fact = 1;\n    // result = 1\n    $result = 1;\n    // for i in range(1, n + 1):\n    for ($i = 1; $i <= $n; $i++) {\n        // fact *= i\n        $fact *= $i;\n        // result *= fact\n        $result *= $fact;\n    }\n    // return result\n    return $result;\n}\n",
            "function fixSpaces($txt) {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    return preg_replace('/\\s{3,}/', '-', str_replace(' ', '_', $txt));\n}\n",
            "function fileNameCheck($fileName) {\n    // suf = [\"txt\", \"exe\", \"dll\"]\n    $suf = [\"txt\", \"exe\", \"dll\"];\n    // lst = file_name.split(\".\")\n    $lst = explode(\".\", $fileName);\n    // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n    if (count($lst) != 2 || !in_array($lst[1], $suf) || strlen($lst[0]) == 0 || !ctype_alpha($lst[0][0]) || count(preg_grep(\"/[0-9]/\", str_split($lst[0]))) > 3) {\n        // return \"No\"\n        return \"No\";\n    }\n    // return \"Yes\"\n    return \"Yes\";\n}\n",
            "function sumSquares($lst) {\n    // result = 0\n    $result = 0;\n    // for i in range(len(lst)):\n    for ($i = 0; $i < count($lst); $i++) {\n        // if i % 3 == 0:\n        if ($i % 3 == 0) {\n            // result += pow(lst[i], 2)\n            $result += pow($lst[$i], 2);\n        }\n        // elif i % 4 == 0:\n        elseif ($i % 4 == 0) {\n            // result += pow(lst[i], 3)\n            $result += pow($lst[$i], 3);\n        }\n        // else:\n        else {\n            // result += lst[i]\n            $result += $lst[$i];\n        }\n    }\n    // return result\n    return $result;\n}\n",
            "function isPrime($n) {\n    // if n < 2:\n    if ($n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for ($i = 2; $i <= floor(sqrt($n)) + 1; $i++) {\n        // if n % i == 0:\n        if ($n % $i == 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nfunction wordsInSentence($sentence) {\n    // words = sentence.split(\" \")\n    $words = explode(\" \", $sentence);\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    return implode(\" \", array_filter($words, function ($w) {\n        return isPrime(strlen($w));\n    }));\n}\n",
            "function simplify($x, $n) {\n    // xs = x.split(\"/\")\n    $xs = explode(\"/\", $x);\n    // ns = n.split(\"/\")\n    $ns = explode(\"/\", $n);\n    // num = int(xs[0]) * int(ns[0])\n    $num = intval($xs[0]) * intval($ns[0]);\n    // den = int(xs[1]) * int(ns[1])\n    $den = intval($xs[1]) * intval($ns[1]);\n    // return num % den == 0\n    return $num % $den == 0;\n}\n",
            "function digitsSum ($n) {\n    // n_str = str(n)\n    $nStr = (string)$n;\n    // if n >= 0:\n    if ($n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return array_sum(array_map('intval', str_split($nStr)));\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return intval(substr($nStr, 0, 2)) * 2 + digitsSum(abs($n));\n    }\n}\nfunction orderByPoints ($nums) {\n    // return sorted(nums, key=digits_sum)\n    return array_values(array_sort($nums, function ($a, $b) {\n        return digitsSum($a) - digitsSum($b);\n    }));\n}\n",
            "function specialFilter($nums) {\n    // odds = \"13579\"\n    $odds = \"13579\";\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    return count(array_filter($nums, function ($n) use ($odds) {\n        return $n > 10 && $n % 2 == 1 && strpos($odds, (string) $n[0]) !== false;\n    }));\n}\n",
            "function getMaxTriples ($n) {\n    // c = [0, 0, 0]\n    $c = [0, 0, 0];\n    // for i in range(1, n + 1):\n    for ($i = 1; $i <= $n; $i++) {\n        // a = i * i - i + 1\n        $a = $i * $i - $i + 1;\n        // c[a % 3] += 1\n        $c[$a % 3] += 1;\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    return $c[0] * $c[1] * $c[2] + ($c[0] * ($c[0] - 1) * ($c[0] - 2) + $c[1] * ($c[1] - 1) * ($c[1] - 2) + $c[2] * ($c[2] - 1) * ($c[2] - 2)) // 6;\n}\n",
            "function bf($planet1, $planet2) {\n    // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    $names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    // if planet1 not in names or planet2 not in names:\n    if (!in_array($planet1, $names) || !in_array($planet2, $names)) {\n        // return []\n        return [];\n    }\n    // l = names.index(planet1)\n    $l = array_search($planet1, $names);\n    // r = names.index(planet2)\n    $r = array_search($planet2, $names);\n    // if l > r:\n    if ($l > $r) {\n        // l, r = r, l\n        $l = $r;\n        $r = $l;\n    }\n    // if l == r:\n    if ($l == $r) {\n        // return []\n        return [];\n    }\n    // return names[l + 1 : r]\n    return array_slice($names, $l + 1, $r - $l - 1);\n}\n",
            "function sortedListSum($lst) {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    $result = array_filter($lst, function ($s) {\n        return strlen($s) % 2 == 0;\n    });\n    // return sorted(result, key=lambda x: (len(x), x))\n    return array_map(function ($x) {\n        return [strlen($x), $x];\n    }, $result);\n}\n",
            "function xOrY($n, $x, $y) {\n    // if n < 2:\n    if ($n < 2) {\n        // return y\n        return $y;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for ($i = 2; $i <= floor(sqrt($n)) + 1; $i++) {\n        // if n % i == 0:\n        if ($n % $i == 0) {\n            // return y\n            return $y;\n        }\n    }\n    // return x\n    return $x;\n}\n",
            "function doubleTheDifference ($lst) {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    return array_sum(array_map(function ($n) {\n        return $n * $n;\n    }, array_filter($lst, function ($n) {\n        return $n >= 0 && $n % 2 == 1;\n    })));\n}\n",
            "function compare($game, $guess) {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    return array_map(function ($x, $y) {\n        return abs($x - $y);\n    }, $game, $guess);\n}\n",
            "function strongestExtension ($className, $extensions) {\n    // max_s = float(\"-inf\")\n    $maxS = -INF;\n    // max_ext = \"\"\n    $maxExt = \"\";\n    // for ext in extensions:\n    foreach ($extensions as $ext) {\n        // upper = len([c for c in ext if c.isupper()])\n        $upper = count(preg_grep('/[A-Z]/', str_split($ext)));\n        // lower = len([c for c in ext if c.islower()])\n        $lower = count(preg_grep('/[a-z]/', str_split($ext)));\n        // s = upper - lower\n        $s = $upper - $lower;\n        // if s > max_s:\n        if ($s > $maxS) {\n            // max_s = s\n            $maxS = $s;\n            // max_ext = ext\n            $maxExt = $ext;\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    return $className . \".\" . $maxExt;\n}\n",
            "function cycpatternCheck($a, $b) {\n    // if len(a) < len(b):\n    if (strlen($a) < strlen($b)) {\n        // return False\n        return false;\n    }\n    // for i in range(len(b)):\n    for ($i = 0; $i < strlen($b); $i++) {\n        // if b[i:] + b[:i] in a:\n        if (strpos($a, substr($b, $i) . substr($b, 0, $i)) !== false) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "function evenOddCount($num) {\n    // ds = str(abs(num))\n    $ds = str_split(abs($num));\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    $even = count(array_filter($ds, function ($d) {\n        return ord($d) % 2 == 0;\n    }));\n    // return [even, len(ds) - even]\n    return [$even, count($ds) - $even];\n}\n",
            "function intToMiniRoman($num) {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    $values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    $numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    // res = []\n    $res = [];\n    // for i in range(len(values)):\n    for ($i = 0; $i < count($values); $i++) {\n        // while num >= values[i]:\n        while ($num >= $values[$i]) {\n            // res.append(numerals[i])\n            $res[] = $numerals[$i];\n            // num -= values[i]\n            $num -= $values[$i];\n        }\n    }\n    // return \"\".join(res)\n    return implode(\"\", $res);\n}\n",
            "function rightAngleTriangle ($a, $b, $c) {\n    // s = sorted([a, b, c])\n    $s = [$a, $b, $c];\n    sort($s);\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return $s[0] * $s[0] + $s[1] * $s[1] == $s[2] * $s[2];\n}\n",
            "function findMax ($words) {\n    // max_cnt = 0\n    $maxCnt = 0;\n    // max_w = \"\"\n    $maxW = \"\";\n    // for w in words:\n    foreach ($words as $w) {\n        // cnt = len(set(w))\n        $cnt = count(array_unique(str_split($w)));\n        // if cnt > max_cnt:\n        if ($cnt > $maxCnt) {\n            // max_cnt = cnt\n            $maxCnt = $cnt;\n            // max_w = w\n            $maxW = $w;\n        } elseif ($cnt == $maxCnt) {\n            // max_w = min(max_w, w)\n            $maxW = min($maxW, $w);\n        }\n    }\n    // return max_w\n    return $maxW;\n}\n",
            "function eat($num, $need, $remaining) {\n    // if need <= remaining:\n    if ($need <= $remaining) {\n        // return [num + need, remaining - need]\n        return [$num + $need, $remaining - $need];\n    } else {\n        // return [num + remaining, 0]\n        return [$num + $remaining, 0];\n    }\n}\n",
            "function doAlgebra($operators, $operands) {\n    // ops = operators.copy()\n    $ops = $operators;\n    // nums = operands.copy()\n    $nums = $operands;\n    // i = len(ops) - 1\n    $i = count($ops) - 1;\n    // while i >= 0:\n    while ($i >= 0) {\n        // if ops[i] == \"**\":\n        if ($ops[$i] == \"**\") {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            $nums[$i] = pow($nums[$i], $nums[$i + 1]);\n            // nums.pop(i + 1)\n            array_pop($nums);\n            // ops.pop(i)\n            array_pop($ops);\n        }\n        // i -= 1\n        $i -= 1;\n    }\n    // i = 0\n    $i = 0;\n    // while i < len(ops):\n    while ($i < count($ops)) {\n        // if ops[i] == \"*\":\n        if ($ops[$i] == \"*\") {\n            // nums[i] = nums[i] * nums[i + 1]\n            $nums[$i] = $nums[$i] * $nums[$i + 1];\n            // nums.pop(i + 1)\n            array_pop($nums);\n            // ops.pop(i)\n            array_pop($ops);\n            // i -= 1\n            $i -= 1;\n        }\n        // elif ops[i] == \"//\":\n        elseif ($ops[$i] == \"//\") {\n            // nums[i] = nums[i] // nums[i + 1]\n            $nums[$i] = $nums[$i] // $nums[$i + 1];\n            // nums.pop(i + 1)\n            array_pop($nums);\n            // ops.pop(i)\n            array_pop($ops);\n            // i -= 1\n            $i -= 1;\n        }\n        // i += 1\n        $i += 1;\n    }\n    // i = 0\n    $i = 0;\n    // while i < len(ops):\n    while ($i < count($ops)) {\n        // if ops[i] == \"+\":\n        if ($ops[$i] == \"+\") {\n            // nums[i] = nums[i] + nums[i + 1]\n            $nums[$i] = $nums[$i] + $nums[$i + 1];\n            // nums.pop(i + 1)\n            array_pop($nums);\n            // ops.pop(i)\n            array_pop($ops);\n            // i -= 1\n            $i -= 1;\n        }\n        // elif ops[i] == \"-\":\n        elseif ($ops[$i] == \"-\") {\n            // nums[i] = nums[i] - nums[i + 1]\n            $nums[$i] = $nums[$i] - $nums[$i + 1];\n            // nums.pop(i + 1)\n            array_pop($nums);\n            // ops.pop(i)\n            array_pop($ops);\n            // i -= 1\n            $i -= 1;\n        }\n        // i += 1\n        $i += 1;\n    }\n    // return nums[0]\n    return $nums[0];\n}\n",
            "function solve($s) {\n    // if not any(ch.isalpha() for ch in s):\n    if (!preg_match('/[a-zA-Z]/', $s)) {\n        // return s[::-1]\n        return strrev($s);\n    }\n    // result = []\n    $result = [];\n    // for ch in s:\n    for ($i = 0; $i < strlen($s); $i++) {\n        // ch = s[i]\n        $ch = $s[$i];\n        // if not ch.isalpha():\n        if (!preg_match('/[a-zA-Z]/', $ch)) {\n            // result.append(ch)\n            $result[] = $ch;\n        } elseif (preg_match('/[A-Z]/', $ch)) {\n            // result.append(ch.lower())\n            $result[] = strtolower($ch);\n        } elseif (preg_match('/[a-z]/', $ch)) {\n            // result.append(ch.upper())\n            $result[] = strtoupper($ch);\n        }\n    }\n    // return \"\".join(result)\n    return implode('', $result);\n}\n",
            "function stringToMd5 ($txt) {\n    // if not txt:\n    if (!$txt) {\n        // return None\n        return null;\n    }\n    // md5_hash = hashlib.md5()\n    $md5_hash = hash('md5');\n    // txt_bytes = txt.encode()\n    $txt_bytes = utf8_encode($txt);\n    // md5_hash.update(txt_bytes)\n    $md5_hash->update($txt_bytes);\n    // md5_encoded = md5_hash.hexdigest()\n    $md5_encoded = $md5_hash->hexdigest();\n    // return md5_encoded\n    return $md5_encoded;\n}\n",
            "function generateIntegers($a, $b) {\n    // lower = max(2, min(a, b))\n    $lower = max(2, min($a, $b));\n    // upper = min(8, max(a, b))\n    $upper = min(8, max($a, $b));\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    return array_filter(range($lower, $upper + 1), function ($i) {\n        return $i % 2 == 0;\n    });\n}\n"
        ],
        "ruby": [
            "def has_close_elements(numbers, threshold)\n    # for i in range(len(numbers)):\n    for i in 0...numbers.length\n        # for j in range(i + 1, len(numbers)):\n        for j in i + 1...numbers.length\n            # if abs(numbers[i] - numbers[j]) < threshold:\n            if (numbers[i] - numbers[j]).abs < threshold\n                # return True\n                return true\n            end\n        end\n    end\n    # return False\n    return false\nend\n",
            "def separate_paren_groups(paren_string)\n    # groups = []\n    groups = []\n    # stk = []\n    stk = []\n    # current_group = \"\"\n    current_group = \"\"\n    # parens = paren_string.replace(\" \", \"\")\n    parens = paren_string.gsub(\" \", \"\")\n    # for ch in parens:\n    for ch in parens\n        # if ch == \"(\":\n        if ch == \"(\"\n            # stk.append(ch)\n            stk.push(ch)\n            # current_group += ch\n            current_group += ch\n        # elif ch == \")\":\n        elsif ch == \")\"\n            # stk.pop()\n            stk.pop\n            # current_group += ch\n            current_group += ch\n            # if not stk:\n            if stk.empty?\n                # groups.append(current_group)\n                groups.push(current_group)\n                # current_group = \"\"\n                current_group = \"\"\n            end\n        end\n    end\n    # return groups\n    return groups\nend\n",
            "def truncate_number(num)\n    # return num - floor(num)\n    num - num.floor\nend\n",
            "def below_zero(operations)\n    # balance = 0\n    balance = 0\n    # for op in operations:\n    for op in operations\n        # balance += op\n        balance += op\n        # if balance < 0:\n        if balance < 0\n            # return True\n            return true\n        end\n    end\n    # return False\n    return false\nend\n",
            "def mean_absolute_deviation(numbers)\n    # mean = sum(numbers) / len(numbers)\n    mean = numbers.sum.to_f / numbers.size\n    # deviation = sum(abs(x - mean) for x in numbers)\n    deviation = numbers.map {|x| (x - mean).abs}.sum\n    # return deviation / len(numbers)\n    return deviation / numbers.size\nend\n",
            "def intersperse(numbers, delimiter)\n    # result = []\n    result = []\n    # for i in range(len(numbers)):\n    for i in 0...numbers.length\n        # if i != 0:\n        if i != 0\n            # result.append(delimiter)\n            result << delimiter\n        end\n        # result.append(numbers[i])\n        result << numbers[i]\n    end\n    # return result\n    return result\nend\n",
            "def parse_nested_parens(paren_string)\n    # result = []\n    result = []\n    # paren_groups = paren_string.split()\n    paren_groups = paren_string.split\n    # for group in paren_groups:\n    for group in paren_groups\n        # max_depth = 0\n        max_depth = 0\n        # depth = 0\n        depth = 0\n        # for ch in group:\n        for ch in group\n            # if ch == \"(\":\n            if ch == \"(\"\n                # depth += 1\n                depth += 1\n                # max_depth = max(max_depth, depth)\n                max_depth = [max_depth, depth].max\n            # elif ch == \")\":\n            elsif ch == \")\"\n                # depth -= 1\n                depth -= 1\n            end\n        end\n        # result.append(max_depth)\n        result << max_depth\n    end\n    # return result\n    return result\nend\n",
            "def filter_by_substring(strs, substring)\n    # return [s for s in strs if substring in s]\n    strs.select {|s| s.include? substring}\nend\n",
            "def sum_product(numbers)\n    # n_sum = sum(numbers)\n    n_sum = numbers.reduce(:+)\n    # n_product = reduce(lambda x, y: x * y, numbers, 1)\n    n_product = numbers.reduce(1) {|x, y| x * y}\n    # return [n_sum, n_product]\n    return [n_sum, n_product]\nend\n",
            "def rolling_max(numbers)\n    # max_so_far = float(\"-inf\")\n    max_so_far = -Float::INFINITY\n    # result = []\n    result = []\n    # for num in numbers:\n    for num in numbers\n        # max_so_far = max(max_so_far, num)\n        max_so_far = [max_so_far, num].max\n        # result.append(max_so_far)\n        result << max_so_far\n    end\n    # return result\n    return result\nend\n",
            "def is_palindrome(s)\n    # return s == s[::-1]\n    s == s.reverse\nend\ndef make_palindrome(s)\n    # if is_palindrome(s):\n    if is_palindrome(s)\n        # return s\n        return s\n    end\n    # for i in range(len(s)):\n    for i in 0...s.length\n        # if is_palindrome(s[i:]):\n        if is_palindrome(s[i..-1])\n            # return s + s[:i][::-1]\n            return s + s[0...i].reverse\n        end\n    end\n    # return \"\"\n    return \"\"\nend\n",
            "def string_xor(a, b)\n    # return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    a.chars.zip(b.chars).map {|x, y| x == y ? \"0\" : \"1\"}.join\nend\n",
            "def longest(strs)\n    # if not strs:\n    if strs.empty?\n        # return None\n        return nil\n    end\n    # longest_s = strs[0]\n    longest_s = strs[0]\n    # for s in strs:\n    for s in strs\n        # if len(s) > len(longest_s):\n        if s.length > longest_s.length\n            # longest_s = s\n            longest_s = s\n        end\n    end\n    # return longest_s\n    return longest_s\nend\n",
            "def greatest_common_divisor(a, b)\n    # if b == 0:\n    if b == 0\n        # return a\n        return a\n    else\n        # return greatest_common_divisor(b, a % b)\n        return greatest_common_divisor(b, a % b)\n    end\nend\n",
            "def all_prefixes(s)\n    # prefixes = []\n    prefixes = []\n    # for i in range(len(s)):\n    for i in 0...s.length\n        # prefixes.append(s[: i + 1])\n        prefixes << s[0...i + 1]\n    end\n    # return prefixes\n    return prefixes\nend\n",
            "def string_sequence(n)\n    # return \" \".join([str(i) for i in range(n + 1)])\n    return (0..n).map {|i| i.to_s}.join(\" \")\nend\n",
            "def count_distinct_characters(s)\n    # return len(set(s.lower()))\n    return s.downcase.chars.uniq.size\nend\n",
            "def parse_music(music_string)\n    # durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    durations = {\"o\" => 4, \"o|\" => 2, \".|\" => 1}\n    # notes = music_string.split()\n    notes = music_string.split\n    # return [durations[note] for note in notes]\n    return notes.map {|note| durations[note]}\nend\n",
            "def how_many_times(s, substring)\n    # times = 0\n    times = 0\n    # for i in range(len(s) - len(substring) + 1):\n    for i in 0..(s.length - substring.length)\n        # if s[i : i + len(substring)] == substring:\n        if s[i, substring.length] == substring\n            # times += 1\n            times += 1\n        end\n    end\n    # return times\n    return times\nend\n",
            "def sort_numbers(numbers)\n    # num_dict = {\n    #     \"zero\": 0,\n    #     \"one\": 1,\n    #     \"two\": 2,\n    #     \"three\": 3,\n    #     \"four\": 4,\n    #     \"five\": 5,\n    #     \"six\": 6,\n    #     \"seven\": 7,\n    #     \"eight\": 8,\n    #     \"nine\": 9,\n    # }\n    num_dict = {\n        \"zero\" => 0,\n        \"one\" => 1,\n        \"two\" => 2,\n        \"three\" => 3,\n        \"four\" => 4,\n        \"five\" => 5,\n        \"six\" => 6,\n        \"seven\" => 7,\n        \"eight\" => 8,\n        \"nine\" => 9,\n    }\n    # num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    num_list = numbers.split(\" \").select {|x| num_dict.has_key?(x)}\n    # num_list.sort(key=lambda x: num_dict[x])\n    num_list.sort_by {|x| num_dict[x]}\n    # return \" \".join(num_list)\n    return num_list.join(\" \")\nend\n",
            "def find_closest_elements(numbers)\n    # sorted_numbers = sorted(numbers)\n    sorted_numbers = numbers.sort\n    # min_diff = float(\"inf\")\n    min_diff = Float::INFINITY\n    # closest_pair = []\n    closest_pair = []\n    # for i in range(1, len(sorted_numbers)):\n    for i in 1..sorted_numbers.length\n        # diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if diff < min_diff:\n        if diff < min_diff\n            # min_diff = diff\n            min_diff = diff\n            # closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n        end\n    end\n    # return closest_pair\n    return closest_pair\nend\n",
            "def rescale_to_unit(numbers)\n    # min_num = min(numbers)\n    min_num = numbers.min\n    # max_num = max(numbers)\n    max_num = numbers.max\n    # if min_num == max_num:\n    if min_num == max_num\n        # return [0.0] * len(numbers)\n        return [0.0] * numbers.length\n    else\n        # return [(num - min_num) / (max_num - min_num) for num in numbers]\n        return numbers.map {|num| (num - min_num) / (max_num - min_num)}\n    end\nend\n",
            "def filter_integers(values)\n    # return [x for x in values if isinstance(x, int)]\n    values.select {|x| x.is_a? Integer}\nend\n",
            "def str_length(s)\n    # return len(s)\n    s.length\nend\n",
            "def largest_divisor(n)\n    # for i in range(2, n):\n    (2..n).each do |i|\n        # if n % i == 0:\n        if n % i == 0\n            # return n // i\n            return n / i\n        end\n    end\n    # return 1\n    1\nend\n",
            "def factorize(n)\n    # factors = []\n    factors = []\n    # divisor = 2\n    divisor = 2\n    # while divisor <= n:\n    while divisor <= n\n        # if n % divisor == 0:\n        if n % divisor == 0\n            # factors.append(divisor)\n            factors << divisor\n            # n //= divisor\n            n /= divisor\n        else\n            # divisor += 1\n            divisor += 1\n        end\n    end\n    # return factors\n    return factors\nend\n",
            "def remove_duplicates(numbers)\n    # counts = {}\n    counts = {}\n    # for num in numbers:\n    for num in numbers\n        # counts[num] = counts.get(num, 0) + 1\n        counts[num] = counts.fetch(num, 0) + 1\n    end\n    # res = [num for num in numbers if counts[num] == 1]\n    res = numbers.select {|num| counts[num] == 1}\n    # return res\n    return res\nend\n",
            "def flip_case(s)\n    # flipped = []\n    flipped = []\n    # for ch in s:\n    for ch in s.chars\n        # if not ch.isalpha():\n        if not ch.match(/[a-zA-Z]/)\n            # flipped.append(ch)\n            flipped << ch\n        # elif ch.islower():\n        elsif ch.match(/[a-z]/)\n            # flipped.append(ch.upper())\n            flipped << ch.upcase\n        # elif ch.isupper():\n        elsif ch.match(/[A-Z]/)\n            # flipped.append(ch.lower())\n            flipped << ch.downcase\n        end\n    end\n    # return ''.join(flipped)\n    return flipped.join\nend\n",
            "def concatenate(strs)\n    # return \"\".join(strs)\n    return strs.join(\"\")\nend\n",
            "def filter_by_prefix(strs, prefix_str)\n    # return [s for s in strs if s.startswith(prefix_str)]\n    strs.select {|s| s.start_with?(prefix_str)}\nend\n",
            "def get_positive(l)\n    # return [num for num in l if num > 0]\n    l.select {|num| num > 0}\nend\n",
            "def is_prime(n)\n    # if n < 2:\n    if n < 2\n        # return False\n        return false\n    end\n    # for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..(Math.sqrt(n).floor + 1)\n        # if n % i == 0:\n        if n % i == 0\n            # return False\n            return false\n        end\n    end\n    # return True\n    return true\nend\n",
            "def poly(xs, x)\n    res = 0.0\n    # for i in range(len(xs)):\n    xs.each_with_index do |e, i|\n        # res += xs[i] * x**i\n        res += e * x**i\n    end\n    return res\nend\ndef find_zero(xs)\n    x1, x2 = 1.0, -1.0\n    # while poly(xs, x1) * poly(xs, x2) > 0:\n    while poly(xs, x1) * poly(xs, x2) > 0\n        # x1 *= 2\n        x1 *= 2\n        # x2 *= 2\n        x2 *= 2\n    end\n    # while abs(x1 - x2) > 1e-10:\n    while (x1 - x2).abs > 1e-10\n        # mid = (x1 + x2) / 2\n        mid = (x1 + x2) / 2\n        # if poly(xs, mid) == 0:\n        if poly(xs, mid) == 0\n            return mid\n        # elif poly(xs, mid) * poly(xs, x1) < 0:\n        elsif poly(xs, mid) * poly(xs, x1) < 0\n            # x2 = mid\n            x2 = mid\n        # else:\n        else\n            # x1 = mid\n            x1 = mid\n        end\n    end\n    # return (x1 + x2) / 2\n    return (x1 + x2) / 2\nend\n",
            "def sort_third(l)\n    # sorted_third = sorted(l[::3])\n    sorted_third = l[::3].sort\n    # return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    return l.map.with_index {|e, i| i % 3 == 0 ? sorted_third[i // 3] : e}\nend\n",
            "def list_unique(l)\n    # return sorted(list(set(l)))\n    return l.to_set.to_a.sort\nend\n",
            "def max_element(l)\n    # if not l:\n    if l.empty?\n        # return 0\n        return 0\n    end\n    # return max(l)\n    return l.max\nend\n",
            "def fizz_buzz(n)\n    # cnt = 0\n    cnt = 0\n    # for i in range(n):\n    for i in 0..n\n        # if i % 11 == 0 or i % 13 == 0:\n        if i % 11 == 0 or i % 13 == 0\n            # cnt += str(i).count(\"7\")\n            cnt += i.to_s.count(\"7\")\n        end\n    end\n    # return cnt\n    return cnt\nend\n",
            "def sort_even(l)\n    # sorted_even = sorted(l[::2])\n    sorted_even = l[0..-1].select {|e| e.even?}.sort\n    # return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    return l.map.with_index {|e, i| i.even? ? sorted_even[i / 2] : e}\nend\n",
            "def encode_cyclic(s)\n    result = []\n    # for i in range(0, len(s), 3):\n    (0..(s.length - 1)).step(3).each do |i|\n        # if i + 3 > len(s):\n        if i + 3 > s.length\n            # result.append(s[i:])\n            result << s[i..-1]\n        else\n            # result.append(s[i+1:i+3])\n            result << s[i+1..i+3]\n            # result.append(s[i])\n            result << s[i]\n        end\n    end\n    # return \"\".join(result)\n    return result.join\nend\ndef decode_cyclic(s)\n    return encode_cyclic(encode_cyclic(s))\nend\n",
            "def is_prime(n)\n    # if n < 2:\n    return false if n < 2\n    # for i in range(2, floor(sqrt(n)) + 1):\n    (2..Math.sqrt(n).floor + 1).each do |i|\n        # if n % i == 0:\n        return false if n % i == 0\n    end\n    # return True\n    true\nend\ndef prime_fib(n)\n    # f = [0, 1]\n    f = [0, 1]\n    # cnt = 0\n    cnt = 0\n    # while cnt < n:\n    while cnt < n\n        # f = [f[1], f[0] + f[1]]\n        f = [f[1], f[0] + f[1]]\n        # if is_prime(f[1]):\n        if is_prime(f[1])\n            # cnt += 1\n            cnt += 1\n        end\n    end\n    # return f[1]\n    f[1]\nend\n",
            "def triples_sum_to_zero(l)\n    # for i in range(len(l)):\n    for i in 0...l.length\n        # for j in range(i + 1, len(l)):\n        for j in i + 1...l.length\n            # for k in range(j + 1, len(l)):\n            for k in j + 1...l.length\n                # if l[i] + l[j] + l[k] == 0:\n                if l[i] + l[j] + l[k] == 0\n                    # return True\n                    return true\n                end\n            end\n        end\n    end\n    # return False\n    return false\nend\n",
            "def car_race_collision(n)\n    # return n ** 2\n    n ** 2\nend\n",
            "def incr_list(l)\n    # return [i + 1 for i in l]\n    l.map {|i| i + 1}\nend\n",
            "def pairs_sum_to_zero(l)\n    # seen = set()\n    seen = Set.new\n    # for num in l:\n    for num in l\n        # if -num in seen:\n        if seen.include?(-num)\n            # return True\n            return true\n        end\n        # seen.add(num)\n        seen.add(num)\n    end\n    # return False\n    return false\nend\n",
            "def change_base(x, bas)\n    # if x == 0:\n    if x == 0\n        # return \"0\"\n        return \"0\"\n    end\n    # digits = []\n    digits = []\n    # while x > 0:\n    while x > 0\n        # digits.append(str(x % bas))\n        digits.push(x % bas).to_s\n        # x //= bas\n        x /= bas\n    end\n    # return \"\".join(digits[::-1])\n    return digits.join(\"\")[::-1]\nend\n",
            "def triangle_area(a, h)\n    # return a * h / 2\n    a * h / 2.0\nend\n",
            "def fib4(n)\n    # fib = [0, 0, 2, 0]\n    fib = [0, 0, 2, 0]\n    # for i in range(4, n + 1):\n    for i in 4..n\n        # fib[i % 4] = sum(fib)\n        fib[i % 4] = fib[0] + fib[1] + fib[2] + fib[3]\n    end\n    # return fib[n % 4]\n    return fib[n % 4]\nend\n",
            "def median(l)\n    # sl = sorted(l)\n    sl = l.sort\n    # if len(l) % 2 != 0:\n    if l.size % 2 != 0\n        # return sl[len(l) // 2]\n        return sl[l.size // 2]\n    else\n        # return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (sl[l.size // 2] + sl[l.size // 2 - 1]) / 2\n    end\nend\n",
            "def is_palindrome(txt)\n    # return txt == txt[::-1]\n    txt == txt.reverse\nend\n",
            "def modp(n, p)\n    # ret = 1\n    ret = 1\n    # for _ in range(n):\n    for _ in 0...n\n        # ret = (ret * 2) % p\n        ret = (ret * 2) % p\n    end\n    # return ret\n    return ret\nend\n",
            "def encode_shift(s)\n    result = [(((ch.ord - 97 + 5) % 26) + 97).chr for ch in s]\n    return result.join\nend\ndef decode_shift(s)\n    result = [(((ch.ord - 97 + 21) % 26) + 97).chr for ch in s]\n    return result.join\nend\n",
            "def remove_vowels(txt)\n    # vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # return \"\".join([char for char in txt if char not in vowels])\n    return txt.chars.select {|char| vowels.include?(char)}.join\nend\n",
            "def below_threshold(l, t)\n    # return all(x < t for x in l)\n    l.all? {|x| x < t}\nend\n",
            "def add(x, y)\n    # return x + y\n    x + y\nend\n",
            "def same_chars(s0, s1)\n    # return set(s0) == set(s1)\n    return s0.chars.to_set == s1.chars.to_set\nend\n",
            "def fib(n)\n    # if n <= 1:\n    if n <= 1\n        # return n\n        return n\n    else\n        # return fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2)\n    end\nend\n",
            "def correct_bracketing(brackets)\n    # depth = 0\n    depth = 0\n    # for b in brackets:\n    for b in brackets\n        # if b == \"<\":\n        if b == \"<\"\n            # depth += 1\n            depth += 1\n        # elif b == \">\":\n        elsif b == \">\"\n            # depth -= 1\n            depth -= 1\n        # if depth < 0:\n        if depth < 0\n            # return False\n            return false\n        end\n    end\n    # return depth == 0\n    return depth == 0\nend\n",
            "def monotonic(l)\n    # diff = [y - x for x, y in zip(l, l[1:])]\n    diff = l.each_cons(2).map {|x, y| y - x}\n    # return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    return diff.all? {|x| x <= 0} or diff.all? {|x| x >= 0}\nend\n",
            "def common(l1, l2)\n    # return sorted(list(set(l1) & set(l2)))\n    (l1 & l2).sort\nend\n",
            "def largest_prime_factor(n)\n    # i = 2\n    i = 2\n    # while i * i <= n:\n    while i * i <= n\n        # if n % i:\n        if n % i != 0\n            # i += 1\n            i += 1\n        else\n            # n //= i\n            n /= i\n        end\n    end\n    # return n\n    return n\nend\n",
            "def sum_to_n(n)\n    # return sum(range(n + 1))\n    (1..n).sum\nend\n",
            "def correct_bracketing(brackets)\n    # depth = 0\n    depth = 0\n    # for b in brackets:\n    for b in brackets\n        # if b == \"(\":\n        if b == \"(\"\n            # depth += 1\n            depth += 1\n        # elif b == \")\":\n        elsif b == \")\"\n            # depth -= 1\n            depth -= 1\n        # if depth < 0:\n        if depth < 0\n            # return False\n            return false\n        end\n    end\n    # return depth == 0\n    return depth == 0\nend\n",
            "def derivative(xs)\n    # return [xs[i] * i for i in range(1, len(xs))]\n    xs.each_with_index.map {|x, i| x * i}\nend\n",
            "def fibfib(n)\n    # if n <= 1:\n    if n <= 1\n        # return 0 \n        return 0\n    end\n    # a, b, c = 0, 0, 1\n    a, b, c = 0, 0, 1\n    # while n > 2:\n    while n > 2\n        # a, b, c = b, c, a + b + c\n        a, b, c = b, c, a + b + c\n        # n -= 1\n        n -= 1\n    end\n    # return c\n    return c\nend\n",
            "def vowels_count(s)\n    # vowels = \"aeiou\"\n    vowels = \"aeiou\"\n    # cnt = 0\n    cnt = 0\n    # for i in range(len(s)):\n    for i in 0...s.length\n        # if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if vowels.include?(s[i].downcase) or (i == s.length - 1 and s[i].downcase == \"y\")\n            # cnt += 1\n            cnt += 1\n        end\n    end\n    # return cnt\n    return cnt\nend\n",
            "def circular_shift(x, shift)\n    # x_str = str(x)\n    x_str = x.to_s\n    # if shift > len(x_str):\n    if shift > x_str.length\n        # return x_str[::-1]\n        return x_str.reverse\n    else\n        # return x_str[-shift:] + x_str[:-shift]\n        return x_str[-shift, x_str.length] + x_str[0, x_str.length - shift]\n    end\nend\n",
            "def digit_sum(s)\n    # return sum(ord(c) for c in s if c.isupper())\n    s.chars.select {|c| c.upcase == c}.map {|c| c.ord}.reduce(:+)\nend\n",
            "def fruit_distribution(s, n)\n    # words = s.split(' ')\n    words = s.split(' ')\n    # apples = int(words[words.index(\"apples\") - 1])\n    apples = words.index(\"apples\") - 1\n    apples = words[apples].to_i\n    # oranges = int(words[words.index(\"oranges\") - 1])\n    oranges = words.index(\"oranges\") - 1\n    oranges = words[oranges].to_i\n    # return n - apples - oranges\n    return n - apples - oranges\nend\n",
            "def pluck(arr)\n    # evens = [n for n in arr if n % 2 == 0]\n    evens = arr.select {|n| n % 2 == 0}\n    # if len(evens) == 0:\n    if evens.empty?\n        # return []\n        return []\n    end\n    # min_even = min(evens)\n    min_even = evens.min\n    # return [min_even, arr.index(min_even)]\n    return [min_even, arr.index(min_even)]\nend\n",
            "def search(lst)\n    # freqs = {}\n    freqs = {}\n    # for n in lst:\n    for n in lst\n        # freqs[n] = freqs.get(n, 0) + 1\n        freqs[n] = freqs.fetch(n, 0) + 1\n    end\n    # good_vals = [k for k, v in freqs.items() if v >= k]\n    good_vals = freqs.map {|k, v| k if v >= k}.compact\n    # return max(good_vals, default=-1)\n    return good_vals.max || -1\nend\n",
            "def strange_sort_list(lst)\n    # sl = sorted(lst)\n    sl = lst.sort\n    # result = []\n    result = []\n    # left, right = 0, len(sl) - 1\n    left, right = 0, sl.length - 1\n    # while left <= right:\n    while left <= right\n        # result.append(sl[left])\n        result << sl[left]\n        # left += 1\n        left += 1\n        # if left <= right:\n        if left <= right\n            # result.append(sl[right])\n            result << sl[right]\n            # right -= 1\n            right -= 1\n        end\n    end\n    # return result\n    return result\nend\n",
            "def triangle_area(a, b, c)\n    # if a + b > c and a + c > b and b + c > a:\n    if a + b > c and a + c > b and b + c > a\n        # s = (a + b + c) / 2.0\n        s = (a + b + c) / 2.0\n        # return sqrt(s * (s - a) * (s - b) * (s - c))\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    else\n        # return -1.0\n        return -1.0\n    end\nend\n",
            "def will_it_fly(q, w)\n    # if len(q) == 0:\n    if q.empty?\n        # return False\n        return false\n    end\n    # is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    is_palin = q.each_index.all? {|i| q[i] == q[q.size - i - 1]}\n    # total = sum(q)\n    total = q.sum\n    # return is_palin and total <= w\n    return is_palin and total <= w\nend\n",
            "def smallest_change(arr)\n    # ans = 0\n    ans = 0\n    # for i in range(len(arr) // 2):\n    for i in 0...(arr.length / 2)\n        # if arr[i] != arr[len(arr) - i - 1]:\n        if arr[i] != arr[-i - 1]\n            # ans += 1\n            ans += 1\n        end\n    end\n    # return ans\n    return ans\nend\n",
            "def total_match(lst1, lst2)\n    # cnt1 = sum(len(s) for s in lst1)\n    cnt1 = lst1.map {|s| s.length}.reduce(:+)\n    # cnt2 = sum(len(s) for s in lst2)\n    cnt2 = lst2.map {|s| s.length}.reduce(:+)\n    # return lst1 if cnt1 <= cnt2 else lst2\n    return lst1 if cnt1 <= cnt2 else lst2\nend\n",
            "def is_prime(n)\n    # if n < 2:\n    return false if n < 2\n    # for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..Math.sqrt(n).floor\n        # if n % i == 0:\n        return false if n % i == 0\n    end\n    # return True\n    true\nend\ndef is_multiply_prime(a)\n    # cnt = 0\n    cnt = 0\n    # for i in range(2, a + 1):\n    for i in 2..a\n        # if is_prime(i):\n        if is_prime(i)\n            # while a % i == 0:\n            while a % i == 0\n                # cnt += 1\n                cnt += 1\n                # a /= i\n                a /= i\n            end\n        end\n    end\n    # return cnt == 3\n    cnt == 3\nend\n",
            "def is_simple_power(x, n)\n    # if n < 2:\n    if n < 2\n        # return x == n\n        return x == n\n    end\n    # tmp = 1\n    tmp = 1\n    # while tmp < x:\n    while tmp < x\n        # tmp *= n\n        tmp *= n\n    end\n    # return tmp == x\n    return tmp == x\nend\n",
            "def is_cube(a)\n    # a = abs(a)\n    a = a.abs\n    # root = int(round(pow(a, 1.0 / 3.0)))\n    root = (a ** (1.0 / 3.0)).round\n    # return root * root * root == a\n    return root * root * root == a\nend\n",
            "def hex_key(num)\n    # return len([x for x in num if x in \"2357BD\"])\n    num.count {|x| \"2357BD\".include?(x)}\nend\n",
            "def decimal_to_binary(dec)\n    # binary = bin(dec)[2:]\n    binary = dec.to_s(2)\n    # return f\"db{binary}db\"\n    return \"db#{binary}db\"\nend\n",
            "def is_happy(s)\n    # if len(s) < 3:\n    if s.length < 3\n        # return False\n        return false\n    end\n    # for i in range(len(s) - 2):\n    for i in 0..(s.length - 3)\n        # if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]\n            # return False\n            return false\n        end\n    end\n    # return True\n    return true\nend\n",
            "def numerical_letter_grade(grades)\n    result = []\n    for g in grades\n        if g == 4.0\n            result.append(\"A+\")\n        elsif g > 3.7\n            result.append(\"A\")\n        elsif g > 3.3\n            result.append(\"A-\")\n        elsif g > 3.0\n            result.append(\"B+\")\n        elsif g > 2.7\n            result.append(\"B\")\n        elsif g > 2.3\n            result.append(\"B-\")\n        elsif g > 2.0\n            result.append(\"C+\")\n        elsif g > 1.7\n            result.append(\"C\")\n        elsif g > 1.3\n            result.append(\"C-\")\n        elsif g > 1.0\n            result.append(\"D+\")\n        elsif g > 0.7\n            result.append(\"D\")\n        elsif g > 0.0\n            result.append(\"D-\")\n        else\n            result.append(\"E\")\n        end\n    end\n    return result\nend\n",
            "def prime_length(s)\n    # length = len(s)\n    length = s.length\n    # if length < 2:\n    if length < 2\n        # return False\n        return false\n    end\n    # for i in range(2, floor(sqrt(length)) + 1):\n    for i in 2..(Math.sqrt(length).floor + 1)\n        # if length % i == 0:\n        if length % i == 0\n            # return False\n            return false\n        end\n    end\n    # return True\n    return true\nend\n",
            "def starts_one_ends(n)\n    # if n == 1:\n    if n == 1\n        # return 1\n        return 1\n    # return 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * (10 ** (n - 2))\nend\n",
            "def solve(n)\n    # digits_sum = sum(int(d) for d in str(n))\n    digits_sum = n.to_s.chars.map(&:to_i).sum\n    # return bin(digits_sum)[2:]\n    return digits_sum.to_s(2)[2..-1]\nend\n",
            "def add(lst)\n    # return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    return lst.each_with_index.select {|x, i| i % 2 == 1 and x % 2 == 0}.map {|x| x}.sum\nend\n",
            "def anti_shuffle(s)\n    # words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    words = s.split(\" \").map {|word| word.chars.sort.join}\n    # return \" \".join(words)\n    return words.join(\" \")\nend\n",
            "def get_row(lst, x)\n    coords = []\n    # for i in range(len(lst)):\n    for i in 0...lst.length\n        # for j in range(len(lst[i])):\n        for j in 0...lst[i].length\n            # if lst[i][j] == x:\n            if lst[i][j] == x\n                # coords.append([i, j])\n                coords.append([i, j])\n            end\n        end\n    end\n    # return sorted(coords, key=lambda a: (a[0], -a[1]))\n    return coords.sort_by {|a| [a[0], -a[1]]}\nend\n",
            "def sort_array(arr)\n    # if len(arr) == 0:\n    if arr.empty?\n        # return []\n        return []\n    end\n    # if (arr[0] + arr[-1]) % 2 == 0:\n    if (arr[0] + arr[-1]) % 2 == 0\n        # return sorted(arr, reverse=True)\n        return arr.sort.reverse\n    else\n        # return sorted(arr)\n        return arr.sort\n    end\nend\n",
            "def encrypt(s)\n    # result = []\n    result = []\n    # for ch in s:\n    for ch in s.chars\n        # shifted = ord(ch) + 4\n        shifted = ch.ord + 4\n        # if shifted > ord('z'):\n        if shifted > 'z'.ord\n            # shifted -= 26\n            shifted -= 26\n        end\n        # result.append(chr(shifted))\n        result << shifted.chr\n    end\n    # return \"\".join(result)\n    return result.join\nend\n",
            "def next_smallest(lst)\n    # sl = sorted(set(lst))\n    sl = lst.to_set.to_a.sort\n    # if len(sl) < 2:\n    if sl.length < 2\n        # return None\n        return nil\n    end\n    # return sl[1]\n    return sl[1]\nend\n",
            "def is_bored(s)\n    # sentences = re.split(r\"[.!?]\\s*\", s)\n    sentences = s.split(/[.!?]\\s*/)\n    # return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    return sentences.select {|sentence| sentence.length >= 2 && sentence[0..1] == \"I \"}.length\nend\n",
            "def any_int(x, y, z)\n    # if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if x.is_a?(Integer) and y.is_a?(Integer) and z.is_a?(Integer)\n        # if (x + y == z) or (x + z == y) or (y + z == x):\n        if (x + y == z) or (x + z == y) or (y + z == x)\n            # return True\n            return true\n        end\n    end\n    # return False\n    false\nend\n",
            "def encode(message)\n    # vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # result = []\n    result = []\n    # for ch in message:\n    for ch in message.chars\n        # if ch.isalpha():\n        if ch =~ /[a-zA-Z]/\n            # ch1 = ch.upper() if ch.islower() else ch.lower()\n            ch1 = ch.upcase if ch.downcase? else ch.downcase\n            # if ch1 in vowels:\n            if vowels.include?(ch1)\n                # ch1 = chr(ord(ch1) + 2)\n                ch1 = ch1.succ.succ\n            end\n            # result.append(ch1)\n            result << ch1\n        else\n            # result.append(ch)\n            result << ch\n        end\n    end\n    # return \"\".join(result)\n    return result.join\nend\n",
            "def is_prime(n)\n    # if n < 2:\n    return false if n < 2\n    # for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..Math.sqrt(n).floor + 1\n        # if n % i == 0:\n        return false if n % i == 0\n    end\n    # return True\n    true\nend\ndef skjkasdkd(lst)\n    # primes = [n for n in lst if is_prime(n)]\n    primes = lst.select {|n| is_prime(n)}\n    # if len(primes) == 0:\n    if primes.empty?\n        # return 0\n        return 0\n    end\n    # largest = str(max(primes))\n    largest = primes.max.to_s\n    # return sum(int(digit) for digit in largest)\n    largest.chars.map(&:to_i).sum\nend\n",
            "def check_dict_case(d)\n    # if not d:\n    if d.empty?\n        # return False\n        return false\n    end\n    # return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    return d.keys.all? {|c| c.downcase == c} || d.keys.all? {|c| c.upcase == c}\nend\n",
            "def count_up_to(n)\n    # primes = []\n    primes = []\n    # for num in range(2, n):\n    for num in 2..n\n        # if all(num % p != 0 for p in primes):\n        if primes.all? {|p| num % p != 0}\n            # primes.append(num)\n            primes << num\n        end\n    end\n    # return primes\n    return primes\nend\n",
            "def multiply(a, b)\n    # return (abs(a) % 10) * (abs(b) % 10)\n    (a.abs % 10) * (b.abs % 10)\nend\n",
            "def count_upper(s)\n    # vowels = \"AEIOU\"\n    vowels = \"AEIOU\"\n    # return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    return s.chars.each_with_index.count {|c, i| i % 2 == 0 and vowels.include?(c)}\nend\n",
            "def closest_integer(value)\n    # num = float(value)\n    num = value.to_f\n    # if num >= 0:\n    if num >= 0\n        # return int(num + 0.5)\n        return (num + 0.5).to_i\n    else\n        # return int(num - 0.5)\n        return (num - 0.5).to_i\n    end\nend\n",
            "def make_a_pile(n)\n    # return [n + 2 * i for i in range(n)]\n    (0..n-1).map {|i| n + 2 * i}\nend\n",
            "def words_string(s)\n    # return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    re.split(r\"[, ]\", s).select {|w| w.length > 0}\nend\n",
            "def choose_num(x, y)\n    # if x > y:\n    if x > y\n        # return -1\n        return -1\n    end\n    # if y % 2 == 0:\n    if y % 2 == 0\n        # return y\n        return y\n    end\n    # return y - 1 if x != y else -1\n    return y - 1 if x != y else -1\nend\n",
            "def rounded_avg(n, m)\n    # if n > m:\n    if n > m\n        # return None\n        return nil\n    end\n    # r_avg = int((m + n) / 2.0 + 0.5)\n    r_avg = (m + n) / 2.0 + 0.5\n    # return bin(r_avg)[2:]\n    return r_avg.to_s(2)\nend\n",
            "def all_digits_odd(s)\n    # return all(ord(digit) % 2 != 0 for digit in s)\n    s.each_char.all? {|digit| ord(digit) % 2 != 0}\nend\ndef unique_digits(x)\n    # return sorted([num for num in x if all_digits_odd(str(num))])\n    x.select {|num| all_digits_odd(num.to_s)}.sort\nend\n",
            "def by_length(arr)\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    sorted_arr = arr.select {|x| 1 <= x && x <= 9}.sort {|a, b| b <=> a}\n    return sorted_arr.map {|x| digit_names[x-1]}\nend\n",
            "def f(n)\n    # nums = list(range(1, n + 1))\n    nums = (1..n).to_a\n    # return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    return nums.map do |i|\n        if i % 2 != 0\n            nums[0..i].sum\n        else\n            nums[0..i].reduce(:*)\n        end\n    end\nend\n",
            "def is_palindrome(txt)\n    # return txt == txt[::-1]\n    txt == txt.reverse\nend\ndef even_odd_palindrome(n)\n    # cnt = [0, 0]\n    cnt = [0, 0]\n    # for i in range(1, n + 1):\n    for i in 1..n\n        # if is_palindrome(str(i)):\n        if is_palindrome(i.to_s)\n            # cnt[i % 2] += 1\n            cnt[i % 2] += 1\n        end\n    end\n    # return cnt\n    return cnt\nend\n",
            "def digits_sum(n)\n    # n_str = str(n)\n    n_str = n.to_s\n    # if n >= 0:\n    if n >= 0\n        # return sum(int(d) for d in n_str)\n        return n_str.chars.map(&:to_i).sum\n    else\n        # return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return n_str[0..1].to_i * 2 + digits_sum(n.abs)\n    end\nend\ndef count_nums(arr)\n    # return len([n for n in arr if digits_sum(n) > 0])\n    return arr.count {|n| digits_sum(n) > 0}\nend\n",
            "def move_one_ball(arr)\n    # if len(arr) == 0:\n    if arr.length == 0\n        # return True\n        return true\n    end\n    # sorted_arr = sorted(arr)\n    sorted_arr = arr.sort\n    # for i in range(0, len(arr)):\n    for i in 0...arr.length\n        # if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if arr[i..-1] == sorted_arr[0...arr.length - i] and arr[0...i] == sorted_arr[arr.length - i..-1]\n            # return True\n            return true\n        end\n    end\n    # return False\n    return false\nend\n",
            "def can_exchange(lst1, lst2)\n    # odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    odd_cnt = lst1.count {|num| num % 2 != 0}\n    # even_cnt = len([num for num in lst2 if num % 2 == 0])\n    even_cnt = lst2.count {|num| num % 2 == 0}\n    # return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\nend\n",
            "def histogram(test)\n    # freq = {}\n    freq = {}\n    # words = [w for w in test.split(\" \") if len(w) > 0]\n    words = test.split(\" \").select {|w| w.length > 0}\n    # for w in words:\n    for w in words\n        # freq[w] = freq.get(w, 0) + 1\n        freq[w] = freq.fetch(w, 0) + 1\n    end\n    # result = {}\n    result = {}\n    # if len(freq) > 0:\n    if freq.length > 0\n        # max_freq = max(freq.values())\n        max_freq = freq.values.max\n        # for k, v in freq.items():\n        for k, v in freq.items\n            # if v == max_freq:\n            if v == max_freq\n                # result[k] = v\n                result[k] = v\n            end\n        end\n    end\n    # return result\n    return result\nend\n",
            "def is_palindrome(s)\n    # return s == s[::-1]\n    s == s.reverse\nend\ndef reverse_delete(s, c)\n    # s1 = \"\".join([ch for ch in s if ch not in c])\n    s1 = s.chars.select {|ch| not c.include?(ch)}.join\n    # return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    return [s1, is_palindrome(s1) ? \"yes\" : \"no\"]\nend\n",
            "def odd_count(lst)\n    # result = []\n    result = []\n    # for num in lst:\n    for num in lst\n        # n = sum(ord(d) % 2 == 1 for d in num)\n        n = num.chars.map {|d| d.ord % 2 == 1}.sum\n        # rs = \"the number of odd elements in the string i of the input.\"\n        rs = \"the number of odd elements in the string i of the input.\"\n        # result.append(rs.replace(\"i\", str(n)))\n        result << rs.gsub(\"i\", n.to_s)\n    end\n    # return result\n    return result\nend\n",
            "def min_sub_array_sum(nums)\n    # min_sum = 0\n    min_sum = 0\n    # cur_sum = 0\n    cur_sum = 0\n    # for n in nums:\n    for n in nums\n        # cur_sum = min(cur_sum + n, 0)\n        cur_sum = [cur_sum + n, 0].min\n        # min_sum = min(cur_sum, min_sum)\n        min_sum = [cur_sum, min_sum].min\n    end\n    # if min_sum == 0:\n    if min_sum == 0\n        # min_sum = min(nums)\n        min_sum = nums.min\n    end\n    # return min_sum\n    return min_sum\nend\n",
            "def max_fill(grid, capacity)\n    # return sum([ceil(sum(arr) / capacity) for arr in grid])\n    return grid.map {|arr| (arr.sum.to_f / capacity).ceil}.sum\nend\n",
            "def count_ones(num)\n    # return bin(num).count(\"1\")\n    num.to_s(2).count(\"1\")\nend\ndef sort_array(arr)\n    # return sorted(arr, key=lambda x: (count_ones(x), x))\n    arr.sort_by {|x| [count_ones(x), x]}\nend\n",
            "def select_words(s, n)\n    # consonants = \"bcdfghjklmnpqrstvwxyz\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # words = [w for w in s.split(\" \") if len(w) > 0]\n    words = s.split(\" \").select {|w| w.length > 0}\n    # return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    return words.select {|w| w.chars.select {|c| consonants.include?(c.downcase)}.length == n}\nend\n",
            "def get_closest_vowel(word)\n    # vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # for i in range(len(word) - 2, 0, -1):\n    for i in (0..(word.length - 2)).reverse_each\n        # if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if vowels.include?(word[i]) and not vowels.include?(word[i - 1]) and not vowels.include?(word[i + 1])\n            # return word[i]\n            return word[i]\n        end\n    end\n    # return \"\"\n    return \"\"\nend\n",
            "def check(s)\n    depth = 0\n    for ch in s\n        if ch == \"(\"\n            depth += 1\n        else\n            depth -= 1\n        end\n        if depth < 0\n            return false\n        end\n    end\n    return true if depth == 0 else false\nend\ndef match_parens(lst)\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\nend\n",
            "def maximum(arr, k)\n    # if k == 0:\n    if k == 0\n        # return []\n        return []\n    # return sorted(arr)[-k:]\n    return arr.sort[-k..-1]\nend\n",
            "def solution(lst)\n    # return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    return lst.each_with_index.select {|x, i| i % 2 == 0 and x % 2 != 0}.map {|x| x}.sum\nend\n",
            "def add_elements(arr, k)\n    # return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    return arr[0..k].select {|n| n.to_s.length <= 2}.reduce(:+)\nend\n",
            "def get_odd_collatz(n)\n    # collatz = [1]\n    collatz = [1]\n    # while n != 1:\n    while n != 1\n        # if n % 2 != 0:\n        if n % 2 != 0\n            # collatz.append(n)\n            collatz << n\n            # n = 3 * n + 1\n            n = 3 * n + 1\n        else\n            # n = n // 2\n            n = n / 2\n        end\n    end\n    # return sorted(collatz)\n    return collatz.sort\nend\n",
            "def valid_date(date)\n    # if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if date.length != 10 or date[2] != \"-\" or date[5] != \"-\"\n        return false\n    # m = int(date[:2])\n    m = date[0..1].to_i\n    # d = int(date[3:5])\n    d = date[3..4].to_i\n    # if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if [1, 3, 5, 7, 8, 10, 12].include?(m) and d >= 1 and d <= 31\n        return true\n    # if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if [4, 6, 9, 11].include?(m) and d >= 1 and d <= 30\n        return true\n    # if m == 2 and d >= 1 and d <= 29:\n    if m == 2 and d >= 1 and d <= 29\n        return true\n    # return False\n    return false\nend\n",
            "def split_words(txt)\n    # if \" \" in txt:\n    if txt.include?(\" \")\n        # return txt.split(\" \")\n        return txt.split(\" \")\n    # elif \",\" in txt:\n    elsif txt.include?(\",\")\n        # return txt.split(\",\")\n        return txt.split(\",\")\n    # else:\n    else\n        # return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        return [str(txt.count {|c| c.islower() and c.ord % 2 == 0})]\n    end\nend\n",
            "def is_sorted(lst)\n    # if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    if not (0...lst.length).all? {|i| lst[i-1] <= lst[i]}\n        return false\n    end\n    # freq = {}\n    freq = {}\n    # for i in lst:\n    for i in lst\n        # freq[i] = freq.get(i, 0) + 1\n        freq[i] = freq.fetch(i, 0) + 1\n    end\n    # return max(freq.values(), default=0) <= 2\n    return freq.values.max <= 2\nend\n",
            "def is_prime(n)\n    # if n < 2:\n    return false if n < 2\n    # for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..Math.sqrt(n).floor\n        # if n % i == 0:\n        return false if n % i == 0\n    end\n    # return True\n    true\nend\ndef intersection(interval1, interval2)\n    # l = max(interval1[0], interval2[0])\n    l = [interval1[0], interval2[0]].max\n    # r = min(interval1[1], interval2[1])\n    r = [interval1[1], interval2[1]].min\n    # length = r - l\n    length = r - l\n    # return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\nend\n",
            "def prod_signs(arr)\n    # if not arr:\n    if arr.empty?\n        # return None\n        return nil\n    end\n    # if 0 in arr:\n    if arr.include?(0)\n        # return 0\n        return 0\n    end\n    # sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    sign = -1 if arr.count {|n| n < 0} % 2 == 1 else 1\n    # return sign * sum([abs(n) for n in arr])\n    return sign * arr.map {|n| n.abs}.sum\nend\n",
            "def min_path(grid, k)\n    # n = len(grid)\n    n = grid.size\n    # min_val = n * n + 1\n    min_val = n * n + 1\n    # for i in range(n):\n    for i in 0...n\n        # for j in range(n):\n        for j in 0...n\n            # if grid[i][j] == 1:\n            if grid[i][j] == 1\n                # temp = []\n                temp = []\n                # if i != 0:\n                if i != 0\n                    # temp.append(grid[i - 1][j])\n                    temp << grid[i - 1][j]\n                end\n                # if j != 0:\n                if j != 0\n                    # temp.append(grid[i][j - 1])\n                    temp << grid[i][j - 1]\n                end\n                # if i != n - 1:\n                if i != n - 1\n                    # temp.append(grid[i + 1][j])\n                    temp << grid[i + 1][j]\n                end\n                # if j != n - 1:\n                if j != n - 1\n                    # temp.append(grid[i][j + 1])\n                    temp << grid[i][j + 1]\n                end\n                # min_val = min(temp)\n                min_val = [min_val, temp.min].min\n            end\n        end\n    end\n    # result = []\n    result = []\n    # for i in range(k):\n    for i in 0...k\n        # result.append(1 if i % 2 == 0 else min_val)\n        result << (i % 2 == 0 ? 1 : min_val)\n    end\n    # return result\n    return result\nend\n",
            "def tri(n)\n    # if n == 0:\n    if n == 0\n        # return [1]\n        return [1]\n    end\n    # seq = [1, 3]\n    seq = [1, 3]\n    # for i in range(2, n + 1):\n    for i in 2..n\n        # if i % 2 == 0:\n        if i % 2 == 0\n            # seq.append(i / 2 + 1)\n            seq << i / 2 + 1\n        else\n            # seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq << seq[i - 1] + seq[i - 2] + (i + 3) / 2\n        end\n    end\n    # return seq\n    return seq\nend\n",
            "def digits(n)\n    # odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    odds = str(n).split('').map {|d| d.to_i}.select {|d| d % 2 == 1}\n    # return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    return odds.reduce(1) {|x, y| x * y} if odds.length > 0 else 0\nend\n",
            "def is_nested(s)\n    # open_idx = []\n    open_idx = []\n    # close_idx = []\n    close_idx = []\n    # for i, ch in enumerate(s):\n    s.each_char.with_index do |ch, i|\n        # if ch == '[':\n        if ch == '['\n            # open_idx.append(i)\n            open_idx << i\n        # elif ch == ']':\n        elsif ch == ']'\n            # close_idx.append(i)\n            close_idx << i\n        end\n    end\n    # close_idx.reverse()\n    close_idx.reverse!\n    # cnt = 0\n    cnt = 0\n    # i = 0\n    i = 0\n    # l = len(close_idx)\n    l = close_idx.length\n    # for idx in open_idx:\n    open_idx.each do |idx|\n        # if i < l and idx < close_idx[i]:\n        if i < l and idx < close_idx[i]\n            # cnt += 1\n            cnt += 1\n            # i += 1\n            i += 1\n        end\n    end\n    # return cnt >= 2\n    return cnt >= 2\nend\n",
            "def sum_squares(lst)\n    # return sum([pow(ceil(n), 2) for n in lst])\n    return lst.map {|n| n.ceil ** 2}.sum\nend\n",
            "def check_if_last_char_is_a_letter(txt)\n    # if not txt:\n    if txt.nil? || txt.empty?\n        # return False\n        return false\n    end\n    # last = txt[txt.rfind(' ') + 1:]\n    last = txt[txt.rindex(' ') + 1..-1]\n    # return len(last) == 1 and last[0].isalpha()\n    return last.length == 1 && last[0].isalpha\nend\n",
            "def can_arrange(arr)\n    # if len (arr) <= 1:\n    if arr.length <= 1\n        # return -1\n        return -1\n    end\n    # idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    idx = (1..arr.length - 1).select {|i| arr[i] < arr[i - 1]}\n    # return max(idx, default=-1)\n    return idx.max {|a, b| a <=> b}\nend\n",
            "def largest_smallest_integers(lst)\n    # neg = [i for i in lst if i < 0]\n    neg = lst.select {|i| i < 0}\n    # pos = [i for i in lst if i > 0]\n    pos = lst.select {|i| i > 0}\n    # max_neg = max(neg) if len(neg) > 0 else None\n    max_neg = neg.max if neg.size > 0 else nil\n    # min_pos = min(pos) if len(pos) > 0 else None\n    min_pos = pos.min if pos.size > 0 else nil\n    # return [max_neg, min_pos]\n    return [max_neg, min_pos]\nend\n",
            "def any_to_real(o)\n    # if isinstance(o, str): \n    if o.is_a?(String)\n        # return float(o.replace(',','.'))\n        return o.gsub(',','.').to_f\n    # elif isinstance(o, int):\n    elsif o.is_a?(Integer)\n        # return float(o)\n        return o.to_f\n    # elif isinstance(o, float):\n    elsif o.is_a?(Float)\n        # return o\n        return o\n    # raise RuntimeError(\"Type Error\");\n    raise RuntimeError(\"Type Error\");\nend\ndef compare_one(a, b)\n    # a1 = any_to_real(a)\n    a1 = any_to_real(a)\n    # b1 = any_to_real(b)\n    b1 = any_to_real(b)\n    # if a1 == b1:\n    if a1 == b1\n        # return None\n        return nil\n    # elif a1 > b1:\n    elsif a1 > b1\n        # return a1\n        return a1\n    # else:\n    else\n        # return b1\n        return b1\n    end\nend\n",
            "def is_equal_to_sum_even(n)\n    # return n % 2 == 0 and n >= 8\n    n % 2 == 0 and n >= 8\nend\n",
            "def special_factorial(n)\n    # fact = 1\n    fact = 1\n    # result = 1\n    result = 1\n    # for i in range(1, n + 1):\n    for i in 1..(n + 1)\n        # fact *= i\n        fact *= i\n        # result *= fact\n        result *= fact\n    end\n    # return result\n    return result\nend\n",
            "def fix_spaces(txt)\n    # return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    return RE.sub(r\"\\s{3,}\", \"-\", txt).gsub(\" \", \"_\")\nend\n",
            "def file_name_check(file_name)\n    suf = [\"txt\", \"exe\", \"dll\"]\n    lst = file_name.split(\".\")\n    if lst.size != 2 or not suf.include?(lst[1]) or lst[0].size == 0 or not lst[0][0].is_a?(String) or lst[0][0].is_a?(Symbol) or lst[0][0].is_a?(Integer) or lst[0][0].is_a?(Float) or lst[0][0].is_a?(TrueClass) or lst[0][0].is_a?(FalseClass) or lst[0][0].is_a?(NilClass) or lst[0][0].is_a?(Array) or lst[0][0].is_a?(Hash) or lst[0][0].is_a?(Proc) or lst[0][0].is_a?(Range) or lst[0][0].is_a?(Regexp) or lst[0][0].is_a?(MatchData) or lst[0][0].is_a?(Method) or lst[0][0].is_a?(UnboundMethod) or lst[0][0].is_a?(File) or lst[0][0].is_a?(Dir) or lst[0][0].is_a?(IO) or lst[0][0].is_a?(StringIO) or lst[0][0].is_a?(Random) or lst[0][0].is_a?(Time) or lst[0][0].is_a?(Struct) or lst[0][0].is_a?(Object) or lst[0][0].is_a?(Class) or lst[0][0].is_a?(Module) or lst[0][0].is_a?(Binding) or lst[0][0].is_a?(Continuation) or lst[0][0].is_a?(ThreadGroup) or lst[0][0].is_a?(Thread) or lst[0][0].is_a?(MatchData) or lst[0][0].is_a?(MatchingData) or lst[0][0].is_a?(Rational) or lst[0][0].is_a?(Complex) or lst[0][0].is_a?(Encoding) or lst[0][0].is_a?(Encoding::UndefinedConversionError) or lst[0][0].is_a?(Encoding::InvalidByteSequenceError) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::InvalidByteSequenceError) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter) or lst[0][0].is_a?(Encoding::Converter)",
            "def sum_squares(lst)\n    # result = 0\n    result = 0\n    # for i in range(len(lst)):\n    for i in 0...lst.length\n        # if i % 3 == 0:\n        if i % 3 == 0\n            # result += pow(lst[i], 2)\n            result += lst[i] ** 2\n        # elif i % 4 == 0:\n        elsif i % 4 == 0\n            # result += pow(lst[i], 3)\n            result += lst[i] ** 3\n        # else:\n        else\n            # result += lst[i]\n            result += lst[i]\n        end\n    end\n    # return result\n    return result\nend\n",
            "def is_prime(n)\n    # if n < 2:\n    return false if n < 2\n    # for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..Math.sqrt(n).floor\n        # if n % i == 0:\n        return false if n % i == 0\n    end\n    # return True\n    true\nend\ndef words_in_sentence(sentence)\n    # words = sentence.split(\" \")\n    words = sentence.split(\" \")\n    # return \" \".join([w for w in words if is_prime(len(w))])\n    return words.select {|w| is_prime(w.length)}.join(\" \")\nend\n",
            "def simplify(x, n)\n    xs = x.split(\"/\")\n    ns = n.split(\"/\")\n    num = xs[0].to_i * ns[0].to_i\n    den = xs[1].to_i * ns[1].to_i\n    return num % den == 0\nend\n",
            "def digits_sum(n)\n    # n_str = str(n)\n    n_str = n.to_s\n    # if n >= 0:\n    if n >= 0\n        # return sum(int(d) for d in n_str)\n        return n_str.chars.map(&:to_i).sum\n    else\n        # return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return n_str[0..1].to_i * 2 + digits_sum(n.abs)\n    end\nend\ndef order_by_points(nums)\n    # return sorted(nums, key=digits_sum)\n    return nums.sort_by {|n| digits_sum(n)}\nend\n",
            "def special_filter(nums)\n    # odds = \"13579\"\n    odds = \"13579\"\n    # return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    return nums.count {|n| n > 10 and n % 2 == 1 and odds.include?(n.to_s[0])}\nend\n",
            "def get_max_triples(n)\n    # c = [0, 0, 0]\n    c = [0, 0, 0]\n    # for i in range(1, n + 1):\n    for i in 1..n\n        # a = i * i - i + 1\n        a = i * i - i + 1\n        # c[a % 3] += 1\n        c[a % 3] += 1\n    end\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\nend\n",
            "def bf(planet1, planet2)\n    # names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if planet1 not in names or planet2 not in names:\n    if !names.include?(planet1) || !names.include?(planet2)\n        # return []\n        return []\n    end\n    # l = names.index(planet1)\n    l = names.index(planet1)\n    # r = names.index(planet2)\n    r = names.index(planet2)\n    # if l > r:\n    if l > r\n        # l, r = r, l\n        l, r = r, l\n    end\n    # if l == r:\n    if l == r\n        # return []\n        return []\n    end\n    # return names[l + 1 : r]\n    return names[l + 1 .. r]\nend\n",
            "def sorted_list_sum(lst)\n    # result = [s for s in lst if len(s) % 2 == 0]\n    result = lst.select {|s| s.length % 2 == 0}\n    # return sorted(result, key=lambda x: (len(x), x))\n    return result.sort_by {|x| [x.length, x]}\nend\n",
            "def x_or_y(n, x, y)\n    # if n < 2:\n    if n < 2\n        # return y\n        return y\n    end\n    # for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..(Math.sqrt(n).floor + 1)\n        # if n % i == 0:\n        if n % i == 0\n            # return y\n            return y\n        end\n    end\n    # return x\n    return x\nend\n",
            "def double_the_difference(lst)\n    # return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    return lst.select {|n| n >= 0 and n % 2 == 1}.map {|n| n * n}.sum\nend\n",
            "def compare(game, guess)\n    # return [abs(x - y) for x, y in zip(game, guess)]\n    game.zip(guess).map {|x, y| x - y}.map {|x| x.abs}\nend\n",
            "def strongest_extension(class_name, extensions)\n    # max_s = float(\"-inf\")\n    max_s = -Float::INFINITY\n    # max_ext = \"\"\n    max_ext = \"\"\n    # for ext in extensions:\n    for ext in extensions\n        # upper = len([c for c in ext if c.isupper()])\n        upper = ext.count {|c| c.upcase == c}\n        # lower = len([c for c in ext if c.islower()])\n        lower = ext.count {|c| c.downcase == c}\n        # s = upper - lower\n        s = upper - lower\n        # if s > max_s:\n        if s > max_s\n            # max_s = s\n            max_s = s\n            # max_ext = ext\n            max_ext = ext\n        end\n    end\n    # return f\"{class_name}.{max_ext}\"\n    return \"#{class_name}.#{max_ext}\"\nend\n",
            "def cycpattern_check(a, b)\n    # if len(a) < len(b):\n    if a.length < b.length\n        # return False\n        return false\n    end\n    # for i in range(len(b)):\n    for i in 0...b.length\n        # if b[i:] + b[:i] in a:\n        if a.include?(b[i..-1] + b[0...i])\n            # return True\n            return true\n        end\n    end\n    # return False\n    return false\nend\n",
            "def even_odd_count(num)\n    # ds = str(abs(num))\n    ds = num.abs.to_s\n    # even = len([d for d in ds if ord(d) % 2 == 0])\n    even = ds.count {|d| d.ord % 2 == 0}\n    # return [even, len(ds) - even]\n    return [even, ds.length - even]\nend\n",
            "def int_to_mini_roman(num)\n    # values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    # numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # res = []\n    res = []\n    # for i in range(len(values)):\n    for i in 0...values.length\n        # while num >= values[i]:\n        while num >= values[i]\n            # res.append(numerals[i])\n            res << numerals[i]\n            # num -= values[i]\n            num -= values[i]\n        end\n    end\n    # return \"\".join(res)\n    return res.join\nend\n",
            "def right_angle_triangle(a, b, c)\n    # s = sorted([a, b, c])\n    s = [a, b, c].sort\n    # return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\nend\n",
            "def find_max(words)\n    # max_cnt = 0\n    max_cnt = 0\n    # max_w = \"\"\n    max_w = \"\"\n    # for w in words:\n    for w in words\n        # cnt = len(set(w))\n        cnt = w.chars.uniq.size\n        # if cnt > max_cnt:\n        if cnt > max_cnt\n            # max_cnt = cnt\n            max_cnt = cnt\n            # max_w = w\n            max_w = w\n        # elif cnt == max_cnt:\n        elsif cnt == max_cnt\n            # max_w = min(max_w, w)\n            max_w = [max_w, w].min\n        end\n    end\n    # return max_w\n    return max_w\nend\n",
            "def eat(num, need, remaining)\n    # if need <= remaining:\n    if need <= remaining\n        # return [num + need, remaining - need]\n        return [num + need, remaining - need]\n    else\n        # return [num + remaining, 0]\n        return [num + remaining, 0]\n    end\nend\n",
            "def do_algebra(operators, operands)\n    ops = operators.dup\n    nums = operands.dup\n    i = ops.length - 1\n    while i >= 0\n        if ops[i] == \"**\"\n            nums[i] = nums[i] ** nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n        end\n        i -= 1\n    end\n    i = 0\n    while i < ops.length\n        if ops[i] == \"*\"\n            nums[i] = nums[i] * nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        elsif ops[i] == \"//\"\n            nums[i] = nums[i] // nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        end\n        i += 1\n    end\n    i = 0\n    while i < ops.length\n        if ops[i] == \"+\"\n            nums[i] = nums[i] + nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        elsif ops[i] == \"-\"\n            nums[i] = nums[i] - nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        end\n        i += 1\n    end\n    return nums[0]\nend\n",
            "def solve(s)\n    # if not any(ch.isalpha() for ch in s):\n    if s.chars.none? {|ch| ch.is_a? String and ch.isalpha}\n        # return s[::-1]\n        return s.reverse\n    end\n    # result = []\n    result = []\n    # for ch in s:\n    for ch in s.chars\n        # if not ch.isalpha():\n        if ch.is_a? String and not ch.isalpha\n            # result.append(ch)\n            result << ch\n        # elif ch.isupper():\n        elsif ch.is_a? String and ch.isupper\n            # result.append(ch.lower())\n            result << ch.downcase\n        # elif ch.islower():\n        elsif ch.is_a? String and ch.islower\n            # result.append(ch.upper())\n            result << ch.upcase\n        end\n    end\n    # return \"\".join(result)\n    return result.join\nend\n",
            "def string_to_md5(txt)\n    # if not txt:\n    if txt.nil?\n        # return None\n        return nil\n    end\n    # md5_hash = hashlib.md5()\n    md5_hash = Digest::MD5.new\n    # txt_bytes = txt.encode()\n    txt_bytes = txt.encode('utf-8')\n    # md5_hash.update(txt_bytes)\n    md5_hash.update(txt_bytes)\n    # md5_encoded = md5_hash.hexdigest()\n    md5_encoded = md5_hash.hexdigest\n    # return md5_encoded\n    return md5_encoded\nend\n",
            "def generate_integers(a, b)\n    # lower = max(2, min(a, b))\n    lower = [2, [a, b].min].max\n    # upper = min(8, max(a, b))\n    upper = [8, [a, b].max].min\n    # return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    return (lower..upper).to_a.select {|i| i % 2 == 0}\nend\n"
        ],
        "rust": [
            "pub fn has_close_elements(numbers: &Vec<f64>, threshold: f64) -> bool {\n    // for i in range(len(numbers)):\n    for i in 0..numbers.len() {\n        // for j in range(i + 1, len(numbers)):\n        for j in (i + 1)..numbers.len() {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                // return True\n                return true;\n            }\n        }\n    }\n    // return False\n    false\n}\n",
            "pub fn separate_paren_groups(paren_string: &str) -> Vec<String> {\n    // groups = []\n    let mut groups = Vec::new();\n    // stk = []\n    let mut stk = Vec::new();\n    // current_group = \"\"\n    let mut current_group = String::new();\n    // parens = paren_string.replace(\" \", \"\")\n    let parens = paren_string.replace(\" \", \"\");\n    // for ch in parens:\n    for ch in parens.chars() {\n        // if ch == \"(\":\n        if ch == '(' {\n            // stk.append(ch)\n            stk.push(ch);\n            // current_group += ch\n            current_group.push(ch);\n        }\n        // elif ch == \")\":\n        else if ch == ')' {\n            // stk.pop()\n            stk.pop();\n            // current_group += ch\n            current_group.push(ch);\n            // if not stk:\n            if stk.is_empty() {\n                // groups.append(current_group)\n                groups.push(current_group);\n                // current_group = \"\"\n                current_group.clear();\n            }\n        }\n    }\n    // return groups\n    groups\n}\n",
            "pub fn truncate_number(num: f64) -> f64 {\n    // return num - floor(num)\n    num - num.floor()\n}\n",
            "pub fn below_zero(operations: &Vec<i32>) -> bool {\n    // balance = 0\n    let mut balance = 0;\n    // for op in operations:\n    for op in operations {\n        // balance += op\n        balance += *op;\n        // if balance < 0:\n        if balance < 0 {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    false\n}\n",
            "pub fn mean_absolute_deviation(numbers: &Vec<f64>) -> f64 {\n    // mean = sum(numbers) / len(numbers)\n    let mean = numbers.iter().sum::<f64>() / numbers.len() as f64;\n    // deviation = sum(abs(x - mean) for x in numbers)\n    let deviation = numbers.iter().map(|x| (x - mean).abs()).sum::<f64>();\n    // return deviation / len(numbers)\n    deviation / numbers.len() as f64\n}\n",
            "pub fn intersperse(numbers: &Vec<i32>, delimiter: i32) -> Vec<i32> {\n    // result = []\n    let mut result = Vec::new();\n    // for i in range(len(numbers)):\n    for i in 0..numbers.len() {\n        // if i != 0:\n        if i != 0 {\n            // result.append(delimiter)\n            result.push(delimiter);\n        }\n        // result.append(numbers[i])\n        result.push(numbers[i]);\n    }\n    // return result\n    result\n}\n",
            "pub fn parse_nested_parens(paren_string: &str) -> Vec<i32> {\n    // result = []\n    let mut result = Vec::new();\n    // paren_groups = paren_string.split()\n    let paren_groups = paren_string.split_whitespace();\n    // for group in paren_groups:\n    for group in paren_groups {\n        // max_depth = 0\n        let mut max_depth = 0;\n        // depth = 0\n        let mut depth = 0;\n        // for ch in group:\n        for ch in group.chars() {\n            // if ch == \"(\":\n            if ch == '(' {\n                // depth += 1\n                depth += 1;\n                // max_depth = max(max_depth, depth)\n                max_depth = max(max_depth, depth);\n            }\n            // elif ch == \")\":\n            else if ch == ')' {\n                // depth -= 1\n                depth -= 1;\n            }\n        }\n        // result.append(max_depth)\n        result.push(max_depth);\n    }\n    // return result\n    result\n}\n",
            "pub fn filter_by_substring(strs: &Vec<String>, substring: &str) -> Vec<String> {\n    // return [s for s in strs if substring in s]\n    strs.iter().filter(|s| s.contains(substring)).cloned().collect()\n}\n",
            "pub fn sum_product(numbers: &Vec<i32>) -> Vec<i32> {\n    // n_sum = sum(numbers)\n    let n_sum = numbers.iter().sum();\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    let n_product = numbers.iter().fold(1, |acc, x| acc * x);\n    // return [n_sum, n_product]\n    vec![n_sum, n_product]\n}\n",
            "pub fn rolling_max(numbers: &Vec<i32>) -> Vec<i32> {\n    // max_so_far = float(\"-inf\")\n    let mut max_so_far = std::i32::MIN;\n    // result = []\n    let mut result = Vec::new();\n    // for num in numbers:\n    for num in numbers {\n        // max_so_far = max(max_so_far, num)\n        max_so_far = max_so_far.max(*num);\n        // result.append(max_so_far)\n        result.push(max_so_far);\n    }\n    // return result\n    result\n}\n",
            "pub fn is_palindrome(s: &str) -> bool {\n    // return s == s[::-1]\n    s == s.chars().rev().collect::<String>()\n}\npub fn make_palindrome(s: &str) -> String {\n    // if is_palindrome(s):\n    if is_palindrome(s) {\n        // return s\n        return s.to_string();\n    }\n    // for i in range(len(s)):\n    for i in 0..s.len() {\n        // if is_palindrome(s[i:]):\n        if is_palindrome(&s[i..]) {\n            // return s + s[:i][::-1]\n            return format!(\"{}{}\", s, &s[..i].chars().rev().collect::<String>());\n        }\n    }\n    // return \"\"\n    \"\".to_string()\n}\n",
            "pub fn string_xor(a: &str, b: &str) -> String {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    a.chars().zip(b.chars()).map(|(x, y)| if x == y { '0' } else { '1' }).collect()\n}\n",
            "pub fn longest(strs: &Vec<String>) -> Option<String> {\n    // if not strs:\n    if strs.is_empty() {\n        // return None\n        return None;\n    }\n    // longest_s = strs[0]\n    let mut longest_s = strs[0].clone();\n    // for s in strs:\n    for s in strs {\n        // if len(s) > len(longest_s):\n        if s.len() > longest_s.len() {\n            // longest_s = s\n            longest_s = s.clone();\n        }\n    }\n    // return longest_s\n    Some(longest_s)\n}\n",
            "pub fn greatest_common_divisor(a: i32, b: i32) -> i32 {\n    // if b == 0:\n    if b == 0 {\n        // return a\n        return a;\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        return greatest_common_divisor(b, a % b);\n    }\n}\n",
            "pub fn all_prefixes(s: &str) -> Vec<String> {\n    // prefixes = []\n    let mut prefixes = Vec::new();\n    // for i in range(len(s)):\n    for i in 0..s.len() {\n        // prefixes.append(s[: i + 1])\n        prefixes.push(s[..i + 1].to_string());\n    }\n    // return prefixes\n    prefixes\n}\n",
            "pub fn string_sequence(n: i32) -> String {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    let mut result = String::new();\n    for i in 0..n + 1 {\n        result.push_str(&format!(\"{} \", i));\n    }\n    result\n}\n",
            "pub fn count_distinct_characters(s: &str) -> usize {\n    // return len(set(s.lower()))\n    let mut set = std::collections::HashSet::new();\n    for c in s.to_lowercase().chars() {\n        set.insert(c);\n    }\n    set.len()\n}\n",
            "pub fn parse_music(music_string: &str) -> Vec<i32> {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    let durations = vec![4, 2, 1];\n    // notes = music_string.split()\n    let notes = music_string.split_whitespace();\n    // return [durations[note] for note in notes]\n    notes.map(|note| {\n        let index = match note {\n            \"o\" => 0,\n            \"o|\" => 1,\n            \".|\" => 2,\n            _ => panic!(\"Invalid note: {}\", note),\n        };\n        durations[index]\n    }).collect()\n}\n",
            "pub fn how_many_times(s: &str, substring: &str) -> usize {\n    // times = 0\n    let mut times = 0;\n    // for i in range(len(s) - len(substring) + 1):\n    for i in 0..(s.len() - substring.len() + 1) {\n        // if s[i : i + len(substring)] == substring:\n        if &s[i..i + substring.len()] == substring {\n            // times += 1\n            times += 1;\n        }\n    }\n    // return times\n    times\n}\n",
            "pub fn sort_numbers(numbers: &str) -> String {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    let num_dict = [\n        (\"zero\", 0),\n        (\"one\", 1),\n        (\"two\", 2),\n        (\"three\", 3),\n        (\"four\", 4),\n        (\"five\", 5),\n        (\"six\", 6),\n        (\"seven\", 7),\n        (\"eight\", 8),\n        (\"nine\", 9),\n    ];\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    let num_list: Vec<&str> = numbers\n        .split(\" \")\n        .filter(|x| num_dict.iter().any(|(k, _)| k == x))\n        .collect();\n    // num_list.sort(key=lambda x: num_dict[x])\n    num_list.sort_by_key(|x| num_dict.iter().find(|(k, _)| k == x).unwrap().1);\n    // return \" \".join(num_list)\n    num_list.join(\" \")\n}\n",
            "pub fn find_closest_elements(numbers: &Vec<f64>) -> Vec<f64> {\n    // sorted_numbers = sorted(numbers)\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    // min_diff = float(\"inf\")\n    let mut min_diff = f64::INFINITY;\n    // closest_pair = []\n    let mut closest_pair = Vec::new();\n    // for i in range(1, len(sorted_numbers)):\n    for i in 1..sorted_numbers.len() {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        let diff = sorted_numbers[i] - sorted_numbers[i - 1];\n        // if diff < min_diff:\n        if diff < min_diff {\n            // min_diff = diff\n            min_diff = diff;\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closest_pair = vec![sorted_numbers[i - 1], sorted_numbers[i]];\n        }\n    }\n    // return closest_pair\n    closest_pair\n}\n",
            "pub fn rescale_to_unit(numbers: &Vec<f64>) -> Vec<f64> {\n    // min_num = min(numbers)\n    let min_num = numbers.iter().min().unwrap();\n    // max_num = max(numbers)\n    let max_num = numbers.iter().max().unwrap();\n    // if min_num == max_num:\n    if min_num == max_num {\n        // return [0.0] * len(numbers)\n        return vec![0.0; numbers.len()];\n    } else {\n        // return [(num - min_num) / (max_num - min_num) for num in numbers]\n        numbers.iter().map(|num| (num - min_num) / (max_num - min_num)).collect()\n    }\n}\n",
            "pub fn filter_integers(values: &Vec<Any>) -> Vec<i32> {\n    // return [x for x in values if isinstance(x, int)]\n    values.iter().filter(|x| x.is_int()).map(|x| x.as_int().unwrap()).collect()\n}\n",
            "pub fn str_length(s: &str) -> usize {\n    // return len(s)\n    s.len()\n}\n",
            "pub fn largest_divisor(n: i32) -> i32 {\n    // for i in range(2, n):\n    for i in 2..n {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return n // i\n            return n / i;\n        }\n    }\n    // return 1\n    1\n}\n",
            "pub fn factorize(n: i32) -> Vec<i32> {\n    // factors = []\n    let mut factors = Vec::new();\n    // divisor = 2\n    let mut divisor = 2;\n    // while divisor <= n:\n    while divisor <= n {\n        // if n % divisor == 0:\n        if n % divisor == 0 {\n            // factors.append(divisor)\n            factors.push(divisor);\n            // n //= divisor\n            n /= divisor;\n        } else {\n            // divisor += 1\n            divisor += 1;\n        }\n    }\n    // return factors\n    factors\n}\n",
            "pub fn remove_duplicates(numbers: &Vec<i32>) -> Vec<i32> {\n    // counts = {}\n    let mut counts = std::collections::HashMap::new();\n    // for num in numbers:\n    for num in numbers {\n        // counts[num] = counts.get(num, 0) + 1\n        *counts.entry(*num).or_insert(0) += 1;\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    let mut res = Vec::new();\n    for num in numbers {\n        if counts.get(num) == Some(&1) {\n            res.push(*num);\n        }\n    }\n    // return res\n    res\n}\n",
            "pub fn flip_case(s: &str) -> String {\n    // flipped = []\n    let mut flipped = Vec::new();\n    // for ch in s:\n    for ch in s.chars() {\n        // if not ch.isalpha():\n        if !ch.is_alphabetic() {\n            // flipped.append(ch)\n            flipped.push(ch);\n        }\n        // elif ch.islower():\n        else if ch.is_lowercase() {\n            // flipped.append(ch.upper())\n            flipped.push(ch.to_uppercase().next().unwrap());\n        }\n        // elif ch.isupper():\n        else if ch.is_uppercase() {\n            // flipped.append(ch.lower())\n            flipped.push(ch.to_lowercase().next().unwrap());\n        }\n    }\n    // return ''.join(flipped)\n    flipped.into_iter().collect()\n}\n",
            "pub fn concatenate(strs: &Vec<String>) -> String {\n    // return \"\".join(strs)\n    strs.join(\"\")\n}\n",
            "pub fn filter_by_prefix(strs: &Vec<String>, prefix_str: &str) -> Vec<String> {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    strs.iter().filter(|s| s.starts_with(prefix_str)).cloned().collect()\n}\n",
            "pub fn get_positive(l: &Vec<i32>) -> Vec<i32> {\n    // return [num for num in l if num > 0]\n    l.iter().filter(|&num| num > 0).cloned().collect()\n}\n",
            "pub fn is_prime(n: i32) -> bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..=((n as f64).sqrt() as i32) {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    true\n}\n",
            "pub fn poly(xs: &Vec<i32>, x: f64) -> f64 {\n    // res = 0.0\n    let mut res = 0.0;\n    // for i in range(len(xs)):\n    for i in 0..xs.len() {\n        // res += xs[i] * x**i\n        res += xs[i] as f64 * x.powi(i as i32);\n    }\n    // return res\n    res\n}\npub fn find_zero(xs: &Vec<i32>) -> f64 {\n    // x1, x2 = 1.0, -1.0\n    let mut x1 = 1.0;\n    let mut x2 = -1.0;\n    // while poly(xs, x1) * poly(xs, x2) > 0:\n    while poly(xs, x1) * poly(xs, x2) > 0.0 {\n        // x1 *= 2\n        x1 *= 2.0;\n        // x2 *= 2\n        x2 *= 2.0;\n    }\n    // while abs(x1 - x2) > 1e-10:\n    while (x1 - x2).abs() > 1e-10 {\n        // mid = (x1 + x2) / 2\n        let mid = (x1 + x2) / 2.0;\n        // if poly(xs, mid) == 0:\n        if poly(xs, mid) == 0.0 {\n            // return mid\n            return mid;\n        }\n        // elif poly(xs, mid) * poly(xs, x1) < 0:\n        else if poly(xs, mid) * poly(xs, x1) < 0.0 {\n            // x2 = mid\n            x2 = mid;\n        }\n        // else:\n        else {\n            // x1 = mid\n            x1 = mid;\n        }\n    }\n    // return (x1 + x2) / 2\n    (x1 + x2) / 2.0\n}\n",
            "pub fn sort_third(l: &Vec<i32>) -> Vec<i32> {\n    // sorted_third = sorted(l[::3])\n    let sorted_third = l.iter().step_by(3).cloned().collect::<Vec<i32>>();\n    sorted_third.sort();\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    let mut result = Vec::new();\n    for i in 0..l.len() {\n        if i % 3 == 0 {\n            result.push(sorted_third[i / 3]);\n        } else {\n            result.push(l[i]);\n        }\n    }\n    result\n}\n",
            "pub fn list_unique(l: &Vec<i32>) -> Vec<i32> {\n    // return sorted(list(set(l)))\n    let mut s = std::collections::HashSet::new();\n    for e in l {\n        s.insert(*e);\n    }\n    let mut result = Vec::new();\n    for e in s {\n        result.push(e);\n    }\n    result.sort();\n    result\n}\n",
            "pub fn max_element(l: &Vec<i32>) -> i32 {\n    // if not l:\n    if l.is_empty() {\n        // return 0\n        0\n    } else {\n        // return max(l)\n        l.iter().max().unwrap()\n    }\n}\n",
            "pub fn fizz_buzz(n: i32) -> i32 {\n    // cnt = 0\n    let mut cnt = 0;\n    // for i in range(n):\n    for i in 0..n {\n        // if i % 11 == 0 or i % 13 == 0:\n        if i % 11 == 0 || i % 13 == 0 {\n            // cnt += str(i).count(\"7\")\n            cnt += i.to_string().chars().filter(|&c| c == '7').count() as i32;\n        }\n    }\n    // return cnt\n    cnt\n}\n",
            "pub fn sort_even(l: &Vec<i32>) -> Vec<i32> {\n    // sorted_even = sorted(l[::2])\n    let sorted_even = l[..].iter().step_by(2).cloned().collect::<Vec<i32>>();\n    sorted_even.sort();\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    let mut result = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            result.push(sorted_even[i / 2]);\n        } else {\n            result.push(l[i]);\n        }\n    }\n    result\n}\n",
            "pub fn encode_cyclic(s: &str) -> String {\n    // result = []\n    let mut result = Vec::new();\n    // for i in range(0, len(s), 3):\n    for i in (0..s.len()).step_by(3) {\n        // if i + 3 > len(s):\n        if i + 3 > s.len() {\n            // result.append(s[i:])\n            result.push(s[i..].to_string());\n        } else {\n            // result.append(s[i+1:i+3])\n            result.push(s[i+1..i+3].to_string());\n            // result.append(s[i])\n            result.push(s[i..i+1].to_string());\n        }\n    }\n    // return \"\".join(result)\n    result.join(\"\")\n}\npub fn decode_cyclic(s: &str) -> String {\n    encode_cyclic(&encode_cyclic(s))\n}\n",
            "pub fn is_prime(n: i32) -> bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..=((n as f64).sqrt() + 1.0) as i32 {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    true\n}\npub fn prime_fib(n: i32) -> i32 {\n    // f = [0, 1]\n    let mut f = vec![0, 1];\n    // cnt = 0\n    let mut cnt = 0;\n    // while cnt < n:\n    while cnt < n {\n        // f = [f[1], f[0] + f[1]]\n        f.swap(0, 1);\n        f[1] += f[0];\n        // if is_prime(f[1]):\n        if is_prime(f[1]) {\n            // cnt += 1\n            cnt += 1;\n        }\n    }\n    // return f[1]\n    f[1]\n}\n",
            "pub fn triples_sum_to_zero(l: &Vec<i32>) -> bool {\n    // for i in range(len(l)):\n    for i in 0..l.len() {\n        // for j in range(i + 1, len(l)):\n        for j in (i + 1)..l.len() {\n            // for k in range(j + 1, len(l)):\n            for k in (j + 1)..l.len() {\n                // if l[i] + l[j] + l[k] == 0:\n                if l[i] + l[j] + l[k] == 0 {\n                    // return True\n                    return true;\n                }\n            }\n        }\n    }\n    // return False\n    false\n}\n",
            "pub fn car_race_collision(n: i32) -> i32 {\n    // return n ** 2\n    n * n\n}\n",
            "pub fn incr_list(l: &Vec<i32>) -> Vec<i32> {\n    // return [i + 1 for i in l]\n    l.iter().map(|i| i + 1).collect()\n}\n",
            "pub fn pairs_sum_to_zero(l: &Vec<i32>) -> bool {\n    // seen = set()\n    let mut seen = HashSet::new();\n    // for num in l:\n    for num in l {\n        // if -num in seen:\n        if seen.contains(&(-num)) {\n            // return True\n            return true;\n        }\n        // seen.add(num)\n        seen.insert(*num);\n    }\n    // return False\n    false\n}\n",
            "pub fn change_base(x: i32, bas: i32) -> String {\n    // if x == 0:\n    if x == 0 {\n        // return \"0\"\n        return \"0\".to_string();\n    }\n    // digits = []\n    let mut digits = Vec::new();\n    // while x > 0:\n    while x > 0 {\n        // digits.append(str(x % bas))\n        digits.push(format!(\"{}\", x % bas));\n        // x //= bas\n        x /= bas;\n    }\n    // return \"\".join(digits[::-1])\n    digits.reverse();\n    digits.join(\"\")\n}\n",
            "pub fn triangle_area(a: i32, h: i32) -> f64 {\n    // return a * h / 2\n    (a as f64) * (h as f64) / 2.0\n}\n",
            "pub fn fib4(n: i32) -> i32 {\n    // fib = [0, 0, 2, 0]\n    let mut fib = [0, 0, 2, 0];\n    // for i in range(4, n + 1):\n    for i in 4..=n {\n        // fib[i % 4] = sum(fib)\n        fib[(i % 4) as usize] = fib[0] + fib[1];\n    }\n    // return fib[n % 4]\n    fib[(n % 4) as usize]\n}\n",
            "pub fn median(l: &Vec<f64>) -> f64 {\n    // sl = sorted(l)\n    let mut sl = l.clone();\n    sl.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    // if len(l) % 2 != 0:\n    if l.len() % 2 != 0 {\n        // return sl[len(l) // 2]\n        return sl[l.len() / 2];\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (sl[l.len() / 2] + sl[l.len() / 2 - 1]) / 2.0;\n    }\n}\n",
            "pub fn is_palindrome(txt: &str) -> bool {\n    // return txt == txt[::-1]\n    txt == txt.chars().rev().collect::<String>()\n}\n",
            "pub fn modp(n: i32, p: i32) -> i32 {\n    // ret = 1\n    let mut ret = 1;\n    // for _ in range(n):\n    for _ in 0..n {\n        // ret = (ret * 2) % p\n        ret = (ret * 2) % p;\n    }\n    // return ret\n    ret\n}\n",
            "pub fn encode_shift(s: &str) -> String {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    let result: Vec<char> = s.chars().map(|ch| {\n        // ((ord(ch) - 97 + 5) % 26) + 97\n        ((ch as u8 - 97 + 5) % 26) as u8 + 97\n    }).collect();\n    // return \"\".join(result)\n    result.into_iter().collect()\n}\npub fn decode_shift(s: &str) -> String {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    let result: Vec<char> = s.chars().map(|ch| {\n        // ((ord(ch) - 97 + 21) % 26) + 97\n        ((ch as u8 - 97 + 21) % 26) as u8 + 97\n    }).collect();\n    // return \"\".join(result)\n    result.into_iter().collect()\n}\n",
            "pub fn remove_vowels(txt: &str) -> String {\n    // vowels = \"aeiouAEIOU\"\n    let vowels = \"aeiouAEIOU\";\n    // return \"\".join([char for char in txt if char not in vowels])\n    txt.chars()\n        .filter(|c| !vowels.contains(*c))\n        .collect()\n}\n",
            "pub fn below_threshold(l: &Vec<i32>, t: i32) -> bool {\n    // return all(x < t for x in l)\n    l.iter().all(|x| x < &t)\n}\n",
            "pub fn add(x: i32, y: i32) -> i32 {\n    // return x + y\n    x + y\n}\n",
            "pub fn same_chars(s0: &str, s1: &str) -> bool {\n    // return set(s0) == set(s1)\n    s0.chars().collect::<std::collections::HashSet<_>>() == s1.chars().collect::<std::collections::HashSet<_>>()\n}\n",
            "fn fib(n: i32) -> i32 {\n    // if n <= 1:\n    if n <= 1 {\n        // return n\n        return n;\n    }\n    // else:\n    else {\n        // return fib(n - 1) + fib(n - 2)\n        fib(n - 1) + fib(n - 2)\n    }\n}\n",
            "pub fn correct_bracketing(brackets: &str) -> bool {\n    // depth = 0\n    let mut depth = 0;\n    // for b in brackets:\n    for b in brackets.chars() {\n        // if b == \"<\":\n        if b == '<' {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \">\":\n        else if b == '>' {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if depth < 0 {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    depth == 0\n}\n",
            "pub fn monotonic(l: &Vec<i32>) -> bool {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    let diff: Vec<i32> = l.iter().zip(l.iter().skip(1)).map(|(x, y)| y - x).collect();\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    diff.iter().all(|x| *x <= 0) || diff.iter().all(|x| *x >= 0)\n}\n",
            "pub fn common(l1: &Vec<i32>, l2: &Vec<i32>) -> Vec<i32> {\n    // return sorted(list(set(l1) & set(l2)))\n    let mut result = Vec::new();\n    let mut set = std::collections::HashSet::new();\n    for e in l1 {\n        set.insert(*e);\n    }\n    for e in l2 {\n        if set.contains(e) {\n            result.push(*e);\n        }\n    }\n    result.sort();\n    result\n}\n",
            "pub fn largest_prime_factor(n: i32) -> i32 {\n    // i = 2\n    let mut i = 2;\n    // while i * i <= n:\n    while i * i <= n {\n        // if n % i:\n        if n % i != 0 {\n            // i += 1\n            i += 1;\n        } else {\n            // n //= i\n            n /= i;\n        }\n    }\n    // return n\n    n\n}\n",
            "pub fn sum_to_n(n: i32) -> i32 {\n    // return sum(range(n + 1))\n    (1..(n + 1)).sum()\n}\n",
            "pub fn correct_bracketing(brackets: &str) -> bool {\n    // depth = 0\n    let mut depth = 0;\n    // for b in brackets:\n    for b in brackets.chars() {\n        // if b == \"(\":\n        if b == '(' {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \")\":\n        else if b == ')' {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if depth < 0 {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    depth == 0\n}\n",
            "pub fn derivative(xs: &Vec<i32>) -> Vec<i32> {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    xs.iter().enumerate().map(|(i, x)| x * i as i32).collect()\n}\n",
            "pub fn fibfib(n: i32) -> i32 {\n    // if n <= 1:\n    if n <= 1 {\n        // return 0 \n        0\n    } else {\n        // a, b, c = 0, 0, 1\n        let mut a = 0;\n        let mut b = 0;\n        let mut c = 1;\n        // while n > 2:\n        while n > 2 {\n            // a, b, c = b, c, a + b + c\n            let tmp = a;\n            a = b;\n            b = c;\n            c = tmp + b + c;\n            // n -= 1\n            n -= 1;\n        }\n        // return c\n        c\n    }\n}\n",
            "pub fn vowels_count(s: &str) -> i32 {\n    // vowels = \"aeiou\"\n    let vowels = \"aeiou\";\n    // cnt = 0\n    let mut cnt = 0;\n    // for i in range(len(s)):\n    for i in 0..s.len() {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if s[i..i+1].to_lowercase() == \"y\" || vowels.contains(&s[i..i+1].to_lowercase()) {\n            // cnt += 1\n            cnt += 1;\n        }\n    }\n    // return cnt\n    cnt\n}\n",
            "pub fn circular_shift(x: i32, shift: i32) -> String {\n    // x_str = str(x)\n    let x_str = x.to_string();\n    // if shift > len(x_str):\n    if shift > x_str.len() as i32 {\n        // return x_str[::-1]\n        return x_str.chars().rev().collect();\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return x_str.chars().skip(x_str.len() - shift as usize).collect::<String>() + &x_str[..x_str.len() - shift as usize];\n    }\n}\n",
            "pub fn digit_sum(s: &str) -> i32 {\n    // return sum(ord(c) for c in s if c.isupper())\n    s.chars().filter(|c| c.is_uppercase()).map(|c| c as u32).sum()\n}\n",
            "pub fn fruit_distribution(s: &str, n: i32) -> i32 {\n    // words = s.split(' ')\n    let words: Vec<&str> = s.split(' ').collect();\n    // apples = int(words[words.index(\"apples\") - 1])\n    let apples = words[words.iter().position(|&x| x == \"apples\").unwrap() - 1].parse::<i32>().unwrap();\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    let oranges = words[words.iter().position(|&x| x == \"oranges\").unwrap() - 1].parse::<i32>().unwrap();\n    // return n - apples - oranges\n    n - apples - oranges\n}\n",
            "pub fn pluck(arr: &Vec<i32>) -> Vec<i32> {\n    // evens = [n for n in arr if n % 2 == 0]\n    let evens: Vec<i32> = arr.iter().filter(|&n| n % 2 == 0).cloned().collect();\n    // if len(evens) == 0:\n    if evens.len() == 0 {\n        // return []\n        return vec![];\n    }\n    // min_even = min(evens)\n    let min_even = *evens.iter().min().unwrap();\n    // return [min_even, arr.index(min_even)]\n    vec![min_even, arr.iter().position(|&n| n == min_even).unwrap() as i32]\n}\n",
            "pub fn search(lst: &Vec<i32>) -> i32 {\n    // freqs = {}\n    let mut freqs = std::collections::HashMap::new();\n    // for n in lst:\n    for n in lst {\n        // freqs[n] = freqs.get(n, 0) + 1\n        *freqs.entry(*n).or_insert(0) += 1;\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    let good_vals: Vec<i32> = freqs.iter().filter(|(k, v)| *v >= *k).map(|(k, _)| *k).collect();\n    // return max(good_vals, default=-1)\n    *good_vals.iter().max().unwrap_or(&-1)\n}\n",
            "pub fn strange_sort_list(lst: &Vec<i32>) -> Vec<i32> {\n    // sl = sorted(lst)\n    let mut sl = lst.clone();\n    sl.sort();\n    // result = []\n    let mut result = Vec::new();\n    // left, right = 0, len(sl) - 1\n    let mut left = 0;\n    let mut right = sl.len() - 1;\n    // while left <= right:\n    while left <= right {\n        // result.append(sl[left])\n        result.push(sl[left]);\n        left += 1;\n        // if left <= right:\n        if left <= right {\n            // result.append(sl[right])\n            result.push(sl[right]);\n            right -= 1;\n        }\n    }\n    // return result\n    result\n}\n",
            "pub fn triangle_area(a: i32, b: i32, c: i32) -> f64 {\n    // if a + b > c and a + c > b and b + c > a:\n    if a + b > c && a + c > b && b + c > a {\n        // s = (a + b + c) / 2.0\n        let s = (a + b + c) as f64 / 2.0;\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return s.sqrt() * (s - a as f64) * (s - b as f64) * (s - c as f64);\n    } else {\n        // return -1.0\n        return -1.0;\n    }\n}\n",
            "pub fn will_it_fly(q: &Vec<i32>, w: i32) -> bool {\n    // if len(q) == 0:\n    if q.len() == 0 {\n        // return False\n        return false;\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    let is_palin = q.iter().enumerate().all(|(i, &e)| e == q[q.len() - i - 1]);\n    // total = sum(q)\n    let total = q.iter().sum();\n    // return is_palin and total <= w\n    is_palin && total <= w\n}\n",
            "pub fn smallest_change(arr: &Vec<i32>) -> i32 {\n    // ans = 0\n    let mut ans = 0;\n    // for i in range(len(arr) // 2):\n    for i in 0..(arr.len() / 2) {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if arr[i] != arr[arr.len() - i - 1] {\n            // ans += 1\n            ans += 1;\n        }\n    }\n    // return ans\n    ans\n}\n",
            "pub fn total_match(lst1: &Vec<String>, lst2: &Vec<String>) -> Vec<String> {\n    // cnt1 = sum(len(s) for s in lst1)\n    let cnt1 = lst1.iter().map(|s| s.len()).sum();\n    // cnt2 = sum(len(s) for s in lst2)\n    let cnt2 = lst2.iter().map(|s| s.len()).sum();\n    // return lst1 if cnt1 <= cnt2 else lst2\n    if cnt1 <= cnt2 {\n        lst1.clone()\n    } else {\n        lst2.clone()\n    }\n}\n",
            "pub fn is_prime(n: i32) -> bool {\n    // if n < 2:\n    if n < 2 { return false; }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..(n as f64).sqrt().ceil() as i32 + 1 {\n        // if n % i == 0:\n        if n % i == 0 { return false; }\n    }\n    // return True\n    true\n}\npub fn is_multiply_prime(a: i32) -> bool {\n    // cnt = 0\n    let mut cnt = 0;\n    // for i in range(2, a + 1):\n    for i in 2..(a + 1) {\n        // if is_prime(i):\n        if is_prime(i) {\n            // while a % i == 0:\n            while a % i == 0 {\n                // cnt += 1\n                cnt += 1;\n                // a /= i\n                a /= i;\n            }\n        }\n    }\n    // return cnt == 3\n    cnt == 3\n}\n",
            "pub fn is_simple_power(x: i32, n: i32) -> bool {\n    // if n < 2:\n    if n < 2 {\n        // return x == n\n        return x == n;\n    }\n    // tmp = 1\n    let mut tmp = 1;\n    // while tmp < x:\n    while tmp < x {\n        // tmp *= n\n        tmp *= n;\n    }\n    // return tmp == x\n    tmp == x\n}\n",
            "pub fn is_cube(a: i32) -> bool {\n    // a = abs(a)\n    let a = a.abs();\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    let root = (a as f64).powf(1.0 / 3.0).round() as i32;\n    // return root * root * root == a\n    root * root * root == a\n}\n",
            "pub fn hex_key(num: &str) -> i32 {\n    // return len([x for x in num if x in \"2357BD\"])\n    num.chars().filter(|x| \"2357BD\".contains(x)).count() as i32\n}\n",
            "pub fn decimal_to_binary(dec: i32) -> String {\n    // binary = bin(dec)[2:]\n    let binary = format!(\"{:b}\", dec);\n    // return f\"db{binary}db\"\n    format!(\"db{}db\", binary)\n}\n",
            "pub fn is_happy(s: &str) -> bool {\n    // if len(s) < 3:\n    if s.len() < 3 {\n        // return False\n        return false;\n    }\n    // for i in range(len(s) - 2):\n    for i in 0..s.len() - 2 {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if s.chars().nth(i).unwrap() == s.chars().nth(i + 1).unwrap() ||\n            s.chars().nth(i).unwrap() == s.chars().nth(i + 2).unwrap() ||\n            s.chars().nth(i + 1).unwrap() == s.chars().nth(i + 2).unwrap() {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    true\n}\n",
            "pub fn numerical_letter_grade(grades: &Vec<f64>) -> Vec<String> {\n    // result = []\n    let mut result = Vec::new();\n    // for g in grades:\n    for g in grades {\n        // if g == 4.0:\n        if *g == 4.0 {\n            // result.append(\"A+\")\n            result.push(\"A+\".to_string());\n        }\n        // elif g > 3.7:\n        else if *g > 3.7 {\n            // result.append(\"A\")\n            result.push(\"A\".to_string());\n        }\n        // elif g > 3.3:\n        else if *g > 3.3 {\n            // result.append(\"A-\")\n            result.push(\"A-\".to_string());\n        }\n        // elif g > 3.0:\n        else if *g > 3.0 {\n            // result.append(\"B+\")\n            result.push(\"B+\".to_string());\n        }\n        // elif g > 2.7:\n        else if *g > 2.7 {\n            // result.append(\"B\")\n            result.push(\"B\".to_string());\n        }\n        // elif g > 2.3:\n        else if *g > 2.3 {\n            // result.append(\"B-\")\n            result.push(\"B-\".to_string());\n        }\n        // elif g > 2.0:\n        else if *g > 2.0 {\n            // result.append(\"C+\")\n            result.push(\"C+\".to_string());\n        }\n        // elif g > 1.7:\n        else if *g > 1.7 {\n            // result.append(\"C\")\n            result.push(\"C\".to_string());\n        }\n        // elif g > 1.3:\n        else if *g > 1.3 {\n            // result.append(\"C-\")\n            result.push(\"C-\".to_string());\n        }\n        // elif g > 1.0:\n        else if *g > 1.0 {\n            // result.append(\"D+\")\n            result.push(\"D+\".to_string());\n        }\n        // elif g > 0.7:\n        else if *g > 0.7 {\n            // result.append(\"D\")\n            result.push(\"D\".to_string());\n        }\n        // elif g > 0.0:\n        else if *g > 0.0 {\n            // result.append(\"D-\")\n            result.push(\"D-\".to_string());\n        }\n        // else:\n        else {\n            // result.append(\"E\")\n            result.push(\"E\".to_string());\n        }\n    }\n    // return result\n    result\n}\n",
            "pub fn prime_length(s: &str) -> bool {\n    // length = len(s)\n    let length = s.len();\n    // if length < 2:\n    if length < 2 {\n        return false;\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for i in 2..(length as f64).sqrt().ceil() as usize + 1 {\n        // if length % i == 0:\n        if length % i == 0 {\n            return false;\n        }\n    }\n    // return True\n    true\n}\n",
            "pub fn starts_one_ends(n: i32) -> i32 {\n    // if n == 1:\n    if n == 1 {\n        // return 1\n        1\n    } else {\n        // return 2 * 9 * (10 ** (n - 2))\n        2 * 9 * (10i32.pow(n - 2))\n    }\n}\n",
            "pub fn solve(n: i32) -> String {\n    // digits_sum = sum(int(d) for d in str(n))\n    let digits_sum = n.to_string().chars().map(|d| d.to_digit(10).unwrap()).sum();\n    // return bin(digits_sum)[2:]\n    format!(\"{:b}\", digits_sum)\n}\n",
            "pub fn add(lst: &Vec<i32>) -> i32 {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    lst.iter().enumerate().filter(|(i, x)| i % 2 == 1 && x % 2 == 0).map(|(_, x)| x).sum()\n}\n",
            "pub fn anti_shuffle(s: &str) -> String {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    let words: Vec<String> = s.split(\" \").map(|word| {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n        chars.into_iter().collect()\n    }).collect();\n    // return \" \".join(words)\n    words.join(\" \")\n}\n",
            "pub fn get_row(lst: &Vec<Vec<i32>>, x: i32) -> Vec<Vec<i32>> {\n    // coords = []\n    let mut coords = Vec::new();\n    // for i in range(len(lst)):\n    for i in 0..lst.len() {\n        // for j in range(len(lst[i])):\n        for j in 0..lst[i].len() {\n            // if lst[i][j] == x:\n            if lst[i][j] == x {\n                // coords.append([i, j])\n                coords.push(vec![i as i32, j as i32]);\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    coords.sort_by(|a, b| {\n        a[0].cmp(&b[0]).then(a[1].cmp(&b[1]).reverse())\n    });\n    coords\n}\n",
            "pub fn sort_array(arr: &Vec<i32>) -> Vec<i32> {\n    // if len(arr) == 0:\n    if arr.len() == 0 {\n        // return []\n        return vec![];\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if (arr[0] + arr[arr.len() - 1]) % 2 == 0 {\n        // return sorted(arr, reverse=True)\n        return arr.iter().rev().cloned().collect();\n    } else {\n        // return sorted(arr)\n        return arr.iter().cloned().collect();\n    }\n}\n",
            "pub fn encrypt(s: &str) -> String {\n    // result = []\n    let mut result = Vec::new();\n    // for ch in s:\n    for ch in s.chars() {\n        // shifted = ord(ch) + 4\n        let shifted = ch as u32 + 4;\n        // if shifted > ord('z'):\n        if shifted > 'z' as u32 {\n            // shifted -= 26\n            shifted -= 26;\n        }\n        // result.append(chr(shifted))\n        result.push(std::char::from_u32(shifted).unwrap());\n    }\n    // return \"\".join(result)\n    result.into_iter().collect()\n}\n",
            "pub fn next_smallest(lst: &Vec<i32>) -> Option<i32> {\n    // sl = sorted(set(lst))\n    let mut sl = lst.clone();\n    sl.sort();\n    sl.dedup();\n    // if len(sl) < 2:\n    if sl.len() < 2 {\n        // return None\n        return None;\n    }\n    // return sl[1]\n    Some(sl[1])\n}\n",
            "pub fn is_bored(s: &str) -> i32 {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    let sentences = Regex::new(r\"[.!?]\\s*\").unwrap().split(s).collect::<Vec<&str>>();\n    // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    sentences.iter().filter(|sentence| sentence.len() >= 2).map(|sentence| sentence.starts_with(\"I \")).sum()\n}\n",
            "pub fn any_int(x: &Any, y: &Any, z: &Any) -> bool {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if x.is::<i32>() && y.is::<i32>() && z.is::<i32>() {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if x.downcast_ref::<i32>().unwrap() + y.downcast_ref::<i32>().unwrap() == z.downcast_ref::<i32>().unwrap()\n            || x.downcast_ref::<i32>().unwrap() + z.downcast_ref::<i32>().unwrap() == y.downcast_ref::<i32>().unwrap()\n            || y.downcast_ref::<i32>().unwrap() + z.downcast_ref::<i32>().unwrap() == x.downcast_ref::<i32>().unwrap() {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    false\n}\n",
            "pub fn encode(message: &str) -> String {\n    // vowels = \"aeiouAEIOU\"\n    let vowels = \"aeiouAEIOU\";\n    // result = []\n    let mut result = String::new();\n    // for ch in message:\n    for ch in message.chars() {\n        // if ch.isalpha():\n        if ch.is_alphabetic() {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            let ch1 = if ch.is_lowercase() { ch.to_uppercase().next().unwrap() } else { ch.to_lowercase().next().unwrap() };\n            // if ch1 in vowels:\n            if vowels.contains(ch1) {\n                // ch1 = chr(ord(ch1) + 2)\n                ch1 = std::char::from_u32(ch1 as u32 + 2).unwrap();\n            }\n            // result.append(ch1)\n            result.push(ch1);\n        } else {\n            // result.append(ch)\n            result.push(ch);\n        }\n    }\n    // return \"\".join(result)\n    result\n}\n",
            "pub fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\npub fn skjkasdkd(lst: &Vec<i32>) -> i32 {\n    let primes = lst.iter().filter(|&n| is_prime(*n)).collect::<Vec<&i32>>();\n    if primes.len() == 0 {\n        return 0;\n    }\n    let largest = primes.iter().max().unwrap();\n    largest.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum()\n}\n",
            "pub fn check_dict_case(d: &std::collections::HashMap<String, String>) -> bool {\n    // if not d:\n    if d.is_empty() {\n        // return False\n        return false;\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    d.keys().all(|c| c.chars().all(|c| c.is_lowercase())) || d.keys().all(|c| c.chars().all(|c| c.is_uppercase()))\n}\n",
            "pub fn count_up_to(n: i32) -> Vec<i32> {\n    // primes = []\n    let mut primes = Vec::new();\n    // for num in range(2, n):\n    for num in 2..n {\n        // if all(num % p != 0 for p in primes):\n        if primes.iter().all(|p| num % p != 0) {\n            // primes.append(num)\n            primes.push(num);\n        }\n    }\n    // return primes\n    primes\n}\n",
            "pub fn multiply(a: i32, b: i32) -> i32 {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    (a.abs() % 10) * (b.abs() % 10)\n}\n",
            "pub fn count_upper(s: &str) -> usize {\n    // vowels = \"AEIOU\"\n    let vowels = \"AEIOU\";\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    s.chars().enumerate().filter(|(i, c)| i % 2 == 0 && vowels.contains(*c)).count()\n}\n",
            "pub fn closest_integer(value: &str) -> i32 {\n    // num = float(value)\n    let num = value.parse::<f64>().unwrap();\n    // if num >= 0:\n    if num >= 0.0 {\n        // return int(num + 0.5)\n        return (num + 0.5).round() as i32;\n    } else {\n        // return int(num - 0.5)\n        return (num - 0.5).round() as i32;\n    }\n}\n",
            "pub fn make_a_pile(n: i32) -> Vec<i32> {\n    // return [n + 2 * i for i in range(n)]\n    (0..n).map(|i| n + 2 * i).collect()\n}\n",
            "pub fn words_string(s: &str) -> Vec<&str> {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    let re = Regex::new(r\"[, ]\").unwrap();\n    re.split(s).filter(|w| w.len() > 0).collect()\n}\n",
            "pub fn choose_num(x: i32, y: i32) -> i32 {\n    // if x > y:\n    if x > y {\n        // return -1\n        return -1;\n    }\n    // if y % 2 == 0:\n    if y % 2 == 0 {\n        // return y\n        return y;\n    }\n    // return y - 1 if x != y else -1\n    if x != y { y - 1 } else { -1 }\n}\n",
            "pub fn rounded_avg(n: i32, m: i32) -> Option<String> {\n    // if n > m:\n    if n > m {\n        // return None\n        return None;\n    }\n    // r_avg = int((m + n) / 2.0 + 0.5)\n    let r_avg = (m + n) / 2 + 1;\n    // return bin(r_avg)[2:]\n    Some(format!(\"{:b}\", r_avg))\n}\n",
            "pub fn all_digits_odd(s: &str) -> bool {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    s.chars().all(|digit| digit.to_string().parse::<i32>().unwrap() % 2 != 0)\n}\npub fn unique_digits(x: &Vec<i32>) -> Vec<i32> {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    x.iter().filter(|num| all_digits_odd(&num.to_string())).cloned().collect::<Vec<i32>>()\n}\n",
            "pub fn by_length(arr: &Vec<i32>) -> Vec<String> {\n    // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    let digit_names = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n    let sorted_arr = arr.iter().filter(|&x| 1 <= *x && *x <= 9).cloned().collect::<Vec<i32>>();\n    sorted_arr.sort_unstable_by(|a, b| b.cmp(a));\n    // return [digit_names[x-1] for x in sorted_arr]\n    sorted_arr.iter().map(|x| digit_names[(*x - 1) as usize].to_string()).collect()\n}\n",
            "pub fn f(n: i32) -> Vec<i32> {\n    // nums = list(range(1, n + 1))\n    let nums: Vec<i32> = (1..n + 1).collect();\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    nums.iter().map(|&i| {\n        if i % 2 != 0 {\n            nums[..i as usize].iter().sum()\n        } else {\n            nums[..i as usize].iter().product()\n        }\n    }).collect()\n}\n",
            "fn is_palindrome(txt: &str) -> bool {\n    txt == txt.chars().rev().collect::<String>()\n}\nfn even_odd_palindrome(n: i32) -> Vec<i32> {\n    let mut cnt = vec![0, 0];\n    for i in 1..=n {\n        if is_palindrome(&i.to_string()) {\n            cnt[(i % 2) as usize] += 1;\n        }\n    }\n    cnt\n}\n",
            "fn digits_sum(n: i32) -> i32 {\n    // n_str = str(n)\n    let n_str = n.to_string();\n    // if n >= 0:\n    if n >= 0 {\n        // return sum(int(d) for d in n_str)\n        return n_str.chars().map(|c| c.to_digit(10).unwrap()).sum();\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return (n_str.chars().next().unwrap().to_digit(10).unwrap() * 2) + digits_sum(n.abs())\n    }\n}\nfn count_nums(arr: &Vec<i32>) -> usize {\n    // return len([n for n in arr if digits_sum(n) > 0])\n    arr.iter().filter(|n| digits_sum(**n) > 0).count()\n}\n",
            "pub fn move_one_ball(arr: &Vec<i32>) -> bool {\n    // if len(arr) == 0:\n    if arr.len() == 0 {\n        // return True\n        return true;\n    }\n    // sorted_arr = sorted(arr)\n    let sorted_arr = arr.clone().into_iter().sorted().collect::<Vec<i32>>();\n    // for i in range(0, len(arr)):\n    for i in 0..arr.len() {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if arr[i..] == sorted_arr[..arr.len() - i] && arr[..i] == sorted_arr[arr.len() - i..] {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    false\n}\n",
            "pub fn can_exchange(lst1: &Vec<i32>, lst2: &Vec<i32>) -> String {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    let odd_cnt = lst1.iter().filter(|&num| num % 2 != 0).count();\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    let even_cnt = lst2.iter().filter(|&num| num % 2 == 0).count();\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    if even_cnt >= odd_cnt { \"YES\" } else { \"NO\" }\n}\n",
            "pub fn histogram(test: &str) -> HashMap<String, i32> {\n    // freq = {}\n    let mut freq = HashMap::new();\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    let words: Vec<&str> = test.split(\" \").filter(|w| w.len() > 0).collect();\n    // for w in words:\n    for w in words {\n        // freq[w] = freq.get(w, 0) + 1\n        *freq.entry(w.to_string()).or_insert(0) += 1;\n    }\n    // result = {}\n    let mut result = HashMap::new();\n    // if len(freq) > 0:\n    if !freq.is_empty() {\n        // max_freq = max(freq.values())\n        let max_freq = *freq.values().max().unwrap();\n        // for k, v in freq.items():\n        for (k, v) in freq.iter() {\n            // if v == max_freq:\n            if v == &max_freq {\n                // result[k] = v\n                result.insert(k.to_string(), *v);\n            }\n        }\n    }\n    // return result\n    result\n}\n",
            "pub fn is_palindrome(s: &str) -> bool {\n    // return s == s[::-1]\n    s == s.chars().rev().collect::<String>()\n}\npub fn reverse_delete(s: &str, c: &str) -> Vec<String> {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    let s1 = s.chars().filter(|ch| !c.contains(*ch)).collect::<String>();\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    vec![s1, if is_palindrome(&s1) { \"yes\" } else { \"no\" }]\n}\n",
            "pub fn odd_count(lst: &Vec<String>) -> Vec<String> {\n    // result = []\n    let mut result = Vec::new();\n    // for num in lst:\n    for num in lst {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        let n = num.chars().fold(0, |acc, c| acc + (c as u32) % 2);\n        // rs = \"the number of odd elements in the string i of the input.\"\n        let rs = format!(\"the number of odd elements in the string {} of the input.\", n);\n        // result.append(rs.replace(\"i\", str(n)))\n        result.push(rs.replace(\"i\", &n.to_string()));\n    }\n    // return result\n    result\n}\n",
            "pub fn min_sub_array_sum(nums: &Vec<i32>) -> i32 {\n    // min_sum = 0\n    let mut min_sum = 0;\n    // cur_sum = 0\n    let mut cur_sum = 0;\n    // for n in nums:\n    for n in nums {\n        // cur_sum = min(cur_sum + n, 0)\n        cur_sum = cur_sum.min(0);\n        cur_sum += n;\n        // min_sum = min(cur_sum, min_sum)\n        min_sum = min_sum.min(cur_sum);\n    }\n    // if min_sum == 0:\n    if min_sum == 0 {\n        // min_sum = min(nums)\n        min_sum = nums.iter().min().unwrap();\n    }\n    // return min_sum\n    min_sum\n}\n",
            "",
            "pub fn count_ones(num: i32) -> i32 {\n    // return bin(num).count(\"1\")\n    let mut count = 0;\n    let mut num = num;\n    while num > 0 {\n        if num & 1 == 1 {\n            count += 1;\n        }\n        num >>= 1;\n    }\n    count\n}\npub fn sort_array(arr: &Vec<i32>) -> Vec<i32> {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    let mut arr = arr.clone();\n    arr.sort_by_key(|x| (count_ones(*x), *x));\n    arr\n}\n",
            "pub fn select_words(s: &str, n: i32) -> Vec<&str> {\n    // consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\";\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    let words: Vec<&str> = s.split(\" \").filter(|w| w.len() > 0).collect();\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    words.into_iter().filter(|w| w.chars().filter(|c| consonants.contains(c)).count() == n as usize).collect()\n}\n",
            "pub fn get_closest_vowel(word: &str) -> String {\n    // vowels = \"aeiouAEIOU\"\n    let vowels = \"aeiouAEIOU\";\n    // for i in range(len(word) - 2, 0, -1):\n    for i in (1..word.len() - 1).rev() {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if vowels.contains(word.chars().nth(i).unwrap()) && !vowels.contains(word.chars().nth(i - 1).unwrap()) && !vowels.contains(word.chars().nth(i + 1).unwrap()) {\n            // return word[i]\n            return word.chars().nth(i).unwrap().to_string();\n        }\n    }\n    // return \"\"\n    \"\".to_string()\n}\n",
            "pub fn check(s: &str) -> bool {\n    // depth = 0\n    let mut depth = 0;\n    // for ch in s:\n    for ch in s.chars() {\n        // if ch == \"(\":\n        if ch == '(' {\n            // depth += 1\n            depth += 1;\n        } else {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if depth < 0 {\n            // return False\n            return false;\n        }\n    }\n    // return True if depth == 0 else False\n    depth == 0\n}\npub fn match_parens(lst: &Vec<String>) -> String {\n    // s1 = lst[0] + lst[1]\n    let s1 = format!(\"{}{}\", lst[0], lst[1]);\n    // s2 = lst[1] + lst[0]\n    let s2 = format!(\"{}{}\", lst[1], lst[0]);\n    // return \"Yes\" if check(s1) or check(s2) else \"No\"\n    if check(&s1) || check(&s2) {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n",
            "pub fn maximum(arr: &Vec<i32>, k: i32) -> Vec<i32> {\n    // if k == 0:\n    if k == 0 {\n        // return []\n        return vec![];\n    }\n    // return sorted(arr)[-k:]\n    let mut result = arr.clone();\n    result.sort();\n    result.truncate(k as usize);\n    result\n}\n",
            "pub fn solution(lst: &Vec<i32>) -> i32 {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    lst.iter().enumerate().filter(|(i, x)| i % 2 == 0 && x % 2 != 0).map(|(_, x)| x).sum()\n}\n",
            "pub fn add_elements(arr: &Vec<i32>, k: i32) -> i32 {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    arr.iter().take(k as usize).filter(|n| format!(\"{}\", n).len() <= 2).sum()\n}\n",
            "pub fn get_odd_collatz(n: i32) -> Vec<i32> {\n    // collatz = [1]\n    let mut collatz = vec![1];\n    // while n != 1:\n    while n != 1 {\n        // if n % 2 != 0:\n        if n % 2 != 0 {\n            // collatz.append(n)\n            collatz.push(n);\n            // n = 3 * n + 1\n            n = 3 * n + 1;\n        } else {\n            // n = n // 2\n            n = n / 2;\n        }\n    }\n    // return sorted(collatz)\n    collatz.sort();\n    collatz\n}\n",
            "pub fn valid_date(date: &str) -> bool {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if date.len() != 10 || date.as_bytes()[2] != b'-' || date.as_bytes()[5] != b'-' {\n        return false;\n    }\n    // m = int(date[:2])\n    let m = date[..2].parse::<i32>().unwrap();\n    // d = int(date[3:5])\n    let d = date[3..5].parse::<i32>().unwrap();\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && d >= 1 && d <= 31 {\n        return true;\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if (m == 4 || m == 6 || m == 9 || m == 11) && d >= 1 && d <= 30 {\n        return true;\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if m == 2 && d >= 1 && d <= 29 {\n        return true;\n    }\n    // return False\n    false\n}\n",
            "pub fn split_words(txt: &str) -> Vec<String> {\n    // if \" \" in txt:\n    if txt.contains(\" \") {\n        // return txt.split(\" \")\n        return txt.split(\" \").map(|s| s.to_string()).collect();\n    }\n    // elif \",\" in txt:\n    else if txt.contains(\",\") {\n        // return txt.split(\",\")\n        return txt.split(\",\").map(|s| s.to_string()).collect();\n    }\n    // else:\n    else {\n        // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        let mut count = 0;\n        for c in txt.chars() {\n            if c.is_lowercase() && c.to_string().parse::<i32>().unwrap() % 2 == 0 {\n                count += 1;\n            }\n        }\n        return vec![count.to_string()];\n    }\n}\n",
            "pub fn is_sorted(lst: &Vec<i32>) -> bool {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    if !lst.iter().zip(lst.iter().skip(1)).all(|(a, b)| a <= b) {\n        return false;\n    }\n    // freq = {}\n    let mut freq = std::collections::HashMap::new();\n    // for i in lst:\n    for i in lst {\n        // freq[i] = freq.get(i, 0) + 1\n        *freq.entry(*i).or_insert(0) += 1;\n    }\n    // return max(freq.values(), default=0) <= 2\n    return freq.values().max().unwrap_or(&0) <= &2;\n}\n",
            "pub fn is_prime(n: i32) -> bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..=((n as f64).sqrt() as i32) {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    true\n}\npub fn intersection(interval1: &Vec<i32>, interval2: &Vec<i32>) -> String {\n    // l = max(interval1[0], interval2[0])\n    let l = interval1[0].max(interval2[0]);\n    // r = min(interval1[1], interval2[1])\n    let r = interval1[1].min(interval2[1]);\n    // length = r - l\n    let length = r - l;\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    if length > 0 && is_prime(length) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n",
            "pub fn prod_signs(arr: &Vec<i32>) -> Option<i32> {\n    // if not arr:\n    if arr.is_empty() {\n        // return None\n        return None;\n    }\n    // if 0 in arr:\n    if arr.iter().any(|&n| n == 0) {\n        // return 0\n        return Some(0);\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    let sign = if arr.iter().filter(|&n| *n < 0).count() % 2 == 1 { -1 } else { 1 };\n    // return sign * sum([abs(n) for n in arr])\n    Some(sign * arr.iter().map(|&n| n.abs()).sum())\n}\n",
            "pub fn min_path(grid: &Vec<Vec<i32>>, k: i32) -> Vec<i32> {\n    // n = len(grid)\n    let n = grid.len();\n    // min_val = n * n + 1\n    let mut min_val = n * n + 1;\n    // for i in range(n):\n    for i in 0..n {\n        // for j in range(n):\n        for j in 0..n {\n            // if grid[i][j] == 1:\n            if grid[i][j] == 1 {\n                // temp = []\n                let mut temp = Vec::new();\n                // if i != 0:\n                if i != 0 {\n                    // temp.append(grid[i - 1][j])\n                    temp.push(grid[i - 1][j]);\n                }\n                // if j != 0:\n                if j != 0 {\n                    // temp.append(grid[i][j - 1])\n                    temp.push(grid[i][j - 1]);\n                }\n                // if i != n - 1:\n                if i != n - 1 {\n                    // temp.append(grid[i + 1][j])\n                    temp.push(grid[i + 1][j]);\n                }\n                // if j != n - 1:\n                if j != n - 1 {\n                    // temp.append(grid[i][j + 1])\n                    temp.push(grid[i][j + 1]);\n                }\n                // min_val = min(temp)\n                min_val = min_val.min(temp.iter().min().unwrap());\n            }\n        }\n    }\n    // result = []\n    let mut result = Vec::new();\n    // for i in range(k):\n    for i in 0..k {\n        // result.append(1 if i % 2 == 0 else min_val)\n        result.push(if i % 2 == 0 { 1 } else { min_val });\n    }\n    // return result\n    result\n}\n",
            "pub fn tri(n: i32) -> Vec<i32> {\n    // if n == 0:\n    if n == 0 {\n        // return [1]\n        return vec![1];\n    }\n    // seq = [1, 3]\n    let mut seq = vec![1, 3];\n    // for i in range(2, n + 1):\n    for i in 2..=n {\n        // if i % 2 == 0:\n        if i % 2 == 0 {\n            // seq.append(i / 2 + 1)\n            seq.push(i / 2 + 1);\n        } else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq.push(seq[i as usize - 1] + seq[i as usize - 2] + (i + 3) / 2);\n        }\n    }\n    // return seq\n    seq\n}\n",
            "pub fn digits(n: i32) -> i32 {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    let odds: Vec<i32> = n.to_string()\n        .chars()\n        .map(|d| d.to_digit(10).unwrap())\n        .filter(|d| d % 2 == 1)\n        .collect();\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    if odds.len() > 0 {\n        odds.iter().fold(1, |x, y| x * y)\n    } else {\n        0\n    }\n}\n",
            "pub fn is_nested(s: &str) -> bool {\n    // open_idx = []\n    let mut open_idx = Vec::new();\n    // close_idx = []\n    let mut close_idx = Vec::new();\n    // for i, ch in enumerate(s):\n    for (i, ch) in s.chars().enumerate() {\n        // if ch == '[':\n        if ch == '[' {\n            // open_idx.append(i)\n            open_idx.push(i);\n        }\n        // elif ch == ']':\n        else if ch == ']' {\n            // close_idx.append(i)\n            close_idx.push(i);\n        }\n    }\n    // close_idx.reverse()\n    close_idx.reverse();\n    // cnt = 0\n    let mut cnt = 0;\n    // i = 0\n    let mut i = 0;\n    // l = len(close_idx)\n    let l = close_idx.len();\n    // for idx in open_idx:\n    for idx in open_idx {\n        // if i < l and idx < close_idx[i]:\n        if i < l && idx < close_idx[i] {\n            // cnt += 1\n            cnt += 1;\n            // i += 1\n            i += 1;\n        }\n    }\n    // return cnt >= 2\n    cnt >= 2\n}\n",
            "pub fn sum_squares(lst: &Vec<f64>) -> i32 {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    lst.iter().map(|n| (n.ceil() as i32).pow(2)).sum()\n}\n",
            "pub fn check_if_last_char_is_a_letter(txt: &str) -> bool {\n    // if not txt:\n    if txt.is_empty() {\n        // return False\n        return false;\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    let last = &txt[txt.rfind(' ').unwrap() + 1..];\n    // return len(last) == 1 and last[0].isalpha()\n    last.len() == 1 && last.chars().next().unwrap().is_alphabetic()\n}\n",
            "pub fn can_arrange(arr: &Vec<i32>) -> i32 {\n    // if len (arr) <= 1:\n    if arr.len() <= 1 {\n        // return -1\n        return -1;\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    let idx: Vec<i32> = (1..arr.len()).filter(|&i| arr[i] < arr[i - 1]).collect();\n    // return max(idx, default=-1)\n    if idx.is_empty() {\n        return -1;\n    }\n    idx.iter().max().unwrap().clone()\n}\n",
            "pub fn largest_smallest_integers(lst: &Vec<i32>) -> Vec<Option<i32>> {\n    // neg = [i for i in lst if i < 0]\n    let neg: Vec<i32> = lst.iter().filter(|&i| i < 0).cloned().collect();\n    // pos = [i for i in lst if i > 0]\n    let pos: Vec<i32> = lst.iter().filter(|&i| i > 0).cloned().collect();\n    // max_neg = max(neg) if len(neg) > 0 else None\n    let max_neg = if neg.len() > 0 { Some(neg.iter().max().unwrap().clone()) } else { None };\n    // min_pos = min(pos) if len(pos) > 0 else None\n    let min_pos = if pos.len() > 0 { Some(pos.iter().min().unwrap().clone()) } else { None };\n    // return [max_neg, min_pos]\n    vec![max_neg, min_pos]\n}\n",
            "fn any_to_real(o: &Any) -> f64 {\n    if let Some(s) = o.downcast_ref::<String>() {\n        return s.replace(\",\", \".\").parse::<f64>().unwrap();\n    } else if let Some(i) = o.downcast_ref::<i32>() {\n        return *i as f64;\n    } else if let Some(f) = o.downcast_ref::<f64>() {\n        return *f;\n    }\n    panic!(\"Type Error\");\n}\nfn compare_one(a: &Any, b: &Any) -> Option<f64> {\n    let a1 = any_to_real(a);\n    let b1 = any_to_real(b);\n    if a1 == b1 {\n        None\n    } else if a1 > b1 {\n        Some(a1)\n    } else {\n        Some(b1)\n    }\n}\n",
            "pub fn is_equal_to_sum_even(n: i32) -> bool {\n    // return n % 2 == 0 and n >= 8\n    n % 2 == 0 && n >= 8\n}\n",
            "pub fn special_factorial(n: i32) -> i32 {\n    // fact = 1\n    let mut fact = 1;\n    // result = 1\n    let mut result = 1;\n    // for i in range(1, n + 1):\n    for i in 1..=n {\n        // fact *= i\n        fact *= i;\n        // result *= fact\n        result *= fact;\n    }\n    // return result\n    result\n}\n",
            "pub fn fix_spaces(txt: &str) -> String {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    let re = Regex::new(r\"\\s{3,}\").unwrap();\n    re.replace_all(txt, \"-\").replace(\" \", \"_\")\n}\n",
            "pub fn file_name_check(file_name: &str) -> &str {\n    // suf = [\"txt\", \"exe\", \"dll\"]\n    let suf = vec![\"txt\", \"exe\", \"dll\"];\n    // lst = file_name.split(\".\")\n    let lst = file_name.split(\".\").collect::<Vec<&str>>();\n    // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n    if lst.len() != 2 || !suf.contains(&lst[1]) || lst[0].len() == 0 || !lst[0].chars().next().unwrap().is_alphabetic() || lst[0].chars().filter(|x| x.is_digit(10)).count() > 3 {\n        // return \"No\"\n        return \"No\";\n    }\n    // return \"Yes\"\n    \"Yes\"\n}\n",
            "pub fn sum_squares(lst: &Vec<i32>) -> i32 {\n    // result = 0\n    let mut result = 0;\n    // for i in range(len(lst)):\n    for i in 0..lst.len() {\n        // if i % 3 == 0:\n        if i % 3 == 0 {\n            // result += pow(lst[i], 2)\n            result += (lst[i] * lst[i]) as i32;\n        }\n        // elif i % 4 == 0:\n        else if i % 4 == 0 {\n            // result += pow(lst[i], 3)\n            result += (lst[i] * lst[i] * lst[i]) as i32;\n        }\n        // else:\n        else {\n            // result += lst[i]\n            result += lst[i];\n        }\n    }\n    // return result\n    result\n}\n",
            "pub fn is_prime(n: i32) -> bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..=((n as f64).sqrt() as i32 + 1) {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    true\n}\npub fn words_in_sentence(sentence: &str) -> String {\n    // words = sentence.split(\" \")\n    let words: Vec<&str> = sentence.split(\" \").collect();\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    words.iter().filter(|w| is_prime(w.len() as i32)).collect::<Vec<&str>>().join(\" \")\n}\n",
            "pub fn simplify(x: &str, n: &str) -> bool {\n    // xs = x.split(\"/\")\n    let xs: Vec<&str> = x.split(\"/\").collect();\n    // ns = n.split(\"/\")\n    let ns: Vec<&str> = n.split(\"/\").collect();\n    // num = int(xs[0]) * int(ns[0])\n    let num = xs[0].parse::<i32>().unwrap() * ns[0].parse::<i32>().unwrap();\n    // den = int(xs[1]) * int(ns[1])\n    let den = xs[1].parse::<i32>().unwrap() * ns[1].parse::<i32>().unwrap();\n    // return num % den == 0\n    num % den == 0\n}\n",
            "fn digits_sum(n: i32) -> i32 {\n    // n_str = str(n)\n    let n_str = n.to_string();\n    // if n >= 0:\n    if n >= 0 {\n        // return sum(int(d) for d in n_str)\n        return n_str.chars().map(|c| c.to_digit(10).unwrap()).sum();\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return (n_str[..2].parse::<i32>().unwrap() * 2) + digits_sum(n.abs());\n    }\n}\nfn order_by_points(nums: &Vec<i32>) -> Vec<i32> {\n    // return sorted(nums, key=digits_sum)\n    nums.iter().map(|n| *n).sorted_by(|a, b| digits_sum(*a).cmp(&digits_sum(*b))).collect()\n}\n",
            "pub fn special_filter(nums: &Vec<i32>) -> i32 {\n    // odds = \"13579\"\n    let odds = \"13579\";\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    nums.iter().filter(|&n| n > 10 && n % 2 == 1 && odds.contains(&n.to_string()[0..1])).count() as i32\n}\n",
            "pub fn get_max_triples(n: i32) -> i32 {\n    // c = [0, 0, 0]\n    let mut c = [0, 0, 0];\n    // for i in range(1, n + 1):\n    for i in 1..=n {\n        // a = i * i - i + 1\n        let a = i * i - i + 1;\n        // c[a % 3] += 1\n        c[(a % 3) as usize] += 1;\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n}\n",
            "pub fn bf(planet1: &str, planet2: &str) -> Vec<&str> {\n    // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    let names = vec![\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    // if planet1 not in names or planet2 not in names:\n    if !names.contains(&planet1) || !names.contains(&planet2) {\n        // return []\n        return vec![];\n    }\n    // l = names.index(planet1)\n    let l = names.iter().position(|&x| x == planet1).unwrap();\n    // r = names.index(planet2)\n    let r = names.iter().position(|&x| x == planet2).unwrap();\n    // if l > r:\n    if l > r {\n        // l, r = r, l\n        std::mem::swap(&mut l, &mut r);\n    }\n    // if l == r:\n    if l == r {\n        // return []\n        return vec![];\n    }\n    // return names[l + 1 : r]\n    names[l + 1..r].to_vec()\n}\n",
            "pub fn sorted_list_sum(lst: &Vec<String>) -> Vec<String> {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    let result: Vec<String> = lst.iter().filter(|s| s.len() % 2 == 0).cloned().collect();\n    // return sorted(result, key=lambda x: (len(x), x))\n    result.iter().sorted_by_key(|s| (s.len(), s.clone())).cloned().collect()\n}\n",
            "pub fn x_or_y(n: i32, x: i32, y: i32) -> i32 {\n    // if n < 2:\n    if n < 2 {\n        // return y\n        return y;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2..(n as f64).sqrt().floor() as i32 + 1 {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return y\n            return y;\n        }\n    }\n    // return x\n    x\n}\n",
            "pub fn double_the_difference(lst: &Vec<f64>) -> i32 {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    lst.iter().filter(|n| **n >= 0.0 && (*n as i32) % 2 == 1).map(|n| n * n).sum()\n}\n",
            "pub fn compare(game: &Vec<i32>, guess: &Vec<i32>) -> Vec<i32> {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    game.iter().zip(guess.iter()).map(|(x, y)| (x - y).abs()).collect()\n}\n",
            "pub fn strongest_extension(class_name: &str, extensions: &Vec<String>) -> String {\n    // max_s = float(\"-inf\")\n    let mut max_s = f64::NEG_INFINITY;\n    // max_ext = \"\"\n    let mut max_ext = String::new();\n    // for ext in extensions:\n    for ext in extensions {\n        // upper = len([c for c in ext if c.isupper()])\n        let upper = ext.chars().filter(|c| c.is_uppercase()).count();\n        // lower = len([c for c in ext if c.islower()])\n        let lower = ext.chars().filter(|c| c.is_lowercase()).count();\n        // s = upper - lower\n        let s = upper as f64 - lower as f64;\n        // if s > max_s:\n        if s > max_s {\n            // max_s = s\n            max_s = s;\n            // max_ext = ext\n            max_ext = ext.clone();\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    format!(\"{}.{}\", class_name, max_ext)\n}\n",
            "pub fn cycpattern_check(a: &str, b: &str) -> bool {\n    // if len(a) < len(b):\n    if a.len() < b.len() {\n        // return False\n        return false;\n    }\n    // for i in range(len(b)):\n    for i in 0..b.len() {\n        // if b[i:] + b[:i] in a:\n        if a.contains(&b[i..]) && a.contains(&b[..i]) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    false\n}\n",
            "pub fn even_odd_count(num: i32) -> Vec<i32> {\n    // ds = str(abs(num))\n    let ds = num.abs().to_string();\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    let even = ds.chars().filter(|d| d.to_string().parse::<i32>().unwrap() % 2 == 0).count() as i32;\n    // return [even, len(ds) - even]\n    vec![even, ds.len() as i32 - even]\n}\n",
            "pub fn int_to_mini_roman(num: i32) -> String {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let values = vec![1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numerals = vec![\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    // res = []\n    let mut res = Vec::new();\n    // for i in range(len(values)):\n    for i in 0..values.len() {\n        // while num >= values[i]:\n        while num >= values[i] {\n            // res.append(numerals[i])\n            res.push(numerals[i].to_string());\n            // num -= values[i]\n            num -= values[i];\n        }\n    }\n    // return \"\".join(res)\n    res.join(\"\")\n}\n",
            "pub fn right_angle_triangle(a: i32, b: i32, c: i32) -> bool {\n    // s = sorted([a, b, c])\n    let s = [a, b, c].iter().sorted().collect::<Vec<&i32>>();\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n}\n",
            "pub fn find_max(words: &Vec<String>) -> String {\n    // max_cnt = 0\n    let mut max_cnt = 0;\n    // max_w = \"\"\n    let mut max_w = String::new();\n    // for w in words:\n    for w in words {\n        // cnt = len(set(w))\n        let cnt = w.chars().collect::<std::collections::HashSet<char>>().len();\n        // if cnt > max_cnt:\n        if cnt > max_cnt {\n            // max_cnt = cnt\n            max_cnt = cnt;\n            // max_w = w\n            max_w = w.clone();\n        }\n        // elif cnt == max_cnt:\n        else if cnt == max_cnt {\n            // max_w = min(max_w, w)\n            max_w = std::cmp::min(max_w, w);\n        }\n    }\n    // return max_w\n    max_w\n}\n",
            "pub fn eat(num: i32, need: i32, remaining: i32) -> Vec<i32> {\n    // if need <= remaining:\n    if need <= remaining {\n        // return [num + need, remaining - need]\n        vec![num + need, remaining - need]\n    } else {\n        // return [num + remaining, 0]\n        vec![num + remaining, 0]\n    }\n}\n",
            "pub fn do_algebra(operators: &Vec<String>, operands: &Vec<i32>) -> i32 {\n    // ops = operators.copy()\n    let mut ops = operators.clone();\n    // nums = operands.copy()\n    let mut nums = operands.clone();\n    // i = len(ops) - 1\n    let mut i = ops.len() - 1;\n    // while i >= 0:\n    while i >= 0 {\n        // if ops[i] == \"**\":\n        if ops[i] == \"**\" {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            nums[i] = nums[i].pow(nums[i + 1]);\n            // nums.pop(i + 1)\n            nums.remove(i + 1);\n            // ops.pop(i)\n            ops.remove(i);\n        }\n        // i -= 1\n        i -= 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while i < ops.len() {\n        // if ops[i] == \"*\":\n        if ops[i] == \"*\" {\n            // nums[i] = nums[i] * nums[i + 1]\n            nums[i] = nums[i] * nums[i + 1];\n            // nums.pop(i + 1)\n            nums.remove(i + 1);\n            // ops.pop(i)\n            ops.remove(i);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"//\":\n        else if ops[i] == \"//\" {\n            // nums[i] = nums[i] // nums[i + 1]\n            nums[i] = nums[i] / nums[i + 1];\n            // nums.pop(i + 1)\n            nums.remove(i + 1);\n            // ops.pop(i)\n            ops.remove(i);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while i < ops.len() {\n        // if ops[i] == \"+\":\n        if ops[i] == \"+\" {\n            // nums[i] = nums[i] + nums[i + 1]\n            nums[i] = nums[i] + nums[i + 1];\n            // nums.pop(i + 1)\n            nums.remove(i + 1);\n            // ops.pop(i)\n            ops.remove(i);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"-\":\n        else if ops[i] == \"-\" {\n            // nums[i] = nums[i] - nums[i + 1]\n            nums[i] = nums[i] - nums[i + 1];\n            // nums.pop(i + 1)\n            nums.remove(i + 1);\n            // ops.pop(i)\n            ops.remove(i);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // return nums[0]\n    nums[0]\n}\n",
            "pub fn solve(s: &str) -> String {\n    // if not any(ch.isalpha() for ch in s):\n    if !s.chars().any(|ch| ch.is_alphabetic()) {\n        // return s[::-1]\n        return s.chars().rev().collect();\n    }\n    // result = []\n    let mut result = Vec::new();\n    // for ch in s:\n    for ch in s.chars() {\n        // if not ch.isalpha():\n        if !ch.is_alphabetic() {\n            // result.append(ch)\n            result.push(ch);\n        }\n        // elif ch.isupper():\n        else if ch.is_uppercase() {\n            // result.append(ch.lower())\n            result.push(ch.to_lowercase().next().unwrap());\n        }\n        // elif ch.islower():\n        else if ch.is_lowercase() {\n            // result.append(ch.upper())\n            result.push(ch.to_uppercase().next().unwrap());\n        }\n    }\n    // return \"\".join(result)\n    result.into_iter().collect()\n}\n",
            "pub fn string_to_md5(txt: &str) -> Option<String> {\n    // if not txt:\n    if txt.is_empty() {\n        // return None\n        return None;\n    }\n    // md5_hash = hashlib.md5()\n    let mut md5_hash = Md5::new();\n    // txt_bytes = txt.encode()\n    let txt_bytes = txt.as_bytes();\n    // md5_hash.update(txt_bytes)\n    md5_hash.update(txt_bytes);\n    // md5_encoded = md5_hash.hexdigest()\n    let md5_encoded = md5_hash.finalize();\n    // return md5_encoded\n    Some(md5_encoded.to_string())\n}\n",
            "pub fn generate_integers(a: i32, b: i32) -> Vec<i32> {\n    // lower = max(2, min(a, b))\n    let lower = std::cmp::max(2, std::cmp::min(a, b));\n    // upper = min(8, max(a, b))\n    let upper = std::cmp::min(8, std::cmp::max(a, b));\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    (lower..upper + 1).filter(|i| i % 2 == 0).collect()\n}\n"
        ],
        "scala": [
            "def hasCloseElements(numbers: Seq[Float], threshold: Float): Boolean = {\n    // for i in range(len(numbers)):\n    for (i <- 0 until numbers.length) {\n        // for j in range(i + 1, len(numbers)):\n        for (j <- i + 1 until numbers.length) {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if (math.abs(numbers(i) - numbers(j)) < threshold) {\n                // return True\n                return true\n            }\n        }\n    }\n    // return False\n    false\n}\n",
            "def separateParenGroups(parenString: String): Seq[String] = {\n    // groups = []\n    val groups = mutable.ListBuffer[String]()\n    // stk = []\n    val stk = mutable.ListBuffer[String]()\n    // current_group = \"\"\n    var currentGroup = \"\"\n    // parens = paren_string.replace(\" \", \"\")\n    val parens = parenString.replace(\" \", \"\")\n    // for ch in parens:\n    for (ch <- parens) {\n        // if ch == \"(\":\n        if (ch == \"(\") {\n            // stk.append(ch)\n            stk.addOne(ch)\n            // current_group += ch\n            currentGroup += ch\n        }\n        // elif ch == \")\":\n        else if (ch == \")\") {\n            // stk.pop()\n            stk.remove(stk.size - 1)\n            // current_group += ch\n            currentGroup += ch\n            // if not stk:\n            if (stk.isEmpty) {\n                // groups.append(current_group)\n                groups.addOne(currentGroup)\n                // current_group = \"\"\n                currentGroup = \"\"\n            }\n        }\n    }\n    // return groups\n    groups.toList\n}\n",
            "def truncateNumber(num: Double): Double = {\n    // return num - floor(num)\n    num - math.floor(num)\n}\n",
            "def belowZero(operations: Seq[Int]): Boolean = {\n    // balance = 0\n    var balance = 0\n    // for op in operations:\n    for (op <- operations) {\n        // balance += op\n        balance += op\n        // if balance < 0:\n        if (balance < 0) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    false\n}\n",
            "def meanAbsoluteDeviation(numbers: Seq[Float]): Float = {\n    // mean = sum(numbers) / len(numbers)\n    val mean = numbers.sum / numbers.size\n    // deviation = sum(abs(x - mean) for x in numbers)\n    val deviation = numbers.map(x => math.abs(x - mean)).sum\n    // return deviation / len(numbers)\n    deviation / numbers.size\n}\n",
            "def intersperse(numbers: Seq[Int], delimiter: Int): Seq[Int] = {\n    // result = []\n    val result = mutable.ListBuffer[Int]()\n    // for i in range(len(numbers)):\n    for (i <- 0 until numbers.size) {\n        // if i != 0:\n        if (i != 0) {\n            // result.append(delimiter)\n            result.addOne(delimiter)\n        }\n        // result.append(numbers[i])\n        result.addOne(numbers(i))\n    }\n    // return result\n    result.toList\n}\n",
            "def parseNestedParens(parenString: String): Seq[Int] = {\n    // result = []\n    val result = mutable.ListBuffer[Int]()\n    // paren_groups = paren_string.split()\n    val parenGroups = parenString.split(\" \")\n    // for group in paren_groups:\n    for (group <- parenGroups) {\n        // max_depth = 0\n        var maxDepth = 0\n        // depth = 0\n        var depth = 0\n        // for ch in group:\n        for (ch <- group) {\n            // if ch == \"(\":\n            if (ch == \"(\") {\n                // depth += 1\n                depth += 1\n                // max_depth = max(max_depth, depth)\n                maxDepth = math.max(maxDepth, depth)\n            }\n            // elif ch == \")\":\n            else if (ch == \")\") {\n                // depth -= 1\n                depth -= 1\n            }\n        }\n        // result.append(max_depth)\n        result.addOne(maxDepth)\n    }\n    // return result\n    result.toList\n}\n",
            "def filterBySubstring(strs: Seq[String], substring: String): Seq[String] = {\n    // return [s for s in strs if substring in s]\n    strs.filter(s => s.contains(substring))\n}\n",
            "def sumProduct(numbers: Seq[Int]): Seq[Int] = {\n    // n_sum = sum(numbers)\n    val nSum = numbers.sum\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    val nProduct = numbers.foldLeft(1)(_ * _)\n    // return [n_sum, n_product]\n    Seq(nSum, nProduct)\n}\n",
            "def rollingMax(numbers: Seq[Int]): Seq[Int] = {\n    // max_so_far = float(\"-inf\")\n    var maxSoFar = Double.NegativeInfinity\n    // result = []\n    val result = mutable.ListBuffer[Int]()\n    // for num in numbers:\n    for (num <- numbers) {\n        // max_so_far = max(max_so_far, num)\n        maxSoFar = maxSoFar.max(num)\n        // result.append(max_so_far)\n        result.addOne(maxSoFar.toInt)\n    }\n    // return result\n    result.toList\n}\n",
            "def isPalindrome(s: String): Boolean = {\n    // return s == s[::-1]\n    s == s.reverse\n}\ndef makePalindrome(s: String): String = {\n    // if is_palindrome(s):\n    if (isPalindrome(s)) {\n        // return s\n        return s\n    }\n    // for i in range(len(s)):\n    for (i <- 0 until s.length) {\n        // if is_palindrome(s[i:]):\n        if (isPalindrome(s.substring(i))) {\n            // return s + s[:i][::-1]\n            return s + s.substring(0, i).reverse\n        }\n    }\n    // return \"\"\n    return \"\"\n}\n",
            "def stringXor(a: String, b: String): String = {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    a.zip(b).map { case (x, y) => if (x == y) \"0\" else \"1\" }.mkString\n}\n",
            "def longest(strs: Seq[String]): Option[String] = {\n    // if not strs:\n    if (strs.isEmpty) {\n        // return None\n        return None\n    }\n    // longest_s = strs[0]\n    var longest_s = strs.head\n    // for s in strs:\n    for (s <- strs) {\n        // if len(s) > len(longest_s):\n        if (s.length > longest_s.length) {\n            // longest_s = s\n            longest_s = s\n        }\n    }\n    // return longest_s\n    Some(longest_s)\n}\n",
            "def greatestCommonDivisor(a: Int, b: Int): Int = {\n    // if b == 0:\n    if (b == 0) {\n        // return a\n        a\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        greatestCommonDivisor(b, a % b)\n    }\n}\n",
            "def allPrefixes(s: String): Seq[String] = {\n    // prefixes = []\n    val prefixes = mutable.ListBuffer[String]()\n    // for i in range(len(s)):\n    for (i <- 0 until s.length) {\n        // prefixes.append(s[: i + 1])\n        prefixes.addOne(s.substring(0, i + 1))\n    }\n    // return prefixes\n    prefixes.toList\n}\n",
            "def stringSequence(n: Int): String = {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    (0 to n).map(_.toString).mkString(\" \")\n}\n",
            "def countDistinctCharacters(s: String): Int = {\n    // return len(set(s.lower()))\n    s.toLowerCase.toSet.size\n}\n",
            "def parseMusic(musicString: String): Seq[Int] = {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    val durations = Map(\"o\" -> 4, \"o|\" -> 2, \".|\" -> 1)\n    // notes = music_string.split()\n    val notes = musicString.split(\" \")\n    // return [durations[note] for note in notes]\n    notes.map(durations)\n}\n",
            "def howManyTimes(s: String, substring: String): Int = {\n    // times = 0\n    var times = 0\n    // for i in range(len(s) - len(substring) + 1):\n    for (i <- 0 until s.length - substring.length + 1) {\n        // if s[i : i + len(substring)] == substring:\n        if (s.substring(i, i + substring.length) == substring) {\n            // times += 1\n            times += 1\n        }\n    }\n    // return times\n    times\n}\n",
            "def sortNumbers(numbers: String): String = {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    val numDict = Map(\n        \"zero\" -> 0,\n        \"one\" -> 1,\n        \"two\" -> 2,\n        \"three\" -> 3,\n        \"four\" -> 4,\n        \"five\" -> 5,\n        \"six\" -> 6,\n        \"seven\" -> 7,\n        \"eight\" -> 8,\n        \"nine\" -> 9\n    )\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    val numList = numbers.split(\" \").filter(numDict.contains)\n    // num_list.sort(key=lambda x: num_dict[x])\n    numList.sortWith(numDict(_) < numDict(_))\n    // return \" \".join(num_list)\n    numList.mkString(\" \")\n}\n",
            "def findClosestElements(numbers: Seq[Float]): Seq[Float] = {\n    // sorted_numbers = sorted(numbers)\n    val sortedNumbers = numbers.sorted\n    // min_diff = float(\"inf\")\n    var minDiff = Float.PositiveInfinity\n    // closest_pair = []\n    var closestPair = Seq.empty[Float]\n    // for i in range(1, len(sorted_numbers)):\n    for (i <- 1 until sortedNumbers.length) {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        val diff = sortedNumbers(i) - sortedNumbers(i - 1)\n        // if diff < min_diff:\n        if (diff < minDiff) {\n            // min_diff = diff\n            minDiff = diff\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closestPair = Seq(sortedNumbers(i - 1), sortedNumbers(i))\n        }\n    }\n    // return closest_pair\n    closestPair\n}\n",
            "def rescaleToUnit(numbers: Seq[Float]): Seq[Float] = {\n    // min_num = min(numbers)\n    val minNum = numbers.min\n    // max_num = max(numbers)\n    val maxNum = numbers.max\n    // if min_num == max_num:\n    if (minNum == maxNum) {\n        // return [0.0] * len(numbers)\n        return Seq.fill(numbers.size)(0.0)\n    } else {\n        // return [(num - min_num) / (max_num - min_num) for num in numbers]\n        return numbers.map(num => (num - minNum) / (maxNum - minNum))\n    }\n}\n",
            "def filterIntegers(values: Seq[Any]): Seq[Int] = {\n    // return [x for x in values if isinstance(x, int)]\n    values.collect { case x: Int => x }\n}\n",
            "def strLength(s: String): Int = {\n    // return len(s)\n    s.length\n}\n",
            "def largestDivisor(n: Int): Int = {\n    // for i in range(2, n):\n    for (i <- 2 to n) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return n // i\n            return n / i\n        }\n    }\n    // return 1\n    1\n}\n",
            "def factorize(n: Int): Seq[Int] = {\n    // factors = []\n    var factors = mutable.ListBuffer[Int]()\n    // divisor = 2\n    var divisor = 2\n    // while divisor <= n:\n    while (divisor <= n) {\n        // if n % divisor == 0:\n        if (n % divisor == 0) {\n            // factors.append(divisor)\n            factors.addOne(divisor)\n            // n //= divisor\n            n /= divisor\n        } else {\n            // divisor += 1\n            divisor += 1\n        }\n    }\n    // return factors\n    factors.toList\n}\n",
            "def removeDuplicates(numbers: Seq[Int]): Seq[Int] = {\n    // counts = {}\n    val counts = mutable.Map.empty[Int, Int]\n    // for num in numbers:\n    for (num <- numbers) {\n        // counts[num] = counts.get(num, 0) + 1\n        counts(num) = counts.getOrElse(num, 0) + 1\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    val res = numbers.filter(num => counts(num) == 1)\n    // return res\n    res\n}\n",
            "def flipCase(s: String): String = {\n    // flipped = []\n    val flipped = mutable.ListBuffer[Char]()\n    // for ch in s:\n    for (ch <- s) {\n        // if not ch.isalpha():\n        if (!ch.isLetter) {\n            // flipped.append(ch)\n            flipped.addOne(ch)\n        }\n        // elif ch.islower():\n        else if (ch.isLower) {\n            // flipped.append(ch.upper())\n            flipped.addOne(ch.toUpper)\n        }\n        // elif ch.isupper():\n        else if (ch.isUpper) {\n            // flipped.append(ch.lower())\n            flipped.addOne(ch.toLower)\n        }\n    }\n    // return ''.join(flipped)\n    flipped.mkString\n}\n",
            "def concatenate(strs: Seq[String]): String = {\n    // return \"\".join(strs)\n    strs.mkString\n}\n",
            "def filterByPrefix(strs: Seq[String], prefixStr: String): Seq[String] = {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    strs.filter(_.startsWith(prefixStr))\n}\n",
            "def getPositive(l: Seq[Int]): Seq[Int] = {\n    // return [num for num in l if num > 0]\n    l.filter(_ > 0)\n}\n",
            "def isPrime(n: Int): Boolean = {\n    // if n < 2:\n    if (n < 2) return false\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i <- 2 to floor(sqrt(n)).toInt + 1) {\n        // if n % i == 0:\n        if (n % i == 0) return false\n    }\n    // return True\n    true\n}\n",
            "def poly(xs: Seq[Int], x: Double): Double = {\n    // res = 0.0\n    var res = 0.0\n    // for i in range(len(xs)):\n    for (i <- 0 until xs.size) {\n        // res += xs[i] * x**i\n        res += xs(i) * math.pow(x, i)\n    }\n    // return res\n    res\n}\ndef findZero(xs: Seq[Int]): Double = {\n    // x1, x2 = 1.0, -1.0\n    var x1 = 1.0\n    var x2 = -1.0\n    // while poly(xs, x1) * poly(xs, x2) > 0:\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        // x1 *= 2\n        x1 *= 2\n        // x2 *= 2\n        x2 *= 2\n    }\n    // while abs(x1 - x2) > 1e-10:\n    while (math.abs(x1 - x2) > 1e-10) {\n        // mid = (x1 + x2) / 2\n        val mid = (x1 + x2) / 2\n        // if poly(xs, mid) == 0:\n        if (poly(xs, mid) == 0) {\n            // return mid\n            return mid\n        }\n        // elif poly(xs, mid) * poly(xs, x1) < 0:\n        else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            // x2 = mid\n            x2 = mid\n        }\n        // else:\n        else {\n            // x1 = mid\n            x1 = mid\n        }\n    }\n    // return (x1 + x2) / 2\n    (x1 + x2) / 2\n}\n",
            "def sortThird(l: Seq[Int]): Seq[Int] = {\n    // sorted_third = sorted(l[::3])\n    val sortedThird = l.grouped(3).map(_.sorted).flatten\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    l.zipWithIndex.map {\n        case (e, i) => if (i % 3 == 0) sortedThird(i / 3) else e\n    }\n}\n",
            "def listUnique(l: Seq[Int]): Seq[Int] = {\n    // return sorted(list(set(l)))\n    l.toSet.toList.sorted\n}\n",
            "def maxElement(l: Seq[Int]): Int = {\n    // if not l:\n    if (l.isEmpty) {\n        // return 0\n        0\n    } else {\n        // return max(l)\n        l.max\n    }\n}\n",
            "def fizzBuzz(n: Int): Int = {\n    // cnt = 0\n    var cnt = 0\n    // for i in range(n):\n    for (i <- 0 until n) {\n        // if i % 11 == 0 or i % 13 == 0:\n        if (i % 11 == 0 || i % 13 == 0) {\n            // cnt += str(i).count(\"7\")\n            cnt += i.toString.count(_ == '7')\n        }\n    }\n    // return cnt\n    cnt\n}\n",
            "def sortEven(l: Seq[Int]): Seq[Int] = {\n    // sorted_even = sorted(l[::2])\n    val sortedEven = l.filter(_ % 2 == 0).sorted\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    l.zipWithIndex.map {\n        case (e, i) => if (i % 2 == 0) sortedEven(i / 2) else e\n    }\n}\n",
            "def encodeCyclic(s: String): String = {\n    // result = []\n    val result = mutable.ListBuffer[String]()\n    // for i in range(0, len(s), 3):\n    for (i <- 0 until s.length by 3) {\n        // if i + 3 > len(s):\n        if (i + 3 > s.length) {\n            // result.append(s[i:])\n            result.addOne(s.substring(i))\n        } else {\n            // result.append(s[i+1:i+3])\n            result.addOne(s.substring(i + 1, i + 3))\n            // result.append(s[i])\n            result.addOne(s.substring(i, i + 1))\n        }\n    }\n    // return \"\".join(result)\n    result.mkString\n}\ndef decodeCyclic(s: String): String = {\n    // return encode_cyclic(encode_cyclic(s))\n    encodeCyclic(encodeCyclic(s))\n}\n",
            "def isPrime(n: Int): Boolean = {\n    // if n < 2:\n    if (n < 2) return false\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i <- 2 to floor(sqrt(n)).toInt + 1) {\n        // if n % i == 0:\n        if (n % i == 0) return false\n    }\n    // return True\n    true\n}\ndef primeFib(n: Int): Int = {\n    // f = [0, 1]\n    var f = Array(0, 1)\n    // cnt = 0\n    var cnt = 0\n    // while cnt < n:\n    while (cnt < n) {\n        // f = [f[1], f[0] + f[1]]\n        f = Array(f(1), f(0) + f(1))\n        // if is_prime(f[1]):\n        if (isPrime(f(1))) {\n            // cnt += 1\n            cnt += 1\n        }\n    }\n    // return f[1]\n    f(1)\n}\n",
            "def triplesSumToZero(l: Seq[Int]): Boolean = {\n    // for i in range(len(l)):\n    for (i <- 0 until l.length) {\n        // for j in range(i + 1, len(l)):\n        for (j <- i + 1 until l.length) {\n            // for k in range(j + 1, len(l)):\n            for (k <- j + 1 until l.length) {\n                // if l[i] + l[j] + l[k] == 0:\n                if (l(i) + l(j) + l(k) == 0) {\n                    // return True\n                    return true\n                }\n            }\n        }\n    }\n    // return False\n    false\n}\n",
            "def carRaceCollision(n: Int): Int = {\n    // return n ** 2\n    n * n\n}\n",
            "def incrList(l: Seq[Int]): Seq[Int] = {\n    // return [i + 1 for i in l]\n    l.map(_ + 1)\n}\n",
            "def pairsSumToZero(l: Seq[Int]): Boolean = {\n    // seen = set()\n    val seen = mutable.Set.empty[Int]\n    // for num in l:\n    for (num <- l) {\n        // if -num in seen:\n        if (seen.contains(-num)) {\n            // return True\n            return true\n        }\n        // seen.add(num)\n        seen.add(num)\n    }\n    // return False\n    false\n}\n",
            "def changeBase(x: Int, bas: Int): String = {\n    // if x == 0:\n    if (x == 0) {\n        // return \"0\"\n        return \"0\"\n    }\n    // digits = []\n    val digits = mutable.ListBuffer[String]()\n    // while x > 0:\n    while (x > 0) {\n        // digits.append(str(x % bas))\n        digits.addOne(x % bas + \"\")\n        // x //= bas\n        x /= bas\n    }\n    // return \"\".join(digits[::-1])\n    digits.reverse.mkString\n}\n",
            "def triangleArea(a: Int, h: Int): Double = {\n    // return a * h / 2\n    a * h / 2\n}\n",
            "def fib4(n: Int): Int = {\n    // fib = [0, 0, 2, 0]\n    val fib = Array(0, 0, 2, 0)\n    // for i in range(4, n + 1):\n    for (i <- 4 to n) {\n        // fib[i % 4] = sum(fib)\n        fib(i % 4) = fib.sum\n    }\n    // return fib[n % 4]\n    fib(n % 4)\n}\n",
            "def median(l: Seq[Float]): Float = {\n    // sl = sorted(l)\n    val sl = l.sorted\n    // if len(l) % 2 != 0:\n    if (l.size % 2 != 0) {\n        // return sl[len(l) // 2]\n        return sl(l.size / 2)\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (sl(l.size / 2) + sl(l.size / 2 - 1)) / 2\n    }\n}\n",
            "def isPalindrome(txt: String): Boolean = {\n    // return txt == txt[::-1]\n    txt == txt.reverse\n}\n",
            "def modp(n: Int, p: Int): Int = {\n    // ret = 1\n    var ret = 1\n    // for _ in range(n):\n    for (_ <- 0 until n) {\n        // ret = (ret * 2) % p\n        ret = (ret * 2) % p\n    }\n    // return ret\n    ret\n}\n",
            "def encodeShift(s: String): String = {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    val result = s.map(ch => (((ch.toInt - 97 + 5) % 26) + 97).toChar)\n    // return \"\".join(result)\n    result.mkString\n}\ndef decodeShift(s: String): String = {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    val result = s.map(ch => (((ch.toInt - 97 + 21) % 26) + 97).toChar)\n    // return \"\".join(result)\n    result.mkString\n}\n",
            "def removeVowels(txt: String): String = {\n    // vowels = \"aeiouAEIOU\"\n    val vowels = \"aeiouAEIOU\"\n    // return \"\".join([char for char in txt if char not in vowels])\n    txt.filterNot(vowels.contains(_))\n}\n",
            "def belowThreshold(l: Seq[Int], t: Int): Boolean = {\n    // return all(x < t for x in l)\n    l.forall(_ < t)\n}\n",
            "def add(x: Int, y: Int): Int = x + y\n",
            "def sameChars(s0: String, s1: String): Boolean = {\n    // return set(s0) == set(s1)\n    s0.toSet == s1.toSet\n}\n",
            "def fib(n: Int): Int = {\n    // if n <= 1:\n    if (n <= 1) {\n        // return n\n        n\n    } else {\n        // return fib(n - 1) + fib(n - 2)\n        fib(n - 1) + fib(n - 2)\n    }\n}\n",
            "def correctBracketing(brackets: String): Boolean = {\n    // depth = 0\n    var depth = 0\n    // for b in brackets:\n    for (b <- brackets) {\n        // if b == \"<\":\n        if (b == '<') {\n            // depth += 1\n            depth += 1\n        }\n        // elif b == \">\":\n        else if (b == '>') {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false\n        }\n    }\n    // return depth == 0\n    depth == 0\n}\n",
            "def monotonic(l: Seq[Int]): Boolean = {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    val diff = l.zip(l.tail).map { case (x, y) => y - x }\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    diff.forall(_ <= 0) || diff.forall(_ >= 0)\n}\n",
            "def common(l1: Seq[Int], l2: Seq[Int]): Seq[Int] = {\n    // return sorted(list(set(l1) & set(l2)))\n    (l1.toSet & l2.toSet).toList.sorted\n}\n",
            "def largestPrimeFactor(n: Int): Int = {\n    // i = 2\n    var i = 2\n    // while i * i <= n:\n    while (i * i <= n) {\n        // if n % i:\n        if (n % i != 0) {\n            // i += 1\n            i += 1\n        } else {\n            // n //= i\n            n /= i\n        }\n    }\n    // return n\n    n\n}\n",
            "def sumToN(n: Int): Int = {\n    // return sum(range(n + 1))\n    (1 to n).sum\n}\n",
            "def correctBracketing(brackets: String): Boolean = {\n    // depth = 0\n    var depth = 0\n    // for b in brackets:\n    for (b <- brackets) {\n        // if b == \"(\":\n        if (b == '(') {\n            // depth += 1\n            depth += 1\n        }\n        // elif b == \")\":\n        else if (b == ')') {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false\n        }\n    }\n    // return depth == 0\n    depth == 0\n}\n",
            "def derivative(xs: Seq[Int]): Seq[Int] = {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    xs.zipWithIndex.map { case (x, i) => x * i }\n}\n",
            "def fibfib(n: Int): Int = {\n    // if n <= 1:\n    if (n <= 1) 0\n    // else:\n    else {\n        // a, b, c = 0, 0, 1\n        var a = 0\n        var b = 0\n        var c = 1\n        // while n > 2:\n        while (n > 2) {\n            // a, b, c = b, c, a + b + c\n            val tmp = a\n            a = b\n            b = c\n            c = tmp + b + c\n            // n -= 1\n            n -= 1\n        }\n        // return c\n        c\n    }\n}\n",
            "def vowelsCount(s: String): Int = {\n    // vowels = \"aeiou\"\n    val vowels = \"aeiou\"\n    // cnt = 0\n    var cnt = 0\n    // for i in range(len(s)):\n    for (i <- 0 until s.length) {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if (vowels.contains(s(i).toLower) || (i == s.length - 1 && s(i).toLower == 'y')) {\n            // cnt += 1\n            cnt += 1\n        }\n    }\n    // return cnt\n    cnt\n}\n",
            "def circularShift(x: Int, shift: Int): String = {\n    // x_str = str(x)\n    val x_str = x.toString\n    // if shift > len(x_str):\n    if (shift > x_str.length) {\n        // return x_str[::-1]\n        return x_str.reverse\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return x_str.substring(x_str.length - shift) + x_str.substring(0, x_str.length - shift)\n    }\n}\n",
            "def digitSum(s: String): Int = {\n    // return sum(ord(c) for c in s if c.isupper())\n    s.filter(_.isUpper).map(_.toInt).sum\n}\n",
            "def fruitDistribution(s: String, n: Int): Int = {\n    // words = s.split(' ')\n    val words = s.split(' ')\n    // apples = int(words[words.index(\"apples\") - 1])\n    val apples = words.indexOf(\"apples\") - 1\n    val applesCount = words(apples).toInt\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    val oranges = words.indexOf(\"oranges\") - 1\n    val orangesCount = words(oranges).toInt\n    // return n - apples - oranges\n    n - applesCount - orangesCount\n}\n",
            "def pluck(arr: Seq[Int]): Seq[Int] = {\n    // evens = [n for n in arr if n % 2 == 0]\n    val evens = arr.filter(_ % 2 == 0)\n    // if len(evens) == 0:\n    if (evens.isEmpty) {\n        // return []\n        return Seq()\n    }\n    // min_even = min(evens)\n    val min_even = evens.min\n    // return [min_even, arr.index(min_even)]\n    Seq(min_even, arr.indexOf(min_even))\n}\n",
            "def search(lst: Seq[Int]): Int = {\n    // freqs = {}\n    val freqs = mutable.Map.empty[Int, Int]\n    // for n in lst:\n    for (n <- lst) {\n        // freqs[n] = freqs.get(n, 0) + 1\n        freqs(n) = freqs.getOrElse(n, 0) + 1\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    val goodVals = freqs.filter { case (k, v) => v >= k }.keys\n    // return max(good_vals, default=-1)\n    goodVals.maxOption.getOrElse(-1)\n}\n",
            "def strangeSortList(lst: Seq[Int]): Seq[Int] = {\n    // sl = sorted(lst)\n    val sl = lst.sorted\n    // result = []\n    val result = mutable.ListBuffer[Int]()\n    // left, right = 0, len(sl) - 1\n    var left = 0\n    var right = sl.size - 1\n    // while left <= right:\n    while (left <= right) {\n        // result.append(sl[left])\n        result.addOne(sl(left))\n        // left += 1\n        left += 1\n        // if left <= right:\n        if (left <= right) {\n            // result.append(sl[right])\n            result.addOne(sl(right))\n            // right -= 1\n            right -= 1\n        }\n    }\n    // return result\n    result.toList\n}\n",
            "def triangleArea(a: Int, b: Int, c: Int): Double = {\n    // if a + b > c and a + c > b and b + c > a:\n    if (a + b > c && a + c > b && b + c > a) {\n        // s = (a + b + c) / 2.0\n        val s = (a + b + c) / 2.0\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n    } else {\n        // return -1.0\n        return -1.0\n    }\n}\n",
            "def willItFly(q: Seq[Int], w: Int): Boolean = {\n    // if len(q) == 0:\n    if (q.isEmpty) {\n        // return False\n        return false\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    val isPalin = q.zip(q.reverse).forall { case (a, b) => a == b }\n    // total = sum(q)\n    val total = q.sum\n    // return is_palin and total <= w\n    isPalin && total <= w\n}\n",
            "def smallestChange(arr: Seq[Int]): Int = {\n    // ans = 0\n    var ans = 0\n    // for i in range(len(arr) // 2):\n    for (i <- 0 until arr.size / 2) {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if (arr(i) != arr(arr.size - i - 1)) {\n            // ans += 1\n            ans += 1\n        }\n    }\n    // return ans\n    ans\n}\n",
            "def totalMatch(lst1: Seq[String], lst2: Seq[String]): Seq[String] = {\n    // cnt1 = sum(len(s) for s in lst1)\n    val cnt1 = lst1.map(_.length).sum\n    // cnt2 = sum(len(s) for s in lst2)\n    val cnt2 = lst2.map(_.length).sum\n    // return lst1 if cnt1 <= cnt2 else lst2\n    if (cnt1 <= cnt2) lst1 else lst2\n}\n",
            "def isPrime(n: Int): Boolean = {\n    // if n < 2:\n    if (n < 2) return false\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i <- 2 to floor(sqrt(n)).toInt + 1) {\n        // if n % i == 0:\n        if (n % i == 0) return false\n    }\n    // return True\n    true\n}\ndef isMultiplyPrime(a: Int): Boolean = {\n    // cnt = 0\n    var cnt = 0\n    // for i in range(2, a + 1):\n    for (i <- 2 to a + 1) {\n        // if is_prime(i):\n        if (isPrime(i)) {\n            // while a % i == 0:\n            while (a % i == 0) {\n                // cnt += 1\n                cnt += 1\n                // a /= i\n                a /= i\n            }\n        }\n    }\n    // return cnt == 3\n    cnt == 3\n}\n",
            "def isSimplePower(x: Int, n: Int): Boolean = {\n    // if n < 2:\n    if (n < 2) {\n        // return x == n\n        x == n\n    } else {\n        // tmp = 1\n        var tmp = 1\n        // while tmp < x:\n        while (tmp < x) {\n            // tmp *= n\n            tmp *= n\n        }\n        // return tmp == x\n        tmp == x\n    }\n}\n",
            "def isCube(a: Int): Boolean = {\n    // a = abs(a)\n    val a = math.abs(a)\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    val root = math.round(math.pow(a, 1.0 / 3.0)).toInt\n    // return root * root * root == a\n    root * root * root == a\n}\n",
            "def hexKey(num: String): Int = {\n    // return len([x for x in num if x in \"2357BD\"])\n    num.count(Set(\"2357BD\"))\n}\n",
            "def decimalToBinary(dec: Int): String = {\n    // binary = bin(dec)[2:]\n    val binary = Integer.toBinaryString(dec)\n    // return f\"db{binary}db\"\n    s\"db$binary\"\n}\n",
            "def isHappy(s: String): Boolean = {\n    // if len(s) < 3:\n    if (s.length < 3) {\n        // return False\n        return false\n    }\n    // for i in range(len(s) - 2):\n    for (i <- 0 until s.length - 2) {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    true\n}\n",
            "def numericalLetterGrade(grades: Seq[Float]): Seq[String] = {\n    // result = []\n    val result = mutable.ListBuffer[String]()\n    // for g in grades:\n    for (g <- grades) {\n        // if g == 4.0:\n        if (g == 4.0f) {\n            // result.append(\"A+\")\n            result.addOne(\"A+\")\n        }\n        // elif g > 3.7:\n        else if (g > 3.7f) {\n            // result.append(\"A\")\n            result.addOne(\"A\")\n        }\n        // elif g > 3.3:\n        else if (g > 3.3f) {\n            // result.append(\"A-\")\n            result.addOne(\"A-\")\n        }\n        // elif g > 3.0:\n        else if (g > 3.0f) {\n            // result.append(\"B+\")\n            result.addOne(\"B+\")\n        }\n        // elif g > 2.7:\n        else if (g > 2.7f) {\n            // result.append(\"B\")\n            result.addOne(\"B\")\n        }\n        // elif g > 2.3:\n        else if (g > 2.3f) {\n            // result.append(\"B-\")\n            result.addOne(\"B-\")\n        }\n        // elif g > 2.0:\n        else if (g > 2.0f) {\n            // result.append(\"C+\")\n            result.addOne(\"C+\")\n        }\n        // elif g > 1.7:\n        else if (g > 1.7f) {\n            // result.append(\"C\")\n            result.addOne(\"C\")\n        }\n        // elif g > 1.3:\n        else if (g > 1.3f) {\n            // result.append(\"C-\")\n            result.addOne(\"C-\")\n        }\n        // elif g > 1.0:\n        else if (g > 1.0f) {\n            // result.append(\"D+\")\n            result.addOne(\"D+\")\n        }\n        // elif g > 0.7:\n        else if (g > 0.7f) {\n            // result.append(\"D\")\n            result.addOne(\"D\")\n        }\n        // elif g > 0.0:\n        else if (g > 0.0f) {\n            // result.append(\"D-\")\n            result.addOne(\"D-\")\n        }\n        // else:\n        else {\n            // result.append(\"E\")\n            result.addOne(\"E\")\n        }\n    }\n    // return result\n    result.toList\n}\n",
            "def primeLength(s: String): Boolean = {\n    // length = len(s)\n    val length = s.length\n    // if length < 2:\n    if (length < 2) {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for (i <- 2 to floor(sqrt(length)).toInt + 1) {\n        // if length % i == 0:\n        if (length % i == 0) {\n            // return False\n            return false\n        }\n    }\n    // return True\n    true\n}\n",
            "def startsOneEnds(n: Int): Int = {\n    // if n == 1:\n    if (n == 1) {\n        // return 1\n        1\n    } else {\n        // return 2 * 9 * (10 ** (n - 2))\n        2 * 9 * (10 ** (n - 2))\n    }\n}\n",
            "def solve(n: Int): String = {\n    // digits_sum = sum(int(d) for d in str(n))\n    val digitsSum = (for (d <- n.toString) yield d.toInt).sum\n    // return bin(digits_sum)[2:]\n    Integer.toBinaryString(digitsSum).substring(2)\n}\n",
            "def add(lst: Seq[Int]): Int = {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    lst.zipWithIndex.filter { case (x, i) => i % 2 == 1 && x % 2 == 0 }.map(_._1).sum\n}\n",
            "def antiShuffle(s: String): String = {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    val words = s.split(\" \").map(word => word.sorted.mkString)\n    // return \" \".join(words)\n    words.mkString(\" \")\n}\n",
            "def getRow(lst: Seq[Seq[Int]], x: Int): Seq[Seq[Int]] = {\n    // coords = []\n    val coords = mutable.ListBuffer[Seq[Int]]()\n    // for i in range(len(lst)):\n    for (i <- 0 until lst.length) {\n        // for j in range(len(lst[i])):\n        for (j <- 0 until lst(i).length) {\n            // if lst[i][j] == x:\n            if (lst(i)(j) == x) {\n                // coords.append([i, j])\n                coords.addOne(Seq(i, j))\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    coords.toList.sortBy(a => (a(0), -a(1)))\n}\n",
            "def sortArray(arr: Seq[Int]): Seq[Int] = {\n    // if len(arr) == 0:\n    if (arr.isEmpty) {\n        // return []\n        return Seq()\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if ((arr.head + arr.last) % 2 == 0) {\n        // return sorted(arr, reverse=True)\n        return arr.sorted.reverse\n    } else {\n        // return sorted(arr)\n        return arr.sorted\n    }\n}\n",
            "def encrypt(s: String): String = {\n    // result = []\n    val result = mutable.ListBuffer[Char]()\n    // for ch in s:\n    for (ch <- s) {\n        // shifted = ord(ch) + 4\n        val shifted = ch.toInt + 4\n        // if shifted > ord('z'):\n        if (shifted > 'z'.toInt) {\n            // shifted -= 26\n            shifted -= 26\n        }\n        // result.append(chr(shifted))\n        result.addOne(shifted.toChar)\n    }\n    // return \"\".join(result)\n    result.mkString\n}\n",
            "def nextSmallest(lst: Seq[Int]): Option[Int] = {\n    // sl = sorted(set(lst))\n    val sl = mutable.ListBuffer(lst.toSet.toList.sorted: _*)\n    // if len(sl) < 2:\n    if (sl.size < 2) {\n        // return None\n        return None\n    }\n    // return sl[1]\n    Some(sl(1))\n}\n",
            "def isBored(s: String): Int = {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    val sentences = s.split(Regex.quote(\"\"\"[.!?]\\s*\"\"\"))\n    // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    sentences.count(sentence => sentence.length >= 2 && sentence.substring(0, 2) == \"I \")\n}\n",
            "def anyInt(x: Any, y: Any, z: Any): Boolean = {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if (x.isInstanceOf[Int] && y.isInstanceOf[Int] && z.isInstanceOf[Int]) {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if (x.asInstanceOf[Int] + y.asInstanceOf[Int] == z.asInstanceOf[Int]) ||\n            (x.asInstanceOf[Int] + z.asInstanceOf[Int] == y.asInstanceOf[Int]) ||\n            (y.asInstanceOf[Int] + z.asInstanceOf[Int] == x.asInstanceOf[Int]) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    false\n}\n",
            "def encode(message: String): String = {\n    // vowels = \"aeiouAEIOU\"\n    val vowels = \"aeiouAEIOU\"\n    // result = []\n    val result = mutable.ListBuffer[Char]()\n    // for ch in message:\n    for (ch <- message) {\n        // if ch.isalpha():\n        if (ch.isLetter) {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            val ch1 = if (ch.isLower) ch.toUpper else ch.toLower\n            // if ch1 in vowels:\n            if (vowels.contains(ch1)) {\n                // ch1 = chr(ord(ch1) + 2)\n                ch1 = (ch1.toInt + 2).toChar\n            }\n            // result.append(ch1)\n            result.addOne(ch1)\n        } else {\n            // result.append(ch)\n            result.addOne(ch)\n        }\n    }\n    // return \"\".join(result)\n    result.mkString\n}\n",
            "def isPrime(n: Int): Boolean = {\n    // if n < 2:\n    if (n < 2) return false\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i <- 2 to floor(sqrt(n)).toInt + 1) {\n        // if n % i == 0:\n        if (n % i == 0) return false\n    }\n    // return True\n    true\n}\ndef skjkasdkd(lst: Seq[Int]): Int = {\n    // primes = [n for n in lst if is_prime(n)]\n    val primes = lst.filter(isPrime)\n    // if len(primes) == 0:\n    if (primes.isEmpty) return 0\n    // largest = str(max(primes))\n    val largest = primes.max.toString\n    // return sum(int(digit) for digit in largest)\n    largest.map(_.asDigit).sum\n}\n",
            "def checkDictCase(d: Map[String, String]): Boolean = {\n    // if not d:\n    if (d.isEmpty) {\n        // return False\n        return false\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    d.keys.forall(_.forall(_.isLower)) || d.keys.forall(_.forall(_.isUpper))\n}\n",
            "def countUpTo(n: Int): Seq[Int] = {\n    // primes = []\n    var primes = Seq[Int]()\n    // for num in range(2, n):\n    for (num <- 2 to n) {\n        // if all(num % p != 0 for p in primes):\n        if (primes.forall(num % _ != 0)) {\n            // primes.append(num)\n            primes = primes :+ num\n        }\n    }\n    // return primes\n    primes\n}\n",
            "def multiply(a: Int, b: Int): Int = {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    (math.abs(a) % 10) * (math.abs(b) % 10)\n}\n",
            "def countUpper(s: String): Int = {\n    // vowels = \"AEIOU\"\n    val vowels = \"AEIOU\"\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    s.zipWithIndex.count { case (c, i) => i % 2 == 0 && vowels.contains(c) }\n}\n",
            "def closestInteger(value: String): Int = {\n    // num = float(value)\n    val num = value.toFloat\n    // if num >= 0:\n    if (num >= 0) {\n        // return int(num + 0.5)\n        return num.toInt + 1\n    } else {\n        // return int(num - 0.5)\n        return num.toInt - 1\n    }\n}\n",
            "def makeAPile(n: Int): Seq[Int] = {\n    // return [n + 2 * i for i in range(n)]\n    (0 until n).map(i => n + 2 * i).toList\n}\n",
            "def wordsString(s: String): Seq[String] = {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    re.split(r\"[, ]\", s).filter(_.length > 0)\n}\n",
            "def chooseNum(x: Int, y: Int): Int = {\n    // if x > y:\n    if (x > y) {\n        // return -1\n        return -1\n    }\n    // if y % 2 == 0:\n    if (y % 2 == 0) {\n        // return y\n        return y\n    }\n    // return y - 1 if x != y else -1\n    if (x != y) y - 1 else -1\n}\n",
            "def roundedAvg(n: Int, m: Int): Option[String] = {\n    // if n > m:\n    if (n > m) {\n        // return None\n        None\n    } else {\n        // r_avg = int((m + n) / 2.0 + 0.5)\n        val rAvg = (m + n) / 2.0 + 0.5\n        // return bin(r_avg)[2:]\n        Some(Integer.toBinaryString(rAvg.toInt))\n    }\n}\n",
            "def allDigitsOdd(s: String): Boolean = {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    s.forall(digit => (digit.toInt & 1) != 0)\n}\ndef uniqueDigits(x: Seq[Int]): Seq[Int] = {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    x.filter(num => allDigitsOdd(num.toString)).sorted\n}\n",
            "def byLength(arr: Seq[Int]): Seq[String] = {\n    // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    val digitNames = Seq(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n    val sortedArr = arr.filter(x => 1 <= x && x <= 9).sorted.reverse\n    // return [digit_names[x-1] for x in sorted_arr]\n    sortedArr.map(x => digitNames(x - 1))\n}\n",
            "def f(n: Int): Seq[Int] = {\n    // nums = list(range(1, n + 1))\n    val nums = (1 to n).toList\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    nums.map(i => if (i % 2 != 0) nums.take(i).sum else nums.take(i).reduce(_ * _))\n}\n",
            "def isPalindrome(txt: String): Boolean = {\n    // return txt == txt[::-1]\n    txt == txt.reverse\n}\ndef evenOddPalindrome(n: Int): Seq[Int] = {\n    // cnt = [0, 0]\n    val cnt = mutable.ListBuffer[Int](0, 0)\n    // for i in range(1, n + 1):\n    for (i <- 1 to n) {\n        // if is_palindrome(str(i)):\n        if (isPalindrome(i.toString)) {\n            // cnt[i % 2] += 1\n            cnt(i % 2) += 1\n        }\n    }\n    // return cnt\n    cnt.toList\n}\n",
            "def digitsSum(n: Int): Int = {\n    // n_str = str(n)\n    val nStr = n.toString\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.map(_.asDigit).sum\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return nStr.take(2).toInt * 2 + digitsSum(n.abs)\n    }\n}\ndef countNums(arr: Seq[Int]): Int = {\n    // return len([n for n in arr if digits_sum(n) > 0])\n    return arr.count(n => digitsSum(n) > 0)\n}\n",
            "def moveOneBall(arr: Seq[Int]): Boolean = {\n    // if len(arr) == 0:\n    if (arr.isEmpty) {\n        // return True\n        return true\n    }\n    // sorted_arr = sorted(arr)\n    val sortedArr = arr.sorted\n    // for i in range(0, len(arr)):\n    for (i <- 0 until arr.length) {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if (arr.drop(i) == sortedArr.take(arr.length - i) && arr.take(i) == sortedArr.drop(arr.length - i)) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    false\n}\n",
            "def canExchange(lst1: Seq[Int], lst2: Seq[Int]): String = {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    val oddCnt = lst1.count(_ % 2 != 0)\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    val evenCnt = lst2.count(_ % 2 == 0)\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    if (evenCnt >= oddCnt) \"YES\" else \"NO\"\n}\n",
            "def histogram(test: String): Map[String, Int] = {\n    // freq = {}\n    val freq = mutable.Map.empty[String, Int]\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    val words = test.split(\" \").filter(_.length > 0)\n    // for w in words:\n    for (w <- words) {\n        // freq[w] = freq.get(w, 0) + 1\n        freq(w) = freq.getOrElse(w, 0) + 1\n    }\n    // result = {}\n    val result = mutable.Map.empty[String, Int]\n    // if len(freq) > 0:\n    if (freq.nonEmpty) {\n        // max_freq = max(freq.values())\n        val max_freq = freq.values.max\n        // for k, v in freq.items():\n        for ((k, v) <- freq) {\n            // if v == max_freq:\n            if (v == max_freq) {\n                // result[k] = v\n                result(k) = v\n            }\n        }\n    }\n    // return result\n    result.toMap\n}\n",
            "def isPalindrome(s: String): Boolean = {\n    // return s == s[::-1]\n    s == s.reverse\n}\ndef reverseDelete(s: String, c: String): Seq[String] = {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    val s1 = s.filterNot(c.contains(_))\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    Seq(s1, if (isPalindrome(s1)) \"yes\" else \"no\")\n}\n",
            "def oddCount(lst: Seq[String]): Seq[String] = {\n    // result = []\n    val result = mutable.ListBuffer[String]()\n    // for num in lst:\n    for (num <- lst) {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        val n = num.foldLeft(0)((acc, d) => acc + (d.toInt % 2 == 1).toInt)\n        // rs = \"the number of odd elements in the string i of the input.\"\n        val rs = \"the number of odd elements in the string i of the input.\"\n        // result.append(rs.replace(\"i\", str(n)))\n        result.addOne(rs.replace(\"i\", n.toString))\n    }\n    // return result\n    result.toList\n}\n",
            "def minSubArraySum(nums: Seq[Int]): Int = {\n    // min_sum = 0\n    var minSum = 0\n    // cur_sum = 0\n    var curSum = 0\n    // for n in nums:\n    for (n <- nums) {\n        // cur_sum = min(cur_sum + n, 0)\n        curSum = Math.min(curSum + n, 0)\n        // min_sum = min(cur_sum, min_sum)\n        minSum = Math.min(curSum, minSum)\n    }\n    // if min_sum == 0:\n    if (minSum == 0) {\n        // min_sum = min(nums)\n        minSum = nums.min\n    }\n    // return min_sum\n    minSum\n}\n",
            "def maxFill(grid: Seq[Seq[Int]], capacity: Int): Int = {\n    // return sum([ceil(sum(arr) / capacity) for arr in grid])\n    grid.map(arr => ceil(arr.sum / capacity)).sum\n}\n",
            "def countOnes(num: Int): Int = {\n    // return bin(num).count(\"1\")\n    Integer.bitCount(num)\n}\ndef sortArray(arr: Seq[Int]): Seq[Int] = {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    arr.sortWith((x, y) => (countOnes(x), x) < (countOnes(y), y))\n}\n",
            "def selectWords(s: String, n: Int): Seq[String] = {\n    // consonants = \"bcdfghjklmnpqrstvwxyz\"\n    val consonants = \"bcdfghjklmnpqrstvwxyz\"\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    val words = s.split(\" \").filter(_.length > 0)\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    words.filter(w => w.count(c => consonants.contains(c.toLower)) == n)\n}\n",
            "def getClosestVowel(word: String): String = {\n    // vowels = \"aeiouAEIOU\"\n    val vowels = \"aeiouAEIOU\"\n    // for i in range(len(word) - 2, 0, -1):\n    for (i <- (word.length - 2) to 0 by -1) {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if (vowels.contains(word(i)) && !vowels.contains(word(i - 1)) && !vowels.contains(word(i + 1))) {\n            // return word[i]\n            return word(i)\n        }\n    }\n    // return \"\"\n    \"\"\n}\n",
            "def check(s: String): Boolean = {\n    // depth = 0\n    var depth = 0\n    // for ch in s:\n    for (ch <- s) {\n        // if ch == \"(\":\n        if (ch == '(') {\n            // depth += 1\n            depth += 1\n        } else {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false\n        }\n    }\n    // return True if depth == 0 else False\n    depth == 0\n}\ndef matchParens(lst: Seq[String]): String = {\n    // s1 = lst[0] + lst[1]\n    val s1 = lst(0) + lst(1)\n    // s2 = lst[1] + lst[0]\n    val s2 = lst(1) + lst(0)\n    // return \"Yes\" if check(s1) or check(s2) else \"No\"\n    if (check(s1) || check(s2)) \"Yes\" else \"No\"\n}\n",
            "def maximum(arr: Seq[Int], k: Int): Seq[Int] = {\n    // if k == 0:\n    if (k == 0) {\n        // return []\n        return Seq()\n    }\n    // return sorted(arr)[-k:]\n    arr.sorted.takeRight(k)\n}\n",
            "def solution(lst: Seq[Int]): Int = {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    lst.zipWithIndex.filter { case (x, i) => i % 2 == 0 && x % 2 != 0 }.map(_._1).sum\n}\n",
            "def addElements(arr: Seq[Int], k: Int): Int = {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    arr.take(k).filter(n => str(n).length <= 2).sum\n}\n",
            "def getOddCollatz(n: Int): Seq[Int] = {\n    // collatz = [1]\n    var collatz = mutable.ListBuffer[Int](1)\n    // while n != 1:\n    while (n != 1) {\n        // if n % 2 != 0:\n        if (n % 2 != 0) {\n            // collatz.append(n)\n            collatz.addOne(n)\n            // n = 3 * n + 1\n            n = 3 * n + 1\n        } else {\n            // n = n // 2\n            n = n / 2\n        }\n    }\n    // return sorted(collatz)\n    collatz.toList.sorted\n}\n",
            "def validDate(date: String): Boolean = {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if (date.length != 10 || date(2) != '-' || date(5) != '-') {\n        return false\n    }\n    // m = int(date[:2])\n    val m = date.substring(0, 2).toInt\n    // d = int(date[3:5])\n    val d = date.substring(3, 5).toInt\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) {\n        if (d >= 1 && d <= 31) {\n            return true\n        }\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if (m == 4 || m == 6 || m == 9 || m == 11) {\n        if (d >= 1 && d <= 30) {\n            return true\n        }\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if (m == 2) {\n        if (d >= 1 && d <= 29) {\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "def splitWords(txt: String): Seq[String] = {\n    // if \" \" in txt:\n    if (txt.contains(\" \")) {\n        // return txt.split(\" \")\n        txt.split(\" \")\n    }\n    // elif \",\" in txt:\n    else if (txt.contains(\",\")) {\n        // return txt.split(\",\")\n        txt.split(\",\")\n    }\n    // else:\n    else {\n        // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        Seq(txt.count(c => c.isLower && c.toInt % 2 == 0).toString)\n    }\n}\n",
            "def isSorted(lst: Seq[Int]): Boolean = {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    if (!lst.sliding(2).forall(x => x(0) <= x(1))) {\n        return false\n    }\n    // freq = {}\n    val freq = mutable.Map[Int, Int]()\n    // for i in lst:\n    for (i <- lst) {\n        // freq[i] = freq.get(i, 0) + 1\n        freq(i) = freq.getOrElse(i, 0) + 1\n    }\n    // return max(freq.values(), default=0) <= 2\n    freq.values.max <= 2\n}\n",
            "def isPrime(n: Int): Boolean = {\n    // if n < 2:\n    if (n < 2) return false\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i <- 2 to floor(sqrt(n)).toInt + 1) {\n        // if n % i == 0:\n        if (n % i == 0) return false\n    }\n    // return True\n    true\n}\ndef intersection(interval1: Seq[Int], interval2: Seq[Int]): String = {\n    // l = max(interval1[0], interval2[0])\n    val l = interval1(0).max(interval2(0))\n    // r = min(interval1[1], interval2[1])\n    val r = interval1(1).min(interval2(1))\n    // length = r - l\n    val length = r - l\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    if (length > 0 && isPrime(length)) \"YES\" else \"NO\"\n}\n",
            "def prodSigns(arr: Seq[Int]): Option[Int] = {\n    // if not arr:\n    if (arr.isEmpty) {\n        // return None\n        return None\n    }\n    // if 0 in arr:\n    if (arr.contains(0)) {\n        // return 0\n        return Some(0)\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    val sign = if (arr.count(_ < 0) % 2 == 1) -1 else 1\n    // return sign * sum([abs(n) for n in arr])\n    Some(sign * arr.map(math.abs).sum)\n}\n",
            "def minPath(grid: Seq[Seq[Int]], k: Int): Seq[Int] = {\n    // n = len(grid)\n    val n = grid.size\n    // min_val = n * n + 1\n    var minVal = n * n + 1\n    // for i in range(n):\n    for (i <- 0 until n) {\n        // for j in range(n):\n        for (j <- 0 until n) {\n            // if grid[i][j] == 1:\n            if (grid(i)(j) == 1) {\n                // temp = []\n                val temp = mutable.ListBuffer[Int]()\n                // if i != 0:\n                if (i != 0) {\n                    // temp.append(grid[i - 1][j])\n                    temp.addOne(grid(i - 1)(j))\n                }\n                // if j != 0:\n                if (j != 0) {\n                    // temp.append(grid[i][j - 1])\n                    temp.addOne(grid(i)(j - 1))\n                }\n                // if i != n - 1:\n                if (i != n - 1) {\n                    // temp.append(grid[i + 1][j])\n                    temp.addOne(grid(i + 1)(j))\n                }\n                // if j != n - 1:\n                if (j != n - 1) {\n                    // temp.append(grid[i][j + 1])\n                    temp.addOne(grid(i)(j + 1))\n                }\n                // min_val = min(temp)\n                minVal = math.min(minVal, temp.min)\n            }\n        }\n    }\n    // result = []\n    val result = mutable.ListBuffer[Int]()\n    // for i in range(k):\n    for (i <- 0 until k) {\n        // result.append(1 if i % 2 == 0 else min_val)\n        result.addOne(if (i % 2 == 0) 1 else minVal)\n    }\n    // return result\n    result.toList\n}\n",
            "def tri(n: Int): Seq[Int] = {\n    // if n == 0:\n    if (n == 0) {\n        // return [1]\n        return Seq(1)\n    }\n    // seq = [1, 3]\n    var seq = Seq(1, 3)\n    // for i in range(2, n + 1):\n    for (i <- 2 to n) {\n        // if i % 2 == 0:\n        if (i % 2 == 0) {\n            // seq.append(i / 2 + 1)\n            seq = seq :+ (i / 2 + 1)\n        } else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq = seq :+ (seq(i - 1) + seq(i - 2) + (i + 3) / 2)\n        }\n    }\n    // return seq\n    seq\n}\n",
            "def digits(n: Int): Int = {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    val odds = mutable.ListBuffer[Int]()\n    for (d <- str(n)) {\n        val dd = int(d)\n        if (dd % 2 == 1) {\n            odds.addOne(dd)\n        }\n    }\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    if (odds.nonEmpty) {\n        odds.reduceLeft(_ * _)\n    } else {\n        0\n    }\n}\n",
            "def isNested(s: String): Boolean = {\n    // open_idx = []\n    val openIdx = mutable.ListBuffer[Int]()\n    // close_idx = []\n    val closeIdx = mutable.ListBuffer[Int]()\n    // for i, ch in enumerate(s):\n    for (i <- s.indices) {\n        val ch = s(i)\n        // if ch == '[':\n        if (ch == '[') {\n            // open_idx.append(i)\n            openIdx.addOne(i)\n        }\n        // elif ch == ']':\n        else if (ch == ']') {\n            // close_idx.append(i)\n            closeIdx.addOne(i)\n        }\n    }\n    // close_idx.reverse()\n    closeIdx.reverse()\n    // cnt = 0\n    var cnt = 0\n    // i = 0\n    var i = 0\n    // l = len(close_idx)\n    val l = closeIdx.size\n    // for idx in open_idx:\n    for (idx <- openIdx) {\n        // if i < l and idx < close_idx[i]:\n        if (i < l && idx < closeIdx(i)) {\n            // cnt += 1\n            cnt += 1\n            // i += 1\n            i += 1\n        }\n    }\n    // return cnt >= 2\n    cnt >= 2\n}\n",
            "def sumSquares(lst: Seq[Float]): Int = {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    lst.map(n => math.pow(math.ceil(n).toDouble, 2).toInt).sum\n}\n",
            "def checkIfLastCharIsALetter(txt: String): Boolean = {\n    // if not txt:\n    if (txt.isEmpty) {\n        // return False\n        return false\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    val last = txt.substring(txt.lastIndexOf(' ') + 1)\n    // return len(last) == 1 and last[0].isalpha()\n    last.length == 1 && last.head.isLetter\n}\n",
            "def canArrange(arr: Seq[Int]): Int = {\n    // if len (arr) <= 1:\n    if (arr.length <= 1) {\n        // return -1\n        return -1\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    val idx = for (i <- 1 until arr.length if arr(i) < arr(i - 1)) yield i\n    // return max(idx, default=-1)\n    idx.maxOption.getOrElse(-1)\n}\n",
            "def largestSmallestIntegers(lst: Seq[Int]): Seq[Option[Int]] = {\n    // neg = [i for i in lst if i < 0]\n    val neg = lst.filter(_ < 0)\n    // pos = [i for i in lst if i > 0]\n    val pos = lst.filter(_ > 0)\n    // max_neg = max(neg) if len(neg) > 0 else None\n    val maxNeg = if (neg.nonEmpty) Some(neg.max) else None\n    // min_pos = min(pos) if len(pos) > 0 else None\n    val minPos = if (pos.nonEmpty) Some(pos.min) else None\n    // return [max_neg, min_pos]\n    Seq(maxNeg, minPos)\n}\n",
            "def anyToReal(o: Any): Double = {\n    // if isinstance(o, str): \n    if (o.isInstanceOf[String]) {\n        // return float(o.replace(',','.'))\n        return o.asInstanceOf[String].replace(',','.').toDouble\n    }\n    // elif isinstance(o, int):\n    else if (o.isInstanceOf[Int]) {\n        // return float(o)\n        return o.asInstanceOf[Int].toDouble\n    }\n    // elif isinstance(o, float):\n    else if (o.isInstanceOf[Float]) {\n        // return o\n        return o.asInstanceOf[Float]\n    }\n    // raise RuntimeError(\"Type Error\");\n    throw new RuntimeException(\"Type Error\")\n}\ndef compareOne(a: Any, b: Any): Option[Double] = {\n    // a1 = any_to_real(a)\n    val a1 = anyToReal(a)\n    // b1 = any_to_real(b)\n    val b1 = anyToReal(b)\n    // if a1 == b1:\n    if (a1 == b1) {\n        // return None\n        return None\n    }\n    // elif a1 > b1:\n    else if (a1 > b1) {\n        // return a1\n        return Some(a1)\n    }\n    // else:\n    else {\n        // return b1\n        return Some(b1)\n    }\n}\n",
            "def isEqualToSumEven(n: Int): Boolean = {\n    // return n % 2 == 0 and n >= 8\n    n % 2 == 0 && n >= 8\n}\n",
            "def specialFactorial(n: Int): Int = {\n    // fact = 1\n    var fact = 1\n    // result = 1\n    var result = 1\n    // for i in range(1, n + 1):\n    for (i <- 1 to n) {\n        // fact *= i\n        fact *= i\n        // result *= fact\n        result *= fact\n    }\n    // return result\n    result\n}\n",
            "def fixSpaces(txt: String): String = {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    txt.replaceAll(\"\"\"\\s{3,}\"\"\", \"-\").replace(\" \", \"_\")\n}\n",
            "def fileNameCheck(fileName: String): String = {\n    // suf = [\"txt\", \"exe\", \"dll\"]\n    val suf = Seq(\"txt\", \"exe\", \"dll\")\n    // lst = file_name.split(\".\")\n    val lst = fileName.split('.')\n    // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n    if (lst.length != 2 || !suf.contains(lst(1)) || lst(0).length == 0 || !lst(0).head.isLetter || lst(0).filter(_.isDigit).length > 3) {\n        // return \"No\"\n        return \"No\"\n    }\n    // return \"Yes\"\n    return \"Yes\"\n}\n",
            "def sumSquares(lst: Seq[Int]): Int = {\n    // result = 0\n    var result = 0\n    // for i in range(len(lst)):\n    for (i <- 0 until lst.length) {\n        // if i % 3 == 0:\n        if (i % 3 == 0) {\n            // result += pow(lst[i], 2)\n            result += math.pow(lst(i), 2).toInt\n        }\n        // elif i % 4 == 0:\n        else if (i % 4 == 0) {\n            // result += pow(lst[i], 3)\n            result += math.pow(lst(i), 3).toInt\n        }\n        // else:\n        else {\n            // result += lst[i]\n            result += lst(i)\n        }\n    }\n    // return result\n    result\n}\n",
            "def isPrime(n: Int): Boolean = {\n    // if n < 2:\n    if (n < 2) return false\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i <- 2 to floor(sqrt(n)).toInt + 1) {\n        // if n % i == 0:\n        if (n % i == 0) return false\n    }\n    // return True\n    true\n}\ndef wordsInSentence(sentence: String): String = {\n    // words = sentence.split(\" \")\n    val words = sentence.split(\" \")\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    words.filter(w => isPrime(w.length)).mkString(\" \")\n}\n",
            "def simplify(x: String, n: String): Boolean = {\n    // xs = x.split(\"/\")\n    val xs = x.split(\"/\")\n    // ns = n.split(\"/\")\n    val ns = n.split(\"/\")\n    // num = int(xs[0]) * int(ns[0])\n    val num = xs(0).toInt * ns(0).toInt\n    // den = int(xs[1]) * int(ns[1])\n    val den = xs(1).toInt * ns(1).toInt\n    // return num % den == 0\n    num % den == 0\n}\n",
            "def digitsSum(n: Int): Int = {\n    // n_str = str(n)\n    val nStr = n.toString\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.map(_.asDigit).sum\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return nStr.take(2).toInt * 2 + digitsSum(n.abs)\n    }\n}\ndef orderByPoints(nums: Seq[Int]): Seq[Int] = {\n    // return sorted(nums, key=digits_sum)\n    return nums.sortWith((a, b) => digitsSum(a) < digitsSum(b))\n}\n",
            "def specialFilter(nums: Seq[Int]): Int = {\n    // odds = \"13579\"\n    val odds = \"13579\"\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    nums.count(n => n > 10 && n % 2 == 1 && odds.contains(n.toString.charAt(0)))\n}\n",
            "def getMaxTriples(n: Int): Int = {\n    // c = [0, 0, 0]\n    val c = Array(0, 0, 0)\n    // for i in range(1, n + 1):\n    for (i <- 1 to n) {\n        // a = i * i - i + 1\n        val a = i * i - i + 1\n        // c[a % 3] += 1\n        c(a % 3) += 1\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    c(0) * c(1) * c(2) + (c(0) * (c(0) - 1) * (c(0) - 2) + c(1) * (c(1) - 1) * (c(1) - 2) + c(2) * (c(2) - 1) * (c(2) - 2)) // 6\n}\n",
            "def bf(planet1: String, planet2: String): Seq[String] = {\n    // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    val names = Seq(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    // if planet1 not in names or planet2 not in names:\n    if (!names.contains(planet1) || !names.contains(planet2)) {\n        // return []\n        return Seq()\n    }\n    // l = names.index(planet1)\n    val l = names.indexOf(planet1)\n    // r = names.index(planet2)\n    val r = names.indexOf(planet2)\n    // if l > r:\n    if (l > r) {\n        // l, r = r, l\n        val t = l\n        l = r\n        r = t\n    }\n    // if l == r:\n    if (l == r) {\n        // return []\n        return Seq()\n    }\n    // return names[l + 1 : r]\n    names.slice(l + 1, r)\n}\n",
            "def sortedListSum(lst: Seq[String]): Seq[String] = {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    val result = lst.filter(s => s.length % 2 == 0)\n    // return sorted(result, key=lambda x: (len(x), x))\n    result.sortBy(x => (x.length, x))\n}\n",
            "def xOrY(n: Int, x: Int, y: Int): Int = {\n    // if n < 2:\n    if (n < 2) {\n        // return y\n        return y\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (i <- 2 to floor(sqrt(n)) + 1) {\n        // if n % i == 0:\n        if (n % i == 0) {\n            // return y\n            return y\n        }\n    }\n    // return x\n    return x\n}\n",
            "def doubleTheDifference(lst: Seq[Float]): Int = {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    lst.filter(n => n >= 0 && n % 2 == 1).map(n => n * n).sum.toInt\n}\n",
            "def compare(game: Seq[Int], guess: Seq[Int]): Seq[Int] = {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    game.zip(guess).map { case (x, y) => math.abs(x - y) }\n}\n",
            "def strongestExtension(className: String, extensions: Seq[String]): String = {\n    // max_s = float(\"-inf\")\n    var maxS = Float.MinValue\n    // max_ext = \"\"\n    var maxExt = \"\"\n    // for ext in extensions:\n    for (ext <- extensions) {\n        // upper = len([c for c in ext if c.isupper()])\n        val upper = ext.count(_.isUpper)\n        // lower = len([c for c in ext if c.islower()])\n        val lower = ext.count(_.isLower)\n        // s = upper - lower\n        val s = upper - lower\n        // if s > max_s:\n        if (s > maxS) {\n            // max_s = s\n            maxS = s\n            // max_ext = ext\n            maxExt = ext\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    s\"$className.$maxExt\"\n}\n",
            "def cycpatternCheck(a: String, b: String): Boolean = {\n    // if len(a) < len(b):\n    if (a.length < b.length) {\n        // return False\n        return false\n    }\n    // for i in range(len(b)):\n    for (i <- 0 until b.length) {\n        // if b[i:] + b[:i] in a:\n        if (a.contains(b.substring(i) + b.substring(0, i))) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "def evenOddCount(num: Int): Seq[Int] = {\n    // ds = str(abs(num))\n    val ds = Math.abs(num).toString\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    val even = ds.count(d => d.toInt % 2 == 0)\n    // return [even, len(ds) - even]\n    Seq(even, ds.length - even)\n}\n",
            "def intToMiniRoman(num: Int): String = {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    val values = Seq(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    val numerals = Seq(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n    // res = []\n    val res = mutable.ListBuffer[String]()\n    // for i in range(len(values)):\n    for (i <- 0 until values.length) {\n        // while num >= values[i]:\n        while (num >= values(i)) {\n            // res.append(numerals[i])\n            res.addOne(numerals(i))\n            // num -= values[i]\n            num -= values(i)\n        }\n    }\n    // return \"\".join(res)\n    res.mkString\n}\n",
            "def rightAngleTriangle(a: Int, b: Int, c: Int): Boolean = {\n    // s = sorted([a, b, c])\n    val s = List(a, b, c).sorted\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    s(0) * s(0) + s(1) * s(1) == s(2) * s(2)\n}\n",
            "def findMax(words: Seq[String]): String = {\n    // max_cnt = 0\n    var maxCnt = 0\n    // max_w = \"\"\n    var maxW = \"\"\n    // for w in words:\n    for (w <- words) {\n        // cnt = len(set(w))\n        val cnt = w.toSet.size\n        // if cnt > max_cnt:\n        if (cnt > maxCnt) {\n            // max_cnt = cnt\n            maxCnt = cnt\n            // max_w = w\n            maxW = w\n        }\n        // elif cnt == max_cnt:\n        else if (cnt == maxCnt) {\n            // max_w = min(max_w, w)\n            maxW = if (maxW < w) maxW else w\n        }\n    }\n    // return max_w\n    maxW\n}\n",
            "def eat(num: Int, need: Int, remaining: Int): Seq[Int] = {\n    // if need <= remaining:\n    if (need <= remaining) {\n        // return [num + need, remaining - need]\n        Seq(num + need, remaining - need)\n    } else {\n        // return [num + remaining, 0]\n        Seq(num + remaining, 0)\n    }\n}\n",
            "def doAlgebra(operators: Seq[String], operands: Seq[Int]): Int = {\n    // ops = operators.copy()\n    val ops = operators.toList\n    // nums = operands.copy()\n    val nums = operands.toList\n    // i = len(ops) - 1\n    var i = ops.length - 1\n    // while i >= 0:\n    while (i >= 0) {\n        // if ops[i] == \"**\":\n        if (ops(i) == \"**\") {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            nums(i) = math.pow(nums(i), nums(i + 1)).toInt\n            // nums.pop(i + 1)\n            nums.remove(i + 1)\n            // ops.pop(i)\n            ops.remove(i)\n        }\n        // i -= 1\n        i -= 1\n    }\n    // i = 0\n    i = 0\n    // while i < len(ops):\n    while (i < ops.length) {\n        // if ops[i] == \"*\":\n        if (ops(i) == \"*\") {\n            // nums[i] = nums[i] * nums[i + 1]\n            nums(i) = nums(i) * nums(i + 1)\n            // nums.pop(i + 1)\n            nums.remove(i + 1)\n            // ops.pop(i)\n            ops.remove(i)\n            // i -= 1\n            i -= 1\n        }\n        // elif ops[i] == \"//\":\n        else if (ops(i) == \"//\") {\n            // nums[i] = nums[i] // nums[i + 1]\n            nums(i) = nums(i) / nums(i + 1)\n            // nums.pop(i + 1)\n            nums.remove(i + 1)\n            // ops.pop(i)\n            ops.remove(i)\n            // i -= 1\n            i -= 1\n        }\n        // i += 1\n        i += 1\n    }\n    // i = 0\n    i = 0\n    // while i < len(ops):\n    while (i < ops.length) {\n        // if ops[i] == \"+\":\n        if (ops(i) == \"+\") {\n            // nums[i] = nums[i] + nums[i + 1]\n            nums(i) = nums(i) + nums(i + 1)\n            // nums.pop(i + 1)\n            nums.remove(i + 1)\n            // ops.pop(i)\n            ops.remove(i)\n            // i -= 1\n            i -= 1\n        }\n        // elif ops[i] == \"-\":\n        else if (ops(i) == \"-\") {\n            // nums[i] = nums[i] - nums[i + 1]\n            nums(i) = nums(i) - nums(i + 1)\n            // nums.pop(i + 1)\n            nums.remove(i + 1)\n            // ops.pop(i)\n            ops.remove(i)\n            // i -= 1\n            i -= 1\n        }\n        // i += 1\n        i += 1\n    }\n    // return nums[0]\n    nums(0)\n}\n",
            "def solve(s: String): String = {\n    // if not any(ch.isalpha() for ch in s):\n    if (!s.exists(_.isLetter)) {\n        // return s[::-1]\n        return s.reverse\n    }\n    // result = []\n    val result = mutable.ListBuffer[Char]()\n    // for ch in s:\n    for (ch <- s) {\n        // if not ch.isalpha():\n        if (!ch.isLetter) {\n            // result.append(ch)\n            result.addOne(ch)\n        }\n        // elif ch.isupper():\n        else if (ch.isUpper) {\n            // result.append(ch.lower())\n            result.addOne(ch.toLower)\n        }\n        // elif ch.islower():\n        else if (ch.isLower) {\n            // result.append(ch.upper())\n            result.addOne(ch.toUpper)\n        }\n    }\n    // return \"\".join(result)\n    result.mkString\n}\n",
            "def stringToMd5(txt: String): Option[String] = {\n    // if not txt:\n    if (txt == null || txt.isEmpty) {\n        // return None\n        return None\n    }\n    // md5_hash = hashlib.md5()\n    val md5_hash = MessageDigest.getInstance(\"MD5\")\n    // txt_bytes = txt.encode()\n    val txt_bytes = txt.getBytes()\n    // md5_hash.update(txt_bytes)\n    md5_hash.update(txt_bytes)\n    // md5_encoded = md5_hash.hexdigest()\n    val md5_encoded = md5_hash.digest().map(\"%02x\".format(_)).mkString\n    // return md5_encoded\n    Some(md5_encoded)\n}\n",
            "def generateIntegers(a: Int, b: Int): Seq[Int] = {\n    // lower = max(2, min(a, b))\n    val lower = math.max(2, math.min(a, b))\n    // upper = min(8, max(a, b))\n    val upper = math.min(8, math.max(a, b))\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    (lower to upper).filter(_ % 2 == 0)\n}\n"
        ],
        "swift": [
            "func hasCloseElements(_ numbers: [Float], _ threshold: Float) -> Bool {\n    // for i in range(len(numbers)):\n    for i in 0..<numbers.count {\n        // for j in range(i + 1, len(numbers)):\n        for j in i + 1..<numbers.count {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if abs(numbers[i] - numbers[j]) < threshold {\n                // return True\n                return true\n            }\n        }\n    }\n    // return False\n    return false\n}\n",
            "func separateParenGroups(_ parenString: String) -> [String] {\n    // groups = []\n    var groups = [String]()\n    // stk = []\n    var stk = [Character]()\n    // current_group = \"\"\n    var currentGroup = \"\"\n    // parens = paren_string.replace(\" \", \"\")\n    let parens = parenString.replacingOccurrences(of: \" \", with: \"\")\n    // for ch in parens:\n    for ch in parens {\n        // if ch == \"(\":\n        if ch == \"(\" {\n            // stk.append(ch)\n            stk.append(ch)\n            // current_group += ch\n            currentGroup.append(ch)\n        }\n        // elif ch == \")\":\n        else if ch == \")\" {\n            // stk.pop()\n            stk.removeLast()\n            // current_group += ch\n            currentGroup.append(ch)\n            // if not stk:\n            if stk.isEmpty {\n                // groups.append(current_group)\n                groups.append(currentGroup)\n                // current_group = \"\"\n                currentGroup = \"\"\n            }\n        }\n    }\n    // return groups\n    return groups\n}\n",
            "func truncateNumber(_ num: Float) -> Float {\n    // return num - floor(num)\n    return num - floor(num)\n}\n",
            "func belowZero(_ operations: [Int]) -> Bool {\n    // balance = 0\n    var balance = 0\n    // for op in operations:\n    for op in operations {\n        // balance += op\n        balance += op\n        // if balance < 0:\n        if balance < 0 {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "func meanAbsoluteDeviation(_ numbers: [Float]) -> Float {\n    // mean = sum(numbers) / len(numbers)\n    let mean = numbers.reduce(0, +) / Float(numbers.count)\n    // deviation = sum(abs(x - mean) for x in numbers)\n    let deviation = numbers.map { abs($0 - mean) }.reduce(0, +)\n    // return deviation / len(numbers)\n    return deviation / Float(numbers.count)\n}\n",
            "func intersperse(_ numbers: [Int], _ delimiter: Int) -> [Int] {\n    // result = []\n    var result = [Int]()\n    // for i in range(len(numbers)):\n    for i in 0..<numbers.count {\n        // if i != 0:\n        if i != 0 {\n            // result.append(delimiter)\n            result.append(delimiter)\n        }\n        // result.append(numbers[i])\n        result.append(numbers[i])\n    }\n    // return result\n    return result\n}\n",
            "func parseNestedParens(_ parenString: String) -> [Int] {\n    // result = []\n    var result = [Int]()\n    // paren_groups = paren_string.split()\n    let parenGroups = parenString.split(separator: \" \")\n    // for group in paren_groups:\n    for group in parenGroups {\n        // max_depth = 0\n        var maxDepth = 0\n        // depth = 0\n        var depth = 0\n        // for ch in group:\n        for ch in group {\n            // if ch == \"(\":\n            if ch == \"(\" {\n                // depth += 1\n                depth += 1\n                // max_depth = max(max_depth, depth)\n                maxDepth = max(maxDepth, depth)\n            }\n            // elif ch == \")\":\n            else if ch == \")\" {\n                // depth -= 1\n                depth -= 1\n            }\n        }\n        // result.append(max_depth)\n        result.append(maxDepth)\n    }\n    // return result\n    return result\n}\n",
            "func filterBySubstring(_ strs: [String], _ substring: String) -> [String] {\n    // return [s for s in strs if substring in s]\n    return strs.filter { substring.contains($0) }\n}\n",
            "func sumProduct(_ numbers: [Int]) -> [Int] {\n    // n_sum = sum(numbers)\n    let nSum = numbers.reduce(0, +)\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    let nProduct = numbers.reduce(1, *)\n    // return [n_sum, n_product]\n    return [nSum, nProduct]\n}\n",
            "func rollingMax(_ numbers: [Int]) -> [Int] {\n    // max_so_far = float(\"-inf\")\n    var maxSoFar = Float.leastNonzeroMagnitude\n    // result = []\n    var result = [Int]()\n    // for num in numbers:\n    for num in numbers {\n        // max_so_far = max(max_so_far, num)\n        maxSoFar = max(maxSoFar, Float(num))\n        // result.append(max_so_far)\n        result.append(Int(maxSoFar))\n    }\n    // return result\n    return result\n}\n",
            "func isPalindrome(_ s: String) -> Bool {\n    // return s == s[::-1]\n    return s == String(s.reversed())\n}\nfunc makePalindrome(_ s: String) -> String {\n    // if is_palindrome(s):\n    if isPalindrome(s) {\n        // return s\n        return s\n    }\n    // for i in range(len(s)):\n    for i in 0..<s.count {\n        // if is_palindrome(s[i:]):\n        if isPalindrome(String(s.suffix(s.count - i))) {\n            // return s + s[:i][::-1]\n            return s + String(s.prefix(i).reversed())\n        }\n    }\n    // return \"\"\n    return \"\"\n}\n",
            "func stringXor(_ a: String, _ b: String) -> String {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    return String(zip(a, b).map { x, y in x == y ? \"0\" : \"1\" })\n}\n",
            "func longest(_ strs: [String]) -> String? {\n    // if not strs:\n    if strs.isEmpty {\n        // return None\n        return nil\n    }\n    // longest_s = strs[0]\n    var longest_s = strs[0]\n    // for s in strs:\n    for s in strs {\n        // if len(s) > len(longest_s):\n        if s.count > longest_s.count {\n            // longest_s = s\n            longest_s = s\n        }\n    }\n    // return longest_s\n    return longest_s\n}\n",
            "func greatestCommonDivisor(_ a: Int, _ b: Int) -> Int {\n    // if b == 0:\n    if b == 0 {\n        // return a\n        return a\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        return greatestCommonDivisor(b, a % b)\n    }\n}\n",
            "func allPrefixes(_ s: String) -> [String] {\n    // prefixes = []\n    var prefixes = [String]()\n    // for i in range(len(s)):\n    for i in 0..<s.count {\n        // prefixes.append(s[: i + 1])\n        prefixes.append(String(s.prefix(i + 1)))\n    }\n    // return prefixes\n    return prefixes\n}\n",
            "func stringSequence(_ n: Int) -> String {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    return (0...n).map { String($0) }.joined(separator: \" \")\n}\n",
            "func countDistinctCharacters(_ s: String) -> Int {\n    // return len(set(s.lower()))\n    return Set(s.lowercased()).count\n}\n",
            "func parseMusic(_ musicString: String) -> [Int] {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    let durations: [String: Int] = [\"o\": 4, \"o|\": 2, \".|\": 1]\n    // notes = music_string.split()\n    let notes = musicString.split(separator: \" \")\n    // return [durations[note] for note in notes]\n    return notes.map { durations[$0]! }\n}\n",
            "func howManyTimes(_ s: String, _ substring: String) -> Int {\n    // times = 0\n    var times = 0\n    // for i in range(len(s) - len(substring) + 1):\n    for i in 0 ..< s.count - substring.count + 1 {\n        // if s[i : i + len(substring)] == substring:\n        if s[s.index(s.startIndex, offsetBy: i)..<s.index(s.startIndex, offsetBy: i + substring.count)] == substring {\n            // times += 1\n            times += 1\n        }\n    }\n    // return times\n    return times\n}\n",
            "func sortNumbers(_ numbers: String) -> String {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    let numDict: [String: Int] = [\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    ]\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    let numList = numbers.split(separator: \" \").filter { numDict[$0] != nil }\n    // num_list.sort(key=lambda x: num_dict[x])\n    numList.sort { numDict[$0]! < numDict[$1]! }\n    // return \" \".join(num_list)\n    return numList.joined(separator: \" \")\n}\n",
            "func findClosestElements(_ numbers: [Float]) -> [Float] {\n    // sorted_numbers = sorted(numbers)\n    let sortedNumbers = numbers.sorted()\n    // min_diff = float(\"inf\")\n    var minDiff = Float.infinity\n    // closest_pair = []\n    var closestPair = [Float]()\n    // for i in range(1, len(sorted_numbers)):\n    for i in 1..<sortedNumbers.count {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        let diff = sortedNumbers[i] - sortedNumbers[i - 1]\n        // if diff < min_diff:\n        if diff < minDiff {\n            // min_diff = diff\n            minDiff = diff\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closestPair = [sortedNumbers[i - 1], sortedNumbers[i]]\n        }\n    }\n    // return closest_pair\n    return closestPair\n}\n",
            "func rescaleToUnit(_ numbers: [Float]) -> [Float] {\n    // min_num = min(numbers)\n    let minNum = numbers.min()!\n    // max_num = max(numbers)\n    let maxNum = numbers.max()!\n    // if min_num == max_num:\n    if minNum == maxNum {\n        // return [0.0] * len(numbers)\n        return [Float](repeating: 0.0, count: numbers.count)\n    } else {\n        // return [(num - min_num) / (max_num - min_num) for num in numbers]\n        return numbers.map { (num: Float) -> Float in\n            return (num - minNum) / (maxNum - minNum)\n        }\n    }\n}\n",
            "func filterIntegers(_ values: [Any]) -> [Int] {\n    // return [x for x in values if isinstance(x, int)]\n    return values.filter { x in\n        return x is Int\n    } as! [Int]\n}\n",
            "func strLength(_ s: String) -> Int {\n    // return len(s)\n    return s.count\n}\n",
            "func largestDivisor(_ n: Int) -> Int {\n    // for i in range(2, n):\n    for i in 2..<n {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return n // i\n            return n / i\n        }\n    }\n    // return 1\n    return 1\n}\n",
            "func factorize(_ n: Int) -> [Int] {\n    // factors = []\n    var factors = [Int]()\n    // divisor = 2\n    var divisor = 2\n    // while divisor <= n:\n    while divisor <= n {\n        // if n % divisor == 0:\n        if n % divisor == 0 {\n            // factors.append(divisor)\n            factors.append(divisor)\n            // n //= divisor\n            n /= divisor\n        } else {\n            // divisor += 1\n            divisor += 1\n        }\n    }\n    // return factors\n    return factors\n}\n",
            "func removeDuplicates(_ numbers: [Int]) -> [Int] {\n    // counts = {}\n    var counts = [Int: Int]()\n    // for num in numbers:\n    for num in numbers {\n        // counts[num] = counts.get(num, 0) + 1\n        counts[num] = (counts[num] ?? 0) + 1\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    var res = [Int]()\n    for num in numbers {\n        if counts[num] == 1 {\n            res.append(num)\n        }\n    }\n    // return res\n    return res\n}\n",
            "func flipCase(_ s: String) -> String {\n    // flipped = []\n    var flipped = [Character]()\n    // for ch in s:\n    for ch in s {\n        // if not ch.isalpha():\n        if !ch.isLetter {\n            // flipped.append(ch)\n            flipped.append(ch)\n        }\n        // elif ch.islower():\n        else if ch.isLowercase {\n            // flipped.append(ch.upper())\n            flipped.append(ch.uppercased())\n        }\n        // elif ch.isupper():\n        else if ch.isUppercase {\n            // flipped.append(ch.lower())\n            flipped.append(ch.lowercased())\n        }\n    }\n    // return ''.join(flipped)\n    return String(flipped)\n}\n",
            "func concatenate(_ strs: [String]) -> String {\n    // return \"\".join(strs)\n    return strs.joined()\n}\n",
            "func filterByPrefix(_ strs: [String], _ prefixStr: String) -> [String] {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    return strs.filter { $0.hasPrefix(prefixStr) }\n}\n",
            "func getPositive(_ l: [Int]) -> [Int] {\n    // return [num for num in l if num > 0]\n    return l.filter { $0 > 0 }\n}\n",
            "func isPrime(_ n: Int) -> Bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2...Int(sqrt(Double(n))) {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\n",
            "func poly(_ xs: [Int], _ x: Float) -> Float {\n    var res: Float = 0.0\n    for i in 0..<xs.count {\n        res += Float(xs[i]) * pow(x, Float(i))\n    }\n    return res\n}\nfunc findZero(_ xs: [Int]) -> Float {\n    var x1: Float = 1.0\n    var x2: Float = -1.0\n    while poly(xs, x1) * poly(xs, x2) > 0 {\n        x1 *= 2\n        x2 *= 2\n    }\n    while abs(x1 - x2) > 1e-10 {\n        let mid: Float = (x1 + x2) / 2\n        if poly(xs, mid) == 0 {\n            return mid\n        } else if poly(xs, mid) * poly(xs, x1) < 0 {\n            x2 = mid\n        } else {\n            x1 = mid\n        }\n    }\n    return (x1 + x2) / 2\n}\n",
            "func sortThird(_ l: [Int]) -> [Int] {\n    // sorted_third = sorted(l[::3])\n    let sortedThird = l[::3].sorted()\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    return l.enumerated().map { i, e in\n        if i % 3 == 0 {\n            return sortedThird[i / 3]\n        } else {\n            return e\n        }\n    }\n}\n",
            "func listUnique(_ l: [Int]) -> [Int] {\n    // return sorted(list(set(l)))\n    return Array(Set(l)).sorted()\n}\n",
            "func maxElement(_ l: [Int]) -> Int {\n    // if not l:\n    if l.isEmpty {\n        // return 0\n        return 0\n    }\n    // return max(l)\n    return l.max()!\n}\n",
            "func fizzBuzz(_ n: Int) -> Int {\n    // cnt = 0\n    var cnt = 0\n    // for i in range(n):\n    for i in 0..<n {\n        // if i % 11 == 0 or i % 13 == 0:\n        if i % 11 == 0 || i % 13 == 0 {\n            // cnt += str(i).count(\"7\")\n            cnt += String(i).filter({ $0 == \"7\" }).count\n        }\n    }\n    // return cnt\n    return cnt\n}\n",
            "func sortEven(_ l: [Int]) -> [Int] {\n    // sorted_even = sorted(l[::2])\n    let sortedEven = l[::2].sorted()\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    return l.enumerated().map { i, e in\n        if i % 2 == 0 {\n            return sortedEven[i / 2]\n        } else {\n            return e\n        }\n    }\n}\n",
            "func encodeCyclic(_ s: String) -> String {\n    // result = []\n    var result = [String]()\n    // for i in range(0, len(s), 3):\n    for i in stride(from: 0, to: s.count, by: 3) {\n        // if i + 3 > len(s):\n        if i + 3 > s.count {\n            // result.append(s[i:])\n            result.append(String(s[i..<s.count]))\n        } else {\n            // result.append(s[i+1:i+3])\n            result.append(String(s[i+1..<i+3]))\n            // result.append(s[i])\n            result.append(String(s[i]))\n        }\n    }\n    // return \"\".join(result)\n    return result.joined()\n}\nfunc decodeCyclic(_ s: String) -> String {\n    return encodeCyclic(encodeCyclic(s))\n}\n",
            "func isPrime(_ n: Int) -> Bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2...Int(sqrt(Double(n))) {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc primeFib(_ n: Int) -> Int {\n    // f = [0, 1]\n    var f = [0, 1]\n    // cnt = 0\n    var cnt = 0\n    // while cnt < n:\n    while cnt < n {\n        // f = [f[1], f[0] + f[1]]\n        f = [f[1], f[0] + f[1]]\n        // if is_prime(f[1]):\n        if isPrime(f[1]) {\n            // cnt += 1\n            cnt += 1\n        }\n    }\n    // return f[1]\n    return f[1]\n}\n",
            "func triplesSumToZero(_ l: [Int]) -> Bool {\n    // for i in range(len(l)):\n    for i in 0..<l.count {\n        // for j in range(i + 1, len(l)):\n        for j in i + 1..<l.count {\n            // for k in range(j + 1, len(l)):\n            for k in j + 1..<l.count {\n                // if l[i] + l[j] + l[k] == 0:\n                if l[i] + l[j] + l[k] == 0 {\n                    // return True\n                    return true\n                }\n            }\n        }\n    }\n    // return False\n    return false\n}\n",
            "func carRaceCollision(_ n: Int) -> Int {\n    // return n ** 2\n    return Int(pow(Double(n), 2))\n}\n",
            "func incrList(_ l: [Int]) -> [Int] {\n    // return [i + 1 for i in l]\n    return l.map { $0 + 1 }\n}\n",
            "func pairsSumToZero(_ l: [Int]) -> Bool {\n    // seen = set()\n    var seen = Set<Int>()\n    // for num in l:\n    for num in l {\n        // if -num in seen:\n        if seen.contains(-num) {\n            // return True\n            return true\n        }\n        // seen.add(num)\n        seen.insert(num)\n    }\n    // return False\n    return false\n}\n",
            "func changeBase(_ x: Int, _ bas: Int) -> String {\n    // if x == 0:\n    if x == 0 {\n        // return \"0\"\n        return \"0\"\n    }\n    // digits = []\n    var digits = [String]()\n    // while x > 0:\n    while x > 0 {\n        // digits.append(str(x % bas))\n        digits.append(String(x % bas))\n        // x //= bas\n        x /= bas\n    }\n    // return \"\".join(digits[::-1])\n    return digits.reversed().joined()\n}\n",
            "func triangleArea(_ a: Int, _ h: Int) -> Float {\n    // return a * h / 2\n    return Float(a) * Float(h) / 2\n}\n",
            "func fib4(_ n: Int) -> Int {\n    // fib = [0, 0, 2, 0]\n    var fib = [0, 0, 2, 0]\n    // for i in range(4, n + 1):\n    for i in 4...n {\n        // fib[i % 4] = sum(fib)\n        fib[i % 4] = fib[0] + fib[1] + fib[2]\n    }\n    // return fib[n % 4]\n    return fib[n % 4]\n}\n",
            "func median(_ l: [Float]) -> Float {\n    // sl = sorted(l)\n    let sl = l.sorted()\n    // if len(l) % 2 != 0:\n    if l.count % 2 != 0 {\n        // return sl[len(l) // 2]\n        return sl[l.count / 2]\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (sl[l.count / 2] + sl[l.count / 2 - 1]) / 2\n    }\n}\n",
            "func isPalindrome(_ txt: String) -> Bool {\n    // return txt == txt[::-1]\n    return txt == String(txt.reversed())\n}\n",
            "func modp(_ n: Int, _ p: Int) -> Int {\n    // ret = 1\n    var ret = 1\n    // for _ in range(n):\n    for _ in 0..<n {\n        // ret = (ret * 2) % p\n        ret = (ret * 2) % p\n    }\n    // return ret\n    return ret\n}\n",
            "func encodeShift(_ s: String) -> String {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    let result = s.map { (ch: Character) -> Character in\n        let chCode = ch.asciiValue! - 97 + 5\n        let chCode2 = chCode % 26\n        return Character(UnicodeScalar(chCode2 + 97)!)\n    }\n    // return \"\".join(result)\n    return String(result)\n}\nfunc decodeShift(_ s: String) -> String {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    let result = s.map { (ch: Character) -> Character in\n        let chCode = ch.asciiValue! - 97 + 21\n        let chCode2 = chCode % 26\n        return Character(UnicodeScalar(chCode2 + 97)!)\n    }\n    // return \"\".join(result)\n    return String(result)\n}\n",
            "func removeVowels(_ txt: String) -> String {\n    // vowels = \"aeiouAEIOU\"\n    let vowels = \"aeiouAEIOU\"\n    // return \"\".join([char for char in txt if char not in vowels])\n    return String(txt.filter { !vowels.contains($0) })\n}\n",
            "func belowThreshold(_ l: [Int], _ t: Int) -> Bool {\n    // return all(x < t for x in l)\n    return l.allSatisfy { $0 < t }\n}\n",
            "func add(_ x: Int, _ y: Int) -> Int {\n    // return x + y\n    return x + y\n}\n",
            "func sameChars(_ s0: String, _ s1: String) -> Bool {\n    // return set(s0) == set(s1)\n    return Set(s0) == Set(s1)\n}\n",
            "func fib(_ n: Int) -> Int {\n    // if n <= 1:\n    if n <= 1 {\n        // return n\n        return n\n    } else {\n        // return fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2)\n    }\n}\n",
            "func correctBracketing(_ brackets: String) -> Bool {\n    // depth = 0\n    var depth = 0\n    // for b in brackets:\n    for b in brackets {\n        // if b == \"<\":\n        if b == \"<\" {\n            // depth += 1\n            depth += 1\n        }\n        // elif b == \">\":\n        else if b == \">\" {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if depth < 0 {\n            // return False\n            return false\n        }\n    }\n    // return depth == 0\n    return depth == 0\n}\n",
            "func monotonic(_ l: [Int]) -> Bool {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    let diff = zip(l, l.dropFirst()).map { $0.1 - $0.0 }\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    return diff.allSatisfy { $0 <= 0 } || diff.allSatisfy { $0 >= 0 }\n}\n",
            "func common(_ l1: [Int], _ l2: [Int]) -> [Int] {\n    // return sorted(list(set(l1) & set(l2)))\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n}\n",
            "func largestPrimeFactor(_ n: Int) -> Int {\n    // i = 2\n    var i = 2\n    // while i * i <= n:\n    while i * i <= n {\n        // if n % i:\n        if n % i != 0 {\n            // i += 1\n            i += 1\n        } else {\n            // n //= i\n            n /= i\n        }\n    }\n    // return n\n    return n\n}\n",
            "func sumToN(_ n: Int) -> Int {\n    // return sum(range(n + 1))\n    return (1...n).reduce(0, +)\n}\n",
            "func correctBracketing(_ brackets: String) -> Bool {\n    // depth = 0\n    var depth = 0\n    // for b in brackets:\n    for b in brackets {\n        // if b == \"(\":\n        if b == \"(\" {\n            // depth += 1\n            depth += 1\n        }\n        // elif b == \")\":\n        else if b == \")\" {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if depth < 0 {\n            // return False\n            return false\n        }\n    }\n    // return depth == 0\n    return depth == 0\n}\n",
            "func derivative(_ xs: [Int]) -> [Int] {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    return xs.enumerated().map { $0 * $1 }\n}\n",
            "func fibfib(_ n: Int) -> Int {\n    // if n <= 1:\n    if n <= 1 {\n        // return 0 \n        return 0\n    }\n    // a, b, c = 0, 0, 1\n    var a = 0\n    var b = 0\n    var c = 1\n    // while n > 2:\n    while n > 2 {\n        // a, b, c = b, c, a + b + c\n        (a, b, c) = (b, c, a + b + c)\n        // n -= 1\n        n -= 1\n    }\n    // return c\n    return c\n}\n",
            "func vowelsCount(_ s: String) -> Int {\n    // vowels = \"aeiou\"\n    let vowels = \"aeiou\"\n    // cnt = 0\n    var cnt = 0\n    // for i in range(len(s)):\n    for i in 0..<s.count {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if vowels.contains(s[i].lowercased()) || (i == s.count - 1 && s[i].lowercased() == \"y\") {\n            // cnt += 1\n            cnt += 1\n        }\n    }\n    // return cnt\n    return cnt\n}\n",
            "func circularShift(_ x: Int, _ shift: Int) -> String {\n    // x_str = str(x)\n    let x_str = String(x)\n    // if shift > len(x_str):\n    if shift > x_str.count {\n        // return x_str[::-1]\n        return String(x_str.reversed())\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return String(x_str.suffix(shift)) + String(x_str.prefix(x_str.count - shift))\n    }\n}\n",
            "func digitSum(_ s: String) -> Int {\n    // return sum(ord(c) for c in s if c.isupper())\n    return s.uppercased().unicodeScalars.reduce(0) { $0 + Int(String($1))! }\n}\n",
            "func fruitDistribution(_ s: String, _ n: Int) -> Int {\n    // words = s.split(' ')\n    let words = s.split(separator: \" \")\n    // apples = int(words[words.index(\"apples\") - 1])\n    let apples = Int(words[words.firstIndex(of: \"apples\")! - 1])!\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    let oranges = Int(words[words.firstIndex(of: \"oranges\")! - 1])!\n    // return n - apples - oranges\n    return n - apples - oranges\n}\n",
            "func pluck(_ arr: [Int]) -> [Int] {\n    // evens = [n for n in arr if n % 2 == 0]\n    let evens = arr.filter { $0 % 2 == 0 }\n    // if len(evens) == 0:\n    if evens.count == 0 {\n        // return []\n        return []\n    }\n    // min_even = min(evens)\n    let minEven = evens.min()!\n    // return [min_even, arr.index(min_even)]\n    return [minEven, arr.firstIndex(of: minEven)!]\n}\n",
            "func search(_ lst: [Int]) -> Int {\n    // freqs = {}\n    var freqs = [Int: Int]()\n    // for n in lst:\n    for n in lst {\n        // freqs[n] = freqs.get(n, 0) + 1\n        freqs[n] = (freqs[n] ?? 0) + 1\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    let goodVals = freqs.filter { $0.value >= $0.key }.map { $0.key }\n    // return max(good_vals, default=-1)\n    return goodVals.max() ?? -1\n}\n",
            "func strangeSortList(_ lst: [Int]) -> [Int] {\n    // sl = sorted(lst)\n    let sl = lst.sorted()\n    // result = []\n    var result = [Int]()\n    // left, right = 0, len(sl) - 1\n    var left = 0\n    var right = sl.count - 1\n    // while left <= right:\n    while left <= right {\n        // result.append(sl[left])\n        result.append(sl[left])\n        // left += 1\n        left += 1\n        // if left <= right:\n        if left <= right {\n            // result.append(sl[right])\n            result.append(sl[right])\n            // right -= 1\n            right -= 1\n        }\n    }\n    // return result\n    return result\n}\n",
            "func triangleArea(_ a: Int, _ b: Int, _ c: Int) -> Float {\n    // if a + b > c and a + c > b and b + c > a:\n    if a + b > c && a + c > b && b + c > a {\n        // s = (a + b + c) / 2.0\n        let s = (a + b + c) / 2.0\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return sqrt(s * (s - Float(a)) * (s - Float(b)) * (s - Float(c)))\n    } else {\n        // return -1.0\n        return -1.0\n    }\n}\n",
            "func willItFly(_ q: [Int], _ w: Int) -> Bool {\n    // if len(q) == 0:\n    if q.isEmpty {\n        // return False\n        return false\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    let isPalin = q.indices.all { q[$0] == q[q.count - $0 - 1] }\n    // total = sum(q)\n    let total = q.reduce(0, +)\n    // return is_palin and total <= w\n    return isPalin && total <= w\n}\n",
            "func smallestChange(_ arr: [Int]) -> Int {\n    // ans = 0\n    var ans = 0\n    // for i in range(len(arr) // 2):\n    for i in 0..<(arr.count / 2) {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if arr[i] != arr[arr.count - i - 1] {\n            // ans += 1\n            ans += 1\n        }\n    }\n    // return ans\n    return ans\n}\n",
            "func totalMatch(_ lst1: [String], _ lst2: [String]) -> [String] {\n    // cnt1 = sum(len(s) for s in lst1)\n    let cnt1 = lst1.reduce(0) { $0 + $1.count }\n    // cnt2 = sum(len(s) for s in lst2)\n    let cnt2 = lst2.reduce(0) { $0 + $1.count }\n    // return lst1 if cnt1 <= cnt2 else lst2\n    return cnt1 <= cnt2 ? lst1 : lst2\n}\n",
            "func isPrime(_ n: Int) -> Bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2...Int(sqrt(Double(n))) + 1 {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc isMultiplyPrime(_ a: Int) -> Bool {\n    // cnt = 0\n    var cnt = 0\n    // for i in range(2, a + 1):\n    for i in 2...a + 1 {\n        // if is_prime(i):\n        if isPrime(i) {\n            // while a % i == 0:\n            while a % i == 0 {\n                // cnt += 1\n                cnt += 1\n                // a /= i\n                a /= i\n            }\n        }\n    }\n    // return cnt == 3\n    return cnt == 3\n}\n",
            "func isSimplePower(_ x: Int, _ n: Int) -> Bool {\n    // if n < 2:\n    if n < 2 {\n        // return x == n\n        return x == n\n    }\n    // tmp = 1\n    var tmp = 1\n    // while tmp < x:\n    while tmp < x {\n        // tmp *= n\n        tmp *= n\n    }\n    // return tmp == x\n    return tmp == x\n}\n",
            "func isCube(_ a: Int) -> Bool {\n    // a = abs(a)\n    let a = abs(a)\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    let root = Int(round(pow(Double(a), 1.0 / 3.0)))\n    // return root * root * root == a\n    return root * root * root == a\n}\n",
            "func hexKey(_ num: String) -> Int {\n    // return len([x for x in num if x in \"2357BD\"])\n    return num.filter { \"2357BD\".contains($0) }.count\n}\n",
            "func decimalToBinary(_ dec: Int) -> String {\n    // binary = bin(dec)[2:]\n    let binary = String(dec, radix: 2)\n    // return f\"db{binary}db\"\n    return \"db\\(binary)db\"\n}\n",
            "func isHappy(_ s: String) -> Bool {\n    // if len(s) < 3:\n    if s.count < 3 {\n        // return False\n        return false\n    }\n    // for i in range(len(s) - 2):\n    for i in 0..<s.count - 2 {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2] {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\n",
            "func numericalLetterGrade(_ grades: [Float]) -> [String] {\n    var result = [String]()\n    for g in grades {\n        if g == 4.0 {\n            result.append(\"A+\")\n        } else if g > 3.7 {\n            result.append(\"A\")\n        } else if g > 3.3 {\n            result.append(\"A-\")\n        } else if g > 3.0 {\n            result.append(\"B+\")\n        } else if g > 2.7 {\n            result.append(\"B\")\n        } else if g > 2.3 {\n            result.append(\"B-\")\n        } else if g > 2.0 {\n            result.append(\"C+\")\n        } else if g > 1.7 {\n            result.append(\"C\")\n        } else if g > 1.3 {\n            result.append(\"C-\")\n        } else if g > 1.0 {\n            result.append(\"D+\")\n        } else if g > 0.7 {\n            result.append(\"D\")\n        } else if g > 0.0 {\n            result.append(\"D-\")\n        } else {\n            result.append(\"E\")\n        }\n    }\n    return result\n}\n",
            "func primeLength(_ s: String) -> Bool {\n    // length = len(s)\n    let length = s.count\n    // if length < 2:\n    if length < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for i in 2...Int(sqrt(Double(length))) + 1 {\n        // if length % i == 0:\n        if length % i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\n",
            "func startsOneEnds(_ n: Int) -> Int {\n    // if n == 1:\n    if n == 1 {\n        // return 1\n        return 1\n    }\n    // return 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * (10 ** (n - 2))\n}\n",
            "func solve(_ n: Int) -> String {\n    // digits_sum = sum(int(d) for d in str(n))\n    let digitsSum = String(n).compactMap { Int(String($0)) }.reduce(0, +)\n    // return bin(digits_sum)[2:]\n    return String(digitsSum, radix: 2).dropFirst()\n}\n",
            "func add(_ lst: [Int]) -> Int {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    return lst.enumerated().filter { $0.offset % 2 == 1 && $0.element % 2 == 0 }.map { $0.element }.reduce(0, +)\n}\n",
            "func antiShuffle(_ s: String) -> String {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    let words = s.split(separator: \" \").map { word in\n        return String(word.sorted())\n    }\n    // return \" \".join(words)\n    return words.joined(separator: \" \")\n}\n",
            "func getRow(_ lst: [[Int]], _ x: Int) -> [[Int]] {\n    // coords = []\n    var coords = [[Int]]()\n    // for i in range(len(lst)):\n    for i in 0..<lst.count {\n        // for j in range(len(lst[i])):\n        for j in 0..<lst[i].count {\n            // if lst[i][j] == x:\n            if lst[i][j] == x {\n                // coords.append([i, j])\n                coords.append([i, j])\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    return coords.sorted { $0[0] < $1[0] || $0[0] == $1[0] && $0[1] > $1[1] }\n}\n",
            "func sortArray(_ arr: [Int]) -> [Int] {\n    // if len(arr) == 0:\n    if arr.count == 0 {\n        // return []\n        return []\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if (arr[0] + arr.last!) % 2 == 0 {\n        // return sorted(arr, reverse=True)\n        return arr.sorted(by: >)\n    } else {\n        // return sorted(arr)\n        return arr.sorted()\n    }\n}\n",
            "func encrypt(_ s: String) -> String {\n    // result = []\n    var result = [Character]()\n    // for ch in s:\n    for ch in s {\n        // shifted = ord(ch) + 4\n        let shifted = ch.asciiValue! + 4\n        // if shifted > ord('z'):\n        if shifted > 122 {\n            // shifted -= 26\n            shifted -= 26\n        }\n        // result.append(chr(shifted))\n        result.append(Character(UnicodeScalar(shifted)!))\n    }\n    // return \"\".join(result)\n    return String(result)\n}\n",
            "func nextSmallest(_ lst: [Int]) -> Int? {\n    // sl = sorted(set(lst))\n    let sl = Array(Set(lst)).sorted()\n    // if len(sl) < 2:\n    if sl.count < 2 {\n        // return None\n        return nil\n    }\n    // return sl[1]\n    return sl[1]\n}\n",
            "func isBored(_ s: String) -> Int {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    let sentences = s.split(separator: \".\", omittingEmptySubsequences: false)\n        .map { $0.split(separator: \"!\", omittingEmptySubsequences: false)\n            .map { $0.split(separator: \"?\", omittingEmptySubsequences: false) } }\n        .flatMap { $0 }\n        .map { $0.map { String($0) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .whitespaces) } }\n        .map { $0.map { $0.trimmingCharacters(in: .",
            "func anyInt(_ x: Any, _ y: Any, _ z: Any) -> Bool {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if let x = x as? Int, let y = y as? Int, let z = z as? Int {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if x + y == z || x + z == y || y + z == x {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "func encode(_ message: String) -> String {\n    // vowels = \"aeiouAEIOU\"\n    let vowels = \"aeiouAEIOU\"\n    // result = []\n    var result = [Character]()\n    // for ch in message:\n    for ch in message {\n        // if ch.isalpha():\n        if ch.isLetter {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            let ch1 = ch.isLowercase ? ch.uppercased() : ch.lowercased()\n            // if ch1 in vowels:\n            if vowels.contains(ch1) {\n                // ch1 = chr(ord(ch1) + 2)\n                let ch1 = Character(UnicodeScalar(ch1.unicodeScalars.first!.value + 2)!)\n                result.append(ch1)\n            } else {\n                result.append(ch1)\n            }\n        } else {\n            result.append(ch)\n        }\n    }\n    // return \"\".join(result)\n    return String(result)\n}\n",
            "func isPrime(_ n: Int) -> Bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2...Int(sqrt(Double(n))) {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc skjkasdkd(_ lst: [Int]) -> Int {\n    // primes = [n for n in lst if is_prime(n)]\n    let primes = lst.filter { isPrime($0) }\n    // if len(primes) == 0:\n    if primes.count == 0 {\n        // return 0\n        return 0\n    }\n    // largest = str(max(primes))\n    let largest = String(max(primes))\n    // return sum(int(digit) for digit in largest)\n    return largest.compactMap { Int(String($0)) }.reduce(0, +)\n}\n",
            "func checkDictCase(_ d: [String: String]) -> Bool {\n    // if not d:\n    if d.isEmpty {\n        // return False\n        return false\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    return d.keys.allSatisfy { $0.allSatisfy { $0.isLowercase } } || d.keys.allSatisfy { $0.allSatisfy { $0.isUppercase } }\n}\n",
            "func countUpTo(_ n: Int) -> [Int] {\n    // primes = []\n    var primes = [Int]()\n    // for num in range(2, n):\n    for num in 2..<n {\n        // if all(num % p != 0 for p in primes):\n        if primes.all({ num % $0 != 0 }) {\n            // primes.append(num)\n            primes.append(num)\n        }\n    }\n    // return primes\n    return primes\n}\n",
            "func multiply(_ a: Int, _ b: Int) -> Int {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    return abs(a) % 10 * abs(b) % 10\n}\n",
            "func countUpper(_ s: String) -> Int {\n    // vowels = \"AEIOU\"\n    let vowels = \"AEIOU\"\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    return s.enumerated().filter { $0.offset % 2 == 0 && vowels.contains($0.element) }.count\n}\n",
            "func closestInteger(_ value: String) -> Int {\n    // num = float(value)\n    let num = Float(value)\n    // if num >= 0:\n    if num! >= 0 {\n        // return int(num + 0.5)\n        return Int(num! + 0.5)\n    } else {\n        // return int(num - 0.5)\n        return Int(num! - 0.5)\n    }\n}\n",
            "func makeAPile(_ n: Int) -> [Int] {\n    // return [n + 2 * i for i in range(n)]\n    return (0..<n).map { n + 2 * $0 }\n}\n",
            "func wordsString(_ s: String) -> [String] {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    let words = s.components(separatedBy: CharacterSet(charactersIn: \", \"))\n    return words.filter { $0.count > 0 }\n}\n",
            "func chooseNum(_ x: Int, _ y: Int) -> Int {\n    // if x > y:\n    if x > y {\n        // return -1\n        return -1\n    }\n    // if y % 2 == 0:\n    if y % 2 == 0 {\n        // return y\n        return y\n    }\n    // return y - 1 if x != y else -1\n    return y - 1\n}\n",
            "func roundedAvg(_ n: Int, _ m: Int) -> String? {\n    // if n > m:\n    if n > m {\n        // return None\n        return nil\n    }\n    // r_avg = int((m + n) / 2.0 + 0.5)\n    let rAvg = Int((Double(m) + Double(n)) / 2.0 + 0.5)\n    // return bin(r_avg)[2:]\n    return String(rAvg, radix: 2)\n}\n",
            "func allDigitsOdd(_ s: String) -> Bool {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    return s.allSatisfy { Int(String($0))! % 2 != 0 }\n}\nfunc uniqueDigits(_ x: [Int]) -> [Int] {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    return x.filter { allDigitsOdd(String($0)) }.sorted()\n}\n",
            "func byLength(_ arr: [Int]) -> [String] {\n    let digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    let sortedArr = arr.filter { 1 <= $0 && $0 <= 9 }.sorted(by: >)\n    return sortedArr.map { digitNames[$0 - 1] }\n}\n",
            "func f(_ n: Int) -> [Int] {\n    // nums = list(range(1, n + 1))\n    let nums = Array(1...n)\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    return nums.map { i in\n        if i % 2 != 0 {\n            return nums[0..<i].reduce(0, +)\n        } else {\n            return nums[0..<i].reduce(1, *)\n        }\n    }\n}\n",
            "func isPalindrome(_ txt: String) -> Bool {\n    // return txt == txt[::-1]\n    return txt == String(txt.reversed())\n}\nfunc evenOddPalindrome(_ n: Int) -> [Int] {\n    // cnt = [0, 0]\n    var cnt = [0, 0]\n    // for i in range(1, n + 1):\n    for i in 1...n {\n        // if is_palindrome(str(i)):\n        if isPalindrome(String(i)) {\n            // cnt[i % 2] += 1\n            cnt[i % 2] += 1\n        }\n    }\n    // return cnt\n    return cnt\n}\n",
            "func digitsSum(_ n: Int) -> Int {\n    let nStr = String(n)\n    if n >= 0 {\n        return nStr.compactMap { Int(String($0)) }.reduce(0, +)\n    } else {\n        return Int(String(nStr.prefix(2)))! * 2 + digitsSum(abs(n))\n    }\n}\nfunc countNums(_ arr: [Int]) -> Int {\n    return arr.filter { digitsSum($0) > 0 }.count\n}\n",
            "func moveOneBall(_ arr: [Int]) -> Bool {\n    // if len(arr) == 0:\n    if arr.count == 0 {\n        // return True\n        return true\n    }\n    // sorted_arr = sorted(arr)\n    let sortedArr = arr.sorted()\n    // for i in range(0, len(arr)):\n    for i in 0..<arr.count {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if arr[i...] == sortedArr[0..<arr.count - i] && arr[0..<i] == sortedArr[arr.count - i..<arr.count] {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "func canExchange(_ lst1: [Int], _ lst2: [Int]) -> String {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    let odd_cnt = lst1.filter { $0 % 2 != 0 }.count\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    let even_cnt = lst2.filter { $0 % 2 == 0 }.count\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    return even_cnt >= odd_cnt ? \"YES\" : \"NO\"\n}\n",
            "func histogram(_ test: String) -> [String: Int] {\n    // freq = {}\n    var freq = [String: Int]()\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    let words = test.split(separator: \" \").filter { $0.count > 0 }\n    // for w in words:\n    for w in words {\n        // freq[w] = freq.get(w, 0) + 1\n        freq[w, default: 0] += 1\n    }\n    // result = {}\n    var result = [String: Int]()\n    // if len(freq) > 0:\n    if freq.count > 0 {\n        // max_freq = max(freq.values())\n        let max_freq = freq.values.max()!\n        // for k, v in freq.items():\n        for (k, v) in freq {\n            // if v == max_freq:\n            if v == max_freq {\n                // result[k] = v\n                result[k] = v\n            }\n        }\n    }\n    // return result\n    return result\n}\n",
            "func isPalindrome(_ s: String) -> Bool {\n    // return s == s[::-1]\n    return s == String(s.reversed())\n}\nfunc reverseDelete(_ s: String, _ c: String) -> [String] {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    let s1 = s.filter { !c.contains($0) }\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    return [s1, isPalindrome(s1) ? \"yes\" : \"no\"]\n}\n",
            "func oddCount(_ lst: [String]) -> [String] {\n    // result = []\n    var result = [String]()\n    // for num in lst:\n    for num in lst {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        var n = 0\n        for d in num {\n            n += Int(d.unicodeScalars.first!.value) % 2 == 1 ? 1 : 0\n        }\n        // rs = \"the number of odd elements in the string i of the input.\"\n        let rs = \"the number of odd elements in the string \\(n) of the input.\"\n        // result.append(rs.replace(\"i\", str(n)))\n        result.append(rs.replacingOccurrences(of: \"i\", with: String(n)))\n    }\n    // return result\n    return result\n}\n",
            "func minSubArraySum(_ nums: [Int]) -> Int {\n    // min_sum = 0\n    var minSum = 0\n    // cur_sum = 0\n    var curSum = 0\n    // for n in nums:\n    for n in nums {\n        // cur_sum = min(cur_sum + n, 0)\n        curSum = min(curSum + n, 0)\n        // min_sum = min(cur_sum, min_sum)\n        minSum = min(curSum, minSum)\n    }\n    // if min_sum == 0:\n    if minSum == 0 {\n        // min_sum = min(nums)\n        minSum = nums.min()!\n    }\n    // return min_sum\n    return minSum\n}\n",
            "func maxFill(_ grid: [[Int]], _ capacity: Int) -> Int {\n    // return sum([ceil(sum(arr) / capacity) for arr in grid])\n    return grid.map { arr in ceil(Double(arr.reduce(0, +)) / Double(capacity)) }.reduce(0, +)\n}\n",
            "func countOnes(_ num: Int) -> Int {\n    // return bin(num).count(\"1\")\n    return String(num, radix: 2).filter { $0 == \"1\" }.count\n}\nfunc sortArray(_ arr: [Int]) -> [Int] {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    return arr.sorted { countOnes($0) < countOnes($1) || ($0 == $1 && $0 < $1) }\n}\n",
            "func selectWords(_ s: String, _ n: Int) -> [String] {\n    // consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    let words = s.split(separator: \" \").filter { $0.count > 0 }\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    return words.filter { $0.count(where: { consonants.contains($0.lowercased()) }) == n }\n}\n",
            "func getClosestVowel(_ word: String) -> String {\n    // vowels = \"aeiouAEIOU\"\n    let vowels = \"aeiouAEIOU\"\n    // for i in range(len(word) - 2, 0, -1):\n    for i in stride(from: word.count - 2, through: 0, by: -1) {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if vowels.contains(word[i]) && !vowels.contains(word[i - 1]) && !vowels.contains(word[i + 1]) {\n            // return word[i]\n            return String(word[i])\n        }\n    }\n    // return \"\"\n    return \"\"\n}\n",
            "func check(_ s: String) -> Bool {\n    // depth = 0\n    var depth = 0\n    // for ch in s:\n    for ch in s {\n        // if ch == \"(\":\n        if ch == \"(\" {\n            // depth += 1\n            depth += 1\n        } else {\n            // depth -= 1\n            depth -= 1\n        }\n        // if depth < 0:\n        if depth < 0 {\n            // return False\n            return false\n        }\n    }\n    // return True if depth == 0 else False\n    return depth == 0\n}\nfunc matchParens(_ lst: [String]) -> String {\n    // s1 = lst[0] + lst[1]\n    let s1 = lst[0] + lst[1]\n    // s2 = lst[1] + lst[0]\n    let s2 = lst[1] + lst[0]\n    // return \"Yes\" if check(s1) or check(s2) else \"No\"\n    return check(s1) || check(s2) ? \"Yes\" : \"No\"\n}\n",
            "func maximum(_ arr: [Int], _ k: Int) -> [Int] {\n    // if k == 0:\n    if k == 0 {\n        // return []\n        return []\n    }\n    // return sorted(arr)[-k:]\n    return Array(arr.sorted().suffix(k))\n}\n",
            "func solution(_ lst: [Int]) -> Int {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    return lst.enumerated().filter { $0.offset % 2 == 0 && $0.element % 2 != 0 }.map { $0.element }.reduce(0, +)\n}\n",
            "func addElements(_ arr: [Int], _ k: Int) -> Int {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    return arr[0..<k].filter { len(String($0)) <= 2 }.reduce(0, +)\n}\n",
            "func getOddCollatz(_ n: Int) -> [Int] {\n    // collatz = [1]\n    var collatz = [1]\n    // while n != 1:\n    while n != 1 {\n        // if n % 2 != 0:\n        if n % 2 != 0 {\n            // collatz.append(n)\n            collatz.append(n)\n            // n = 3 * n + 1\n            n = 3 * n + 1\n        } else {\n            // n = n // 2\n            n = n / 2\n        }\n    }\n    // return sorted(collatz)\n    return collatz.sorted()\n}\n",
            "func validDate(_ date: String) -> Bool {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if date.count != 10 || date[2] != \"-\" || date[5] != \"-\" {\n        return false\n    }\n    // m = int(date[:2])\n    let m = Int(date[..<date.index(date.startIndex, offsetBy: 2)])!\n    // d = int(date[3:5])\n    let d = Int(date[date.index(date.startIndex, offsetBy: 3)..<date.index(date.startIndex, offsetBy: 5)])!\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if [1, 3, 5, 7, 8, 10, 12].contains(m) && d >= 1 && d <= 31 {\n        return true\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if [4, 6, 9, 11].contains(m) && d >= 1 && d <= 30 {\n        return true\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if m == 2 && d >= 1 && d <= 29 {\n        return true\n    }\n    // return False\n    return false\n}\n",
            "func splitWords(_ txt: String) -> [String] {\n    // if \" \" in txt:\n    if txt.contains(\" \") {\n        // return txt.split(\" \")\n        return txt.split(separator: \" \")\n    }\n    // elif \",\" in txt:\n    else if txt.contains(\",\") {\n        // return txt.split(\",\")\n        return txt.split(separator: \",\")\n    }\n    // else:\n    else {\n        // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        return [String(txt.count(where: { $0.isLowercase && $0.unicodeScalars.first!.value % 2 == 0 }))]\n    }\n}\n",
            "func isSorted(_ lst: [Int]) -> Bool {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    if !lst.enumerated().allSatisfy({ $0.offset > 0 && $0.element <= lst[$0.offset - 1] }) {\n        return false\n    }\n    // freq = {}\n    var freq = [Int: Int]()\n    // for i in lst:\n    for i in lst {\n        // freq[i] = freq.get(i, 0) + 1\n        freq[i, default: 0] += 1\n    }\n    // return max(freq.values(), default=0) <= 2\n    return freq.values.max() ?? 0 <= 2\n}\n",
            "func isPrime(_ n: Int) -> Bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2...Int(sqrt(Double(n))) {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc intersection(_ interval1: [Int], _ interval2: [Int]) -> String {\n    // l = max(interval1[0], interval2[0])\n    let l = max(interval1[0], interval2[0])\n    // r = min(interval1[1], interval2[1])\n    let r = min(interval1[1], interval2[1])\n    // length = r - l\n    let length = r - l\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    return length > 0 && isPrime(length) ? \"YES\" : \"NO\"\n}\n",
            "func prodSigns(_ arr: [Int]) -> Int? {\n    // if not arr:\n    if arr.isEmpty {\n        // return None\n        return nil\n    }\n    // if 0 in arr:\n    if arr.contains(0) {\n        // return 0\n        return 0\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    let sign = (arr.filter { $0 < 0 }.count % 2 == 1) ? -1 : 1\n    // return sign * sum([abs(n) for n in arr])\n    return sign * arr.map { abs($0) }.reduce(0, +)\n}\n",
            "func minPath(_ grid: [[Int]], _ k: Int) -> [Int] {\n    // n = len(grid)\n    let n = grid.count\n    // min_val = n * n + 1\n    var minVal = n * n + 1\n    // for i in range(n):\n    for i in 0..<n {\n        // for j in range(n):\n        for j in 0..<n {\n            // if grid[i][j] == 1:\n            if grid[i][j] == 1 {\n                // temp = []\n                var temp = [Int]()\n                // if i != 0:\n                if i != 0 {\n                    // temp.append(grid[i - 1][j])\n                    temp.append(grid[i - 1][j])\n                }\n                // if j != 0:\n                if j != 0 {\n                    // temp.append(grid[i][j - 1])\n                    temp.append(grid[i][j - 1])\n                }\n                // if i != n - 1:\n                if i != n - 1 {\n                    // temp.append(grid[i + 1][j])\n                    temp.append(grid[i + 1][j])\n                }\n                // if j != n - 1:\n                if j != n - 1 {\n                    // temp.append(grid[i][j + 1])\n                    temp.append(grid[i][j + 1])\n                }\n                // min_val = min(temp)\n                minVal = min(minVal, temp.min()!)\n            }\n        }\n    }\n    // result = []\n    var result = [Int]()\n    // for i in range(k):\n    for i in 0..<k {\n        // result.append(1 if i % 2 == 0 else min_val)\n        result.append(i % 2 == 0 ? 1 : minVal)\n    }\n    // return result\n    return result\n}\n",
            "func tri(_ n: Int) -> [Int] {\n    // if n == 0:\n    if n == 0 {\n        // return [1]\n        return [1]\n    }\n    // seq = [1, 3]\n    var seq = [1, 3]\n    // for i in range(2, n + 1):\n    for i in 2...n {\n        // if i % 2 == 0:\n        if i % 2 == 0 {\n            // seq.append(i / 2 + 1)\n            seq.append(i / 2 + 1)\n        } else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n        }\n    }\n    // return seq\n    return seq\n}\n",
            "func digits(_ n: Int) -> Int {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    let odds = String(n).compactMap { Int(String($0)) }.filter { $0 % 2 == 1 }\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    return odds.reduce(1, *)\n}\n",
            "func isNested(_ s: String) -> Bool {\n    // open_idx = []\n    var openIdx = [Int]()\n    // close_idx = []\n    var closeIdx = [Int]()\n    // for i, ch in enumerate(s):\n    for (i, ch) in s.enumerated() {\n        // if ch == '[':\n        if ch == \"[\" {\n            // open_idx.append(i)\n            openIdx.append(i)\n        }\n        // elif ch == ']':\n        else if ch == \"]\" {\n            // close_idx.append(i)\n            closeIdx.append(i)\n        }\n    }\n    // close_idx.reverse()\n    closeIdx.reverse()\n    // cnt = 0\n    var cnt = 0\n    // i = 0\n    var i = 0\n    // l = len(close_idx)\n    let l = closeIdx.count\n    // for idx in open_idx:\n    for idx in openIdx {\n        // if i < l and idx < close_idx[i]:\n        if i < l && idx < closeIdx[i] {\n            // cnt += 1\n            cnt += 1\n            // i += 1\n            i += 1\n        }\n    }\n    // return cnt >= 2\n    return cnt >= 2\n}\n",
            "func sumSquares(_ lst: [Float]) -> Int {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    return lst.map { pow(ceil($0), 2) }.reduce(0, +)\n}\n",
            "func checkIfLastCharIsALetter(_ txt: String) -> Bool {\n    // if not txt:\n    if txt.isEmpty {\n        // return False\n        return false\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    let last = txt[txt.lastIndex(of: \" \")!...]\n    // return len(last) == 1 and last[0].isalpha()\n    return last.count == 1 && last[last.startIndex].isLetter\n}\n",
            "func canArrange(_ arr: [Int]) -> Int {\n    // if len (arr) <= 1:\n    if arr.count <= 1 {\n        // return -1\n        return -1\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    let idx = (1..<arr.count).filter { arr[$0] < arr[$0 - 1] }\n    // return max(idx, default=-1)\n    return idx.max() ?? -1\n}\n",
            "func largestSmallestIntegers(_ lst: [Int]) -> [Int?] {\n    // neg = [i for i in lst if i < 0]\n    let neg = lst.filter { $0 < 0 }\n    // pos = [i for i in lst if i > 0]\n    let pos = lst.filter { $0 > 0 }\n    // max_neg = max(neg) if len(neg) > 0 else None\n    let maxNeg = neg.max() ?? nil\n    // min_pos = min(pos) if len(pos) > 0 else None\n    let minPos = pos.min() ?? nil\n    // return [max_neg, min_pos]\n    return [maxNeg, minPos]\n}\n",
            "func anyToReal(_ o: Any) -> Float {\n    // if isinstance(o, str): \n    if let o = o as? String {\n        // return float(o.replace(',','.'))\n        return Float(o.replacingOccurrences(of: \",\", with: \".\"))!\n    }\n    // elif isinstance(o, int):\n    else if let o = o as? Int {\n        // return float(o)\n        return Float(o)\n    }\n    // elif isinstance(o, float):\n    else if let o = o as? Float {\n        // return o\n        return o\n    }\n    // raise RuntimeError(\"Type Error\");\n    fatalError(\"Type Error\")\n}\nfunc compareOne(_ a: Any, _ b: Any) -> Any? {\n    // a1 = any_to_real(a)\n    let a1 = anyToReal(a)\n    // b1 = any_to_real(b)\n    let b1 = anyToReal(b)\n    // if a1 == b1:\n    if a1 == b1 {\n        // return None\n        return nil\n    }\n    // elif a1 > b1:\n    else if a1 > b1 {\n        // return a1\n        return a1\n    }\n    // else:\n    else {\n        // return b1\n        return b1\n    }\n}\n",
            "func isEqualToSumEven(_ n: Int) -> Bool {\n    // return n % 2 == 0 and n >= 8\n    return n % 2 == 0 && n >= 8\n}\n",
            "func specialFactorial(_ n: Int) -> Int {\n    // fact = 1\n    var fact = 1\n    // result = 1\n    var result = 1\n    // for i in range(1, n + 1):\n    for i in 1...n {\n        // fact *= i\n        fact *= i\n        // result *= fact\n        result *= fact\n    }\n    // return result\n    return result\n}\n",
            "func fixSpaces(_ txt: String) -> String {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    return txt.replacingOccurrences(of: \"\\\\s{3,}\", with: \"-\", options: .regularExpression).replacingOccurrences(of: \" \", with: \"_\")\n}\n",
            "func fileNameCheck(_ fileName: String) -> String {\n    // suf = [\"txt\", \"exe\", \"dll\"]\n    let suf = [\"txt\", \"exe\", \"dll\"]\n    // lst = file_name.split(\".\")\n    let lst = fileName.split(separator: \".\")\n    // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n    if lst.count != 2 || !suf.contains(lst[1]) || lst[0].count == 0 || !lst[0].first!.isLetter || lst[0].filter({ $0.isNumber }).count > 3 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n",
            "func sumSquares(_ lst: [Int]) -> Int {\n    // result = 0\n    var result = 0\n    // for i in range(len(lst)):\n    for i in 0..<lst.count {\n        // if i % 3 == 0:\n        if i % 3 == 0 {\n            // result += pow(lst[i], 2)\n            result += Int(pow(Double(lst[i]), 2))\n        }\n        // elif i % 4 == 0:\n        else if i % 4 == 0 {\n            // result += pow(lst[i], 3)\n            result += Int(pow(Double(lst[i]), 3))\n        }\n        // else:\n        else {\n            // result += lst[i]\n            result += lst[i]\n        }\n    }\n    // return result\n    return result\n}\n",
            "func isPrime(_ n: Int) -> Bool {\n    // if n < 2:\n    if n < 2 {\n        // return False\n        return false\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2...Int(sqrt(Double(n))) {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return False\n            return false\n        }\n    }\n    // return True\n    return true\n}\nfunc wordsInSentence(_ sentence: String) -> String {\n    // words = sentence.split(\" \")\n    let words = sentence.split(separator: \" \")\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    return words.filter { isPrime(Int($0.count)) }.joined(separator: \" \")\n}\n",
            "func simplify(_ x: String, _ n: String) -> Bool {\n    // xs = x.split(\"/\")\n    let xs = x.split(separator: \"/\")\n    // ns = n.split(\"/\")\n    let ns = n.split(separator: \"/\")\n    // num = int(xs[0]) * int(ns[0])\n    let num = Int(xs[0])! * Int(ns[0])!\n    // den = int(xs[1]) * int(ns[1])\n    let den = Int(xs[1])! * Int(ns[1])!\n    // return num % den == 0\n    return num % den == 0\n}\n",
            "func digitsSum(_ n: Int) -> Int {\n    let nStr = String(n)\n    if n >= 0 {\n        return nStr.compactMap { Int(String($0)) }.reduce(0, +)\n    } else {\n        return Int(String(nStr.prefix(2)))! * 2 + digitsSum(abs(n))\n    }\n}\nfunc orderByPoints(_ nums: [Int]) -> [Int] {\n    return nums.sorted { digitsSum($0) < digitsSum($1) }\n}\n",
            "func specialFilter(_ nums: [Int]) -> Int {\n    // odds = \"13579\"\n    let odds = \"13579\"\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    return nums.filter { $0 > 10 && $0 % 2 == 1 && odds.contains(String($0)[0]) }.count\n}\n",
            "func getMaxTriples(_ n: Int) -> Int {\n    // c = [0, 0, 0]\n    var c = [Int](repeating: 0, count: 3)\n    // for i in range(1, n + 1):\n    for i in 1...n {\n        // a = i * i - i + 1\n        let a = i * i - i + 1\n        // c[a % 3] += 1\n        c[a % 3] += 1\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n}\n",
            "func bf(_ planet1: String, _ planet2: String) -> [String] {\n    // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    let names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    // if planet1 not in names or planet2 not in names:\n    if !names.contains(planet1) || !names.contains(planet2) {\n        // return []\n        return []\n    }\n    // l = names.index(planet1)\n    let l = names.firstIndex(of: planet1)!\n    // r = names.index(planet2)\n    let r = names.firstIndex(of: planet2)!\n    // if l > r:\n    if l > r {\n        // l, r = r, l\n        let t = l\n        l = r\n        r = t\n    }\n    // if l == r:\n    if l == r {\n        // return []\n        return []\n    }\n    // return names[l + 1 : r]\n    return Array(names[l + 1 ..< r])\n}\n",
            "func sortedListSum(_ lst: [String]) -> [String] {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    let result = lst.filter { (s) -> Bool in\n        return s.count % 2 == 0\n    }\n    // return sorted(result, key=lambda x: (len(x), x))\n    return result.sorted { (s1, s2) -> Bool in\n        return s1.count < s2.count\n    }\n}\n",
            "func xOrY(_ n: Int, _ x: Int, _ y: Int) -> Int {\n    // if n < 2:\n    if n < 2 {\n        // return y\n        return y\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for i in 2...Int(sqrt(Double(n))) + 1 {\n        // if n % i == 0:\n        if n % i == 0 {\n            // return y\n            return y\n        }\n    }\n    // return x\n    return x\n}\n",
            "func doubleTheDifference(_ lst: [Float]) -> Int {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    return lst.filter { $0 >= 0 && $0.truncatingRemainder(dividingBy: 2) == 1 }.map { $0 * $0 }.reduce(0, +)\n}\n",
            "func compare(_ game: [Int], _ guess: [Int]) -> [Int] {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    return zip(game, guess).map { abs($0 - $1) }\n}\n",
            "func strongestExtension(_ className: String, _ extensions: [String]) -> String {\n    // max_s = float(\"-inf\")\n    var maxS = Float.leastNonzeroMagnitude\n    // max_ext = \"\"\n    var maxExt = \"\"\n    // for ext in extensions:\n    for ext in extensions {\n        // upper = len([c for c in ext if c.isupper()])\n        let upper = ext.filter { $0.isUppercase }.count\n        // lower = len([c for c in ext if c.islower()])\n        let lower = ext.filter { $0.isLowercase }.count\n        // s = upper - lower\n        let s = Float(upper) - Float(lower)\n        // if s > max_s:\n        if s > maxS {\n            // max_s = s\n            maxS = s\n            // max_ext = ext\n            maxExt = ext\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    return \"\\(className).\\(maxExt)\"\n}\n",
            "func cycpatternCheck(_ a: String, _ b: String) -> Bool {\n    // if len(a) < len(b):\n    if a.count < b.count {\n        // return False\n        return false\n    }\n    // for i in range(len(b)):\n    for i in 0..<b.count {\n        // if b[i:] + b[:i] in a:\n        if a.contains(b.suffix(b.count - i) + b.prefix(i)) {\n            // return True\n            return true\n        }\n    }\n    // return False\n    return false\n}\n",
            "func evenOddCount(_ num: Int) -> [Int] {\n    // ds = str(abs(num))\n    let ds = String(abs(num))\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    let even = ds.filter { Int(String($0))! % 2 == 0 }.count\n    // return [even, len(ds) - even]\n    return [even, ds.count - even]\n}\n",
            "func intToMiniRoman(_ num: Int) -> String {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    // res = []\n    var res = [String]()\n    // for i in range(len(values)):\n    for i in 0..<values.count {\n        // while num >= values[i]:\n        while num >= values[i] {\n            // res.append(numerals[i])\n            res.append(numerals[i])\n            // num -= values[i]\n            num -= values[i]\n        }\n    }\n    // return \"\".join(res)\n    return res.joined()\n}\n",
            "func rightAngleTriangle(_ a: Int, _ b: Int, _ c: Int) -> Bool {\n    // s = sorted([a, b, c])\n    let s = [a, b, c].sorted()\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n}\n",
            "func findMax(_ words: [String]) -> String {\n    // max_cnt = 0\n    var maxCnt = 0\n    // max_w = \"\"\n    var maxW = \"\"\n    // for w in words:\n    for w in words {\n        // cnt = len(set(w))\n        let cnt = Set(w).count\n        // if cnt > max_cnt:\n        if cnt > maxCnt {\n            // max_cnt = cnt\n            maxCnt = cnt\n            // max_w = w\n            maxW = w\n        }\n        // elif cnt == max_cnt:\n        else if cnt == maxCnt {\n            // max_w = min(max_w, w)\n            maxW = min(maxW, w)\n        }\n    }\n    // return max_w\n    return maxW\n}\n",
            "func eat(_ num: Int, _ need: Int, _ remaining: Int) -> [Int] {\n    // if need <= remaining:\n    if need <= remaining {\n        // return [num + need, remaining - need]\n        return [num + need, remaining - need]\n    } else {\n        // return [num + remaining, 0]\n        return [num + remaining, 0]\n    }\n}\n",
            "func doAlgebra(_ operators: [String], _ operands: [Int]) -> Int {\n    // ops = operators.copy()\n    var ops = operators\n    // nums = operands.copy()\n    var nums = operands\n    // i = len(ops) - 1\n    var i = ops.count - 1\n    // while i >= 0:\n    while i >= 0 {\n        // if ops[i] == \"**\":\n        if ops[i] == \"**\" {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            nums[i] = Int(pow(Double(nums[i]), Double(nums[i + 1])))\n            // nums.pop(i + 1)\n            nums.remove(at: i + 1)\n            // ops.pop(i)\n            ops.remove(at: i)\n        }\n        // i -= 1\n        i -= 1\n    }\n    // i = 0\n    i = 0\n    // while i < len(ops):\n    while i < ops.count {\n        // if ops[i] == \"*\":\n        if ops[i] == \"*\" {\n            // nums[i] = nums[i] * nums[i + 1]\n            nums[i] = nums[i] * nums[i + 1]\n            // nums.pop(i + 1)\n            nums.remove(at: i + 1)\n            // ops.pop(i)\n            ops.remove(at: i)\n            // i -= 1\n            i -= 1\n        // elif ops[i] == \"//\":\n        } else if ops[i] == \"//\" {\n            // nums[i] = nums[i] // nums[i + 1]\n            nums[i] = nums[i] / nums[i + 1]\n            // nums.pop(i + 1)\n            nums.remove(at: i + 1)\n            // ops.pop(i)\n            ops.remove(at: i)\n            // i -= 1\n            i -= 1\n        // i += 1\n        } else {\n            i += 1\n        }\n    }\n    // i = 0\n    i = 0\n    // while i < len(ops):\n    while i < ops.count {\n        // if ops[i] == \"+\":\n        if ops[i] == \"+\" {\n            // nums[i] = nums[i] + nums[i + 1]\n            nums[i] = nums[i] + nums[i + 1]\n            // nums.pop(i + 1)\n            nums.remove(at: i + 1)\n            // ops.pop(i)\n            ops.remove(at: i)\n            // i -= 1\n            i -= 1\n        // elif ops[i] == \"-\":\n        } else if ops[i] == \"-\" {\n            // nums[i] = nums[i] - nums[i + 1]\n            nums[i] = nums[i] - nums[i + 1]\n            // nums.pop(i + 1)\n            nums.remove(at: i + 1)\n            // ops.pop(i)\n            ops.remove(at: i)\n            // i -= 1\n            i -= 1\n        // i += 1\n        } else {\n            i += 1\n        }\n    }\n    // return nums[0]\n    return nums[0]\n}\n",
            "func solve(_ s: String) -> String {\n    // if not any(ch.isalpha() for ch in s):\n    if !s.contains(where: { $0.isLetter }) {\n        // return s[::-1]\n        return String(s.reversed())\n    }\n    // result = []\n    var result = [Character]()\n    // for ch in s:\n    for ch in s {\n        // if not ch.isalpha():\n        if !ch.isLetter {\n            // result.append(ch)\n            result.append(ch)\n        }\n        // elif ch.isupper():\n        else if ch.isUppercase {\n            // result.append(ch.lower())\n            result.append(ch.lowercased())\n        }\n        // elif ch.islower():\n        else if ch.isLowercase {\n            // result.append(ch.upper())\n            result.append(ch.uppercased())\n        }\n    }\n    // return \"\".join(result)\n    return String(result)\n}\n",
            "func stringToMD5(_ txt: String) -> String? {\n    // if not txt:\n    if txt.isEmpty {\n        // return None\n        return nil\n    }\n    // md5_hash = hashlib.md5()\n    let md5_hash = Insecure.MD5()\n    // txt_bytes = txt.encode()\n    let txt_bytes = txt.data(using: .utf8)!\n    // md5_hash.update(txt_bytes)\n    md5_hash.update(data: txt_bytes)\n    // md5_encoded = md5_hash.hexdigest()\n    let md5_encoded = md5_hash.finalize().map { String(format: \"%02x\", $0) }.joined()\n    // return md5_encoded\n    return md5_encoded\n}\n",
            "func generateIntegers(_ a: Int, _ b: Int) -> [Int] {\n    // lower = max(2, min(a, b))\n    let lower = max(2, min(a, b))\n    // upper = min(8, max(a, b))\n    let upper = min(8, max(a, b))\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    return (lower...upper).filter { $0 % 2 == 0 }\n}\n"
        ],
        "typescript": [
            "export const hasCloseElements = (numbers: Array<number>, threshold: number): boolean => {\n    // for i in range(len(numbers)):\n    for (let i = 0; i < numbers.length; i++) {\n        // for j in range(i + 1, len(numbers)):\n        for (let j = i + 1; j < numbers.length; j++) {\n            // if abs(numbers[i] - numbers[j]) < threshold:\n            if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n                // return True\n                return true;\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const separateParenGroups = (parenString: string): Array<string> => {\n    // groups = []\n    const groups: Array<string> = [];\n    // stk = []\n    const stk: Array<string> = [];\n    // current_group = \"\"\n    let currentGroup = \"\";\n    // parens = paren_string.replace(\" \", \"\")\n    const parens = parenString.replace(\" \", \"\");\n    // for ch in parens:\n    for (const ch of parens) {\n        // if ch == \"(\":\n        if (ch === \"(\") {\n            // stk.append(ch)\n            stk.push(ch);\n            // current_group += ch\n            currentGroup += ch;\n        }\n        // elif ch == \")\":\n        else if (ch === \")\") {\n            // stk.pop()\n            stk.pop();\n            // current_group += ch\n            currentGroup += ch;\n            // if not stk:\n            if (!stk.length) {\n                // groups.append(current_group)\n                groups.push(currentGroup);\n                // current_group = \"\"\n                currentGroup = \"\";\n            }\n        }\n    }\n    // return groups\n    return groups;\n}\n",
            "export const truncateNumber = (num: number): number => {\n    // return num - floor(num)\n    return num - floor(num);\n}\n",
            "export const belowZero = (operations: Array<number>): boolean => {\n    // balance = 0\n    let balance = 0;\n    // for op in operations:\n    for (const op of operations) {\n        // balance += op\n        balance += op;\n        // if balance < 0:\n        if (balance < 0) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const meanAbsoluteDeviation = (numbers: Array<number>): number => {\n    // mean = sum(numbers) / len(numbers)\n    const mean = numbers.reduce((a, b) => a + b) / numbers.length;\n    // deviation = sum(abs(x - mean) for x in numbers)\n    const deviation = numbers.reduce((a, b) => a + Math.abs(b - mean), 0);\n    // return deviation / len(numbers)\n    return deviation / numbers.length;\n}\n",
            "export const intersperse = (numbers: Array<number>, delimiter: number): Array<number> => {\n    // result = []\n    const result: Array<number> = [];\n    // for i in range(len(numbers)):\n    for (let i = 0; i < numbers.length; i++) {\n        // if i != 0:\n        if (i !== 0) {\n            // result.append(delimiter)\n            result.push(delimiter);\n        }\n        // result.append(numbers[i])\n        result.push(numbers[i]);\n    }\n    // return result\n    return result;\n}\n",
            "export const parseNestedParens = (parenString: string): Array<number> => {\n    // result = []\n    const result: Array<number> = [];\n    // paren_groups = paren_string.split()\n    const parenGroups = parenString.split(\" \");\n    // for group in paren_groups:\n    for (const group of parenGroups) {\n        // max_depth = 0\n        let maxDepth = 0;\n        // depth = 0\n        let depth = 0;\n        // for ch in group:\n        for (const ch of group) {\n            // if ch == \"(\":\n            if (ch === \"(\") {\n                // depth += 1\n                depth += 1;\n                // max_depth = max(max_depth, depth)\n                maxDepth = Math.max(maxDepth, depth);\n            }\n            // elif ch == \")\":\n            else if (ch === \")\") {\n                // depth -= 1\n                depth -= 1;\n            }\n        }\n        // result.append(max_depth)\n        result.push(maxDepth);\n    }\n    // return result\n    return result;\n}\n",
            "export const filterBySubstring = (strs: Array<string>, substring: string): Array<string> => {\n    // return [s for s in strs if substring in s]\n    return strs.filter(s => s.includes(substring));\n}\n",
            "export const sumProduct = (numbers: Array<number>): Array<number> => {\n    // n_sum = sum(numbers)\n    const nSum = numbers.reduce((a, b) => a + b);\n    // n_product = reduce(lambda x, y: x * y, numbers, 1)\n    const nProduct = reduce(numbers, (x, y) => x * y, 1);\n    // return [n_sum, n_product]\n    return [nSum, nProduct];\n}\n",
            "export const rollingMax = (numbers: Array<number>): Array<number> => {\n    // max_so_far = float(\"-inf\")\n    let maxSoFar = Number.NEGATIVE_INFINITY;\n    // result = []\n    const result: Array<number> = [];\n    // for num in numbers:\n    for (const num of numbers) {\n        // max_so_far = max(max_so_far, num)\n        maxSoFar = Math.max(maxSoFar, num);\n        // result.append(max_so_far)\n        result.push(maxSoFar);\n    }\n    // return result\n    return result;\n}\n",
            "export const isPalindrome = (s: string): boolean => {\n    // return s == s[::-1]\n    return s === s.split(\"\").reverse().join(\"\");\n}\nexport const makePalindrome = (s: string): string => {\n    // if is_palindrome(s):\n    if (isPalindrome(s)) {\n        // return s\n        return s;\n    }\n    // for i in range(len(s)):\n    for (let i = 0; i < s.length; i++) {\n        // if is_palindrome(s[i:]):\n        if (isPalindrome(s.slice(i))) {\n            // return s + s[:i][::-1]\n            return s + s.slice(0, i).split(\"\").reverse().join(\"\");\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "export const stringXor = (a: string, b: string): string => {\n    // return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n    return [...a].map((x, i) => (x === b[i] ? \"0\" : \"1\")).join(\"\");\n}\n",
            "export const longest = (strs: Array<string>): string | null => {\n    // if not strs:\n    if (!strs) {\n        // return None\n        return null;\n    }\n    // longest_s = strs[0]\n    let longestS = strs[0];\n    // for s in strs:\n    for (const s of strs) {\n        // if len(s) > len(longest_s):\n        if (s.length > longestS.length) {\n            // longest_s = s\n            longestS = s;\n        }\n    }\n    // return longest_s\n    return longestS;\n}\n",
            "export const greatestCommonDivisor = (a: number, b: number): number => {\n    // if b == 0:\n    if (b === 0) {\n        // return a\n        return a;\n    } else {\n        // return greatest_common_divisor(b, a % b)\n        return greatestCommonDivisor(b, a % b);\n    }\n}\n",
            "export const allPrefixes = (s: string): Array<string> => {\n    // prefixes = []\n    const prefixes: Array<string> = [];\n    // for i in range(len(s)):\n    for (let i = 0; i < s.length; i++) {\n        // prefixes.append(s[: i + 1])\n        prefixes.push(s.slice(0, i + 1));\n    }\n    // return prefixes\n    return prefixes;\n}\n",
            "export const stringSequence = (n: number): string => {\n    // return \" \".join([str(i) for i in range(n + 1)])\n    return Array.from(Array(n + 1).keys()).map(i => i.toString()).join(\" \");\n}\n",
            "export const countDistinctCharacters = (s: string): number => {\n    // return len(set(s.lower()))\n    return [...new Set(s.toLowerCase())].length;\n}\n",
            "export const parseMusic = (musicString: string): Array<number> => {\n    // durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    const durations: { [key: string]: number } = {\n        \"o\": 4,\n        \"o|\": 2,\n        \".|\": 1,\n    };\n    // notes = music_string.split()\n    const notes = musicString.split(\" \");\n    // return [durations[note] for note in notes]\n    return notes.map((note) => durations[note]);\n}\n",
            "export const howManyTimes = (s: string, substring: string): number => {\n    // times = 0\n    let times = 0;\n    // for i in range(len(s) - len(substring) + 1):\n    for (let i = 0; i < s.length - substring.length + 1; i++) {\n        // if s[i : i + len(substring)] == substring:\n        if (s.substring(i, i + substring.length) === substring) {\n            // times += 1\n            times += 1;\n        }\n    }\n    // return times\n    return times;\n}\n",
            "const sortNumbers = (numbers: string): string => {\n    // num_dict = {\n    //     \"zero\": 0,\n    //     \"one\": 1,\n    //     \"two\": 2,\n    //     \"three\": 3,\n    //     \"four\": 4,\n    //     \"five\": 5,\n    //     \"six\": 6,\n    //     \"seven\": 7,\n    //     \"eight\": 8,\n    //     \"nine\": 9,\n    // }\n    const numDict = {\n        zero: 0,\n        one: 1,\n        two: 2,\n        three: 3,\n        four: 4,\n        five: 5,\n        six: 6,\n        seven: 7,\n        eight: 8,\n        nine: 9,\n    };\n    // num_list = list(filter(lambda x: x in num_dict, numbers.split(\" \")))\n    const numList = numbers.split(\" \").filter((x) => x in numDict);\n    // num_list.sort(key=lambda x: num_dict[x])\n    numList.sort((a, b) => numDict[a] - numDict[b]);\n    // return \" \".join(num_list)\n    return numList.join(\" \");\n}\n",
            "export const findClosestElements = (numbers: Array<number>): Array<number> => {\n    // sorted_numbers = sorted(numbers)\n    const sortedNumbers = numbers.sort((a, b) => a - b);\n    // min_diff = float(\"inf\")\n    let minDiff = Number.POSITIVE_INFINITY;\n    // closest_pair = []\n    let closestPair: Array<number> = [];\n    // for i in range(1, len(sorted_numbers)):\n    for (let i = 1; i < sortedNumbers.length; i++) {\n        // diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        const diff = sortedNumbers[i] - sortedNumbers[i - 1];\n        // if diff < min_diff:\n        if (diff < minDiff) {\n            // min_diff = diff\n            minDiff = diff;\n            // closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closestPair = [sortedNumbers[i - 1], sortedNumbers[i]];\n        }\n    }\n    // return closest_pair\n    return closestPair;\n}\n",
            "export const rescaleToUnit = (numbers: Array<number>): Array<number> => {\n    // min_num = min(numbers)\n    const minNum = Math.min(...numbers);\n    // max_num = max(numbers)\n    const maxNum = Math.max(...numbers);\n    // if min_num == max_num:\n    if (minNum === maxNum) {\n        // return [0.0] * len(numbers)\n        return Array(numbers.length).fill(0.0);\n    } else {\n        // return [(num - min_num) / (max_num - min_num) for num in numbers]\n        return numbers.map(num => (num - minNum) / (maxNum - minNum));\n    }\n}\n",
            "export const filterIntegers = (values: Array<any>): Array<number> => {\n    // return [x for x in values if isinstance(x, int)]\n    return values.filter((x) => typeof x === \"number\");\n}\n",
            "export const strLength = (s: string): number => {\n    // return len(s)\n    return s.length;\n}\n",
            "export const largestDivisor = (n: number): number => {\n    // for i in range(2, n):\n    for (let i = 2; i < n; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return n // i\n            return n / i;\n        }\n    }\n    // return 1\n    return 1;\n}\n",
            "export const factorize = (n: number): Array<number> => {\n    // factors = []\n    const factors: Array<number> = [];\n    // divisor = 2\n    let divisor = 2;\n    // while divisor <= n:\n    while (divisor <= n) {\n        // if n % divisor == 0:\n        if (n % divisor === 0) {\n            // factors.append(divisor)\n            factors.push(divisor);\n            // n //= divisor\n            n /= divisor;\n        } else {\n            // divisor += 1\n            divisor++;\n        }\n    }\n    // return factors\n    return factors;\n}\n",
            "export const removeDuplicates = (numbers: Array<number>): Array<number> => {\n    // counts = {}\n    const counts: { [key: number]: number } = {};\n    // for num in numbers:\n    for (const num of numbers) {\n        // counts[num] = counts.get(num, 0) + 1\n        counts[num] = (counts[num] || 0) + 1;\n    }\n    // res = [num for num in numbers if counts[num] == 1]\n    const res: Array<number> = numbers.filter((num) => counts[num] === 1);\n    // return res\n    return res;\n}\n",
            "export const flipCase = (s: string): string => {\n    // flipped = []\n    const flipped: Array<string> = [];\n    // for ch in s:\n    for (const ch of s) {\n        // if not ch.isalpha():\n        if (!ch.match(/[a-zA-Z]/)) {\n            // flipped.append(ch)\n            flipped.push(ch);\n        }\n        // elif ch.islower():\n        else if (ch.match(/[a-z]/)) {\n            // flipped.append(ch.upper())\n            flipped.push(ch.toUpperCase());\n        }\n        // elif ch.isupper():\n        else if (ch.match(/[A-Z]/)) {\n            // flipped.append(ch.lower())\n            flipped.push(ch.toLowerCase());\n        }\n    }\n    // return ''.join(flipped)\n    return flipped.join('');\n}\n",
            "export const concatenate = (strs: Array<string>): string => {\n    // return \"\".join(strs)\n    return strs.join(\"\");\n}\n",
            "export const filterByPrefix = (strs: Array<string>, prefixStr: string): Array<string> => {\n    // return [s for s in strs if s.startswith(prefix_str)]\n    return strs.filter(s => s.startsWith(prefixStr));\n}\n",
            "export const getPositive = (l: Array<number>): Array<number> => {\n    // return [num for num in l if num > 0]\n    return l.filter(num => num > 0);\n}\n",
            "export const isPrime = (n: number): boolean => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "export const poly = (xs: Array<number>, x: number): number => {\n    // res = 0.0\n    let res = 0.0;\n    // for i in range(len(xs)):\n    for (let i = 0; i < xs.length; i++) {\n        // res += xs[i] * x**i\n        res += xs[i] * Math.pow(x, i);\n    }\n    // return res\n    return res;\n}\nexport const findZero = (xs: Array<number>): number => {\n    // x1, x2 = 1.0, -1.0\n    let x1 = 1.0;\n    let x2 = -1.0;\n    // while poly(xs, x1) * poly(xs, x2) > 0:\n    while (poly(xs, x1) * poly(xs, x2) > 0) {\n        // x1 *= 2\n        x1 *= 2;\n        // x2 *= 2\n        x2 *= 2;\n    }\n    // while abs(x1 - x2) > 1e-10:\n    while (Math.abs(x1 - x2) > 1e-10) {\n        // mid = (x1 + x2) / 2\n        const mid = (x1 + x2) / 2;\n        // if poly(xs, mid) == 0:\n        if (poly(xs, mid) === 0) {\n            // return mid\n            return mid;\n        }\n        // elif poly(xs, mid) * poly(xs, x1) < 0:\n        else if (poly(xs, mid) * poly(xs, x1) < 0) {\n            // x2 = mid\n            x2 = mid;\n        }\n        // else:\n        else {\n            // x1 = mid\n            x1 = mid;\n        }\n    }\n    // return (x1 + x2) / 2\n    return (x1 + x2) / 2;\n}\n",
            "export const sortThird = (l: Array<number>): Array<number> => {\n    // sorted_third = sorted(l[::3])\n    const sortedThird = l.filter((_, i) => i % 3 === 0).sort((a, b) => a - b);\n    // return [sorted_third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    return l.map((e, i) => i % 3 === 0 ? sortedThird[i / 3] : e);\n}\n",
            "export const listUnique = (l: Array<number>): Array<number> => {\n    // return sorted(list(set(l)))\n    return Array.from(new Set(l)).sort();\n}\n",
            "export const maxElement = (l: Array<number>): number => {\n    // if not l:\n    if (!l.length) {\n        // return 0\n        return 0;\n    }\n    // return max(l)\n    return Math.max(...l);\n}\n",
            "export const fizzBuzz = (n: number): number => {\n    // cnt = 0\n    let cnt = 0;\n    // for i in range(n):\n    for (let i = 0; i < n; i++) {\n        // if i % 11 == 0 or i % 13 == 0:\n        if (i % 11 === 0 || i % 13 === 0) {\n            // cnt += str(i).count(\"7\")\n            cnt += (i + \"\").split(\"7\").length - 1;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "export const sortEven = (l: Array<number>): Array<number> => {\n    // sorted_even = sorted(l[::2])\n    const sortedEven = l.filter((_, i) => i % 2 === 0).sort((a, b) => a - b);\n    // return [sorted_even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    return l.map((e, i) => i % 2 === 0 ? sortedEven[i / 2] : e);\n}\n",
            "export const encodeCyclic = (s: string): string => {\n    // result = []\n    const result: Array<string> = [];\n    // for i in range(0, len(s), 3):\n    for (let i = 0; i < s.length; i += 3) {\n        // if i + 3 > len(s):\n        if (i + 3 > s.length) {\n            // result.append(s[i:])\n            result.push(s.substring(i));\n        } else {\n            // result.append(s[i+1:i+3])\n            result.push(s.substring(i + 1, i + 3));\n            // result.append(s[i])\n            result.push(s[i]);\n        }\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\nexport const decodeCyclic = (s: string): string => {\n    // return encode_cyclic(encode_cyclic(s))\n    return encodeCyclic(encodeCyclic(s));\n}\n",
            "export const isPrime = (n: number): boolean => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const primeFib = (n: number): number => {\n    // f = [0, 1]\n    let f = [0, 1];\n    // cnt = 0\n    let cnt = 0;\n    // while cnt < n:\n    while (cnt < n) {\n        // f = [f[1], f[0] + f[1]]\n        f = [f[1], f[0] + f[1]];\n        // if is_prime(f[1]):\n        if (isPrime(f[1])) {\n            // cnt += 1\n            cnt += 1;\n        }\n    }\n    // return f[1]\n    return f[1];\n}\n",
            "export const triplesSumToZero = (l: Array<number>): boolean => {\n    // for i in range(len(l)):\n    for (let i = 0; i < l.length; i++) {\n        // for j in range(i + 1, len(l)):\n        for (let j = i + 1; j < l.length; j++) {\n            // for k in range(j + 1, len(l)):\n            for (let k = j + 1; k < l.length; k++) {\n                // if l[i] + l[j] + l[k] == 0:\n                if (l[i] + l[j] + l[k] === 0) {\n                    // return True\n                    return true;\n                }\n            }\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const carRaceCollision = (n: number): number => {\n    // return n ** 2\n    return n ** 2;\n}\n",
            "export const incrList = (l: Array<number>): Array<number> => {\n    // return [i + 1 for i in l]\n    return l.map(i => i + 1);\n}\n",
            "export const pairsSumToZero = (l: Array<number>): boolean => {\n    // seen = set()\n    const seen: Set<number> = new Set();\n    // for num in l:\n    for (const num of l) {\n        // if -num in seen:\n        if (seen.has(-num)) {\n            // return True\n            return true;\n        }\n        // seen.add(num)\n        seen.add(num);\n    }\n    // return False\n    return false;\n}\n",
            "export const changeBase = (x: number, bas: number): string => {\n    // if x == 0:\n    if (x === 0) {\n        // return \"0\"\n        return \"0\";\n    }\n    // digits = []\n    const digits: Array<string> = [];\n    // while x > 0:\n    while (x > 0) {\n        // digits.append(str(x % bas))\n        digits.push(String(x % bas));\n        // x //= bas\n        x = Math.floor(x / bas);\n    }\n    // return \"\".join(digits[::-1])\n    return digits.reverse().join(\"\");\n}\n",
            "export const triangleArea = (a: number, h: number): number => {\n    // return a * h / 2\n    return a * h / 2;\n}\n",
            "export const fib4 = (n: number): number => {\n    // fib = [0, 0, 2, 0]\n    const fib: Array<number> = [0, 0, 2, 0];\n    // for i in range(4, n + 1):\n    for (let i = 4; i <= n + 1; i++) {\n        // fib[i % 4] = sum(fib)\n        fib[i % 4] = fib.reduce((a, b) => a + b);\n    }\n    // return fib[n % 4]\n    return fib[n % 4];\n}\n",
            "export const median = (l: Array<number>): number => {\n    // sl = sorted(l)\n    const sl = l.slice().sort((a, b) => a - b);\n    // if len(l) % 2 != 0:\n    if (l.length % 2 !== 0) {\n        // return sl[len(l) // 2]\n        return sl[l.length / 2];\n    } else {\n        // return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n        return (sl[l.length / 2] + sl[l.length / 2 - 1]) / 2;\n    }\n}\n",
            "export const isPalindrome = (txt: string): boolean => {\n    // return txt == txt[::-1]\n    return txt === txt.split(\"\").reverse().join(\"\");\n}\n",
            "export const modp = (n: number, p: number): number => {\n    // ret = 1\n    let ret = 1;\n    // for _ in range(n):\n    for (let _ = 0; _ < n; _++) {\n        // ret = (ret * 2) % p\n        ret = (ret * 2) % p;\n    }\n    // return ret\n    return ret;\n}\n",
            "export const encodeShift = (s: string): string => {\n    // result = [chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    const result: Array<string> = [];\n    // for ch in s:\n    for (const ch of s) {\n        // result.append(chr(((ord(ch) - 97 + 5) % 26) + 97))\n        result.push(String.fromCharCode(((ch.charCodeAt(0) - 97 + 5) % 26) + 97));\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\nexport const decodeShift = (s: string): string => {\n    // result = [chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    const result: Array<string> = [];\n    // for ch in s:\n    for (const ch of s) {\n        // result.append(chr(((ord(ch) - 97 + 21) % 26) + 97))\n        result.push(String.fromCharCode(((ch.charCodeAt(0) - 97 + 21) % 26) + 97));\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\n",
            "export const removeVowels = (txt: string): string => {\n    // vowels = \"aeiouAEIOU\"\n    const vowels = \"aeiouAEIOU\";\n    // return \"\".join([char for char in txt if char not in vowels])\n    return [...txt].filter(char => !vowels.includes(char)).join(\"\");\n}\n",
            "export const belowThreshold = (l: Array<number>, t: number): boolean => {\n    // return all(x < t for x in l)\n    return l.every(x => x < t);\n}\n",
            "export const add = (x: number, y: number): number => {\n    // return x + y\n    return x + y;\n}\n",
            "export const sameChars = (s0: string, s1: string): boolean => {\n    // return set(s0) == set(s1)\n    return new Set(s0) === new Set(s1);\n}\n",
            "export const fib = (n: number): number => {\n    // if n <= 1:\n    if (n <= 1) {\n        // return n\n        return n;\n    } else {\n        // return fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n",
            "export const correctBracketing = (brackets: string): boolean => {\n    // depth = 0\n    let depth = 0;\n    // for b in brackets:\n    for (const b of brackets) {\n        // if b == \"<\":\n        if (b === \"<\") {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \">\":\n        else if (b === \">\") {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return depth === 0;\n}\n",
            "export const monotonic = (l: Array<number>): boolean => {\n    // diff = [y - x for x, y in zip(l, l[1:])]\n    const diff = l.slice(1).map((y, i) => y - l[i]);\n    // return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n    return diff.every(x => x <= 0) || diff.every(x => x >= 0);\n}\n",
            "export const common = (l1: Array<number>, l2: Array<number>): Array<number> => {\n    // return sorted(list(set(l1) & set(l2)))\n    return [...new Set(l1)].filter(e => l2.includes(e)).sort((a, b) => a - b);\n}\n",
            "export const largestPrimeFactor = (n: number): number => {\n    // i = 2\n    let i = 2;\n    // while i * i <= n:\n    while (i * i <= n) {\n        // if n % i:\n        if (n % i) {\n            // i += 1\n            i += 1;\n        } else {\n            // n //= i\n            n = Math.floor(n / i);\n        }\n    }\n    // return n\n    return n;\n}\n",
            "export const sumToN = (n: number): number => {\n    // return sum(range(n + 1))\n    return Array.from(Array(n + 1).keys()).reduce((a, b) => a + b);\n}\n",
            "export const correctBracketing = (brackets: string): boolean => {\n    // depth = 0\n    let depth = 0;\n    // for b in brackets:\n    for (const b of brackets) {\n        // if b == \"(\":\n        if (b === \"(\") {\n            // depth += 1\n            depth += 1;\n        }\n        // elif b == \")\":\n        else if (b === \")\") {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return depth == 0\n    return depth === 0;\n}\n",
            "export const derivative = (xs: Array<number>): Array<number> => {\n    // return [xs[i] * i for i in range(1, len(xs))]\n    return xs.slice(1).map((x, i) => x * (i + 1));\n}\n",
            "export const fibfib = (n: number): number => {\n    // if n <= 1:\n    if (n <= 1) {\n        // return 0 \n        return 0;\n    }\n    // a, b, c = 0, 0, 1\n    let a = 0;\n    let b = 0;\n    let c = 1;\n    // while n > 2:\n    while (n > 2) {\n        // a, b, c = b, c, a + b + c\n        a = b;\n        b = c;\n        c = a + b + c;\n        // n -= 1\n        n -= 1;\n    }\n    // return c\n    return c;\n}\n",
            "export const vowelsCount = (s: string): number => {\n    // vowels = \"aeiou\"\n    const vowels = \"aeiou\";\n    // cnt = 0\n    let cnt = 0;\n    // for i in range(len(s)):\n    for (let i = 0; i < s.length; i++) {\n        // if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n        if (vowels.includes(s[i].toLowerCase()) || (i === s.length - 1 && s[i].toLowerCase() === \"y\")) {\n            // cnt += 1\n            cnt++;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "export const circularShift = (x: number, shift: number): string => {\n    // x_str = str(x)\n    const xStr = x.toString();\n    // if shift > len(x_str):\n    if (shift > xStr.length) {\n        // return x_str[::-1]\n        return xStr.split(\"\").reverse().join(\"\");\n    } else {\n        // return x_str[-shift:] + x_str[:-shift]\n        return xStr.slice(-shift) + xStr.slice(0, -shift);\n    }\n}\n",
            "export const digitSum = (s: string): number => {\n    // return sum(ord(c) for c in s if c.isupper())\n    return [...s].reduce((sum, c) => sum + c.charCodeAt(0), 0);\n}\n",
            "export const fruitDistribution = (s: string, n: number): number => {\n    // words = s.split(' ')\n    const words = s.split(\" \");\n    // apples = int(words[words.index(\"apples\") - 1])\n    const apples = parseInt(words[words.indexOf(\"apples\") - 1]);\n    // oranges = int(words[words.index(\"oranges\") - 1])\n    const oranges = parseInt(words[words.indexOf(\"oranges\") - 1]);\n    // return n - apples - oranges\n    return n - apples - oranges;\n}\n",
            "export const pluck = (arr: Array<number>): Array<number> => {\n    // evens = [n for n in arr if n % 2 == 0]\n    const evens = arr.filter((n) => n % 2 === 0);\n    // if len(evens) == 0:\n    if (evens.length === 0) {\n        // return []\n        return [];\n    }\n    // min_even = min(evens)\n    const minEven = Math.min(...evens);\n    // return [min_even, arr.index(min_even)]\n    return [minEven, arr.indexOf(minEven)];\n}\n",
            "export const search = (lst: Array<number>): number => {\n    // freqs = {}\n    const freqs: { [key: number]: number } = {};\n    // for n in lst:\n    for (const n of lst) {\n        // freqs[n] = freqs.get(n, 0) + 1\n        freqs[n] = (freqs[n] || 0) + 1;\n    }\n    // good_vals = [k for k, v in freqs.items() if v >= k]\n    const goodVals: Array<number> = [];\n    for (const [k, v] of Object.entries(freqs)) {\n        if (v >= Number(k)) {\n            goodVals.push(Number(k));\n        }\n    }\n    // return max(good_vals, default=-1)\n    return Math.max(...goodVals, -1);\n}\n",
            "export const strangeSortList = (lst: Array<number>): Array<number> => {\n    // sl = sorted(lst)\n    const sl = lst.slice().sort((a, b) => a - b);\n    // result = []\n    const result: Array<number> = [];\n    // left, right = 0, len(sl) - 1\n    let left = 0, right = sl.length - 1;\n    // while left <= right:\n    while (left <= right) {\n        // result.append(sl[left])\n        result.push(sl[left]);\n        // left += 1\n        left += 1;\n        // if left <= right:\n        if (left <= right) {\n            // result.append(sl[right])\n            result.push(sl[right]);\n            // right -= 1\n            right -= 1;\n        }\n    }\n    // return result\n    return result;\n}\n",
            "export const triangleArea = (a: number, b: number, c: number): number => {\n    // if a + b > c and a + c > b and b + c > a:\n    if (a + b > c && a + c > b && b + c > a) {\n        // s = (a + b + c) / 2.0\n        const s = (a + b + c) / 2.0;\n        // return sqrt(s * (s - a) * (s - b) * (s - c))\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // return -1.0\n        return -1.0;\n    }\n}\n",
            "export const willItFly = (q: Array<number>, w: number): boolean => {\n    // if len(q) == 0:\n    if (q.length === 0) {\n        // return False\n        return false;\n    }\n    // is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    const isPalin = q.every((_, i) => q[i] === q[q.length - i - 1]);\n    // total = sum(q)\n    const total = q.reduce((a, b) => a + b);\n    // return is_palin and total <= w\n    return isPalin && total <= w;\n}\n",
            "export const smallestChange = (arr: Array<number>): number => {\n    // ans = 0\n    let ans = 0;\n    // for i in range(len(arr) // 2):\n    for (let i = 0; i < arr.length / 2; i++) {\n        // if arr[i] != arr[len(arr) - i - 1]:\n        if (arr[i] !== arr[arr.length - i - 1]) {\n            // ans += 1\n            ans += 1;\n        }\n    }\n    // return ans\n    return ans;\n}\n",
            "export const totalMatch = (lst1: Array<string>, lst2: Array<string>): Array<string> => {\n    // cnt1 = sum(len(s) for s in lst1)\n    const cnt1 = lst1.reduce((acc, s) => acc + s.length, 0);\n    // cnt2 = sum(len(s) for s in lst2)\n    const cnt2 = lst2.reduce((acc, s) => acc + s.length, 0);\n    // return lst1 if cnt1 <= cnt2 else lst2\n    return cnt1 <= cnt2 ? lst1 : lst2;\n}\n",
            "export const isPrime = (n: number): boolean => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const isMultiplyPrime = (a: number): boolean => {\n    // cnt = 0\n    let cnt = 0;\n    // for i in range(2, a + 1):\n    for (let i = 2; i <= a + 1; i++) {\n        // if is_prime(i):\n        if (isPrime(i)) {\n            // while a % i == 0:\n            while (a % i === 0) {\n                // cnt += 1\n                cnt += 1;\n                // a /= i\n                a /= i;\n            }\n        }\n    }\n    // return cnt == 3\n    return cnt === 3;\n}\n",
            "export const isSimplePower = (x: number, n: number): boolean => {\n    // if n < 2:\n    if (n < 2) {\n        // return x == n\n        return x === n;\n    }\n    // tmp = 1\n    let tmp = 1;\n    // while tmp < x:\n    while (tmp < x) {\n        // tmp *= n\n        tmp *= n;\n    }\n    // return tmp == x\n    return tmp === x;\n}\n",
            "export const isCube = (a: number): boolean => {\n    // a = abs(a)\n    a = Math.abs(a);\n    // root = int(round(pow(a, 1.0 / 3.0)))\n    const root = Math.round(Math.pow(a, 1.0 / 3.0));\n    // return root * root * root == a\n    return root * root * root === a;\n}\n",
            "export const hexKey = (num: string): number => {\n    // return len([x for x in num if x in \"2357BD\"])\n    return [...num].filter(x => \"2357BD\".includes(x)).length;\n}\n",
            "export const decimalToBinary = (dec: number): string => {\n    // binary = bin(dec)[2:]\n    const binary = dec.toString(2).slice(2);\n    // return f\"db{binary}db\"\n    return `db${binary}db`;\n}\n",
            "export const isHappy = (s: string): boolean => {\n    // if len(s) < 3:\n    if (s.length < 3) {\n        // return False\n        return false;\n    }\n    // for i in range(len(s) - 2):\n    for (let i = 0; i < s.length - 2; i++) {\n        // if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n        if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "export const numericalLetterGrade = (grades: Array<number>): Array<string> => {\n    // result = []\n    const result: Array<string> = [];\n    // for g in grades:\n    for (const g of grades) {\n        // if g == 4.0:\n        if (g === 4.0) {\n            // result.append(\"A+\")\n            result.push(\"A+\");\n        }\n        // elif g > 3.7:\n        else if (g > 3.7) {\n            // result.append(\"A\")\n            result.push(\"A\");\n        }\n        // elif g > 3.3:\n        else if (g > 3.3) {\n            // result.append(\"A-\")\n            result.push(\"A-\");\n        }\n        // elif g > 3.0:\n        else if (g > 3.0) {\n            // result.append(\"B+\")\n            result.push(\"B+\");\n        }\n        // elif g > 2.7:\n        else if (g > 2.7) {\n            // result.append(\"B\")\n            result.push(\"B\");\n        }\n        // elif g > 2.3:\n        else if (g > 2.3) {\n            // result.append(\"B-\")\n            result.push(\"B-\");\n        }\n        // elif g > 2.0:\n        else if (g > 2.0) {\n            // result.append(\"C+\")\n            result.push(\"C+\");\n        }\n        // elif g > 1.7:\n        else if (g > 1.7) {\n            // result.append(\"C\")\n            result.push(\"C\");\n        }\n        // elif g > 1.3:\n        else if (g > 1.3) {\n            // result.append(\"C-\")\n            result.push(\"C-\");\n        }\n        // elif g > 1.0:\n        else if (g > 1.0) {\n            // result.append(\"D+\")\n            result.push(\"D+\");\n        }\n        // elif g > 0.7:\n        else if (g > 0.7) {\n            // result.append(\"D\")\n            result.push(\"D\");\n        }\n        // elif g > 0.0:\n        else if (g > 0.0) {\n            // result.append(\"D-\")\n            result.push(\"D-\");\n        }\n        // else:\n        else {\n            // result.append(\"E\")\n            result.push(\"E\");\n        }\n    }\n    // return result\n    return result;\n}\n",
            "export const primeLength = (s: string): boolean => {\n    // length = len(s)\n    const length = s.length;\n    // if length < 2:\n    if (length < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(length)) + 1):\n    for (let i = 2; i <= floor(sqrt(length)) + 1; i++) {\n        // if length % i == 0:\n        if (length % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\n",
            "export const startsOneEnds = (n: number): number => {\n    // if n == 1:\n    if (n === 1) {\n        // return 1\n        return 1;\n    }\n    // return 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * (10 ** (n - 2));\n}\n",
            "export const solve = (n: number): string => {\n    // digits_sum = sum(int(d) for d in str(n))\n    const digitsSum = [...n.toString()].reduce((acc, d) => acc + parseInt(d), 0);\n    // return bin(digits_sum)[2:]\n    return parseInt(digitsSum.toString(), 10).toString(2).slice(2);\n}\n",
            "export const add = (lst: Array<number>): number => {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0])\n    return lst.reduce((acc, x, i) => {\n        if (i % 2 === 1 && x % 2 === 0) {\n            return acc + x;\n        }\n        return acc;\n    }, 0);\n}\n",
            "export const antiShuffle = (s: string): string => {\n    // words = [\"\".join(sorted(list(word))) for word in s.split(\" \")]\n    const words = s.split(\" \").map((word) => {\n        // return \"\".join(sorted(list(word)))\n        return [...word].sort().join(\"\");\n    });\n    // return \" \".join(words)\n    return words.join(\" \");\n}\n",
            "export const getRow = (lst: Array<Array<number>>, x: number): Array<Array<number>> => {\n    // coords = []\n    const coords: Array<Array<number>> = [];\n    // for i in range(len(lst)):\n    for (let i = 0; i < lst.length; i++) {\n        // for j in range(len(lst[i])):\n        for (let j = 0; j < lst[i].length; j++) {\n            // if lst[i][j] == x:\n            if (lst[i][j] === x) {\n                // coords.append([i, j])\n                coords.push([i, j]);\n            }\n        }\n    }\n    // return sorted(coords, key=lambda a: (a[0], -a[1]))\n    return coords.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n}\n",
            "export const sortArray = (arr: Array<number>): Array<number> => {\n    // if len(arr) == 0:\n    if (arr.length === 0) {\n        // return []\n        return [];\n    }\n    // if (arr[0] + arr[-1]) % 2 == 0:\n    if ((arr[0] + arr[arr.length - 1]) % 2 === 0) {\n        // return sorted(arr, reverse=True)\n        return arr.sort().reverse();\n    } else {\n        // return sorted(arr)\n        return arr.sort();\n    }\n}\n",
            "export const encrypt = (s: string): string => {\n    // result = []\n    const result: Array<string> = [];\n    // for ch in s:\n    for (const ch of s) {\n        // shifted = ord(ch) + 4\n        const shifted = ch.charCodeAt(0) + 4;\n        // if shifted > ord('z'):\n        if (shifted > \"z\".charCodeAt(0)) {\n            // shifted -= 26\n            shifted -= 26;\n        }\n        // result.append(chr(shifted))\n        result.push(String.fromCharCode(shifted));\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\n",
            "export const nextSmallest = (lst: Array<number>): number | null => {\n    // sl = sorted(set(lst))\n    const sl = [...new Set(lst)].sort();\n    // if len(sl) < 2:\n    if (sl.length < 2) {\n        // return None\n        return null;\n    }\n    // return sl[1]\n    return sl[1];\n}\n",
            "export const isBored = (s: string): number => {\n    // sentences = re.split(r\"[.!?]\\s*\", s)\n    const sentences = re.split(new RegExp(\"[.!?]\\\\s*\", \"g\"), s);\n    // return sum(sentence[:2] == \"I \" for sentence in sentences if len(sentence) >= 2)\n    return sentences.reduce((acc, sentence) => {\n        if (sentence.length >= 2 && sentence.slice(0, 2) === \"I \") {\n            return acc + 1;\n        }\n        return acc;\n    }, 0);\n}\n",
            "export const anyInt = (x: any, y: any, z: any): boolean => {\n    // if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n    if (typeof x === \"number\" && typeof y === \"number\" && typeof z === \"number\") {\n        // if (x + y == z) or (x + z == y) or (y + z == x):\n        if (x + y === z || x + z === y || y + z === x) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const encode = (message: string): string => {\n    // vowels = \"aeiouAEIOU\"\n    const vowels = \"aeiouAEIOU\";\n    // result = []\n    const result: Array<string> = [];\n    // for ch in message:\n    for (const ch of message) {\n        // if ch.isalpha():\n        if (ch.match(/[a-zA-Z]/)) {\n            // ch1 = ch.upper() if ch.islower() else ch.lower()\n            const ch1 = ch.toUpperCase() === ch ? ch.toLowerCase() : ch.toUpperCase();\n            // if ch1 in vowels:\n            if (vowels.includes(ch1)) {\n                // ch1 = chr(ord(ch1) + 2)\n                result.push(String.fromCharCode(ch1.charCodeAt(0) + 2));\n            } else {\n                // result.append(ch1)\n                result.push(ch1);\n            }\n        } else {\n            // result.append(ch)\n            result.push(ch);\n        }\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\n",
            "export const isPrime = (n: number): boolean => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const skjkasdkd = (lst: Array<number>): number => {\n    // primes = [n for n in lst if is_prime(n)]\n    const primes = lst.filter(isPrime);\n    // if len(primes) == 0:\n    if (primes.length === 0) {\n        // return 0\n        return 0;\n    }\n    // largest = str(max(primes))\n    const largest = String(Math.max(...primes));\n    // return sum(int(digit) for digit in largest)\n    return largest.split(\"\").reduce((sum, digit) => sum + parseInt(digit), 0);\n}\n",
            "export const checkDictCase = (d: { [key: string]: string }): boolean => {\n    // if not d:\n    if (!d) {\n        // return False\n        return false;\n    }\n    // return all(c.islower() for c in d.keys()) or all(c.isupper() for c in d.keys())\n    return Object.keys(d).every((c) => c.toLowerCase() === c) || Object.keys(d).every((c) => c.toUpperCase() === c);\n}\n",
            "export const countUpTo = (n: number): Array<number> => {\n    // primes = []\n    const primes: Array<number> = [];\n    // for num in range(2, n):\n    for (let num = 2; num < n; num++) {\n        // if all(num % p != 0 for p in primes):\n        if (primes.every(p => num % p !== 0)) {\n            // primes.append(num)\n            primes.push(num);\n        }\n    }\n    // return primes\n    return primes;\n}\n",
            "export const multiply = (a: number, b: number): number => {\n    // return (abs(a) % 10) * (abs(b) % 10)\n    return Math.abs(a) % 10 * Math.abs(b) % 10;\n}\n",
            "export const countUpper = (s: string): number => {\n    // vowels = \"AEIOU\"\n    const vowels = \"AEIOU\";\n    // return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n    return [...s].filter((c, i) => i % 2 === 0 && vowels.includes(c)).length;\n}\n",
            "export const closestInteger = (value: string): number => {\n    // num = float(value)\n    const num = parseFloat(value);\n    // if num >= 0:\n    if (num >= 0) {\n        // return int(num + 0.5)\n        return Math.round(num);\n    } else {\n        // return int(num - 0.5)\n        return Math.round(num - 0.5);\n    }\n}\n",
            "export const makeAPile = (n: number): Array<number> => {\n    // return [n + 2 * i for i in range(n)]\n    return Array.from({ length: n }, (_, i) => n + 2 * i);\n}\n",
            "export const wordsString = (s: string): Array<string> => {\n    // return [w for w in re.split(r\"[, ]\", s) if len(w) > 0]\n    return re.split(s, /[, ]/).filter(w => w.length > 0);\n}\n",
            "export const chooseNum = (x: number, y: number): number => {\n    // if x > y:\n    if (x > y) {\n        // return -1\n        return -1;\n    }\n    // if y % 2 == 0:\n    if (y % 2 === 0) {\n        // return y\n        return y;\n    }\n    // return y - 1 if x != y else -1\n    return x !== y ? y - 1 : -1;\n}\n",
            "export const roundedAvg = (n: number, m: number): string | null => {\n    // if n > m:\n    if (n > m) {\n        // return None\n        return null;\n    }\n    // r_avg = int((m + n) / 2.0 + 0.5)\n    const rAvg = Math.floor((m + n) / 2.0 + 0.5);\n    // return bin(r_avg)[2:]\n    return rAvg.toString(2);\n}\n",
            "export const allDigitsOdd = (s: string): boolean => {\n    // return all(ord(digit) % 2 != 0 for digit in s)\n    return [...s].every((digit) => {\n        return (digit.charCodeAt(0) % 2) !== 0;\n    });\n}\nexport const uniqueDigits = (x: Array<number>): Array<number> => {\n    // return sorted([num for num in x if all_digits_odd(str(num))])\n    return x.filter((num) => {\n        return allDigitsOdd(num.toString());\n    }).sort((a, b) => {\n        return a - b;\n    });\n}\n",
            "export const byLength = (arr: Array<number>): Array<string> => {\n    // digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    const digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    // sorted_arr = sorted([x for x in arr if 1 <= x <= 9], reverse=True)\n    const sortedArr = [...arr].filter(x => 1 <= x && x <= 9).sort((a, b) => b - a);\n    // return [digit_names[x-1] for x in sorted_arr]\n    return sortedArr.map(x => digitNames[x - 1]);\n}\n",
            "export const f = (n: number): Array<number> => {\n    // nums = list(range(1, n + 1))\n    const nums: Array<number> = Array.from({ length: n + 1 }, (_, i) => i + 1);\n    // return [sum(nums[:i]) if i % 2 != 0 else reduce(lambda x, y: x * y, nums[:i], 1) for i in nums]\n    return nums.map((i) => {\n        if (i % 2 !== 0) {\n            return nums.slice(0, i).reduce((x, y) => x + y, 0);\n        }\n        return nums.slice(0, i).reduce((x, y) => x * y, 1);\n    });\n}\n",
            "export const evenOddPalindrome = (n: number): Array<number> => {\n    // cnt = [0, 0]\n    const cnt: Array<number> = [0, 0];\n    // for i in range(1, n + 1):\n    for (let i = 1; i <= n; i++) {\n        // if is_palindrome(str(i)):\n        if (isPalindrome(i.toString())) {\n            // cnt[i % 2] += 1\n            cnt[i % 2] += 1;\n        }\n    }\n    // return cnt\n    return cnt;\n}\n",
            "export const digitsSum = (n: number): number => {\n    // n_str = str(n)\n    const nStr = n.toString();\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.split(\"\").reduce((acc, cur) => acc + parseInt(cur), 0);\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return parseInt(nStr.slice(0, 2)) * 2 + digitsSum(Math.abs(n));\n    }\n}\nexport const countNums = (arr: Array<number>): number => {\n    // return len([n for n in arr if digits_sum(n) > 0])\n    return arr.filter(n => digitsSum(n) > 0).length;\n}\n",
            "export const moveOneBall = (arr: Array<number>): boolean => {\n    // if len(arr) == 0:\n    if (arr.length === 0) {\n        // return True\n        return true;\n    }\n    // sorted_arr = sorted(arr)\n    const sortedArr = arr.slice().sort((a, b) => a - b);\n    // for i in range(0, len(arr)):\n    for (let i = 0; i < arr.length; i++) {\n        // if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n        if (arr.slice(i).join(\"\") === sortedArr.slice(0, arr.length - i).join(\"\") && arr.slice(0, i).join(\"\") === sortedArr.slice(arr.length - i).join(\"\")) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const canExchange = (lst1: Array<number>, lst2: Array<number>): string => {\n    // odd_cnt = len([num for num in lst1 if num % 2 != 0])\n    const oddCnt = lst1.filter(num => num % 2 !== 0).length;\n    // even_cnt = len([num for num in lst2 if num % 2 == 0])\n    const evenCnt = lst2.filter(num => num % 2 === 0).length;\n    // return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n    return evenCnt >= oddCnt ? \"YES\" : \"NO\";\n}\n",
            "export const histogram = (test: string): Record<string, number> => {\n    // freq = {}\n    const freq: Record<string, number> = {};\n    // words = [w for w in test.split(\" \") if len(w) > 0]\n    const words = test.split(\" \").filter((w) => w.length > 0);\n    // for w in words:\n    for (const w of words) {\n        // freq[w] = freq.get(w, 0) + 1\n        freq[w] = (freq[w] || 0) + 1;\n    }\n    // result = {}\n    const result: Record<string, number> = {};\n    // if len(freq) > 0:\n    if (Object.keys(freq).length > 0) {\n        // max_freq = max(freq.values())\n        const max_freq = Math.max(...Object.values(freq));\n        // for k, v in freq.items():\n        for (const k in freq) {\n            // if v == max_freq:\n            if (freq[k] === max_freq) {\n                // result[k] = v\n                result[k] = freq[k];\n            }\n        }\n    }\n    // return result\n    return result;\n}\n",
            "export const isPalindrome = (s: string): boolean => {\n    // return s == s[::-1]\n    return s === s.split(\"\").reverse().join(\"\");\n}\nexport const reverseDelete = (s: string, c: string): Array<string> => {\n    // s1 = \"\".join([ch for ch in s if ch not in c])\n    const s1 = [...s].filter(ch => !c.includes(ch)).join(\"\");\n    // return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n    return [s1, isPalindrome(s1) ? \"yes\" : \"no\"];\n}\n",
            "export const oddCount = (lst: Array<string>): Array<string> => {\n    // result = []\n    const result: Array<string> = [];\n    // for num in lst:\n    for (const num of lst) {\n        // n = sum(ord(d) % 2 == 1 for d in num)\n        const n = [...num].reduce((acc, d) => acc + (d.charCodeAt(0) % 2 === 1 ? 1 : 0), 0);\n        // rs = \"the number of odd elements in the string i of the input.\"\n        const rs = \"the number of odd elements in the string i of the input.\";\n        // result.append(rs.replace(\"i\", str(n)))\n        result.push(rs.replace(\"i\", String(n)));\n    }\n    // return result\n    return result;\n}\n",
            "export const minSubArraySum = (nums: Array<number>): number => {\n    // min_sum = 0\n    let minSum = 0;\n    // cur_sum = 0\n    let curSum = 0;\n    // for n in nums:\n    for (const n of nums) {\n        // cur_sum = min(cur_sum + n, 0)\n        curSum = Math.min(curSum + n, 0);\n        // min_sum = min(cur_sum, min_sum)\n        minSum = Math.min(curSum, minSum);\n    }\n    // if min_sum == 0:\n    if (minSum === 0) {\n        // min_sum = min(nums)\n        minSum = Math.min(...nums);\n    }\n    // return min_sum\n    return minSum;\n}\n",
            "export const maxFill = (grid: Array<Array<number>>, capacity: number): number => {\n    // return sum([ceil(sum(arr) / capacity) for arr in grid])\n    return grid.reduce((acc, arr) => acc + Math.ceil(arr.reduce((a, b) => a + b) / capacity), 0);\n}\n",
            "export const countOnes = (num: number): number => {\n    // return bin(num).count(\"1\")\n    return bin(num).split(\"\").filter(x => x === \"1\").length;\n}\nexport const sortArray = (arr: Array<number>): Array<number> => {\n    // return sorted(arr, key=lambda x: (count_ones(x), x))\n    return arr.sort((a, b) => {\n        const aCount = countOnes(a);\n        const bCount = countOnes(b);\n        if (aCount === bCount) {\n            return a - b;\n        }\n        return aCount - bCount;\n    });\n}\n",
            "export const selectWords = (s: string, n: number): Array<string> => {\n    // consonants = \"bcdfghjklmnpqrstvwxyz\"\n    const consonants = \"bcdfghjklmnpqrstvwxyz\";\n    // words = [w for w in s.split(\" \") if len(w) > 0]\n    const words = s.split(\" \").filter(w => w.length > 0);\n    // return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n    return words.filter(w => [...w].filter(c => consonants.includes(c.toLowerCase())).length === n);\n}\n",
            "export const getClosestVowel = (word: string): string => {\n    // vowels = \"aeiouAEIOU\"\n    const vowels = \"aeiouAEIOU\";\n    // for i in range(len(word) - 2, 0, -1):\n    for (let i = word.length - 2; i >= 0; i--) {\n        // if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n        if (vowels.includes(word[i]) && !vowels.includes(word[i - 1]) && !vowels.includes(word[i + 1])) {\n            // return word[i]\n            return word[i];\n        }\n    }\n    // return \"\"\n    return \"\";\n}\n",
            "export const check = (s: string): boolean => {\n    // depth = 0\n    let depth = 0;\n    // for ch in s:\n    for (const ch of s) {\n        // if ch == \"(\":\n        if (ch === \"(\") {\n            // depth += 1\n            depth += 1;\n        } else {\n            // depth -= 1\n            depth -= 1;\n        }\n        // if depth < 0:\n        if (depth < 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True if depth == 0 else False\n    return depth === 0;\n}\nexport const matchParens = (lst: Array<string>): string => {\n    // s1 = lst[0] + lst[1]\n    const s1 = lst[0] + lst[1];\n    // s2 = lst[1] + lst[0]\n    const s2 = lst[1] + lst[0];\n    // return \"Yes\" if check(s1) or check(s2) else \"No\"\n    return check(s1) || check(s2) ? \"Yes\" : \"No\";\n}\n",
            "export const maximum = (arr: Array<number>, k: number): Array<number> => {\n    // if k == 0:\n    if (k === 0) {\n        // return []\n        return [];\n    }\n    // return sorted(arr)[-k:]\n    return arr.sort().slice(-k);\n}\n",
            "export const solution = (lst: Array<number>): number => {\n    // return sum([x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0])\n    return lst.reduce((acc, x, i) => {\n        if (i % 2 === 0 && x % 2 !== 0) {\n            return acc + x;\n        }\n        return acc;\n    }, 0);\n}\n",
            "export const addElements = (arr: Array<number>, k: number): number => {\n    // return sum([n for n in arr[:k] if len(str(n)) <= 2])\n    return arr.slice(0, k).reduce((sum, n) => sum + (n.toString().length <= 2 ? n : 0), 0);\n}\n",
            "export const getOddCollatz = (n: number): Array<number> => {\n    // collatz = [1]\n    const collatz: Array<number> = [1];\n    // while n != 1:\n    while (n !== 1) {\n        // if n % 2 != 0:\n        if (n % 2 !== 0) {\n            // collatz.append(n)\n            collatz.push(n);\n            // n = 3 * n + 1\n            n = 3 * n + 1;\n        } else {\n            // n = n // 2\n            n = n / 2;\n        }\n    }\n    // return sorted(collatz)\n    return collatz.sort();\n}\n",
            "export const validDate = (date: string): boolean => {\n    // if not len(date) == 10 or not date[2] == \"-\" or not date[5] == \"-\":\n    if (date.length !== 10 || date[2] !== \"-\" || date[5] !== \"-\") {\n        return false;\n    }\n    // m = int(date[:2])\n    const m = parseInt(date.substr(0, 2));\n    // d = int(date[3:5])\n    const d = parseInt(date.substr(3, 2));\n    // if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n    if (m in [1, 3, 5, 7, 8, 10, 12] && d >= 1 && d <= 31) {\n        return true;\n    }\n    // if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n    if (m in [4, 6, 9, 11] && d >= 1 && d <= 30) {\n        return true;\n    }\n    // if m == 2 and d >= 1 and d <= 29:\n    if (m === 2 && d >= 1 && d <= 29) {\n        return true;\n    }\n    // return False\n    return false;\n}\n",
            "export const splitWords = (txt: string): Array<string> => {\n    // if \" \" in txt:\n    if (txt.includes(\" \")) {\n        // return txt.split(\" \")\n        return txt.split(\" \");\n    }\n    // elif \",\" in txt:\n    else if (txt.includes(\",\")) {\n        // return txt.split(\",\")\n        return txt.split(\",\");\n    }\n    // else:\n    else {\n        // return [str(len([c for c in txt if c.islower() and ord(c) % 2 == 0]))]\n        return [String(txt.split(\"\").filter(c => c.toLowerCase() && c.charCodeAt(0) % 2 === 0).length)];\n    }\n}\n",
            "export const isSorted = (lst: Array<number>): boolean => {\n    // if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n    if (!lst.every((_, i) => i === 0 || lst[i - 1] <= lst[i])) {\n        return false;\n    }\n    // freq = {}\n    const freq: { [key: number]: number } = {};\n    // for i in lst:\n    for (const i of lst) {\n        // freq[i] = freq.get(i, 0) + 1\n        freq[i] = (freq[i] || 0) + 1;\n    }\n    // return max(freq.values(), default=0) <= 2\n    return Math.max(...Object.values(freq)) <= 2;\n}\n",
            "export const isPrime = (n: number): boolean => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const intersection = (interval1: Array<number>, interval2: Array<number>): string => {\n    // l = max(interval1[0], interval2[0])\n    const l = Math.max(interval1[0], interval2[0]);\n    // r = min(interval1[1], interval2[1])\n    const r = Math.min(interval1[1], interval2[1]);\n    // length = r - l\n    const length = r - l;\n    // return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n    return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n}\n",
            "export const prodSigns = (arr: Array<number>): number | null => {\n    // if not arr:\n    if (!arr.length) {\n        // return None\n        return null;\n    }\n    // if 0 in arr:\n    if (arr.includes(0)) {\n        // return 0\n        return 0;\n    }\n    // sign = -1 if len([n for n in arr if n < 0]) % 2 == 1 else 1\n    const sign = [...arr].filter(n => n < 0).length % 2 === 1 ? -1 : 1;\n    // return sign * sum([abs(n) for n in arr])\n    return sign * [...arr].map(Math.abs).reduce((a, b) => a + b);\n}\n",
            "export const minPath = (grid: Array<Array<number>>, k: number): Array<number> => {\n    // n = len(grid)\n    const n = grid.length;\n    // min_val = n * n + 1\n    let minVal = n * n + 1;\n    // for i in range(n):\n    for (let i = 0; i < n; i++) {\n        // for j in range(n):\n        for (let j = 0; j < n; j++) {\n            // if grid[i][j] == 1:\n            if (grid[i][j] === 1) {\n                // temp = []\n                const temp: Array<number> = [];\n                // if i != 0:\n                if (i !== 0) {\n                    // temp.append(grid[i - 1][j])\n                    temp.push(grid[i - 1][j]);\n                }\n                // if j != 0:\n                if (j !== 0) {\n                    // temp.append(grid[i][j - 1])\n                    temp.push(grid[i][j - 1]);\n                }\n                // if i != n - 1:\n                if (i !== n - 1) {\n                    // temp.append(grid[i + 1][j])\n                    temp.push(grid[i + 1][j]);\n                }\n                // if j != n - 1:\n                if (j !== n - 1) {\n                    // temp.append(grid[i][j + 1])\n                    temp.push(grid[i][j + 1]);\n                }\n                // min_val = min(temp)\n                minVal = Math.min(...temp);\n            }\n        }\n    }\n    // result = []\n    const result: Array<number> = [];\n    // for i in range(k):\n    for (let i = 0; i < k; i++) {\n        // result.append(1 if i % 2 == 0 else min_val)\n        result.push(i % 2 === 0 ? 1 : minVal);\n    }\n    // return result\n    return result;\n}\n",
            "export const tri = (n: number): Array<number> => {\n    // if n == 0:\n    if (n === 0) {\n        // return [1]\n        return [1];\n    }\n    // seq = [1, 3]\n    const seq: Array<number> = [1, 3];\n    // for i in range(2, n + 1):\n    for (let i = 2; i <= n + 1; i++) {\n        // if i % 2 == 0:\n        if (i % 2 === 0) {\n            // seq.append(i / 2 + 1)\n            seq.push(i / 2 + 1);\n        }\n        else {\n            // seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n            seq.push(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n        }\n    }\n    // return seq\n    return seq;\n}\n",
            "export const digits = (n: number): number => {\n    // odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    const odds = Array.from(String(n)).map(d => parseInt(d)).filter(d => d % 2 === 1);\n    // return reduce(lambda x, y: x * y, odds, 1) if len(odds) > 0 else 0\n    return reduce(odds, (x, y) => x * y, 1) || 0;\n}\n",
            "export const isNested = (s: string): boolean => {\n    // open_idx = []\n    const openIdx: Array<number> = [];\n    // close_idx = []\n    const closeIdx: Array<number> = [];\n    // for i, ch in enumerate(s):\n    for (let i = 0; i < s.length; i++) {\n        const ch = s[i];\n        // if ch == '[':\n        if (ch === '[') {\n            // open_idx.append(i)\n            openIdx.push(i);\n        }\n        // elif ch == ']':\n        else if (ch === ']') {\n            // close_idx.append(i)\n            closeIdx.push(i);\n        }\n    }\n    // close_idx.reverse()\n    closeIdx.reverse();\n    // cnt = 0\n    let cnt = 0;\n    // i = 0\n    let i = 0;\n    // l = len(close_idx)\n    const l = closeIdx.length;\n    // for idx in open_idx:\n    for (const idx of openIdx) {\n        // if i < l and idx < close_idx[i]:\n        if (i < l && idx < closeIdx[i]) {\n            // cnt += 1\n            cnt += 1;\n            // i += 1\n            i += 1;\n        }\n    }\n    // return cnt >= 2\n    return cnt >= 2;\n}\n",
            "export const sumSquares = (lst: Array<number>): number => {\n    // return sum([pow(ceil(n), 2) for n in lst])\n    return lst.reduce((acc, n) => acc + Math.pow(Math.ceil(n), 2), 0);\n}\n",
            "export const checkIfLastCharIsALetter = (txt: string): boolean => {\n    // if not txt:\n    if (!txt) {\n        // return False\n        return false;\n    }\n    // last = txt[txt.rfind(' ') + 1:]\n    const last = txt.substr(txt.lastIndexOf(' ') + 1);\n    // return len(last) == 1 and last[0].isalpha()\n    return last.length === 1 && last[0].isalpha();\n}\n",
            "export const canArrange = (arr: Array<number>): number => {\n    // if len (arr) <= 1:\n    if (arr.length <= 1) {\n        // return -1\n        return -1;\n    }\n    // idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    const idx = arr.map((_, i) => i).filter(i => arr[i] < arr[i - 1]);\n    // return max(idx, default=-1)\n    return Math.max(...idx, -1);\n}\n",
            "export const largestSmallestIntegers = (lst: Array<number>): Array<number | null> => {\n    // neg = [i for i in lst if i < 0]\n    const neg = lst.filter((i) => i < 0);\n    // pos = [i for i in lst if i > 0]\n    const pos = lst.filter((i) => i > 0);\n    // max_neg = max(neg) if len(neg) > 0 else None\n    const maxNeg = neg.length > 0 ? Math.max(...neg) : null;\n    // min_pos = min(pos) if len(pos) > 0 else None\n    const minPos = pos.length > 0 ? Math.min(...pos) : null;\n    // return [max_neg, min_pos]\n    return [maxNeg, minPos];\n}\n",
            "export const anyToReal = (o: any): number => {\n    // if isinstance(o, str): \n    if (isString(o)) {\n        // return float(o.replace(',','.'))\n        return parseFloat(o.replace(\",\", \".\"));\n    }\n    // elif isinstance(o, int):\n    else if (isNumber(o)) {\n        // return float(o)\n        return parseFloat(o);\n    }\n    // elif isinstance(o, float):\n    else if (isFloat(o)) {\n        // return o\n        return o;\n    }\n    // raise RuntimeError(\"Type Error\");\n    throw new Error(\"Type Error\");\n}\nexport const compareOne = (a: any, b: any): number | null => {\n    // a1 = any_to_real(a)\n    const a1 = anyToReal(a);\n    // b1 = any_to_real(b)\n    const b1 = anyToReal(b);\n    // if a1 == b1:\n    if (a1 === b1) {\n        // return None\n        return null;\n    }\n    // elif a1 > b1:\n    else if (a1 > b1) {\n        // return a1\n        return a1;\n    }\n    // else:\n    else {\n        // return b1\n        return b1;\n    }\n}\n",
            "export const isEqualToSumEven = (n: number): boolean => {\n    // return n % 2 == 0 and n >= 8\n    return n % 2 === 0 && n >= 8;\n}\n",
            "export const specialFactorial = (n: number): number => {\n    // fact = 1\n    let fact = 1;\n    // result = 1\n    let result = 1;\n    // for i in range(1, n + 1):\n    for (let i = 1; i <= n; i++) {\n        // fact *= i\n        fact *= i;\n        // result *= fact\n        result *= fact;\n    }\n    // return result\n    return result;\n}\n",
            "export const fixSpaces = (txt: string): string => {\n    // return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n    return re.sub(/\\s{3,}/, \"-\", txt).replace(\" \", \"_\");\n}\n",
            "export const fileNameCheck = (fileName: string): string => {\n    // suf = [\"txt\", \"exe\", \"dll\"]\n    const suf = [\"txt\", \"exe\", \"dll\"];\n    // lst = file_name.split(\".\")\n    const lst = fileName.split(\".\");\n    // if len(lst) != 2 or not lst[1] in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or len([x for x in lst[0] if x.isdigit()]) > 3:\n    if (lst.length !== 2 || !suf.includes(lst[1]) || lst[0].length === 0 || !lst[0][0].isAlpha() || lst[0].split(\"\").filter(x => x.isDigit()).length > 3) {\n        return \"No\";\n    }\n    // return \"Yes\"\n    return \"Yes\";\n}\n",
            "export const sumSquares = (lst: Array<number>): number => {\n    // result = 0\n    let result = 0;\n    // for i in range(len(lst)):\n    for (let i = 0; i < lst.length; i++) {\n        // if i % 3 == 0:\n        if (i % 3 === 0) {\n            // result += pow(lst[i], 2)\n            result += Math.pow(lst[i], 2);\n        }\n        // elif i % 4 == 0:\n        else if (i % 4 === 0) {\n            // result += pow(lst[i], 3)\n            result += Math.pow(lst[i], 3);\n        }\n        // else:\n        else {\n            // result += lst[i]\n            result += lst[i];\n        }\n    }\n    // return result\n    return result;\n}\n",
            "export const isPrime = (n: number): boolean => {\n    // if n < 2:\n    if (n < 2) {\n        // return False\n        return false;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return False\n            return false;\n        }\n    }\n    // return True\n    return true;\n}\nexport const wordsInSentence = (sentence: string): string => {\n    // words = sentence.split(\" \")\n    const words = sentence.split(\" \");\n    // return \" \".join([w for w in words if is_prime(len(w))])\n    return words.filter(w => isPrime(w.length)).join(\" \");\n}\n",
            "export const simplify = (x: string, n: string): boolean => {\n    // xs = x.split(\"/\")\n    const xs = x.split(\"/\");\n    // ns = n.split(\"/\")\n    const ns = n.split(\"/\");\n    // num = int(xs[0]) * int(ns[0])\n    const num = parseInt(xs[0]) * parseInt(ns[0]);\n    // den = int(xs[1]) * int(ns[1])\n    const den = parseInt(xs[1]) * parseInt(ns[1]);\n    // return num % den == 0\n    return num % den === 0;\n}\n",
            "export const digitsSum = (n: number): number => {\n    // n_str = str(n)\n    const nStr = n.toString();\n    // if n >= 0:\n    if (n >= 0) {\n        // return sum(int(d) for d in n_str)\n        return nStr.split(\"\").reduce((acc, cur) => acc + parseInt(cur), 0);\n    } else {\n        // return int(n_str[:2]) * 2 + digits_sum(abs(n))\n        return parseInt(nStr.slice(0, 2)) * 2 + digitsSum(Math.abs(n));\n    }\n}\nexport const orderByPoints = (nums: Array<number>): Array<number> => {\n    // return sorted(nums, key=digits_sum)\n    return nums.sort((a, b) => digitsSum(a) - digitsSum(b));\n}\n",
            "export const specialFilter = (nums: Array<number>): number => {\n    // odds = \"13579\"\n    const odds = \"13579\";\n    // return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n    return (nums.filter((n) => n > 10 && n % 2 === 1 && odds.includes(n.toString()[0]))).length;\n}\n",
            "export const getMaxTriples = (n: number): number => {\n    // c = [0, 0, 0]\n    const c: Array<number> = [0, 0, 0];\n    // for i in range(1, n + 1):\n    for (let i = 1; i <= n; i++) {\n        // a = i * i - i + 1\n        const a = i * i - i + 1;\n        // c[a % 3] += 1\n        c[a % 3] += 1;\n    }\n    // return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) // 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2));\n}\n",
            "export const bf = (planet1: string, planet2: string): Array<string> => {\n    // names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    const names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    // if planet1 not in names or planet2 not in names:\n    if (names.indexOf(planet1) === -1 || names.indexOf(planet2) === -1) {\n        // return []\n        return [];\n    }\n    // l = names.index(planet1)\n    let l = names.indexOf(planet1);\n    // r = names.index(planet2)\n    let r = names.indexOf(planet2);\n    // if l > r:\n    if (l > r) {\n        // l, r = r, l\n        [l, r] = [r, l];\n    }\n    // if l == r:\n    if (l === r) {\n        // return []\n        return [];\n    }\n    // return names[l + 1 : r]\n    return names.slice(l + 1, r);\n}\n",
            "export const sortedListSum = (lst: Array<string>): Array<string> => {\n    // result = [s for s in lst if len(s) % 2 == 0]\n    const result = lst.filter((s) => s.length % 2 === 0);\n    // return sorted(result, key=lambda x: (len(x), x))\n    return result.sort((a, b) => {\n        if (a.length === b.length) {\n            return a.localeCompare(b);\n        }\n        return a.length - b.length;\n    });\n}\n",
            "export const xOrY = (n: number, x: number, y: number): number => {\n    // if n < 2:\n    if (n < 2) {\n        // return y\n        return y;\n    }\n    // for i in range(2, floor(sqrt(n)) + 1):\n    for (let i = 2; i <= floor(sqrt(n)) + 1; i++) {\n        // if n % i == 0:\n        if (n % i === 0) {\n            // return y\n            return y;\n        }\n    }\n    // return x\n    return x;\n}\n",
            "export const doubleTheDifference = (lst: Array<number>): number => {\n    // return sum([n * n for n in lst if n >= 0 and n % 2 == 1])\n    return lst.reduce((acc, n) => {\n        if (n >= 0 && n % 2 === 1) {\n            return acc + n * n;\n        }\n        return acc;\n    }, 0);\n}\n",
            "export const compare = (game: Array<number>, guess: Array<number>): Array<number> => {\n    // return [abs(x - y) for x, y in zip(game, guess)]\n    return game.map((x, i) => Math.abs(x - guess[i]));\n}\n",
            "export const strongestExtension = (className: string, extensions: Array<string>): string => {\n    // max_s = float(\"-inf\")\n    let maxS = -Infinity;\n    // max_ext = \"\"\n    let maxExt = \"\";\n    // for ext in extensions:\n    for (const ext of extensions) {\n        // upper = len([c for c in ext if c.isupper()])\n        const upper = [...ext].filter(c => c.toUpperCase() === c).length;\n        // lower = len([c for c in ext if c.islower()])\n        const lower = [...ext].filter(c => c.toLowerCase() === c).length;\n        // s = upper - lower\n        const s = upper - lower;\n        // if s > max_s:\n        if (s > maxS) {\n            // max_s = s\n            maxS = s;\n            // max_ext = ext\n            maxExt = ext;\n        }\n    }\n    // return f\"{class_name}.{max_ext}\"\n    return `${className}.${maxExt}`;\n}\n",
            "export const cycpatternCheck = (a: string, b: string): boolean => {\n    // if len(a) < len(b):\n    if (a.length < b.length) {\n        // return False\n        return false;\n    }\n    // for i in range(len(b)):\n    for (let i = 0; i < b.length; i++) {\n        // if b[i:] + b[:i] in a:\n        if (a.includes(b.slice(i) + b.slice(0, i))) {\n            // return True\n            return true;\n        }\n    }\n    // return False\n    return false;\n}\n",
            "export const evenOddCount = (num: number): Array<number> => {\n    // ds = str(abs(num))\n    const ds = Math.abs(num).toString();\n    // even = len([d for d in ds if ord(d) % 2 == 0])\n    const even = [...ds].filter(d => d.charCodeAt(0) % 2 === 0).length;\n    // return [even, len(ds) - even]\n    return [even, ds.length - even];\n}\n",
            "export const intToMiniRoman = (num: number): string => {\n    // values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    // numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    const numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    // res = []\n    const res: Array<string> = [];\n    // for i in range(len(values)):\n    for (let i = 0; i < values.length; i++) {\n        // while num >= values[i]:\n        while (num >= values[i]) {\n            // res.append(numerals[i])\n            res.push(numerals[i]);\n            // num -= values[i]\n            num -= values[i];\n        }\n    }\n    // return \"\".join(res)\n    return res.join(\"\");\n}\n",
            "export const rightAngleTriangle = (a: number, b: number, c: number): boolean => {\n    // s = sorted([a, b, c])\n    const s = [a, b, c].sort((a, b) => a - b);\n    // return  s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] === s[2] * s[2];\n}\n",
            "export const findMax = (words: Array<string>): string => {\n    // max_cnt = 0\n    let maxCnt = 0;\n    // max_w = \"\"\n    let maxW = \"\";\n    // for w in words:\n    for (const w of words) {\n        // cnt = len(set(w))\n        const cnt = new Set(w).size;\n        // if cnt > max_cnt:\n        if (cnt > maxCnt) {\n            // max_cnt = cnt\n            maxCnt = cnt;\n            // max_w = w\n            maxW = w;\n        }\n        // elif cnt == max_cnt:\n        else if (cnt === maxCnt) {\n            // max_w = min(max_w, w)\n            maxW = maxW < w ? maxW : w;\n        }\n    }\n    // return max_w\n    return maxW;\n}\n",
            "export const eat = (num: number, need: number, remaining: number): Array<number> => {\n    // if need <= remaining:\n    if (need <= remaining) {\n        // return [num + need, remaining - need]\n        return [num + need, remaining - need];\n    } else {\n        // return [num + remaining, 0]\n        return [num + remaining, 0];\n    }\n}\n",
            "export const doAlgebra = (operators: Array<string>, operands: Array<number>): number => {\n    // ops = operators.copy()\n    const ops = [...operators];\n    // nums = operands.copy()\n    const nums = [...operands];\n    // i = len(ops) - 1\n    let i = ops.length - 1;\n    // while i >= 0:\n    while (i >= 0) {\n        // if ops[i] == \"**\":\n        if (ops[i] === \"**\") {\n            // nums[i] = pow(nums[i], nums[i + 1])\n            nums[i] = Math.pow(nums[i], nums[i + 1]);\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n        }\n        // i -= 1\n        i -= 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while (i < ops.length) {\n        // if ops[i] == \"*\":\n        if (ops[i] === \"*\") {\n            // nums[i] = nums[i] * nums[i + 1]\n            nums[i] = nums[i] * nums[i + 1];\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"//\":\n        else if (ops[i] === \"//\") {\n            // nums[i] = nums[i] // nums[i + 1]\n            nums[i] = Math.floor(nums[i] / nums[i + 1]);\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // i = 0\n    i = 0;\n    // while i < len(ops):\n    while (i < ops.length) {\n        // if ops[i] == \"+\":\n        if (ops[i] === \"+\") {\n            // nums[i] = nums[i] + nums[i + 1]\n            nums[i] = nums[i] + nums[i + 1];\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n            // i -= 1\n            i -= 1;\n        }\n        // elif ops[i] == \"-\":\n        else if (ops[i] === \"-\") {\n            // nums[i] = nums[i] - nums[i + 1]\n            nums[i] = nums[i] - nums[i + 1];\n            // nums.pop(i + 1)\n            nums.splice(i + 1, 1);\n            // ops.pop(i)\n            ops.splice(i, 1);\n            // i -= 1\n            i -= 1;\n        }\n        // i += 1\n        i += 1;\n    }\n    // return nums[0]\n    return nums[0];\n}\n",
            "export const solve = (s: string): string => {\n    // if not any(ch.isalpha() for ch in s):\n    if (!s.split(\"\").some((ch) => ch.match(/[a-zA-Z]/))) {\n        // return s[::-1]\n        return s.split(\"\").reverse().join(\"\");\n    }\n    // result = []\n    const result: Array<string> = [];\n    // for ch in s:\n    for (const ch of s.split(\"\")) {\n        // if not ch.isalpha():\n        if (!ch.match(/[a-zA-Z]/)) {\n            // result.append(ch)\n            result.push(ch);\n        }\n        // elif ch.isupper():\n        else if (ch.match(/[A-Z]/)) {\n            // result.append(ch.lower())\n            result.push(ch.toLowerCase());\n        }\n        // elif ch.islower():\n        else if (ch.match(/[a-z]/)) {\n            // result.append(ch.upper())\n            result.push(ch.toUpperCase());\n        }\n    }\n    // return \"\".join(result)\n    return result.join(\"\");\n}\n",
            "export const stringToMd5 = (txt: string): string | null => {\n    // if not txt:\n    if (!txt) {\n        // return None\n        return null;\n    }\n    // md5_hash = hashlib.md5()\n    const md5_hash = crypto.createHash(\"md5\");\n    // txt_bytes = txt.encode()\n    const txt_bytes = Buffer.from(txt);\n    // md5_hash.update(txt_bytes)\n    md5_hash.update(txt_bytes);\n    // md5_encoded = md5_hash.hexdigest()\n    const md5_encoded = md5_hash.digest(\"hex\");\n    // return md5_encoded\n    return md5_encoded;\n}\n",
            "export const generateIntegers = (a: number, b: number): Array<number> => {\n    // lower = max(2, min(a, b))\n    const lower = Math.max(2, Math.min(a, b));\n    // upper = min(8, max(a, b))\n    const upper = Math.min(8, Math.max(a, b));\n    // return [i for i in range(lower, upper + 1) if i % 2 == 0]\n    return Array.from(Array(upper - lower + 1).keys()).map(i => i + lower).filter(i => i % 2 === 0);\n}\n"
        ]
    },
    "ruby": {
        "python": [
            "def has_close_elements(numbers: List[int], threshold: int) -> bool:\n    # for i in 0...numbers.length\n    for i in range(len(numbers)):\n        # for j in i+1...numbers.length\n        for j in range(i+1, len(numbers)):\n            # if (numbers[i] - numbers[j]).abs < threshold\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true\n                return True\n    # false\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # groups = []\n    groups = []\n    # stk = []\n    stk = []\n    # current_group = \"\"\n    current_group = \"\"\n    # parens = paren_string.gsub(\" \", \"\")\n    parens = paren_string.replace(\" \", \"\")\n    # parens.each_char do |ch|\n    for ch in parens:\n        # if ch == \"(\"\n        if ch == \"(\":\n            # stk.push(ch)\n            stk.append(ch)\n            # current_group += ch\n            current_group += ch\n        # elsif ch == \")\"\n        elif ch == \")\":\n            # stk.pop\n            stk.pop()\n            # current_group += ch\n            current_group += ch\n            # if stk.empty?\n            if not stk:\n                # groups << current_group\n                groups.append(current_group)\n                # current_group = \"\"\n                current_group = \"\"\n        # end\n    # end\n    # groups\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # num - num.floor\n    return num - num.floor()\n",
            "def below_zero(operations: List[int]) -> bool:\n    # balance = 0\n    balance = 0\n    # operations.each do |op|\n    for op in operations:\n        # balance += op\n        balance += op\n        # if balance < 0\n        if balance < 0:\n            # return true\n            return True\n    # false\n    return False\n",
            "def mean_absolute_deviation(numbers: List[int]) -> float:\n    # mean = numbers.sum / numbers.length\n    mean = sum(numbers) / len(numbers)\n    # deviation = numbers.map { |x| (x - mean).abs }.sum \n    deviation = sum([abs(x - mean) for x in numbers])\n    # deviation / numbers.length\n    deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # result = []\n    result = []\n    # for i in 0..numbers.length - 1\n    for i in range(len(numbers)):\n        # if i != 0\n        if i != 0:\n            # result << delimiter\n            result.append(delimiter)\n        # result << numbers[i]\n        result.append(numbers[i])\n    # result\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # result = []\n    result = []\n    # paren_groups = paren_string.split\n    paren_groups = paren_string.split()\n    # paren_groups.each do |group|\n    for group in paren_groups:\n        # max_depth = 0\n        max_depth = 0\n        # depth = 0\n        depth = 0\n        # group.each_char do |ch|\n        for ch in group:\n            # if ch == \"(\"\n            if ch == \"(\":\n                # depth += 1\n                depth += 1\n                # max_depth = [max_depth, depth].max\n                max_depth = max(max_depth, depth)\n            # elsif ch == \")\"\n            elif ch == \")\":\n                # depth -= 1\n                depth -= 1\n            # end\n        # end\n        # result << max_depth\n        result.append(max_depth)\n    # result\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # strs.select { |s| s.include?(substring) }\n    return [s for s in strs if substring in s]\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # n_sum = numbers.sum\n    n_sum = sum(numbers)\n    # n_product = numbers.reduce(1, :*)\n    n_product = reduce(lambda x, y: x * y, numbers, 1)\n    # [n_sum, n_product]\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # max_so_far = Float::MIN\n    max_so_far = float('-inf')\n    # result = []\n    result = []\n    # numbers.each do |num|\n    for num in numbers:\n        # max_so_far = [max_so_far, num].max\n        max_so_far = max(max_so_far, num)\n        # result << max_so_far\n        result.append(max_so_far)\n    # result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # s == s.reverse\n    return s == s[::-1]\ndef make_palindrome(s: str) -> str:\n    # if is_palindrome(s)\n    if is_palindrome(s):\n        # return s\n        return s\n    # for i in 0...s.length\n    for i in range(len(s)):\n        # if is_palindrome(s[i..])\n        if is_palindrome(s[i:]):\n            # return s + s[0...i].reverse\n            return s + s[0:i][::-1]\n    # return \"\"\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # a.chars.zip(b.chars).map { |x, y| x == y ? \"0\" : \"1\" }.join\n    return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n",
            "def longest(strs: List[str]) -> str:\n    # if strs.empty?\n    if not strs:\n        # return nil \n        return None\n    # end\n    # longest_s = strs[0]\n    longest_s = strs[0]\n    # strs.each do |s|\n    for s in strs:\n        # if s.length > longest_s.length\n        if len(s) > len(longest_s):\n            # longest_s = s\n            longest_s = s\n    # end\n    # longest_s\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if b == 0\n    if b == 0:\n        # return a\n        return a\n    # else\n    else:\n        # return greatest_common_divisor(b, a % b)\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # prefixes = []\n    prefixes = []\n    # s.length.times do |i|\n    for i in range(len(s)):\n        # prefixes << s[0..i]\n        prefixes.append(s[0:i+1])\n    # prefixes\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # (0..n).to_a.join(\" \")\n    return \" \".join(map(str, range(n + 1)))\n",
            "def count_distinct_characters(s: str) -> int:\n    # s.downcase.chars.uniq.length\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # durations = {\"o\" => 4, \"o|\" => 2, \".|\" => 1}\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    # notes = music_string.split\n    notes = music_string.split()\n    # notes.map { |note| durations[note] }\n    return [durations[note] for note in notes]\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # times = 0\n    times = 0\n    # for i in 0..(s.length - substring.length)\n    for i in range(0, len(s) - len(substring)):\n        # if s[i...(i + substring.length)] == substring\n        if s[i:i + len(substring)] == substring:\n            # times += 1\n            times += 1\n    # times\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # num_dict = {\n    #     \"zero\" => 0,\n    #     \"one\" => 1,\n    #     \"two\" => 2,\n    #     \"three\" => 3,\n    #     \"four\" => 4,\n    #     \"five\" => 5,\n    #     \"six\" => 6,\n    #     \"seven\" => 7,\n    #     \"eight\" => 8,\n    #     \"nine\" => 9,\n    # }\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    # num_list = numbers.split(\" \").select { |x| num_dict.key?(x) }\n    num_list = [x for x in numbers.split(\" \") if x in num_dict]\n    # num_list.sort_by! { |x| num_dict[x] }\n    num_list.sort(key=lambda x: num_dict[x])\n    # num_list.join(\" \")\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[int]) -> List[int]:\n    # sorted_numbers = numbers.sort\n    sorted_numbers = sorted(numbers)\n    # min_diff = Float::INFINITY\n    min_diff = float('inf')\n    # closest_pair = []\n    closest_pair = []\n    # (1...sorted_numbers.length).each do |i|\n    for i in range(1, len(sorted_numbers)):\n        # diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if diff < min_diff\n        if diff < min_diff:\n            # min_diff = diff\n            min_diff = diff\n            # closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # closest_pair\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # min_num = numbers.min\n    min_num = min(numbers)\n    # max_num = numbers.max\n    max_num = max(numbers)\n    # if min_num == max_num\n    if min_num == max_num:\n        # return [0.0] * numbers.length\n        return [0.0] * len(numbers)\n    # else\n    else:\n        # return numbers.map { |num| (num - min_num) / (max_num - min_num) }\n        return [ (num - min_num) / (max_num - min_num) for num in numbers ]\n",
            "def filter_integers(values: List[int]) -> List[int]:\n    # values.select { |x| x.is_a?(Integer) }\n    return [x for x in values if isinstance(x, int)]\n",
            "def str_length(s: str) -> int:\n    # s.length\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # (2...n).each do |i|\n    for i in range(2, n):\n        # if n % i == 0\n        if n % i == 0:\n            # return n / i\n            return n / i\n    # 1\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # factors = []\n    factors = []\n    # divisor = 2\n    divisor = 2\n    # while divisor <= n\n    while divisor <= n:\n        # if n % divisor == 0\n        if n % divisor == 0:\n            # factors << divisor\n            factors.append(divisor)\n            # n /= divisor\n            n //= divisor\n        else:\n            # divisor += 1\n            divisor += 1\n    # factors\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # counts = {}\n    counts = {}\n    # numbers.each do |num|\n    for num in numbers:\n        # counts[num] = counts.fetch(num, 0) + 1\n        counts[num] = counts.get(num, 0) + 1\n    # res = numbers.select do |num|\n    res = []\n    for num in numbers:\n        # counts[num] == 1\n        if counts[num] == 1:\n            # res.append(num)\n            res.append(num)\n    # res\n    return res\n",
            "def flip_case(s: str) -> str:\n    # flipped = \"\"\n    flipped = \"\"\n    # s.chars.each do |ch|\n    for ch in s:\n        # if not ch.match(/[a-zA-Z]/)\n        if not ch.isalpha():\n            # flipped += ch\n            flipped += ch\n        # elsif ch.match(/[a-z]/)\n        elif ch.islower():\n            # flipped += ch.upcase\n            flipped += ch.upper()\n        # elsif ch.match(/[A-Z]/)\n        elif ch.isupper():\n            # flipped += ch.downcase\n            flipped += ch.lower()\n    # flipped\n    return flipped\n",
            "def concatenate(strs: List[str]) -> str:\n    # strs.join(\"\")\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # strs.select { |s| s.start_with?(prefix_str) }\n    return [s for s in strs if s.startswith(prefix_str)]\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # l.select { |num| num > 0 }\n    return [num for num in l if num > 0]\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2\n    if n < 2:\n        # return false\n        return False\n    # (2..Math.sqrt(n).floor).each do |i|\n    for i in range(2, int(n ** 0.5) + 1):\n        # if n % i == 0\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\n",
            "def poly(xs: List[float], x: float) -> float:\n    # res = 0\n    res = 0\n    # (0...xs.size).each do |i|\n    for i in range(len(xs)):\n        # res += xs[i] * x**i\n        res += xs[i] * x**i\n    # res\n    return res\ndef find_zero(xs: List[float]) -> float:\n    # x1, x2 = 1.0, -1.0\n    x1, x2 = 1.0, -1.0\n    # while poly(xs, x1) * poly(xs, x2) > 0\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2\n        x1 *= 2\n        # x2 *= 2\n        x2 *= 2\n    # while (x1 - x2).abs > 1e-10\n    while abs(x1 - x2) > 1e-10:\n        # mid = (x1 + x2) / 2\n        mid = (x1 + x2) / 2\n        # if poly(xs, mid) == 0\n        if poly(xs, mid) == 0:\n            # return mid\n            return mid\n        # elsif poly(xs, mid) * poly(xs, x1) < 0\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid\n            x2 = mid\n        # else\n        else:\n            # x1 = mid\n            x1 = mid\n    # (x1 + x2) / 2\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # sorted_third = l.select.with_index { |x, i| i % 3 == 0 }.sort\n    sorted_third = sorted([x for i, x in enumerate(l) if i % 3 == 0])\n    # l.map.with_index { |x, i| i % 3 == 0 ? sorted_third[i / 3] : x }\n    return [sorted_third[i // 3] if i % 3 == 0 else x for i, x in enumerate(l)]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # l.uniq.sort\n    return sorted(set(l))\n",
            "def max_element(l: List[int]) -> int:\n    # if l.empty?\n    if len(l) == 0:\n        # return 0\n        return 0\n    # l.max\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # cnt = 0\n    cnt = 0\n    # (0...n).each do |i|\n    for i in range(n):\n        # if i % 11 == 0 || i % 13 == 0\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += i.to_s.count(\"7\")\n            cnt += i.to_s().count(\"7\")\n    # cnt\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # sorted_even = l.select.with_index { |x, i| i % 2 == 0 }.sort\n    sorted_even = sorted([x for i, x in enumerate(l) if i % 2 == 0])\n    # l.map.with_index { |x, i| i % 2 == 0 ? sorted_even[i / 2] : x }  \n    return [sorted_even[i // 2] if i % 2 == 0 else x for i, x in enumerate(l)]\n",
            "def encode_cyclic(s: str) -> str:\n    # result = \"\"\n    result = \"\"\n    # (0...s.length).step(3) do |i|\n    for i in range(0, len(s), 3):\n        # if i + 3 > s.length\n        if i + 3 > len(s):\n            # result += s[i..]\n            result += s[i:]\n        else:\n            # result += s[i+1..i+2]\n            result += s[i+1:i+3]\n            # result += s[i]\n            result += s[i]\n    # result\n    return result\ndef decode_cyclic(s: str) -> str:\n    # encode_cyclic(encode_cyclic(s))\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2\n    if n < 2:\n        # return false\n        return False\n    # (2..Math.sqrt(n).floor).each do |i|\n    for i in range(2, int(n ** 0.5) + 1):\n        # if n % i == 0\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\ndef prime_fib(n: int) -> int:\n    # f = [0, 1]\n    f = [0, 1]\n    # cnt = 0\n    cnt = 0\n    # while cnt < n\n    while cnt < n:\n        # f = [f[1], f[0] + f[1]]\n        f = [f[1], f[0] + f[1]]\n        # if is_prime(f[1])\n        if is_prime(f[1]):\n            # cnt += 1\n            cnt += 1\n    # f[1]\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # (0...l.length).each do |i|\n    for i in range(len(l)):\n        # (i + 1...l.length).each do |j|\n        for j in range(i + 1, len(l)):\n            # (j + 1...l.length).each do |k|\n            for k in range(j + 1, len(l)):\n                # if l[i] + l[j] + l[k] == 0\n                if l[i] + l[j] + l[k] == 0:\n                    # return true\n                    return True\n            # end\n            pass\n        # end\n        pass\n    # end\n    pass\n    # false\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # n ** 2\n    return n ** 2\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # l.map { |i| i + 1 }\n    return [i + 1 for i in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # seen = Set.new\n    seen = set()\n    # l.each do |num|\n    for num in l:\n        # if seen.include?(-num)\n        if -num in seen:\n            # return true\n            return True\n        # seen.add(num)\n        seen.add(num)\n    # false\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if x == 0\n    if x == 0:\n        # return \"0\"\n        return \"0\"\n    # digits = []\n    digits = []\n    # while x > 0\n    while x > 0:\n        # digits << (x % bas).to_s\n        digits.append(str(x % bas))\n        # x /= bas\n        x //= bas\n    # digits.reverse.join(\"\")\n    return \"\".join(reversed(digits))\n",
            "def triangle_area(a: float, h: float) -> float:\n    # (a * h).to_f / 2\n    return (a * h) / 2\n",
            "def fib4(n: int) -> int:\n    # fib = [0, 0, 2, 0]\n    fib = [0, 0, 2, 0]\n    # (4..n).each do |i|\n    for i in range(4, n + 1):\n        # fib[i % 4] = fib.sum\n        fib[i % 4] = sum(fib)\n    # fib[n % 4]\n    return fib[n % 4]\n",
            "def median(l: List[int]) -> float:\n    # sl = l.sort\n    sl = sorted(l)\n    # if l.length % 2 != 0\n    if len(l) % 2 != 0:\n        # return sl[l.length / 2]\n        return sl[len(l) // 2]\n    else:\n        # return (sl[l.length / 2] + sl[l.length / 2 - 1]) / 2\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # txt == txt.reverse\n    return txt == txt[::-1]\n",
            "def modp(n: int, p: int) -> int:\n    # ret = 1\n    ret = 1\n    # (0...n).each do |i|\n    for i in range(n):\n        # ret = (ret * 2) % p\n        ret = (ret * 2) % p\n    # ret\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # result = s.chars.map { |ch| ((ch.ord - 97 + 5) % 26 + 97).chr }\n    result = [((ord(ch) - 97 + 5) % 26 + 97).chr for ch in s]\n    # result.join\n    return ''.join(result)\ndef decode_shift(s: str) -> str:\n    # result = s.chars.map { |ch| ((ch.ord - 97 + 21) % 26 + 97).chr }\n    result = [((ord(ch) - 97 + 21) % 26 + 97).chr for ch in s]\n    # result.join\n    return ''.join(result)\n",
            "def remove_vowels(txt: str) -> str:\n    # vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # txt.chars.select { |char| !vowels.include?(char) }.join\n    return \"\".join([char for char in txt if char not in vowels])\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # l.all? { |x| x < t }\n    return all(x < t for x in l)\n",
            "def add(x: int, y: int) -> int:\n    # x + y\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # s0.chars.to_set == s1.chars.to_set\n    return set(s0) == set(s1)\n",
            "def fib(n: int) -> int:\n    # if n <= 1\n    if n <= 1:\n        # n\n        return n\n    # else\n    else:\n        # fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # depth = 0\n    depth = 0\n    # brackets.each_char do |b|\n    for b in brackets:\n        # if b == '<'\n        if b == '<':\n            # depth += 1\n            depth += 1\n        # elsif b == '>'\n        elif b == '>':\n            # depth -= 1\n            depth -= 1\n        # end\n    # if depth < 0\n    if depth < 0:\n        # return false\n        return False\n    # end\n    # depth == 0\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # diff = l.each_cons(2).map { |a, b| b - a }\n    diff = [b - a for a, b in zip(l, l[1:])]\n    # diff.all? { |x| x <= 0 } || diff.all? { |x| x >= 0 }\n    return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # (l1 & l2).sort\n    return sorted(set(l1) & set(l2))\n",
            "def largest_prime_factor(n: int) -> int:\n    # i = 2\n    i = 2\n    # while i * i <= n\n    while i * i <= n:\n        # if n % i != 0\n        if n % i != 0:\n            # i += 1\n            i += 1\n        else:\n            # n /= i\n            n //= i\n    # n\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # (0..n).sum\n    return sum(range(n + 1))\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # depth = 0\n    depth = 0\n    # brackets.each_char do |b|\n    for b in brackets:\n        # if b == '('\n        if b == '(':\n            # depth += 1\n            depth += 1\n        # elsif b == ')'\n        elif b == ')':\n            # depth -= 1\n            depth -= 1\n        # end\n        # if depth < 0\n        if depth < 0:\n            # return false\n            return False\n        # end\n        # end\n    # depth == 0\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # xs.each_with_index.map { |x, i| x * i }.drop(1)\n    return [x * i for x, i in enumerate(xs)][1:]\n",
            "def fibfib(n: int) -> int:\n    # if n <= 1\n    if n <= 1:\n        # return 0\n        return 0\n    # a, b, c = 0, 0, 1\n    a, b, c = 0, 0, 1\n    # while n > 2\n    while n > 2:\n        # a, b, c = b, c, a + b + c\n        a, b, c = b, c, a + b + c\n        # n -= 1\n        n -= 1\n    # c\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # vowels = \"aeiou\"\n    vowels = \"aeiou\"\n    # cnt = 0\n    cnt = 0\n    # s.length.times do |i|\n    for i in range(len(s)):\n        # if vowels.include?(s[i].downcase) || (i == s.length - 1 && s[i].downcase == \"y\")\n        if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n            # cnt += 1\n            cnt += 1\n    # cnt\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # x_str = x.to_s\n    x_str = str(x)\n    # if shift > x_str.length\n    if shift > len(x_str):\n        # x_str.reverse\n        x_str = x_str[::-1]\n    # else\n    else:\n        # x_str[-shift..] + x_str[...-shift]\n        x_str = x_str[-shift:] + x_str[:-shift]\n    # return x_str\n    return x_str\n",
            "def digit_sum(s: str) -> int:\n    # s.chars.select { |c| c =~/[A-Z]/ }.reduce(0) { |a, c| a + c.ord }\n    return sum(ord(c) for c in s if c.isupper())\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # words = s.split(' ')\n    words = s.split()\n    # apples = words[words.index(\"apples\") - 1].to_i\n    apples = int(words[words.index(\"apples\") - 1])\n    # oranges = words[words.index(\"oranges\") - 1].to_i\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # n - apples - oranges\n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> Tuple[int, int]:\n    # evens = arr.select { |n| n % 2 == 0 }\n    evens = [n for n in arr if n % 2 == 0]\n    # if evens.length == 0\n    if len(evens) == 0:\n        # return []\n        return []\n    # min_even = evens.min\n    min_even = min(evens)\n    # [min_even, arr.index(min_even)]\n    return min_even, arr.index(min_even)\n",
            "def search(lst: List[int]) -> int:\n    # freqs = {}\n    freqs = {}\n    # lst.each do |n|\n    for n in lst:\n        # freqs[n] = freqs.fetch(n, 0) + 1\n        freqs[n] = freqs.get(n, 0) + 1\n    # good_vals = freqs.select { |k, v| v >= k }.keys\n    good_vals = [k for k, v in freqs.items() if v >= k]\n    # good_vals.max || -1\n    return max(good_vals) if good_vals else -1\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # sl = lst.sort\n    sl = sorted(lst)\n    # result = []\n    result = []\n    # left, right = 0, sl.length - 1\n    left, right = 0, len(sl) - 1\n    # while left <= right\n    while left <= right:\n        # result << sl[left]\n        result.append(sl[left])\n        # left += 1\n        left += 1\n        # if left <= right\n        if left <= right:\n            # result << sl[right]\n            result.append(sl[right])\n            # right -= 1\n            right -= 1\n    # result    \n    return result\n",
            "def triangle_area(a: float, b: float, c: float) -> float:\n    # if a + b > c && a + c > b && b + c > a\n    if a + b > c and a + c > b and b + c > a:\n        # s = (a + b + c) / 2.0\n        s = (a + b + c) / 2.0\n        # return Math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n    else:\n        # return -1.0\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if q.length == 0\n    if len(q) == 0:\n        # return false\n        return False\n    # is_palin = (0...q.length).all? do |i|\n    is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    # total = q.sum\n    total = sum(q)\n    # is_palin && total <= w\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # ans = 0\n    ans = 0\n    # (0...arr.length / 2).each do |i|\n    for i in range(0, len(arr) // 2):\n        # if arr[i] != arr[arr.length - i - 1]\n        if arr[i] != arr[len(arr) - i - 1]:\n            # ans += 1\n            ans += 1\n    # ans\n    return ans\n",
            "def total_match(lst1: List[List[int]], lst2: List[List[int]]) -> List[List[int]]:\n    # cnt1 = lst1.map(&:length).sum\n    cnt1 = sum(map(lambda x: len(x), lst1))\n    # cnt2 = lst2.map(&:length).sum\n    cnt2 = sum(map(lambda x: len(x), lst2))\n    # cnt1 <= cnt2 ? lst1 : lst2\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2\n    if n < 2:\n        # return false\n        return False\n    # (2..Math.sqrt(n).floor).each do |i|\n    for i in range(2, int(n ** 0.5) + 1):\n        # if n % i == 0\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # cnt = 0\n    cnt = 0\n    # (2..a).each do |i|\n    for i in range(2, a + 1):\n        # if is_prime(i)\n        if is_prime(i):\n            # while a % i == 0\n            while a % i == 0:\n                # cnt += 1\n                cnt += 1\n                # a /= i\n                a //= i\n    # cnt == 3\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if n < 2\n    if n < 2:\n        # return x == n\n        return x == n\n    # tmp = 1\n    tmp = 1\n    # while tmp < x\n    while tmp < x:\n        # tmp *= n\n        tmp *= n\n    # tmp == x\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # a = a.abs\n    a = abs(a)\n    # root = (a ** (1.0 / 3.0)).round.to_i\n    root = int(round((a ** (1.0 / 3.0))))\n    # root * root * root == a\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # num.count(\"2357BD\")\n    return num.count(\"2357BD\")\n",
            "def decimal_to_binary(dec: int) -> str:\n    # binary = dec.to_s(2)\n    binary = bin(dec)[2:]\n    # \"db#{binary}db\"\n    return \"db\" + binary + \"db\"\n",
            "def is_happy(s: str) -> bool:\n    # if s.length < 3\n    if len(s) < 3:\n        # return false\n        return False\n    # end\n    # for i in 0..(s.length - 3)\n    for i in range(0, len(s) - 3):\n        # if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false\n            return False\n        # end\n        # end\n    # end\n    # return true\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # result = []\n    result = []\n    # grades.each do |g|\n    for g in grades:\n        # case\n        # when g == 4.0\n        if g == 4.0:\n            # result << \"A+\"\n            result.append(\"A+\")\n        # when g > 3.7\n        elif g > 3.7:\n            # result << \"A\"\n            result.append(\"A\")\n        # when g > 3.3\n        elif g > 3.3:\n            # result << \"A-\"\n            result.append(\"A-\")\n        # when g > 3.0\n        elif g > 3.0:\n            # result << \"B+\"\n            result.append(\"B+\")\n        # when g > 2.7\n        elif g > 2.7:\n            # result << \"B\"\n            result.append(\"B\")\n        # when g > 2.3\n        elif g > 2.3:\n            # result << \"B-\"\n            result.append(\"B-\")\n        # when g > 2.0\n        elif g > 2.0:\n            # result << \"C+\"\n            result.append(\"C+\")\n        # when g > 1.7\n        elif g > 1.7:\n            # result << \"C\"\n            result.append(\"C\")\n        # when g > 1.3\n        elif g > 1.3:\n            # result << \"C-\"\n            result.append(\"C-\")\n        # when g > 1.0\n        elif g > 1.0:\n            # result << \"D+\"\n            result.append(\"D+\")\n        # when g > 0.7\n        elif g > 0.7:\n            # result << \"D\"\n            result.append(\"D\")\n        # when g > 0.0\n        elif g > 0.0:\n            # result << \"D-\"\n            result.append(\"D-\")\n        # else\n        else:\n            # result << \"E\"\n            result.append(\"E\")\n    # result\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # length = s.length\n    length = len(s)\n    # if length < 2\n    if length < 2:\n        # return false\n        return False\n    # end\n    # (2..Math.sqrt(length).floor).each do |i|\n    for i in range(2, int(length ** 0.5) + 1):\n        # if length % i == 0\n        if length % i == 0:\n            # return false\n            return False\n        # end\n    # end\n    # true\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if n == 1\n    if n == 1:\n        # return 1\n        return 1\n    # 2 * 9 * (10 ** (n - 2))\n    return 2 * 9 * (10 ** (n - 2))\n",
            "def solve(n: int) -> str:\n    # digits_sum = n.to_s.split('').map(&:to_i).sum\n    digits_sum = sum([int(d) for d in str(n)])\n    # digits_sum.to_s(2)\n    return bin(digits_sum)[2:]\n",
            "def add(lst: List[int]) -> int:\n    # lst.each_with_index.select { |x, i| i.odd? && x.even? }.map(&:first).sum\n    return sum(x for x, i in enumerate(lst) if i % 2 == 1 and x % 2 == 0)\n",
            "def anti_shuffle(s: str) -> str:\n    # words = s.split(\" \").map { |word| word.chars.sort.join }\n    words = [word for word in s.split(\" \") if word]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace(\" \", \"\") for word in words]\n    words = [word.replace",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # coords = []\n    coords = []\n    # lst.each_with_index do |row, i|\n    for row, i in enumerate(lst):\n        # row.each_with_index do |num, j|\n        for num, j in enumerate(row):\n            # if num == x\n            if num == x:\n                # coords << [i, j]\n                coords.append([i, j])\n    # coords.sort_by { |a| [a[0], -a[1]] }\n    coords.sort(key=lambda a: [a[0], -a[1]])\n    # return coords\n    return coords\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if arr.length == 0\n    if len(arr) == 0:\n        # return []\n        return []\n    # if (arr[0] + arr[-1]) % 2 == 0\n    if (arr[0] + arr[-1]) % 2 == 0:\n        # return arr.sort.reverse\n        return sorted(arr, reverse=True)\n    # else\n    else:\n        # return arr.sort\n        return sorted(arr)\n",
            "def encrypt(s: str) -> str:\n    # result = \"\"\n    result = \"\"\n    # s.each_char do |ch|\n    for ch in s:\n        # shifted = ch.ord + 4\n        shifted = ord(ch) + 4\n        # if shifted > 'z'.ord\n        if shifted > ord('z'):\n            # shifted -= 26\n            shifted -= 26\n        # result += shifted.chr\n        result += chr(shifted)\n    # result\n    return result\n",
            "def next_smallest(lst: List[int]) -> int:\n    # sl = lst.uniq.sort\n    sl = sorted(set(lst))\n    # if sl.length < 2\n    if len(sl) < 2:\n        # return nil\n        return None\n    # end\n    # sl[1]\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # sentences = s.split(/[.!?]\\s*/)\n    sentences = s.split(\"!\")\n    sentences = s.split(\"?\")\n    sentences = s.split(\".\")\n    # sentences.count { |sentence| sentence.length >= 2 && sentence[0..1] == \"I \" }\n    return sum(1 for sentence in sentences if len(sentence) >= 2 and sentence[0:2] == \"I \")\n",
            "def any_int(x: int, y: int, z: int) -> bool:\n    # if x.is_a?(Integer) && y.is_a?(Integer) && z.is_a?(Integer)\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # if (x + y == z) || (x + z == y) || (y + z == x)\n        if (x + y == z) or (x + z == y) or (y + z == x):\n            # return true\n            return True\n    # false\n    return False\n",
            "def encode(message: str) -> str:\n    # vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # result = \"\"\n    result = \"\"\n    # message.each_char do |ch|\n    for ch in message:\n        # if ch.match(/[a-zA-Z]/)\n        if ch.isalpha():\n            # ch1 = ch.upcase == ch ? ch.downcase : ch.upcase\n            ch1 = ch.lower() if ch.isupper() else ch.upper()\n            # if vowels.include?(ch1)\n            if ch1 in vowels:\n                # ch1 = (ch1.ord + 2).chr\n                ch1 = chr(ord(ch1) + 2)\n            # result += ch1\n            result += ch1\n        else:\n            # result += ch\n            result += ch\n    # result\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2\n    if n < 2:\n        # return false\n        return False\n    # (2..Math.sqrt(n).floor).each do |i|\n    for i in range(2, int(n ** 0.5) + 1):\n        # if n % i == 0\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # primes = lst.select { |n| is_prime(n) }\n    primes = [n for n in lst if is_prime(n)]\n    # if primes.length == 0\n    if len(primes) == 0:\n        # return 0\n        return 0\n    # largest = primes.max.to_s\n    largest = str(max(primes))\n    # largest.chars.map(&:to_i).sum\n    return sum(map(int, largest))\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if d.empty?\n    if not d:\n        # return false\n        return False\n    # d.keys.all? { |k| k.match(/^[A-Z]+$/) } || d.keys.all? { |k| k.match(/^[a-z]+$/) }\n    return all(k.isupper() for k in d.keys()) or all(k.islower() for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # primes = []\n    primes = []\n    # (2...n).each do |num|\n    for num in range(2, n):\n        # if primes.all? { |p| num % p != 0 }\n        if all(num % p != 0 for p in primes):\n            # primes << num\n            primes.append(num)\n    # primes\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # (a.abs % 10) * (b.abs % 10)\n    return (abs(a) % 10) * (abs(b) % 10)\n",
            "def count_upper(s: str) -> int:\n    # vowels = \"AEIOU\"\n    vowels = \"AEIOU\"\n    # s.chars.select.with_index { |c, i| i % 2 == 0 && vowels.include?(c) }.length\n    return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n",
            "def closest_integer(value: float) -> int:\n    # num = value.to_f\n    num = float(value)\n    # if num >= 0\n    if num >= 0.0:\n        # return (num + 0.5).to_i\n        return int(num + 0.5)\n    # else\n    else:\n        # return (num - 0.5).to_i\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # (0...n).map { |i| n + 2 * i }\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # s.split(/[ ,]/).select { |w| w.length > 0 }\n    return [w for w in s.split(/[ ,]/) if len(w) > 0]\n",
            "def choose_num(x: int, y: int) -> int:\n    # if x > y\n    if x > y:\n        # return -1\n        return -1\n    # if y % 2 == 0\n    if y % 2 == 0:\n        # return y\n        return y\n    # y != x ? y - 1 : -1\n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> str:\n    # if n > m\n    if n > m:\n        # return nil\n        return None\n    # r_avg = ((n + m) / 2.0 + 0.5).to_i\n    r_avg = int((n + m) / 2.0 + 0.5)\n    # r_avg.to_s(2)\n    return str(r_avg)\n",
            "def all_digits_odd(s: str) -> bool:\n    # s.chars.all? { |digit| digit.ord % 2 != 0 }\n    return all(digit.ord % 2 != 0 for digit in s)\ndef unique_digits(x: List[int]) -> List[int]:\n    # x.select { |n| all_digits_odd(n.to_s) }.sort\n    return sorted(filter(lambda n: all_digits_odd(str(n)), x))\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # sorted_arr = arr.select { |x| 1 <= x && x <= 9 }.sort.reverse\n    sorted_arr = sorted(filter(lambda x: 1 <= x and x <= 9, arr), reverse=True)\n    # sorted_arr.map { |x| digit_names[x - 1] }\n    return list(map(lambda x: digit_names[x - 1], sorted_arr))\n",
            "def f(n: int) -> List[int]:\n    # nums = (1..n).to_a\n    nums = list(range(1, n + 1))\n    # nums.map { |i| i % 2 != 0 ? nums.take(i).sum : nums.take(i).reduce(:*) }\n    return [nums.take(i).sum() if i % 2 != 0 else nums.take(i).reduce(lambda a, b: a * b) for i in nums]\n",
            "def is_palindrome(s: str) -> bool:\n    # s == s.reverse\n    return s == s[::-1]\ndef even_odd_palindrome(n: int) -> List[int]:\n    # cnt = [0, 0]\n    cnt = [0, 0]\n    # for i in 1..n\n    for i in range(1, n + 1):\n        # if is_palindrome(i.to_s)\n        if is_palindrome(str(i)):\n            # cnt[i % 2] += 1\n            cnt[i % 2] += 1\n    # cnt\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # n_str = n.to_s\n    n_str = str(n)\n    # if n >= 0\n    if n >= 0:\n        # n_str.split('').map(&:to_i).sum\n        return sum(map(int, n_str.split('')))\n    # else\n    else:\n        # n_str[0..1].to_i * 2 + digits_sum(n.abs)\n        return int(n_str[0:2]) * 2 + digits_sum(abs(n))\ndef count_nums(arr: List[int]) -> int:\n    # arr.count { |n| digits_sum(n) > 0 }\n    return len(list(filter(lambda n: digits_sum(n) > 0, arr)))\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if arr.empty?\n    if not arr:\n        # return true\n        return True\n    # sorted_arr = arr.sort\n    sorted_arr = sorted(arr)\n    # for i in 0..arr.length-1\n    for i in range(len(arr)):\n        # if arr[i..] == sorted_arr[0...arr.length-i] and arr[0...i] == sorted_arr[arr.length-i..]\n        if arr[i:] == sorted_arr[0:len(arr)-i] and arr[0:i] == sorted_arr[len(arr)-i:]:\n            # return true\n            return True\n    # false\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # odd_cnt = lst1.count { |n| n % 2 != 0 }\n    odd_cnt = sum(1 for n in lst1 if n % 2 != 0)\n    # even_cnt = lst2.count { |n| n % 2 == 0 }\n    even_cnt = sum(1 for n in lst2 if n % 2 == 0)\n    # return even_cnt >= odd_cnt ? \"YES\" : \"NO\"\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # freq = {}\n    freq = {}\n    # words = test.split(\" \").select { |w| w.length > 0 }\n    words = [w for w in test.split(\" \") if len(w) > 0]\n    # words.each do |w|\n    for w in words:\n        # freq[w] = freq.fetch(w, 0) + 1\n        freq[w] = freq.get(w, 0) + 1\n    # result = {}\n    result = {}\n    # if freq.length > 0\n    if len(freq) > 0:\n        # max_freq = freq.values.max\n        max_freq = max(freq.values())\n        # freq.each do |k, v|\n        for k, v in freq.items():\n            # if v == max_freq\n            if v == max_freq:\n                # result[k] = v\n                result[k] = v\n    # end\n    # return result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # s == s.reverse\n    return s == s[::-1]\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # s1 = s.chars.select { |ch| !c.include?(ch) }.join\n    s1 = ''.join([ch for ch in s if ch not in c])\n    # return [s1, is_palindrome(s1) ? \"yes\" : \"no\"]\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # result = []\n    result = []\n    # lst.each do |num|\n    for num in lst:\n        # n = num.chars.count { |d| d.ord % 2 == 1 }\n        n = sum(1 for d in num if ord(d) % 2 == 1)\n        # rs = \"the number of odd elements in the string i of the input.\"\n        rs = \"the number of odd elements in the string {} of the input.\".format(n)\n        # result.push(rs.gsub(\"i\", n.to_s))\n        result.append(rs.replace(\"i\", str(n)))\n    # result\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # min_sum = 0\n    min_sum = 0\n    # cur_sum = 0\n    cur_sum = 0\n    # nums.each do |n|\n    for n in nums:\n        # cur_sum = [cur_sum + n, 0].min\n        cur_sum = min(cur_sum + n, 0)\n        # min_sum = [cur_sum, min_sum].min\n        min_sum = min(cur_sum, min_sum)\n    # if min_sum == 0\n    if min_sum == 0:\n        # min_sum = nums.min\n        min_sum = min(nums)\n    # min_sum\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # grid.map { |arr| (arr.sum / capacity.to_f).ceil }.sum\n    return sum(map(lambda arr: int(arr.sum / capacity), grid))\n",
            "def count_ones(num: int) -> int:\n    # num.to_s(2).count(\"1\")\n    return bin(num).count(\"1\")\ndef sort_array(arr: List[int]) -> List[int]:\n    # arr.sort_by { |n| [count_ones(n), n] }\n    return sorted(arr, key=lambda n: (count_ones(n), n))\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # consonants = \"bcdfghjklmnpqrstvwxyz\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # words = s.split(\" \").select { |w| w.length > 0 }\n    words = [w for w in s.split(\" \") if len(w) > 0]\n    # words.select { |w| w.chars.count { |c| consonants.include?(c.downcase) } == n }\n    return [w for w in words if w.count(lambda c: c.lower() in consonants) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # (word.length - 2).downto(1) do |i|\n    for i in range(len(word) - 2, 0, -1):\n        # if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return word[i]\n            return word[i]\n    # return \"\"\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # depth = 0\n    depth = 0\n    # s.each_char do |ch|\n    for ch in s:\n        # if ch == \"(\"\n        if ch == \"(\":\n            # depth += 1\n            depth += 1\n        else:\n            # depth -= 1\n            depth -= 1\n        # if depth < 0\n        if depth < 0:\n            # return false \n            return False\n    # depth == 0 ? true : false\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # s1 = lst[0] + lst[1]\n    s1 = lst[0] + lst[1]\n    # s2 = lst[1] + lst[0]\n    s2 = lst[1] + lst[0]\n    # check(s1) || check(s2) ? \"Yes\" : \"No\"\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if k == 0\n    if k == 0:\n        # return []\n        return []\n    # arr.sort[-k..]\n    return sorted(arr)[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # lst.each_with_index.select { |x, i| i.even? && x.odd? }.map(&:first).sum\n    return sum(map(lambda x: x[0], filter(lambda x: x[1].even() and x[0].odd(), enumerate(lst))))\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # arr.take(k).select { |n| n.to_s.length <= 2 }.sum\n    return sum(filter(lambda n: len(str(n)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # collatz = [1]\n    collatz = [1]\n    # while n != 1\n    while n != 1:\n        # if n % 2 != 0\n        if n % 2 != 0:\n            # collatz.append(n)\n            collatz.append(n)\n            # n = 3 * n + 1\n            n = 3 * n + 1\n        else:\n            # n = n / 2\n            n = n / 2\n    # collatz.sort\n    collatz.sort()\n    # return collatz\n    return collatz\n",
            "def valid_date(date: str) -> bool:\n    # if date.length != 10 || date[2] != \"-\" || date[5] != \"-\"\n    if len(date) != 10 or date[2] != \"-\" or date[5] != \"-\":\n        # return false\n        return False\n    # end\n    # m = date[0..1].to_i\n    m = int(date[0:2])\n    # d = date[3..4].to_i\n    d = int(date[3:5])\n    # if [1, 3, 5, 7, 8, 10, 12].include?(m) && d >= 1 && d <= 31\n    if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n        # return true\n        return True\n    # end\n    # if [4, 6, 9, 11].include?(m) && d >= 1 && d <= 30\n    if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n        # return true\n        return True\n    # end\n    # if m == 2 && d >= 1 && d <= 29\n    if m == 2 and d >= 1 and d <= 29:\n        # return true\n        return True\n    # end\n    # false\n    False\n",
            "def split_words(txt: str) -> List[str]:\n    # if txt.include?(\" \")\n    if \" \" in txt:\n        # txt.split\n        return txt.split()\n    # elsif txt.include?(\",\")\n    elif \",\" in txt:\n        # txt.split(\",\")\n        return txt.split(\",\")\n    # else\n    else:\n        # [txt.chars.count { |c| c == c.downcase && c.ord % 2 == 0 }.to_s]\n        return [str(sum(1 for c in txt if c.islower() and ord(c) % 2 == 0))]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if !lst.each_cons(2).all? { |a, b| a <= b }\n    if not all(a <= b for a, b in zip(lst, lst[1:])):\n        return False\n    # freq = {}\n    freq = {}\n    # lst.each do |i|\n    for i in lst:\n        # freq[i] = freq.fetch(i, 0) + 1\n        freq[i] = freq.get(i, 0) + 1\n    # (freq.values.max || 0) <= 2\n    return max(freq.values() or [0]) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2\n    if n < 2:\n        # return false\n        return False\n    # (2..Math.sqrt(n).floor).each do |i|\n    for i in range(2, int(n ** 0.5) + 1):\n        # if n % i == 0\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # l = [interval1[0], interval2[0]].max\n    l = max(interval1[0], interval2[0])\n    # r = [interval1[1], interval2[1]].min\n    r = min(interval1[1], interval2[1])\n    # length = r - l\n    length = r - l\n    # length > 0 && is_prime(length) ? \"YES\" : \"NO\"\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> int:\n    # if arr.empty?\n    if not arr:\n        # return nil\n        return None\n    # end\n    # if arr.include?(0)\n    if 0 in arr:\n        # return 0\n        return 0\n    # end\n    # sign = arr.count { |n| n < 0 } % 2 == 1 ? -1 : 1\n    sign = 1 if arr.count(lambda n: n < 0) % 2 == 1 else -1\n    # sign * arr.map(&:abs).sum\n    return sign * sum(map(lambda n: abs(n), arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # n = grid.length\n    n = len(grid)\n    # min_val = n * n + 1\n    min_val = n * n + 1\n    # (0...n).each do |i|\n    for i in range(n):\n        # (0...n).each do |j|\n        for j in range(n):\n            # if grid[i][j] == 1\n            if grid[i][j] == 1:\n                # temp = []\n                temp = []\n                # if i != 0\n                if i != 0:\n                    # temp << grid[i - 1][j]\n                    temp.append(grid[i - 1][j])\n                # if j != 0\n                if j != 0:\n                    # temp << grid[i][j - 1]\n                    temp.append(grid[i][j - 1])\n                # if i != n - 1\n                if i != n - 1:\n                    # temp << grid[i + 1][j]\n                    temp.append(grid[i + 1][j])\n                # if j != n - 1\n                if j != n - 1:\n                    # temp << grid[i][j + 1]\n                    temp.append(grid[i][j + 1])\n                # min_val = temp.min\n                min_val = min(temp)\n    # result = []\n    result = []\n    # (0...k).each do |i|\n    for i in range(k):\n        # result << (i % 2 == 0 ? 1 : min_val)\n        result.append(1 if i % 2 == 0 else min_val)\n    # result\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if n == 0\n    if n == 0:\n        # return [1]\n        return [1]\n    # seq = [1, 3]\n    seq = [1, 3]\n    # for i in 2..n\n    for i in range(2, n + 1):\n        # if i % 2 == 0\n        if i % 2 == 0:\n            # seq << i / 2 + 1\n            seq.append(i // 2 + 1)\n        # else\n        else:\n            # seq << seq[i - 1] + seq[i - 2] + (i + 3) / 2\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) // 2)\n    # seq\n    return seq\n",
            "def digits(n: int) -> int:\n    # odds = n.to_s.chars.select { |d| d.to_i % 2 == 1 }.map(&:to_i)\n    odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    # odds.empty? ? 0 : odds.reduce(:*)\n    return 0 if len(odds) == 0 else reduce(lambda x, y: x * y, odds)\n",
            "def is_nested(s: str) -> bool:\n    # open_idx = []\n    open_idx = []\n    # close_idx = []\n    close_idx = []\n    # s.chars.each_with_index do |ch, i|\n    for i, ch in enumerate(s):\n        # case ch\n        # when '['\n        if ch == '[':\n            # open_idx << i\n            open_idx.append(i)\n        # when ']'\n        elif ch == ']':\n            # close_idx << i\n            close_idx.append(i)\n    # close_idx.reverse!\n    close_idx.reverse()\n    # cnt = 0\n    cnt = 0\n    # i = 0\n    i = 0\n    # l = close_idx.length\n    l = len(close_idx)\n    # open_idx.each do |idx|\n    for idx in open_idx:\n        # if i < l && idx < close_idx[i]\n        if i < l and idx < close_idx[i]:\n            # cnt += 1\n            cnt += 1\n            # i += 1\n            i += 1\n    # cnt >= 2\n    return cnt >= 2\n",
            "def sum_squares(lst: List[int]) -> int:\n    # lst.map { |n| n.ceil.pow(2) }.sum\n    return sum([n.ceil().pow(2) for n in lst])\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if txt.empty?\n    if not txt:\n        # return false\n        return False\n    # last = txt[(txt.rindex(\" \") || -1) + 1..]\n    last = txt[(txt.rfind(\" \") + 1) if txt.rfind(\" \") != -1 else 0:]\n    # last.length == 1 && last[0].match?(/[[:alpha:]]/)\n    return len(last) == 1 and last[0].isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if arr.length <= 1\n    if len(arr) <= 1:\n        # return -1\n        return -1\n    # idx = (1...arr.length).select { |i| arr[i] < arr[i - 1] }\n    idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    # idx.max || -1\n    return max(idx) if idx else -1\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # neg = lst.select { |i| i < 0 }\n    neg = [i for i in lst if i < 0]\n    # pos = lst.select { |i| i > 0 }\n    pos = [i for i in lst if i > 0]\n    # max_neg = neg.max || nil\n    max_neg = max(neg) if neg else None\n    # min_pos = pos.min || nil\n    min_pos = min(pos) if pos else None\n    # [max_neg, min_pos]\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if o.is_a?(String)\n    if isinstance(o, str):\n        # return o.gsub(',', '.').to_f\n        return float(o.replace(',', '.'))\n    # elsif o.is_a?(Integer)\n    elif isinstance(o, int):\n        # return o.to_f\n        return float(o)\n    # elsif o.is_a?(Float)\n    elif isinstance(o, float):\n        # return o\n        return o\n    # end\n    # raise Exception.new \"Type Error\"\n    raise Exception(\"Type Error\")\ndef compare_one(a: Any, b: Any) -> float:\n    # a1 = any_to_real(a)\n    a1 = any_to_real(a)\n    # b1 = any_to_real(b)\n    b1 = any_to_real(b)\n    # if a1 == b1\n    if a1 == b1:\n        # return nil\n        return None\n    # elsif a1 > b1\n    elif a1 > b1:\n        # return a1\n        return a1\n    # else\n    else:\n        # return b1\n        return b1\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # n % 2 == 0 && n >= 8\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # fact = 1\n    fact = 1\n    # result = 1\n    result = 1\n    # (1..n).each do |i|\n    for i in range(1, n + 1):\n        # fact *= i\n        fact *= i\n        # result *= fact\n        result *= fact\n    # result\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # txt.gsub(/\\s{3,}/, \"-\").gsub(\" \", \"_\")\n    return txt.replace(\" \", \"_\").replace(\" \", \"-\")\n",
            "def file_name_check(file_name: str) -> str:\n    # suf = [\"txt\", \"exe\", \"dll\"]\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # lst = file_name.split(\".\")\n    lst = file_name.split(\".\")\n    # if lst.length != 2 || !suf.include?(lst[1]) || lst[0].length == 0 || !lst[0][0].match?(/[[:alpha:]]/) || lst[0].chars.count { |x| x.match?(/[[:digit:]]/) } > 3\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or lst[0][0].isalpha() == False or lst[0].count(str.isdigit()) > 3:\n        # return \"No\"\n        return \"No\"\n    # end\n    # \"Yes\"\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # result = 0\n    result = 0\n    # lst.length.times do |i|\n    for i in range(len(lst)):\n        # if i % 3 == 0\n        if i % 3 == 0:\n            # result += lst[i].pow(2)\n            result += lst[i] ** 2\n        # elsif i % 4 == 0\n        elif i % 4 == 0:\n            # result += lst[i].pow(3)\n            result += lst[i] ** 3\n        # else\n        else:\n            # result += lst[i]\n            result += lst[i]\n    # result\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2\n    if n < 2:\n        # return false\n        return False\n    # (2..Math.sqrt(n).floor).each do |i|\n    for i in range(2, int(n ** 0.5) + 1):\n        # if n % i == 0\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # words = sentence.split(\" \")\n    words = sentence.split(\" \")\n    # words.select { |w| is_prime(w.length) }.join(\" \")\n    return \" \".join([w for w in words if is_prime(len(w))])\n",
            "def simplify(x: str, n: str) -> bool:\n    # xs = x.split('/')\n    xs = x.split('/')\n    # ns = n.split('/')\n    ns = n.split('/')\n    # num = xs[0].to_i * ns[0].to_i\n    num = int(xs[0]) * int(ns[0])\n    # den = xs[1].to_i * ns[1].to_i\n    den = int(xs[1]) * int(ns[1])\n    # num % den == 0\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # n_str = n.to_s\n    n_str = str(n)\n    # if n >= 0\n    if n >= 0:\n        # n_str.split('').map(&:to_i).sum\n        return sum(map(int, n_str.split('')))\n    # else\n    else:\n        # n_str[0..1].to_i * 2 + digits_sum(n.abs)\n        return int(n_str[0:2]) * 2 + digits_sum(abs(n))\ndef order_by_points(nums: List[int]) -> List[int]:\n    # nums.sort_by {|n| digits_sum(n)}\n    return sorted(nums, key=lambda n: digits_sum(n))\n",
            "def special_filter(nums: List[int]) -> int:\n    # odds = \"13579\"\n    odds = \"13579\"\n    # nums.count { |n| n > 10 && n % 2 == 1 && odds.include?(n.to_s[0]) }\n    return sum(1 for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds)\n",
            "def get_max_triples(n: int) -> int:\n    # c = [0, 0, 0]\n    c = [0, 0, 0]\n    # (1..n).each do |i|\n    for i in range(1, n + 1):\n        # a = i * i - i + 1\n        a = i * i - i + 1\n        # c[a % 3] += 1\n        c[a % 3] += 1\n    # c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if !names.include?(planet1) || !names.include?(planet2)\n    if planet1 not in names or planet2 not in names:\n        # return []\n        return []\n    # end\n    # l = names.index(planet1)\n    l = names.index(planet1)\n    # r = names.index(planet2)\n    r = names.index(planet2)\n    # if l > r\n    if l > r:\n        # l, r = r, l\n        l, r = r, l\n    # end\n    # if l == r\n    if l == r:\n        # return []\n        return []\n    # end\n    # names[l + 1...r]\n    return names[l + 1:r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # result = lst.select { |s| s.length.even? }\n    result = [s for s in lst if len(s) % 2 == 0]\n    # result.sort_by { |s| [s.length, s] }\n    result.sort(key=lambda s: [len(s), s])\n    # return result\n    return result\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if n < 2\n    if n < 2:\n        # return y\n        return y\n    # (2..Math.sqrt(n).floor).each do |i|\n    for i in range(2, int(n ** 0.5) + 1):\n        # if n % i == 0\n        if n % i == 0:\n            # return y\n            return y\n    # return x\n    return x\n",
            "def double_the_difference(lst: List[int]) -> int:\n    # lst.select { |n| n >= 0 && n % 2 == 1 }.map { |n| (n * n).to_i }.sum\n    return sum([(n * n).to_i for n in lst if n >= 0 and n % 2 == 1])\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # game.zip(guess).map { |x, y| (x - y).abs }\n    return [abs(x - y) for x, y in zip(game, guess)]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # max_s = -Float::INFINITY\n    max_s = float(\"-inf\")\n    # max_ext = \"\"\n    max_ext = \"\"\n    # extensions.each do |ext|\n    for ext in extensions:\n        # upper = ext.chars.count { |c| c == c.upcase }\n        upper = sum(1 for c in ext if c.isupper())\n        # lower = ext.chars.count { |c| c == c.downcase }\n        lower = sum(1 for c in ext if c.islower())\n        # s = upper - lower\n        s = upper - lower\n        # if s > max_s\n        if s > max_s:\n            # max_s = s\n            max_s = s\n            # max_ext = ext\n            max_ext = ext\n    # \"#{class_name}.#{max_ext}\"\n    return f\"{class_name}.{max_ext}\"\n",
            "def cycpattern_check(a: List[int], b: List[int]) -> bool:\n    # return false if a.length < b.length\n    if len(a) < len(b):\n        return False\n    # b.length.times do |i|\n    for i in range(len(b)):\n        # if a.include?(b[i..] + b[0...i])\n        if a[i:] + a[0:i] in a:\n            # return true\n            return True\n    # false\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # ds = num.abs.to_s\n    ds = str(abs(num))\n    # even = ds.chars.count { |d| d.to_i % 2  == 0 }\n    even = sum(1 for d in ds if int(d) % 2 == 0)\n    # [even, ds.length - even]\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    # numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # res = \"\"\n    res = \"\"\n    # values.length.times do |i|\n    for i in range(len(values)):\n        # while num >= values[i]\n        while num >= values[i]:\n            # res += numerals[i]\n            res += numerals[i]\n            # num -= values[i]\n            num -= values[i]\n    # res\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # s = [a, b, c].sort\n    s = sorted([a, b, c])\n    # s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # max_cnt = 0\n    max_cnt = 0\n    # max_w = \"\"\n    max_w = \"\"\n    # words.each do |w|\n    for w in words:\n        # cnt = w.chars.uniq.size\n        cnt = len(set(w))\n        # if cnt > max_cnt\n        if cnt > max_cnt:\n            # max_cnt = cnt\n            max_cnt = cnt\n            # max_w = w\n            max_w = w\n        # elsif cnt == max_cnt\n        elif cnt == max_cnt:\n            # max_w = [max_w, w].min\n            max_w = min(max_w, w)\n    # max_w\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if need <= remaining\n    if need <= remaining:\n        # [num + need, remaining - need]\n        return [num + need, remaining - need]\n    # else\n    else:\n        # [num + remaining, 0]\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # ops = operators.dup\n    ops = operators.copy()\n    # nums = operands.dup\n    nums = operands.copy()\n    # i = ops.length - 1\n    i = len(ops) - 1\n    # while i >= 0\n    while i >= 0:\n        # if ops[i] == \"**\"\n        if ops[i] == \"**\":\n            # nums[i] = nums[i] ** nums[i + 1]\n            nums[i] = nums[i] ** nums[i + 1]\n            # nums.delete_at(i + 1)\n            del nums[i + 1]\n            # ops.delete_at(i)\n            del ops[i]\n        # end\n        # i -= 1\n        i -= 1\n    # i = 0\n    i = 0\n    # while i < ops.length\n    while i < len(ops):\n        # if ops[i] == \"*\"\n        if ops[i] == \"*\":\n            # nums[i] = nums[i] * nums[i + 1]\n            nums[i] = nums[i] * nums[i + 1]\n            # nums.delete_at(i + 1)\n            del nums[i + 1]\n            # ops.delete_at(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # elsif ops[i] == \"//\"\n        elif ops[i] == \"//\":\n            # nums[i] = nums[i] / nums[i + 1]\n            nums[i] = nums[i] / nums[i + 1]\n            # nums.delete_at(i + 1)\n            del nums[i + 1]\n            # ops.delete_at(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # end\n        # i += 1\n        i += 1\n    # i = 0\n    i = 0\n    # while i < ops.length\n    while i < len(ops):\n        # if ops[i] == \"+\"\n        if ops[i] == \"+\":\n            # nums[i] = nums[i] + nums[i + 1]\n            nums[i] = nums[i] + nums[i + 1]\n            # nums.delete_at(i + 1)\n            del nums[i + 1]\n            # ops.delete_at(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # elsif ops[i] == \"-\"\n        elif ops[i] == \"-\":\n            # nums[i] = nums[i] - nums[i + 1]\n            nums[i] = nums[i] - nums[i + 1]\n            # nums.delete_at(i + 1)\n            del nums[i + 1]\n            # ops.delete_at(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # end\n        # i += 1\n        i += 1\n    # nums[0]\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if !s.chars.any? { |ch| ch =~ /[a-zA-Z]/ }\n    if not any(ch for ch in s if ch.isalpha()):\n        # return s.reverse\n        return s[::-1]\n    # result = \"\"\n    result = \"\"\n    # s.each_char do |ch|\n    for ch in s:\n        # if !(ch =~ /[a-zA-Z]/)\n        if not ch.isalpha():\n            # result += ch\n            result += ch\n        # elsif ch =~ /[A-Z]/\n        elif ch.isupper():\n            # result += ch.downcase\n            result += ch.lower()\n        # elsif ch =~ /[a-z]/\n        elif ch.islower():\n            # result += ch.upcase\n            result += ch.upper()\n    # result \n    return result\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if txt.empty?\n    if not txt:\n        # return nil\n        return None\n    # md5_hash = Digest::MD5.new\n    md5_hash = hashlib.md5()\n    # txt_bytes = txt.encode()\n    txt_bytes = txt.encode()\n    # md5_hash.update(txt_bytes)\n    md5_hash.update(txt_bytes)\n    # md5_encoded = md5_hash.hexdigest()\n    md5_encoded = md5_hash.hexdigest()\n    # md5_encoded\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # lower = [2, [a, b].min].max\n    lower = max(2, min(a, b))\n    # upper = [8, [a, b].max].min\n    upper = min(8, max(a, b))\n    # (lower..upper).select { |i| i.even? }\n    return [i for i in range(lower, upper + 1) if i % 2 == 0]\n"
        ]
    },
    "rust": {
        "python": [
            "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # for i in 0..numbers.len() {\n    for i in range(len(numbers)):\n        # for j in (i + 1)..numbers.len() {\n        for j in range(i + 1, len(numbers)):\n            # if (numbers[i] - numbers[j]).abs() < threshold {\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true;\n                return True\n    # false\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # let mut groups: Vec<String> = Vec::new();\n    groups = []\n    # let mut stk: Vec<char> = Vec::new();\n    stk = []\n    # let mut current_group: String = String::new();\n    current_group = \"\"\n    # let parens = paren_string.replace(\" \", \"\");\n    parens = paren_string.replace(\" \", \"\")\n    # for ch in parens.chars() {\n    for ch in parens:\n        # if ch == '(' {\n        if ch == '(':\n            # stk.push(ch);\n            stk.append(ch)\n            # current_group.push(ch);\n            current_group += ch\n        # } else if ch == ')' {\n        elif ch == ')':\n            # stk.pop();\n            stk.pop()\n            # current_group.push(ch);\n            current_group += ch\n            # if stk.is_empty() {\n            if not stk:\n                # groups.push(current_group.clone());\n                groups.append(current_group)\n                # current_group.clear();\n                current_group = \"\"\n    # groups\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # num - num.floor()\n    return num - num.floor()\n",
            "def below_zero(operations: List[int]) -> bool:\n    # let mut balance = 0;\n    balance = 0\n    # for op in operations {\n    for op in operations:\n        # balance += op;\n        balance += op\n        # if balance < 0 {\n        if balance < 0:\n            # return true;\n            return True\n    # false\n    return False\n",
            "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # let mean = numbers.iter().sum::<f64>() / numbers.len() as f64;\n    mean = sum(numbers) / len(numbers)\n    # let deviation = numbers.iter().map(|x| (x - mean).abs()).sum::<f64>();\n    deviation = sum(abs(x - mean) for x in numbers)\n    # deviation / numbers.len() as f64\n    deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # let mut result = Vec::new();\n    result = []\n    # for i in 0..numbers.len() {\n    for i in range(len(numbers)):\n        # if i != 0 {\n        if i != 0:\n            # result.push(delimiter);\n            result.append(delimiter)\n        # result.push(numbers[i]);\n        result.append(numbers[i])\n    # result\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # let mut result = Vec::new();\n    result = []\n    # let paren_group = paren_string.split_whitespace();\n    paren_group = paren_string.split()\n    # for group in paren_group {\n    for group in paren_group:\n        # let mut max_depth = 0;\n        max_depth = 0\n        # let mut depth = 0;\n        depth = 0\n        # for ch in group.chars() {\n        for ch in group:\n            # if ch == '(' {\n            if ch == '(':\n                # depth += 1;\n                depth += 1\n                # max_depth = max(max_depth, depth);\n                max_depth = max(max_depth, depth)\n            # } else if ch == ')' {\n            elif ch == ')':\n                # depth -= 1;\n                depth -= 1\n        # result.push(max_depth);\n        result.append(max_depth)\n    # result\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # strs.iter().filter(|s| s.contains(substring)).cloned().collect()\n    return [s for s in strs if substring in s]\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # let n_sum = numbers.iter().sum();\n    n_sum = sum(numbers)\n    # let n_product = numbers.iter().product();\n    n_product = 1\n    for n in numbers:\n        n_product *= n\n    # vec![n_sum, n_product]\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # let mut max_so_far = i32::MIN;\n    max_so_far = -2147483648\n    # let mut result = Vec::new();\n    result = []\n    # for num in numbers {\n    for num in numbers:\n        # max_so_far = max(max_so_far, *num);\n        max_so_far = max(max_so_far, num)\n        # result.push(max_so_far);\n        result.append(max_so_far)\n    # result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # s == &s.chars().rev().collect::<String>()\n    return s == s[::-1]\ndef make_palindrome(s: str) -> str:\n    # if is_palindrome(s) {\n    if is_palindrome(s):\n        # return s.clone();\n        return s\n    # for i in 0..s.len() {\n    for i in range(len(s)):\n        # if is_palindrome(&s[i..].to_string()) {\n        if is_palindrome(s[i:]):\n            # return s.clone() + &s[..i].chars().rev().collect::<String>();\n            return s + s[:i][::-1]\n    # String::new()\n    return ''\n",
            "def string_xor(a: str, b: str) -> str:\n    # a.chars().zip(b.chars()).map(|(x, y)| if x == y { '0' } else { '1' }).collect()   \n    return ''.join(map(lambda x: '1' if x[0] != x[1] else '0', zip(a, b)))\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if strs.is_empty() {\n    if not strs:\n        # return None;\n        return None\n    # let mut longest_s = strs[0].clone();\n    longest_s = strs[0]\n    # for s in strs {\n    for s in strs:\n        # if s.len() > longest_s.len() {\n        if len(s) > len(longest_s):\n            # longest_s = s.clone();\n            longest_s = s\n    # Some(longest_s)\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if b == 0 {\n    if b == 0:\n        # a\n        return a\n    # } else {\n    #     greatest_common_divisor(b, a % b)\n    # }\n    return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # let mut prefixes = Vec::new();\n    prefixes = []\n    # for i in 0..s.len() {\n    for i in range(len(s)):\n        # prefixes.push(s[..i + 1].to_string());\n        prefixes.append(s[:i + 1])\n    # prefixes\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # (0..=n).map(|i| i.to_string()).collect::<Vec<String>>().join(\" \")\n    return \" \".join([str(i) for i in range(n + 1)])\n",
            "def count_distinct_characters(s: str) -> int:\n    # s.to_lowercase().chars().collect::<HashSet<char>>().len() as i32\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # let durations: HashMap<&str, i32> = HashMap::from([(\"o\", 4), (\"o|\", 2), (\".|\", 1)]);\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    # let notes: Vec<&str> = music_string.split_whitespace().collect();\n    notes = music_string.split()\n    # let parsed_notes: Vec<i32> = notes.iter().map(|note| durations.get(note).unwrap_or(&0).clone()).collect();\n    parsed_notes = [durations.get(note, 0) for note in notes]\n    # parsed_notes\n    return parsed_notes\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # let mut times = 0;\n    times = 0\n    # for i in 0..=(s.len() as i32 - substring.len() as i32) {\n    for i in range(0, s.len() - substring.len() + 1):\n        # if &s[i as usize..i as usize + substring.len()] == substring {\n        if s[i:i + len(substring)] == substring:\n            # times += 1;\n            times += 1\n    # times\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # let mut num_dict: HashMap<&str, i32> = HashMap::from([\n    num_dict = defaultdict(int)\n    # (\"zero\", 0),\n    num_dict[\"zero\"] = 0\n    # (\"one\", 1),\n    num_dict[\"one\"] = 1\n    # (\"two\", 2),\n    num_dict[\"two\"] = 2\n    # (\"three\", 3),\n    num_dict[\"three\"] = 3\n    # (\"four\", 4),\n    num_dict[\"four\"] = 4\n    # (\"five\", 5),\n    num_dict[\"five\"] = 5\n    # (\"six\", 6),\n    num_dict[\"six\"] = 6\n    # (\"seven\", 7),\n    num_dict[\"seven\"] = 7\n    # (\"eight\", 8),\n    num_dict[\"eight\"] = 8\n    # (\"nine\", 9)\n    num_dict[\"nine\"] = 9\n    # ]);\n    # let mut num_list: Vec<&str> = numbers.split(\" \").filter(|&x| num_dict.contains_key(x)).collect();\n    num_list = [x for x in numbers.split(\" \") if x in num_dict]\n    # num_list.sort_by_key(|&x| num_dict[x]);\n    num_list.sort(key=lambda x: num_dict[x])\n    # num_list.join(\" \")\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[float]) -> List[float]:\n    # let mut sorted_numbers = numbers.clone();\n    sorted_numbers = numbers.copy()\n    # sorted_numbers.sort_by(|a, b| a.total_cmp(b));\n    sorted_numbers.sort()\n    # let mut min_diff = f64::INFINITY;\n    min_diff = float('inf')\n    # let mut closest_pair = vec![];\n    closest_pair = []\n    # for i in 1..sorted_numbers.len() {\n    for i in range(1, len(sorted_numbers)):\n        # let diff = sorted_numbers[i] - sorted_numbers[i - 1];\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if diff < min_diff {\n        if diff < min_diff:\n            # min_diff = diff;\n            min_diff = diff\n            # closest_pair = vec![sorted_numbers[i - 1], sorted_numbers[i]];\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # closest_pair\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # let min_num = numbers.iter().min_by(|a, b| a.total_cmp(b)).unwrap();\n    min_num = min(numbers)\n    # let max_num = numbers.iter().max_by(|a, b| a.total_cmp(b)).unwrap();\n    max_num = max(numbers)\n    # if min_num == max_num {\n    if min_num == max_num:\n        # vec![0.0; numbers.len()]\n        [0.0] * len(numbers)\n    # else {\n    else:\n        # numbers.iter().map(|num| (num - min_num) / (max_num - min_num)).collect()\n        [num - min_num / (max_num - min_num) for num in numbers]\n    # }\n",
            "def filter_integers(values: List[Any]) -> List[int]:\n    # let mut integers = Vec::new();\n    integers = []\n    # for value in values {\n    for value in values:\n        # if let Some(&integer) = value.downcast_ref::<i32>() {\n        if isinstance(value, int):\n            # integers.push(integer);\n            integers.append(value)\n    # integers\n    return integers\n",
            "def str_length(s: str) -> int:\n    # s.len() as i32\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for i in (2..n) {\n    for i in range(2, n):\n        # if n % i == 0 {\n        if n % i == 0:\n            # return n / i\n            return n / i\n    # 1\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # let mut factors = Vec::new();\n    factors = []\n    # let mut divisor = 2;\n    divisor = 2\n    # let mut num = n;\n    num = n\n    # while divisor <= num {\n    while divisor <= num:\n        # if num % divisor == 0 {\n        if num % divisor == 0:\n            # factors.push(divisor);\n            factors.append(divisor)\n            # num /= divisor;\n            num /= divisor\n        # else {\n        else:\n            # divisor += 1;\n            divisor += 1\n    # factors\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # let mut counts: HashMap<i32, i32> = HashMap::new();\n    counts = {}\n    # for &num in numbers {\n    for num in numbers:\n        # counts.insert(num, counts.get(&num).unwrap_or(&0) + 1);\n        counts[num] = counts.get(num, 0) + 1\n    # let mut res: Vec<i32> = numbers.iter().filter(|num| counts.get(num) == Some(&1)).cloned().collect();\n    res = [num for num in numbers if counts.get(num) == 1]\n    # res\n    return res\n",
            "def flip_case(s: str) -> str:\n    # let mut flipped = String::new();\n    flipped = ''\n    # for ch in s.chars() {\n    for ch in s:\n        # if !ch.is_alphabetic() {\n        if not ch.isalpha():\n            # flipped.push(ch);\n            flipped += ch\n        # } else if ch.is_lowercase() {\n        elif ch.islower():\n            # flipped.push(ch.to_ascii_uppercase());\n            flipped += ch.upper()\n        # } else if ch.is_uppercase() {\n        elif ch.isupper():\n            # flipped.push(ch.to_ascii_lowercase());\n            flipped += ch.lower()\n    # flipped\n    return flipped\n",
            "def concatenate(strs: List[str]) -> str:\n    # strs.join(\"\")\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # strs.iter().filter(|s| s.starts_with(prefix_str)).cloned().collect::<Vec<String>>()\n    return [s for s in strs if s.startswith(prefix_str)]\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # l.iter().filter(|&x| *x > 0).cloned().collect::<Vec<i32>>()\n    return [x for x in l if x > 0]\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return false;\n        return False\n    # for i in 2..=(n as f64).sqrt().floor() as i32 {\n    for i in range(2, (n ** 0.5) + 1):\n        # if n % i == 0 {\n        if n % i == 0:\n            # return false;\n            return False\n    # true\n    return True\n",
            "def poly(xs: List[int], x: float) -> float:\n    # let mut res = 0.0;\n    res = 0.0\n    # for i in 0..xs.len() {\n    for i in range(len(xs)):\n        # res += xs[i] as f64 * x.powi(i as i32);\n        res += xs[i] * x ** i\n    # res\n    return res\ndef find_zero(xs: List[int]) -> float:\n    # let (mut x1, mut x2) = (1.0, -1.0);\n    x1, x2 = 1.0, -1.0\n    # while poly(xs, x1) * poly(xs, x2) > 0.0 {\n    while poly(xs, x1) * poly(xs, x2) > 0.0:\n        # x1 *= 2.0;\n        x1 *= 2.0\n        # x2 *= 2.0;\n        x2 *= 2.0\n    # while (x1 - x2).abs() > 1e-10 {\n    while (x1 - x2).abs() > 1e-10:\n        # let mid = (x1 + x2) / 2.0;\n        mid = (x1 + x2) / 2.0\n        # if poly(xs, mid) == 0.0 {\n        if poly(xs, mid) == 0.0:\n            # return mid;\n            return mid\n        # else if poly(xs, mid) * poly(xs, x1) < 0.0 {\n        elif poly(xs, mid) * poly(xs, x1) < 0.0:\n            # x2 = mid;\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid;\n            x1 = mid\n    # (x1 + x2) / 2.0\n    return (x1 + x2) / 2.0\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # let mut sorted_third = l.iter().enumerate().filter(|(i, _)| i % 3 == 0).map(|(_, &x)| x).collect::<Vec<_>>();\n    sorted_third = [x for i, x in enumerate(l) if i % 3 == 0]\n    # sorted_third.sort();\n    sorted_third.sort()\n    # l.iter().enumerate().map(|(i, &x)| if i % 3 == 0 { sorted_third[i / 3] } else { x }).collect()\n    return [sorted_third[i / 3] if i % 3 == 0 else x for i, x in enumerate(l)]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # let mut result: Vec<i32> = l.clone();\n    result = l.copy()\n    # result.sort();\n    result.sort()\n    # result.dedup();\n    result = list(set(result))\n    # result\n    return result\n",
            "def max_element(l: List[int]) -> int:\n    # if l.is_empty() {\n    if not l:\n        # return 0;\n        return 0\n    # *l.iter().max().unwrap()\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # let mut cnt = 0;\n    cnt = 0\n    # for i in 0..n {\n    for i in range(n):\n        # if i % 11 == 0 || i % 13 == 0 {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += i.to_string().matches(\"7\").count() as i32;\n            cnt += i.to_string().count(\"7\")\n    # cnt\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # let mut sorted_even = l.iter().enumerate().filter(|(i, _)| i % 2 == 0).map(|(_, &x)| x).collect::<Vec<_>>();\n    sorted_even = [x for i, x in enumerate(l) if i % 2 == 0]\n    # sorted_even.sort();\n    sorted_even.sort()\n    # l.iter().enumerate().map(|(i, &x)| if i % 2 == 0 { sorted_even[i / 2] } else { x }).collect()\n    return [sorted_even[i // 2] if i % 2 == 0 else x for i, x in enumerate(l)]\n",
            "def encode_cyclic(s: str) -> str:\n    # let mut result = String::new();\n    result = ''\n    # for i in (0..s.len()).step_by(3) {\n    for i in range(0, len(s), 3):\n        # if i + 3 > s.len() {\n        if i + 3 > len(s):\n            # result.push_str(&s[i..]);\n            result += s[i:]\n        # } else {\n        else:\n            # result.push_str(&s[i + 1..i + 3]);\n            result += s[i + 1:i + 3]\n            # result.push(s.chars().nth(i).unwrap());\n            result += s[i]\n    # result\n    return result\ndef decode_cyclic(s: str) -> str:\n    encode_cyclic(&encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return false;\n        return False\n    # for i in 2..=(n as f64).sqrt().floor() as i32 {\n    for i in range(2, (n ** 0.5) + 1):\n        # if n % i == 0 {\n        if n % i == 0:\n            # return false;\n            return False\n    # true\n    return True\ndef prime_fib(n: int) -> int:\n    # let mut f = vec![0, 1];\n    f = [0, 1]\n    # let mut cnt = 0;\n    cnt = 0\n    # while cnt < n {\n    while cnt < n:\n        # f = vec![f[1], f[0] + f[1]];\n        f = [f[1], f[0] + f[1]]\n        # if is_prime(f[1]) {\n        if is_prime(f[1]):\n            # cnt += 1;\n            cnt += 1\n    # f[1]\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for i in 0..l.len() {\n    for i in range(len(l)):\n        # for j in (i + 1)..l.len() {\n        for j in range(i + 1, len(l)):\n            # for k in (j + 1)..l.len() {\n            for k in range(j + 1, len(l)):\n                # if l[i] + l[j] + l[k] == 0 {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true;\n                    return True\n    # false\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # n.pow(2)\n    return n ** 2\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # l.iter().map(|x| x + 1).collect()\n    return [x + 1 for x in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # let mut seen = HashSet::new();\n    seen = set()\n    # for num in l {\n    for num in l:\n        # if seen.contains(&(-num)) {\n        if -num in seen:\n            # return true;\n            return True\n        # seen.insert(num);\n        seen.add(num)\n    # false\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # let mut x = x;\n    x = x\n    # if x == 0 {\n    if x == 0:\n        # return \"0\".to_string();\n        return \"0\"\n    # let mut digits = Vec::new();\n    digits = []\n    # while x > 0 {\n    while x > 0:\n        # digits.push((x % bas).to_string());\n        digits.append(str(x % bas))\n        # x /= bas;\n        x //= bas\n    # digits.reverse();\n    digits.reverse()\n    # digits.join(\"\")\n    return \"\".join(digits)\n",
            "def triangle_area(a: int, h: int) -> float:\n    # (a * h) as f64 / 2 as f64\n    return (a * h) / 2\n",
            "def fib4(n: int) -> int:\n    # let mut fib = [0, 0, 2, 0];\n    fib = [0, 0, 2, 0]\n    # for i in 4..=n {\n    for i in range(4, n + 1):\n        # fib[(i % 4) as usize] = fib.iter().sum();\n        fib[(i % 4)] = sum(fib)\n    # fib[(n % 4) as usize]\n    return fib[(n % 4)]\n",
            "def median(l: List[float]) -> float:\n    # let mut sl = l.clone();\n    sl = l.copy()\n    # sl.sort_by(|a, b| a.total_cmp(b));\n    sl.sort()\n    # if l.len() % 2 != 0 {\n    if len(l) % 2 != 0:\n        # sl[l.len() / 2]\n        sl[len(l) // 2]\n    # } else {\n    else:\n        # (sl[l.len() / 2] + sl[l.len() / 2 - 1]) / 2.0\n        (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2.0\n    # }\n",
            "def is_palindrome(txt: str) -> bool:\n    # txt == &txt.chars().rev().collect::<String>()\n    return txt == ''.join(reversed(txt))\n",
            "def modp(n: int, p: int) -> int:\n    # let mut ret = 1;\n    ret = 1\n    # for _ in 0..n {\n    for _ in range(n):\n        # ret = (ret * 2) % p;\n        ret = (ret * 2) % p\n    # ret\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # let result = s.chars().map(|ch| (((ch as u8 - 97 + 5) % 26) + 97) as char);\n    result = [(((ord(ch) - 97 + 5) % 26) + 97) for ch in s]\n    # result.collect::<String>()\n    return ''.join(result)\ndef decode_shift(s: str) -> str:\n    # let result = s.chars().map(|ch| (((ch as u8 - 97 + 21) % 26) + 97) as char);\n    result = [(((ord(ch) - 97 + 21) % 26) + 97) for ch in s]\n    # result.collect::<String>()\n    return ''.join(result)\n",
            "def remove_vowels(txt: str) -> str:\n    # let vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # txt.chars().filter(|&c| !vowels.contains(c)).collect::<String>()\n    return ''.join(c for c in txt if c not in vowels)\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # l.iter().all(|&x| x < t)\n    return all(x < t for x in l)\n",
            "def add(x: int, y: int) -> int:\n    # x + y\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # s0.chars().collect::<HashSet<_>>() == s1.chars().collect::<HashSet<_>>()\n    return set(s0) == set(s1)\n",
            "def fib(n: int) -> int:\n    # if n <= 1 {\n    if n <= 1:\n        # n\n        return n\n    # } else {\n    else:\n        # fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # let mut depth = 0;\n    depth = 0\n    # for b in brackets.chars() {\n    for b in brackets:\n        # if b == '<' {\n        if b == '<':\n            # depth += 1;\n            depth += 1\n        # } else if b == '>' {\n        elif b == '>':\n            # depth -= 1;\n            depth -= 1\n        # }\n        # if depth < 0 {\n        if depth < 0:\n            # return false;\n            return False\n        # }\n    # depth == 0\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # let diff = l.iter().zip(l[1..].iter()).map(|(x, y)| y - x).collect::<Vec<i32>>();\n    diff = [y - x for x, y in zip(l, l[1:])]\n    # diff.iter().all(|&x| x <= 0) || diff.iter().all(|&x| x >= 0)\n    return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # let mut result = l1.iter().filter(|&x| l2.contains(x)).map(|&x| x).collect::<Vec<i32>>();\n    result = [x for x in l1 if x in l2]\n    # result.dedup();\n    result = list(set(result))\n    # result.sort();\n    result.sort()\n    # result    \n    return result\n",
            "def largest_prime_factor(n: int) -> int:\n    # let mut n = n;\n    n = n\n    # let mut i = 2;\n    i = 2\n    # while i * i <= n {\n    while i * i <= n:\n        # if n % i == 0 {\n        if n % i == 0:\n            # n /= i;\n            n /= i\n        else:\n            # i += 1;\n            i += 1\n    # n\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # (0..=n).sum()\n    return sum(range(n + 1))\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # let mut depth = 0;\n    depth = 0\n    # for b in brackets.chars() {\n    for b in brackets:\n        # if b == '(' {\n        if b == '(':\n            # depth += 1;\n            depth += 1\n        # } else if b == ')' {\n        elif b == ')':\n            # depth -= 1;\n            depth -= 1\n        # if depth < 0 {\n        if depth < 0:\n            # return false;\n            return False\n    # depth == 0\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # xs.iter().enumerate().map(|(i, x)| x * i as i32).skip(1).collect()\n    return [x * i for i, x in enumerate(xs)][1:]\n",
            "def fibfib(n: int) -> int:\n    # if n <= 1 {\n    if n <= 1:\n        # return 0;\n        return 0\n    # let (mut a, mut b, mut c) = (0, 0, 1);\n    a, b, c = 0, 0, 1\n    # let mut n = n;\n    n = n\n    # while n > 2 {\n    while n > 2:\n        # (a, b, c) = (b, c, a + b + c);\n        a, b, c = b, c, a + b + c\n        # n -= 1;\n        n -= 1\n    # c\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # let vowels = \"aeiou\";\n    vowels = \"aeiou\"\n    # let mut cnt = 0;\n    cnt = 0\n    # for i in 0..s.len() {\n    for i in range(len(s)):\n        # if vowels.contains(s[i..i+1].to_lowercase().as_str()) || (i == s.len() - 1 && s[i..i+1].to_lowercase() == \"y\") {\n        if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n            # cnt += 1;\n            cnt += 1\n    # cnt\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # let x_str = x.to_string();\n    x_str = str(x)\n    # if shift as usize > x_str.len() {\n    if shift > len(x_str):\n        # return x_str.chars().rev().collect();\n        return ''.join(reversed(x_str))\n    # } else {\n    #     return x_str[x_str.len() - shift as usize..].to_string() + &x_str[..x_str.len() - shift as usize];\n    # }\n    return x_str[len(x_str) - shift:].to_string() + x_str[:len(x_str) - shift]\n",
            "def digit_sum(s: str) -> int:\n    # s.chars().filter(|c| c.is_ascii_uppercase()).map(|c| c as i32 ).sum()\n    return sum(map(lambda c: ord(c), filter(lambda c: c.is_ascii_uppercase(), s)))\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # let words = s.split(\" \").collect::<Vec<&str>>();\n    words = s.split(\" \")\n    # let apples = words[words.iter().position(|&w| w == \"apples\").unwrap() - 1].parse::<i32>().unwrap();\n    apples = int(words[words.index(\"apples\") - 1])\n    # let oranges = words[words.iter().position(|&w| w == \"oranges\").unwrap() - 1].parse::<i32>().unwrap();\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # n - apples - oranges\n    n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # let evens = arr.iter().filter(|&n| n % 2 == 0).cloned().collect::<Vec<i32>>();\n    evens = [n for n in arr if n % 2 == 0]\n    # if evens.len() == 0 {\n    if len(evens) == 0:\n        # return vec![];\n        return []\n    # let min_even = *evens.iter().min().unwrap();\n    min_even = min(evens)\n    # vec![min_even, arr.iter().position(|&n| n == min_even).unwrap() as i32]\n    return [min_even, arr.index(min_even)]\n",
            "def search(lst: List[int]) -> int:\n    # let mut freqs: HashMap<i32, i32> = HashMap::new();\n    freqs = defaultdict(int)\n    # for &n in lst {\n    for n in lst:\n        # freqs.insert(n, freqs.get(&n).unwrap_or(&0) + 1);\n        freqs[n] += 1\n    # let mut good_vals: Vec<i32> = freqs.iter().filter(|(&k, &v)| v >= k).map(|(&k, &v)| k).collect();\n    good_vals = [k for k, v in freqs.items() if v >= k]\n    # *good_vals.iter().max().unwrap_or(&-1)\n    max(good_vals) or -1\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # let mut sl = lst.clone();\n    sl = lst.copy()\n    # sl.sort();\n    sl.sort()\n    # let mut result = Vec::new();\n    result = []\n    # let (mut left, mut right) = (0, sl.len() as i32 - 1);\n    left, right = 0, len(sl) - 1\n    # while left <= right {\n    while left <= right:\n        # result.push(sl[left as usize]);\n        result.append(sl[left])\n        # left += 1;\n        left += 1\n        # if left <= right {\n        if left <= right:\n            # result.push(sl[right as usize]);\n            result.append(sl[right])\n            # right -= 1;\n            right -= 1\n    # result\n    return result\n",
            "def triangle_area(a: int, b: int, c: int) -> float:\n    # if a + b > c && a + c > b && b + c > a {\n    if a + b > c and a + c > b and b + c > a:\n        # let s = (a + b + c) as f64 / 2.0;\n        s = (a + b + c) / 2.0\n        # (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n        (s * (s - a) * (s - b) * (s - c)).sqrt()\n    # } else {\n    else:\n        # -1.0\n        -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if q.len() == 0 {\n    if len(q) == 0:\n        # return false;\n        return False\n    # let is_palin = (0..q.len()).all(|i| q[i] == q[q.len() - i - 1]);\n    is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    # let total = q.iter().sum::<i32>();\n    total = sum(q)\n    # is_palin && total <= w\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # let mut ans = 0;\n    ans = 0\n    # for i in 0..arr.len() / 2 {\n    for i in range(0, len(arr) // 2):\n        # if arr[i] != arr[arr.len() - i - 1] {\n        if arr[i] != arr[len(arr) - i - 1]:\n            # ans += 1;\n            ans += 1\n    # ans\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # let cnt1 = lst1.iter().map(|s| s.len()).sum::<usize>();\n    cnt1 = sum(map(lambda s: len(s), lst1))\n    # let cnt2 = lst2.iter().map(|s| s.len()).sum::<usize>();\n    cnt2 = sum(map(lambda s: len(s), lst2))\n    # if cnt1 <= cnt2 { lst1.clone() } else { lst2.clone() }\n    return lst1.copy() if cnt1 <= cnt2 else lst2.copy()\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return false;\n        return False\n    # for i in 2..=(n as f64).sqrt().floor() as i32 {\n    for i in range(2, (n ** 0.5) + 1):\n        # if n % i == 0 {\n        if n % i == 0:\n            # return false;\n            return False\n    # true\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # let mut cnt = 0;\n    cnt = 0\n    # let mut a = a;\n    a = a\n    # for i in 2..=a {\n    for i in range(2, a + 1):\n        # if is_prime(i) {\n        if is_prime(i):\n            # while a % i == 0 {\n            while a % i == 0:\n                # cnt += 1;\n                cnt += 1\n                # a /= i;\n                a /= i\n    # cnt == 3\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return x == n;\n        return x == n\n    # let mut tmp = 1;\n    tmp = 1\n    # while tmp < x {\n    while tmp < x:\n        # tmp *= n;\n        tmp *= n\n    # tmp == x\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # let a = a.abs();\n    a = abs(a)\n    # let root = (a as f64).powf(1.0 / 3.0).round() as i32;\n    root = round((a ** (1.0 / 3.0)))\n    # root * root * root == a\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # num.chars().filter(|&x| \"2357BD\".contains(x)).count() as i32\n    return len(list(filter(lambda x: x in \"2357BD\", num)))\n",
            "def decimal_to_binary(dec: int) -> str:\n    # format!(\"db{:b}db\", dec)\n    return \"db{:b}db\".format(dec)\n",
            "def is_happy(s: str) -> bool:\n    # if s.len() < 3 {\n    if len(s) < 3:\n        # return false;\n        return False\n    # for i in 0..s.len() - 2 {\n    for i in range(0, len(s) - 2):\n        # if s.chars().nth(i) == s.chars().nth(i + 1) || s.chars().nth(i) == s.chars().nth(i + 2) || s.chars().nth(i + 1) == s.chars().nth(i + 2) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false;\n            return False\n    # true\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # let mut result = Vec::new();\n    result = []\n    # for &g in grades {\n    for g in grades:\n        # match () {\n        #     _ if g == 4.0 => result.push(\"A+\".to_string()),\n        if g == 4.0:\n            result.append(\"A+\")\n        #     _ if g > 3.7 => result.push(\"A\".to_string()),\n        elif g > 3.7:\n            result.append(\"A\")\n        #     _ if g > 3.3 => result.push(\"A-\".to_string()),\n        elif g > 3.3:\n            result.append(\"A-\")\n        #     _ if g > 3.0 => result.push(\"B+\".to_string()),\n        elif g > 3.0:\n            result.append(\"B+\")\n        #     _ if g > 2.7 => result.push(\"B\".to_string()),\n        elif g > 2.7:\n            result.append(\"B\")\n        #     _ if g > 2.3 => result.push(\"B-\".to_string()),\n        elif g > 2.3:\n            result.append(\"B-\")\n        #     _ if g > 2.0 => result.push(\"C+\".to_string()),\n        elif g > 2.0:\n            result.append(\"C+\")\n        #     _ if g > 1.7 => result.push(\"C\".to_string()),\n        elif g > 1.7:\n            result.append(\"C\")\n        #     _ if g > 1.3 => result.push(\"C-\".to_string()),\n        elif g > 1.3:\n            result.append(\"C-\")\n        #     _ if g > 1.0 => result.push(\"D+\".to_string()),\n        elif g > 1.0:\n            result.append(\"D+\")\n        #     _ if g > 0.7 => result.push(\"D\".to_string()),\n        elif g > 0.7:\n            result.append(\"D\")\n        #     _ if g > 0.0 => result.push(\"D-\".to_string()),\n        elif g > 0.0:\n            result.append(\"D-\")\n        #     _ => result.push(\"E\".to_string()),        \n        else:\n            result.append(\"E\")\n        # }\n    # result\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # let length = s.len() as i32;\n    length = len(s)\n    # if length < 2 {\n    if length < 2:\n        # return false;\n        return False\n    # for i in 2..=(length as f64).sqrt().floor() as i32 {\n    for i in range(2, (length as f64).sqrt().floor() as i32 + 1):\n        # if length % i == 0 {\n        if length % i == 0:\n            # return false;\n            return False\n    # true\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if n == 1 {\n    if n == 1:\n        # return 1;\n        return 1\n    # 2 * 9 * (10 as i32).pow(n as u32 - 2)\n    return 2 * 9 * (10 ** (n - 2))\n",
            "def solve(n: int) -> str:\n    # let digits_sum: u32 = n.to_string().chars().map(|d| d.to_digit(10).unwrap()).sum();\n    digits_sum = sum(map(int, str(n)))\n    # format!(\"{:b}\", digits_sum)\n    return format(f\"{digits_sum:b}\")\n",
            "def add(lst: List[int]) -> int:\n    # lst.iter().enumerate().filter(|&(i, x)| i % 2 == 1 && x % 2 == 0).map(|(_, x)| x).sum()\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)\n",
            "def anti_shuffle(s: str) -> str:\n    # let mut words: Vec<String> = s.split(\" \").map(|word| {\n    words = s.split(\" \")\n    # let mut chars: Vec<char> = word.chars().collect();\n    # chars.sort();\n    # chars.into_iter().collect()\n    words = [word for word in words]\n    # words.join(\" \")\n    return \" \".join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # let mut coords: Vec<Vec<i32>> = Vec::new();\n    coords = []\n    # for i in 0..lst.len() {\n    for i in range(len(lst)):\n        # for j in 0..lst[i].len() {\n        for j in range(len(lst[i])):\n            # if lst[i][j] == x {\n            if lst[i][j] == x:\n                # coords.push(vec![i as i32, j as i32]);\n                coords.append([i, j])\n    # coords.sort_by(|a, b| {\n    coords.sort(key=lambda a, b:\n        # if a[0] == b[0] {\n        if a[0] == b[0]:\n            # b[1].cmp(&a[1])\n            b[1] - a[1]\n        else:\n            # a[0].cmp(&b[0])\n            a[0] - b[0]\n    )\n    # coords\n    return coords\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if arr.len() == 0 {\n    if len(arr) == 0:\n        # return vec![];\n        return []\n    # let mut result: Vec<i32> = arr.clone();\n    result = arr.copy()\n    # if (arr[0] + arr[arr.len() - 1]) % 2 == 0 {\n    if (arr[0] + arr[len(arr) - 1]) % 2 == 0:\n        # result.sort_by(|a, b| b.cmp(a));\n        result.sort(key=lambda a, b: b.cmp(a))\n    # } else {\n    else:\n        # result.sort();\n        result.sort()\n    # result\n    return result\n",
            "def encrypt(s: str) -> str:\n    # let mut result = String::new();\n    result = ''\n    # for ch in s.chars() {\n    for ch in s:\n        # let shifted = ch as u8 + 4;\n        shifted = ord(ch) + 4\n        # if shifted > 'z' as u8 {\n        if shifted > ord('z'):\n            # result.push((shifted - 26) as char);\n            result += chr(shifted - 26)\n        # } else {\n        else:\n            # result.push(shifted as char);\n            result += chr(shifted)\n    # result\n    return result\n",
            "def next_smallest(lst: List[int]) -> Optional[int]:\n    # let mut sl: Vec<i32> = lst.clone();\n    sl = lst.copy()\n    # sl.sort();\n    sl.sort()\n    # sl.dedup();\n    sl = list(set(sl))\n    # if sl.len() < 2 {\n    if len(sl) < 2:\n        # return None;\n        return None\n    # Some(sl[1])\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # let sentences: Vec<&str> = Regex::new(r\"[.!?]\\s*\").unwrap().split(s).collect();\n    sentences = re.split(r\"[.!?]\\s*\", s)\n    # sentences.iter().filter(|sentence| sentence.len() >= 2 && sentence.chars().take(2).collect::<String>() == \"I \").count() as i32\n    return sum(1 for sentence in sentences if len(sentence) >= 2 and sentence[:2] == \"I \")\n",
            "def any_int(x: Any, y: Any, z: Any) -> bool:\n    # if let (Some(int_x), Some(int_y), Some(int_z)) = (x.downcast_ref::<i32>(), y.downcast_ref::<i32>(), z.downcast_ref::<i32>()) {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        int_x = x\n        int_y = y\n        int_z = z\n        # if (int_x + int_y == *int_z) || (int_x + int_z == *int_y) || (int_y + int_z == *int_x) {\n        if int_x + int_y == int_z or int_x + int_z == int_y or int_y + int_z == int_x:\n            # return true;\n            return True\n    # }\n    # false\n    return False\n",
            "def encode(message: str) -> str:\n    # let vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # let mut result = String::new();\n    result = \"\"\n    # for ch in message.chars() {\n    for ch in message:\n        # if ch.is_alphabetic() {\n        if ch.isalpha():\n            # let mut ch1 = if ( ch.is_lowercase() ) { ch.to_uppercase().next().unwrap() } else { ch.to_lowercase().next().unwrap() };\n            ch1 = ch.upper() if ch.islower() else ch.lower()\n            # if vowels.contains(ch1) {\n            if ch1 in vowels:\n                # ch1 = (ch1 as u8 + 2) as char;\n                ch1 = chr(ord(ch1) + 2)\n            # result.push(ch1);\n            result += ch1\n        # } else {\n        else:\n            # result.push(ch);\n            result += ch\n    # result\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return false;\n        return False\n    # for i in 2..=(n as f64).sqrt().floor() as i32 {\n    for i in range(2, (n ** 0.5) + 1):\n        # if n % i == 0 {\n        if n % i == 0:\n            # return false;\n            return False\n    # true\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # let primes: Vec<i32> = lst.iter().filter(|&n| is_prime(*n)).map(|&n| n).collect();\n    primes = [n for n in lst if is_prime(n)]\n    # if primes.len() == 0 {\n    if len(primes) == 0:\n        # return 0;\n        return 0\n    # let largest = primes.iter().max().unwrap().to_string();\n    largest = max(primes)\n    # largest.chars().map(|c| c.to_digit(10).unwrap() as i32).sum()\n    sum([int(c) for c in str(largest)])\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if d.len() == 0 {\n    if len(d) == 0:\n        # return false;\n        return False\n    # d.keys().all(|k| k.chars().all(|c| c.is_lowercase())) || d.keys().all(|k| k.chars().all(|c| c.is_uppercase()))\n    return all(k.islower() for k in d.keys()) or all(k.isupper() for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # let mut primes = Vec::new();\n    primes = []\n    # for num in 2..n {\n    for num in range(2, n):\n        # if primes.iter().all(|&p| num % p != 0) {\n        if all(num % p != 0 for p in primes):\n            # primes.push(num);\n            primes.append(num)\n    # primes\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # (a.abs() % 10) as i32 * (b.abs() % 10) as i32\n    return (abs(a) % 10) * (abs(b) % 10)\n",
            "def count_upper(s: str) -> int:\n    # let vowels = \"AEIOU\";\n    vowels = \"AEIOU\"\n    # s.char_indices().filter(|(i, c)| i % 2 == 0 && vowels.contains(*c)).count() as i32\n    return sum(1 for i, c in enumerate(s) if i % 2 == 0 and c in vowels)\n",
            "def closest_integer(value: str) -> int:\n    # let num = value.parse::<f64>().unwrap();\n    num = float(value)\n    # if num >= 0.0 {\n    if num >= 0.0:\n        # (num + 0.5) as i32\n        return int(num + 0.5)\n    # } else {\n    else:\n        # (num - 0.5) as i32\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # (0..n).map(|i| n + 2 * i).collect()\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # Regex::new(r\"[, ]\").unwrap().split(s).filter(|w| w.len() > 0).map(|w| w.to_string()).collect()\n    return re.split(r\"[, ]\", s).filter(lambda w: len(w) > 0).map(lambda w: w.to_string()).collect()\n",
            "def choose_num(x: int, y: int) -> int:\n    # if x > y {\n    if x > y:\n        # return -1;\n        return -1\n    # if y % 2 == 0 {\n    if y % 2 == 0:\n        # return y;\n        return y\n    # if y != x { y - 1 } else { -1 }\n    if y != x:\n        return y - 1\n    else:\n        return -1\n",
            "def rounded_avg(n: int, m: int) -> Optional[str]:\n    # if n > m {\n    if n > m:\n        # return None;\n        return None\n    # let r_avg = ((n + m) as f64 / 2.0 + 0.5) as i32;\n    r_avg = int((n + m) / 2.0 + 0.5)\n    # Some(format!(\"{:b}\", r_avg))\n    return format(\"{:b}\", r_avg)\n",
            "def all_digits_odd(s: str) -> bool:\n    # s.chars().all(|digit| digit as u8 % 2 != 0)\n    return all(digit % 2 != 0 for digit in map(ord, s))\ndef unique_digits(x: List[int]) -> List[int]:\n    # let mut result: Vec<i32> = x.iter().filter(|&num| all_digits_odd(&num.to_string())).map(|&num| num).collect();\n    result = list(filter(lambda num: all_digits_odd(str(num)), x))\n    # result.sort();\n    result.sort()\n    # result\n    return result\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # let digit_names = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # let mut sorted_arr: Vec<i32> = arr.iter().filter(|&x| 1 <= *x && *x <= 9).map(|&x| x).collect();\n    sorted_arr = [x for x in arr if 1 <= x and x <= 9]\n    # sorted_arr.sort();\n    sorted_arr.sort()\n    # sorted_arr.reverse();\n    sorted_arr.reverse()\n    # sorted_arr.iter().map(|&x| digit_names[(x - 1) as usize].to_string()).collect()\n    return [digit_names[(x - 1)] for x in sorted_arr]\n",
            "def f(n: int) -> List[int]:\n    # let mut nums: Vec<i32> = (1..=n).collect();\n    nums = list(range(1, n + 1))\n    # nums.iter().map(|&i| if i % 2 != 0 { nums.iter().take(i as usize).sum() } else { nums.iter().take(i as usize).product() }).collect()\n    return [sum(nums[:i]) if i % 2 != 0 else prod(nums[:i]) for i in nums]\n",
            "def is_palindrome(s: str) -> bool:\n    # s == &s.chars().rev().collect::<String>()\n    return s == ''.join(reversed(s))\ndef even_odd_palindrome(n: int) -> List[int]:\n    # let mut cnt = vec![0, 0];\n    cnt = [0, 0]\n    # for i in 1..=n {\n    for i in range(1, n + 1):\n        # if is_palindrome(&i.to_string()) {\n        if is_palindrome(str(i)):\n            # cnt[(i % 2) as usize] += 1;\n            cnt[(i % 2)] += 1\n    # cnt\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # let n_str = n.to_string();\n    n_str = str(n)\n    # if n >= 0 {\n    if n >= 0:\n        # n_str.chars().map(|d| d.to_digit(10).unwrap() as i32).sum()\n        sum(map(int, n_str))\n    # } else {\n    else:\n        # n_str[0..2].parse::<i32>().unwrap() * 2 + digits_sum(n.abs())\n        int(n_str[0:2]) * 2 + digits_sum(abs(n))\n# }\ndef count_nums(arr: List[int]) -> int:\n    # arr.iter().filter(|&n| digits_sum(*n) > 0).count() as i32\n    sum(1 for n in arr if digits_sum(n) > 0)\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if arr.is_empty() {\n    if not arr:\n        # return true;\n        return True\n    # let mut sorted_arr = arr.clone();\n    sorted_arr = arr.copy()\n    # sorted_arr.sort();\n    sorted_arr.sort()\n    # for i in 0..arr.len() {\n    for i in range(len(arr)):\n        # if arr[i..] == sorted_arr[..arr.len() - i] && arr[..i] == sorted_arr[arr.len() - i..] {\n        if arr[i:] == sorted_arr[:len(arr) - i] and arr[:i] == sorted_arr[len(arr) - i:]:\n            # return true;\n            return True\n    # false\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # let odd_cnt = lst1.iter().filter(|&n| n % 2 != 0).count();\n    odd_cnt = sum(1 for n in lst1 if n % 2 != 0)\n    # let even_cnt = lst2.iter().filter(|&n| n % 2 == 0).count();\n    even_cnt = sum(1 for n in lst2 if n % 2 == 0)\n    # if even_cnt >= odd_cnt {\n    if even_cnt >= odd_cnt:\n        # \"YES\".to_string()\n        \"YES\"\n    else: \n        # \"NO\".to_string()\n        \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # let mut freq = HashMap::new();\n    freq = {}\n    # let words = test.split(\" \").filter(|&w| w.len() > 0);\n    words = filter(lambda w: len(w) > 0, test.split(\" \"))\n    # for w in words {\n    for w in words:\n        # freq.insert(w.to_string(), freq.get(w).unwrap_or(&0) + 1);\n        freq[w] = freq.get(w, 0) + 1\n    # let mut result = HashMap::new();\n    result = {}\n    # if freq.len() > 0 {\n    if freq:\n        # let max_freq = *freq.values().max().unwrap();\n        max_freq = max(freq.values())\n        # for (k, v) in freq {\n        for k, v in freq.items():\n            # if v == max_freq {\n            if v == max_freq:\n                # result.insert(k, v);\n                result[k] = v\n    # }\n    # result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # s == &s.chars().rev().collect::<String>()\n    return s == ''.join(reversed(s))\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # let s1: String = s.chars().filter(|ch| !c.contains(*ch)).collect();\n    s1 = ''.join(ch for ch in s if ch not in c)\n    # vec![s1.clone(), if is_palindrome(&s1) { \"yes\" } else { \"no\" }.to_string()]\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # let mut result = vec![];\n    result = []\n    # for num in lst {\n    for num in lst:\n        # let n = num.chars().filter(|&d| d as u8 % 2 == 1).count();\n        n = sum(1 for d in num if d % 2 == 1)\n        # let rs = \"the number of odd elements in the string i of the input.\";\n        rs = \"the number of odd elements in the string {} of the input.\".format(n)\n        # result.push(rs.replace(\"i\", &n.to_string()));\n        result.append(rs.replace(\"i\", str(n)))\n    # result\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # let mut min_sum = 0;\n    min_sum = 0\n    # let mut cur_sum = 0;\n    cur_sum = 0\n    # for n in nums {\n    for n in nums:\n        # cur_sum = min(cur_sum + n, 0);\n        cur_sum = min(cur_sum + n, 0)\n        # min_sum = min(cur_sum, min_sum);\n        min_sum = min(cur_sum, min_sum)\n    # if min_sum == 0 {\n    if min_sum == 0:\n        # min_sum = *nums.iter().min().unwrap();\n        min_sum = min(nums)\n    # min_sum\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # grid.iter().map(|arr| (arr.iter().sum::<i32>() as f64 / capacity as f64).ceil() as i32).sum()\n    return sum(map(lambda arr: int(ceil((sum(arr) / capacity))), grid))\n",
            "def count_ones(num: int) -> int:\n    # format!(\"{:b}\", num).chars().filter(|&c| c == '1').count() as u32\n    return sum(1 for c in bin(num)[2:] if c == '1')\ndef sort_array(arr: List[int]) -> List[int]:\n    # let mut arr = arr.clone();\n    arr = arr.copy()\n    # arr.sort_by_key(|&x| (count_ones(x), x));\n    arr.sort(key=lambda x: (count_ones(x), x))\n    # arr\n    return arr\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # let consonants = \"bcdfghjklmnpqrstvwxyz\";\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # let words: Vec<&str> = s.split(\" \").filter(|w| w.len() > 0).collect();\n    words = s.split(\" \")\n    # words.iter().filter(|w| w.chars().filter(|c| consonants.contains(c.to_lowercase().next().unwrap())).count() == n as usize).map(|w| w.to_string()).collect()\n    return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # let vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # for i in (1..word.len() - 1).rev() {\n    for i in range(1, len(word) - 1):\n        # if vowels.contains(word.chars().nth(i).unwrap().to_string().as_str()) && !vowels.contains(word.chars().nth(i - 1).unwrap().to_string().as_str()) && !vowels.contains(word.chars().nth(i + 1).unwrap().to_string().as_str()) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return word.chars().nth(i).unwrap().to_string();\n            return word[i]\n    # \"\".to_string()\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # let mut depth = 0;\n    depth = 0\n    # for ch in s.chars() {\n    for ch in s:\n        # if ch == '(' {\n        if ch == '(':\n            # depth += 1;\n            depth += 1\n        # } else {\n        else:\n            # depth -= 1;\n            depth -= 1\n        # if depth < 0 {\n        if depth < 0:\n            # return false;\n            return False\n    # depth == 0\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # let s1 = format!(\"{}{}\", lst[0], lst[1]);\n    s1 = lst[0] + lst[1]\n    # let s2 = format!(\"{}{}\", lst[1], lst[0]);\n    s2 = lst[1] + lst[0]\n    # if check(&s1) || check(&s2) { \"Yes\".to_string() } else { \"No\".to_string() }\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if k == 0 {\n    if k == 0:\n        # return Vec::new();\n        return []\n    # let mut result = arr.clone();\n    result = arr.copy()\n    # result.sort();\n    result.sort()\n    # result.iter().skip(result.len() - k as usize).map(|x| *x).collect()\n    return result[result.len() - k:]\n",
            "def solution(lst: List[int]) -> int:\n    # lst.iter().enumerate().filter(|&(i, x)| i % 2 == 0 && x % 2 != 0).map(|(_, x)| x).sum()\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # arr.iter().take(k as usize).filter(|&n| n.to_string().len() <= 2).sum()\n    return sum(filter(lambda n: len(str(n)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # let mut collatz = vec![1];\n    collatz = [1]\n    # let mut n = n;\n    n = n\n    # while n != 1 {\n    while n != 1:\n        # if n % 2 != 0 {\n        if n % 2 != 0:\n            # collatz.push(n);\n            collatz.append(n)\n            # n = 3 * n + 1;\n            n = 3 * n + 1\n        else:\n            # n = n / 2;\n            n = n / 2\n    # collatz.sort();\n    collatz.sort()\n    # collatz\n    return collatz\n",
            "def valid_date(date: str) -> bool:\n    # if date.len() != 10 || date.chars().nth(2).unwrap() != '-' || date.chars().nth(5).unwrap() != '-' {\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    # let m = date[0..2].parse::<i32>().unwrap();\n    m = int(date[0:2])\n    # let d = date[3..5].parse::<i32>().unwrap();\n    d = int(date[3:5])\n    # if [1, 3, 5, 7, 8, 10, 12].contains(&m) && d >= 1 && d <= 31 {\n    if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n        return True\n    # if [4, 6, 9, 11].contains(&m) && d >= 1 && d <= 30 {\n    if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n        return True\n    # if m == 2 && d >= 1 && d <= 29 {\n    if m == 2 and d >= 1 and d <= 29:\n        return True\n    # false\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if txt.contains(\" \") {\n    if \" \" in txt:\n        # txt.split_whitespace().map(|s| s.to_string()).collect()\n        return [s for s in txt.split()]\n    # } else if txt.contains(\",\") {\n    elif \",\" in txt:\n        # txt.split(\",\").map(|s| s.to_string()).collect()\n        return [s for s in txt.split(\",\")]\n    # } else {\n    else:\n        # vec![txt.chars().filter(|&c| c.is_ascii_lowercase() && c as u8 % 2 == 0).count().to_string()]\n        return [str(sum(1 for c in txt if c.islower() and c % 2 == 0))]\n    # }\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if !lst.windows(2).all(|w| w[0] <= w[1]) {\n    if not all(w[0] <= w[1] for w in zip(lst, lst[1:])):\n        # return false;\n        return False\n    # let mut freq = HashMap::new();\n    freq = {}\n    # for i in lst {\n    for i in lst:\n        # *freq.entry(i).or_insert(0) += 1;\n        freq[i] = freq.get(i, 0) + 1\n    # *freq.values().max().unwrap_or(&0) <= 2\n    return max(freq.values(), default=0) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return false;\n        return False\n    # for i in 2..=(n as f64).sqrt().floor() as i32 {\n    for i in range(2, (n ** 0.5) + 1):\n        # if n % i == 0 {\n        if n % i == 0:\n            # return false;\n            return False\n    # true\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # let l = interval1[0].max(interval2[0]);\n    l = max(interval1[0], interval2[0])\n    # let r = interval1[1].min(interval2[1]);\n    r = min(interval1[1], interval2[1])\n    # let length = r - l;\n    length = r - l\n    # if length > 0 && is_prime(length) { \"YES\".to_string() } else { \"NO\".to_string() }\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if arr.is_empty() {\n    if not arr:\n        # return None;\n        return None\n    # if arr.contains(&0) {\n    if 0 in arr:\n        # return Some(0);\n        return 0\n    # let sign = if arr.iter().filter(|&n| *n < 0).count() % 2 == 1 { -1 } else { 1 };\n    sign = -1 if arr.count(lambda n: n < 0) % 2 == 1 else 1\n    # Some(sign * arr.iter().map(|n| n.abs()).sum::<i32>())\n    return sign * sum(map(abs, arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # let n = grid.len();\n    n = len(grid)\n    # let mut min_val = (n * n + 1) as i32;\n    min_val = n * n + 1\n    # for i in 0..n {\n    for i in range(n):\n        # for j in 0..n {\n        for j in range(n):\n            # if grid[i][j] == 1 {\n            if grid[i][j] == 1:\n                # let mut temp = vec![];\n                temp = []\n                # if i != 0 {\n                if i != 0:\n                    # temp.push(grid[i - 1][j]);\n                    temp.append(grid[i - 1][j])\n                # if j != 0 {\n                if j != 0:\n                    # temp.push(grid[i][j - 1]);\n                    temp.append(grid[i][j - 1])\n                # if i != n - 1 {\n                if i != n - 1:\n                    # temp.push(grid[i + 1][j]);\n                    temp.append(grid[i + 1][j])\n                # if j != n - 1 {\n                if j != n - 1:\n                    # temp.push(grid[i][j + 1]);\n                    temp.append(grid[i][j + 1])\n                # min_val = *temp.iter().min().unwrap();\n                min_val = min(temp)\n    # let mut result = vec![];\n    result = []\n    # for i in 0..k {\n    for i in range(k):\n        # result.push(if i % 2 == 0 { 1 } else { min_val });\n        result.append(1 if i % 2 == 0 else min_val)\n    # result\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if n == 0 {\n    if n == 0:\n        # return vec![1];\n        return [1]\n    # let mut seq = vec![1, 3];\n    seq = [1, 3]\n    # for i in 2..=n {\n    for i in range(2, n + 1):\n        # if i % 2 == 0 {\n        if i % 2 == 0:\n            # seq.push(i / 2 + 1);\n            seq.append(i // 2 + 1)\n        # else {\n        else:\n            # seq.push(seq[i as usize - 1] + seq[i as usize - 2] + (i + 3) / 2);\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) // 2)\n    # seq\n    return seq\n",
            "def digits(n: int) -> int:\n    # let odds: Vec<i32> = n.to_string().chars().filter(|&d| d.to_digit(10).unwrap() % 2 == 1).map(|d| d.to_digit(10).unwrap() as i32).collect();\n    odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    # if odds.is_empty() { 0 } else { odds.iter().product() }\n    return 0 if len(odds) == 0 else reduce(lambda x, y: x * y, odds)\n",
            "def is_nested(s: str) -> bool:\n    # let mut open_idx: Vec<usize> = Vec::new();\n    open_idx = []\n    # let mut close_idx: Vec<usize> = Vec::new();\n    close_idx = []\n    # for (i, ch) in s.char_indices() {\n    for i, ch in enumerate(s):\n        # match ch {\n        #     '[' => open_idx.push(i),\n        #     ']' => close_idx.push(i),\n        #     _ => (),\n        # }\n        if ch == '[':\n            open_idx.append(i)\n        elif ch == ']':\n            close_idx.append(i)\n    # close_idx.reverse();\n    close_idx.reverse()\n    # let mut cnt = 0;\n    cnt = 0\n    # let mut i = 0;\n    i = 0\n    # let l = close_idx.len();\n    l = len(close_idx)\n    # for idx in open_idx {\n    for idx in open_idx:\n        # if i < l && idx < close_idx[i] {\n        if i < l and idx < close_idx[i]:\n            # cnt += 1;\n            cnt += 1\n            # i += 1;\n            i += 1\n    # cnt >= 2\n    return cnt >= 2\n",
            "def sum_squares(lst: List[float]) -> int:\n    # lst.iter().map(|n| (n.ceil() as i32).pow(2)).sum()\n    return sum(int(n) ** 2 for n in lst)\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if txt.is_empty() {\n    if not txt:\n        # return false;\n        return False\n    # let last = &txt[txt.rfind(\" \").map_or(0, |i| i + 1)..];\n    last = txt[txt.rfind(\" \") + 1:]\n    # last.len() == 1 && last.chars().next().unwrap().is_alphabetic()\n    return len(last) == 1 and last[0].isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if arr.len() <= 1 {\n    if len(arr) <= 1:\n        # return -1;\n        return -1\n    # let idx = (1..arr.len()).filter(|&i| arr[i] < arr[i - 1]).map(|i| i as i32);\n    idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    # idx.max().unwrap_or(-1)\n    return max(idx) if idx else -1\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # let neg: Vec<i32> = lst.iter().filter(|&i| *i < 0).cloned().collect();\n    neg = [i for i in lst if i < 0]\n    # let pos: Vec<i32> = lst.iter().filter(|&i| *i > 0).cloned().collect();\n    pos = [i for i in lst if i > 0]\n    # let max_neg = neg.iter().max().cloned();\n    max_neg = max(neg) if neg else None\n    # let min_pos = pos.iter().min().cloned();\n    min_pos = min(pos) if pos else None\n    # vec![max_neg, min_pos]\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if let Some(a_str) = o.downcast_ref::<String>() {\n    if isinstance(o, str):\n        # a_str.replace(\",\", \".\").parse::<f64>().unwrap()\n        float(o.replace(\",\", \".\"))\n    # } else if let Some(a_int) = o.downcast_ref::<i32>() {\n    elif isinstance(o, int):\n        # *a_int as f64\n        float(o)\n    # } else if let Some(a_float) = o.downcast_ref::<f64>() {\n    elif isinstance(o, float):\n        # *a_float\n        o\n    # } else {\n    else:\n        # panic!(\"Type Error\");\n        raise TypeError(\"Type Error\")\ndef compare_one(a: Any, b: Any) -> float:\n    # let a1 = any_to_real(a);\n    a1 = any_to_real(a)\n    # let b1 = any_to_real(b);\n    b1 = any_to_real(b)\n    # if a1 == b1 {\n    if a1 == b1:\n        # None\n        None\n    # } else if a1 > b1 {\n    elif a1 > b1:\n        # Some(a1)\n        a1\n    # } else {\n    else:\n        # Some(b1)\n        b1\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # n % 2 == 0 && n >= 8\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # let mut fact = 1;\n    fact = 1\n    # let mut result = 1;\n    result = 1\n    # for i in 1..=n {\n    for i in range(1, n + 1):\n        # fact *= i;\n        fact *= i\n        # result *= fact;\n        result *= fact\n    # result\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # Regex::new(r\"\\s{3,}\").unwrap().replace_all(txt, \"-\").replace(\" \", \"_\")\n    return re.sub(r\"\\s{3,}\", \"-\", txt).replace(\" \", \"_\")\n",
            "def file_name_check(file_name: str) -> str:\n    # let suf = vec![\"txt\", \"exe\", \"dll\"];\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # let lst: Vec<&str> = file_name.split('.').collect();\n    lst = file_name.split('.')\n    # if lst.len() != 2 || !suf.contains(&lst[1]) || lst[0].len() == 0 || !lst[0].chars().next().unwrap().is_alphabetic() || lst[0].chars().filter(|&c| c.is_digit(10)).count() > 3 {\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or not lst[0][0].isalpha() or lst[0].count(str.isdigit) > 3:\n        # return \"No\".to_string();\n        return \"No\"\n    # return \"Yes\".to_string();\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # let mut result = 0;\n    result = 0\n    # for i in 0..lst.len() {\n    for i in range(len(lst)):\n        # if i % 3 == 0 {\n        if i % 3 == 0:\n            # result += lst[i].pow(2);\n            result += lst[i] ** 2\n        # } else if i % 4 == 0 {\n        elif i % 4 == 0:\n            # result += lst[i].pow(3);\n            result += lst[i] ** 3\n        # } else {\n        else:\n            # result += lst[i];\n            result += lst[i]\n    # result\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return false;\n        return False\n    # for i in 2..=(n as f64).sqrt().floor() as i32 {\n    for i in range(2, (n ** 0.5) + 1):\n        # if n % i == 0 {\n        if n % i == 0:\n            # return false;\n            return False\n    # true\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # let words: Vec<&str> = sentence.split_whitespace().collect();\n    words = sentence.split()\n    # words.into_iter().filter(|w| is_prime(w.len() as i32)).collect::<Vec<&str>>().join(\" \")\n    return \" \".join(filter(lambda w: is_prime(len(w)), words))\n",
            "def simplify(x: str, n: str) -> bool:\n    # let xs: Vec<&str> = x.split('/').collect();\n    xs = x.split('/')\n    # let ns: Vec<&str> = n.split('/').collect();\n    ns = n.split('/')\n    # let num = xs[0].parse::<i32>().unwrap() * ns[0].parse::<i32>().unwrap();\n    num = int(xs[0]) * int(ns[0])\n    # let den = xs[1].parse::<i32>().unwrap() * ns[1].parse::<i32>().unwrap();\n    den = int(xs[1]) * int(ns[1])\n    # num % den == 0\n    num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # let n_str = n.to_string();\n    n_str = str(n)\n    # if n >= 0 {\n    if n >= 0:\n        # n_str.chars().map(|d| d.to_digit(10).unwrap() as i32).sum()\n        return sum(map(lambda d: int(d), n_str))\n    # } else {\n    else:\n        # n_str[0..2].parse::<i32>().unwrap() * 2 + digits_sum(n.abs())\n        return int(n_str[0:2]) * 2 + digits_sum(abs(n))\n    # }\ndef order_by_points(nums: List[int]) -> List[int]:\n    # let mut result = nums.clone();\n    result = nums.copy()\n    # result.sort_by_key(|&num| digits_sum(num));\n    result.sort(key=lambda num: digits_sum(num))\n    # result\n    return result\n",
            "def special_filter(nums: List[int]) -> int:\n    # let odds = \"13579\";\n    odds = \"13579\"\n    # nums.iter().cloned().filter(|&n| n > 10 && n % 2 == 1 && odds.contains(format!(\"{}\", n).chars().nth(0).unwrap())).count() as i32\n    return len([n for n in nums if n > 10 and n % 2 == 1 and odds.find(str(n)[0]) != -1])\n",
            "def get_max_triples(n: int) -> int:\n    # let mut c = vec![0, 0, 0];\n    c = [0, 0, 0]\n    # for i in 1..=n {\n    for i in range(1, n + 1):\n        # let a = i * i - i + 1;\n        a = i * i - i + 1\n        # c[(a % 3) as usize] += 1;\n        c[(a % 3)] += 1\n    # c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # let names: Vec<String> = vec![\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"].iter().map(|&x| x.to_string()).collect();\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if !names.contains(planet1) || !names.contains(planet2) {\n    if planet1 not in names or planet2 not in names:\n        # return vec![];\n        return []\n    # let mut l = names.iter().position(|x| x == planet1).unwrap();\n    l = names.index(planet1)\n    # let mut r = names.iter().position(|x| x == planet2).unwrap();\n    r = names.index(planet2)\n    # if l > r {\n    if l > r:\n        # (l, r) = (r, l);\n        (l, r) = (r, l)\n    # if l == r {\n    if l == r:\n        # return vec![];\n        return []\n    # names[l+1..r].to_vec()\n    return names[l+1:r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # let mut result: Vec<String> = lst.iter().filter(|s| s.len() % 2 == 0).cloned().collect();\n    result = [s for s in lst if len(s) % 2 == 0]\n    # result.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));\n    result.sort(key=lambda a, b: a.len().cmp(b.len()).then(a.cmp(b)))\n    # result\n    return result\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if n < 2 {\n    if n < 2:\n        # return y;\n        return y\n    # for i in 2..=(n as f64).sqrt().floor() as i32 {\n    for i in range(2, (n ** 0.5) + 1):\n        # if n % i == 0 {\n        if n % i == 0:\n            # return y;\n            return y\n    # return x;\n    return x\n",
            "def double_the_difference(lst: List[float]) -> int:\n    # lst.iter().cloned().filter(|&n| n >= 0.0 && n % 2.0 == 1.0).map(|n| (n * n) as i32).sum()\n    return sum(map(lambda n: (n * n) as int, filter(lambda n: n >= 0.0 and n % 2.0 == 1.0, lst)))\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # game.iter().zip(guess.iter()).map(|(&x, &y)| (x - y).abs()).collect()\n    return [abs(x - y) for x, y in zip(game, guess)]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # let mut max_s = i32::MIN;\n    max_s = -2147483648\n    # let mut max_ext = String::new();\n    max_ext = ''\n    # for ext in extensions {\n    for ext in extensions:\n        # let upper = ext.chars().filter(|c| c.is_uppercase()).count();\n        upper = sum(1 for c in ext if c.isupper())\n        # let lower = ext.chars().filter(|c| c.is_lowercase()).count();\n        lower = sum(1 for c in ext if c.islower())\n        # let s = upper as i32 - lower as i32;\n        s = upper - lower\n        # if s > max_s {\n        if s > max_s:\n            # max_s = s;\n            max_s = s\n            # max_ext = ext.clone();\n            max_ext = ext\n    # format!(\"{}.{}\", class_name, max_ext)\n    return '{}.{}'.format(class_name, max_ext)\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if a.len() < b.len() {\n    if len(a) < len(b):\n        # return false;\n        return False\n    # for i in 0..b.len() {\n    for i in range(len(b)):\n        # if a.contains(&format!(\"{}{}\", &b[i..], &b[..i])) {\n        if b[i:] in a and b[:i] in a:\n            # return true;\n            return True\n    # false\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # let ds = num.abs().to_string();\n    ds = str(abs(num))\n    # let even = ds.chars().filter(|d| d.to_digit(10).unwrap() % 2 == 0).count() as i32;\n    even = sum(1 for d in ds if int(d) % 2 == 0)\n    # vec![even, ds.len() as i32 - even]\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # let values = vec![1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    # let numerals = vec![\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # let mut res = String::new();\n    res = \"\"\n    # let mut num = num;\n    num = num\n    # for i in 0..values.len() {\n    for i in range(len(values)):\n        # while num >= values[i] {\n        while num >= values[i]:\n            # res.push_str(numerals[i]);\n            res += numerals[i]\n            # num -= values[i];\n            num -= values[i]\n    # res\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # let mut s = vec![a, b, c];\n    s = [a, b, c]\n    # s.sort();\n    s.sort()\n    # s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # let mut max_cnt = 0;\n    max_cnt = 0\n    # let mut max_w = \"\";\n    max_w = \"\"\n    # for w in words {\n    for w in words:\n        # let cnt = w.chars().collect::<HashSet<char>>().len();\n        cnt = len(set(w))\n        # if cnt > max_cnt {\n        if cnt > max_cnt:\n            # max_cnt = cnt;\n            max_cnt = cnt\n            # max_w = w;\n            max_w = w\n        # else if cnt == max_cnt {\n        elif cnt == max_cnt:\n            # max_w = min(max_w, w);\n            max_w = min(max_w, w)\n    # max_w.to_string()\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if need <= remaining {\n    if need <= remaining:\n        # vec![num + need, remaining - need]\n        return [num + need, remaining - need]\n    # } else {\n    else:\n        # vec![num + remaining, 0]\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # let mut ops = operators.clone();\n    ops = operators.copy()\n    # let mut nums = operands.clone();\n    nums = operands.copy()\n    # let mut i = ops.len() as i32 - 1;\n    i = len(ops) - 1\n    # while i >= 0 {\n    while i >= 0:\n        # if ops[i as usize] == \"**\" {\n        if ops[i] == \"**\":\n            # nums[i as usize] = nums[i as usize].pow(nums[i as usize + 1] as u32);\n            nums[i] = nums[i] ** nums[i + 1]\n            # nums.remove(i as usize + 1);\n            nums.pop(i + 1)\n            # ops.remove(i as usize);\n            ops.pop(i)\n        # }\n        # i -= 1;\n        i -= 1\n    # while i < ops.len() as i32 {\n    while i < len(ops):\n        # if ops[i as usize] == \"*\" {\n        if ops[i] == \"*\":\n            # nums[i as usize] = nums[i as usize] * nums[i as usize + 1];\n            nums[i] = nums[i] * nums[i + 1]\n            # nums.remove(i as usize + 1);\n            nums.pop(i + 1)\n            # ops.remove(i as usize);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if ops[i as usize] == \"//\" {\n        elif ops[i] == \"//\":\n            # nums[i as usize] = nums[i as usize] / nums[i as usize + 1];\n            nums[i] = nums[i] / nums[i + 1]\n            # nums.remove(i as usize + 1);\n            nums.pop(i + 1)\n            # ops.remove(i as usize);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # }\n        # i += 1;\n        i += 1\n    # while i < ops.len() as i32 {\n    while i < len(ops):\n        # if ops[i as usize] == \"+\" {\n        if ops[i] == \"+\":\n            # nums[i as usize] = nums[i as usize] + nums[i as usize + 1];\n            nums[i] = nums[i] + nums[i + 1]\n            # nums.remove(i as usize + 1);\n            nums.pop(i + 1)\n            # ops.remove(i as usize);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if ops[i as usize] == \"-\" {\n        elif ops[i] == \"-\":\n            # nums[i as usize] = nums[i as usize] - nums[i as usize + 1];\n            nums[i] = nums[i] - nums[i + 1]\n            # nums.remove(i as usize + 1);\n            nums.pop(i + 1)\n            # ops.remove(i as usize);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # }\n        # i += 1;\n        i += 1\n    # nums[0]\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if !s.chars().any(|ch| ch.is_alphabetic()) {\n    if not any(ch.isalpha() for ch in s):\n        # return s.chars().rev().collect();\n        return ''.join(reversed(s))\n    # let mut result = String::new();\n    result = ''\n    # for ch in s.chars() {\n    for ch in s:\n        # if !ch.is_alphabetic() {\n        if not ch.isalpha():\n            # result.push(ch);\n            result += ch\n        # } else if ch.is_uppercase() {\n        elif ch.isupper():\n            # result.push(ch.to_ascii_lowercase());\n            result += ch.lower()\n        # } else if ch.is_lowercase() {\n        elif ch.islower():\n            # result.push(ch.to_ascii_uppercase());\n            result += ch.upper()\n    # result\n    return result\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if txt.is_empty() {\n    if not txt:\n        # return None;\n        return None\n    # let mut md5_hash = Md5::new();\n    md5_hash = md5()\n    # let txt_bytes = txt.as_bytes();\n    txt_bytes = txt.encode()\n    # md5_hash.update(txt_bytes);\n    md5_hash.update(txt_bytes)\n    # let md5_encoded = format!(\"{:x}\", md5_hash.finalize());\n    md5_encoded = md5_hash.hexdigest()\n    # Some(md5_encoded)\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # let lower = max(2, min(a, b));\n    lower = max(2, min(a, b))\n    # let upper = min(8, max(a, b));\n    upper = min(8, max(a, b))\n    # (lower..=upper).filter(|&x| x % 2 == 0).collect::<Vec<i32>>()\n    return [x for x in range(lower, upper + 1) if x % 2 == 0]\n"
        ]
    },
    "scala": {
        "python": [
            "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # for (i <- 0 until numbers.length) {\n    for i in range(len(numbers)):\n        # for (j <- i + 1 until numbers.length) {\n        for j in range(i + 1, len(numbers)):\n            # if ((numbers(i) - numbers(j)).abs < threshold) {\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true\n                return True\n    # false\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # val groups = mutable.ListBuffer[String]()\n    groups = []\n    # val stk = mutable.ListBuffer[Char]()\n    stk = []\n    # var currentGroup: String = \"\"\n    current_group = \"\"\n    # val parens = parenString.replace(\" \", \"\")\n    parens = paren_string.replace(\" \", \"\")\n    # for (ch <- parens) {\n    for ch in parens:\n        # if (ch == '(') {\n        if ch == '(':\n            # stk += ch\n            stk.append(ch)\n            # currentGroup += ch\n            current_group += ch\n        # } else if (ch == ')') {\n        elif ch == ')':\n            # stk.remove(stk.length - 1)\n            stk.pop()\n            # currentGroup += ch\n            current_group += ch\n            # if (stk.isEmpty) {\n            if not stk:\n                # groups += currentGroup\n                groups.append(current_group)\n                # currentGroup = \"\"\n                current_group = \"\"\n    # groups.toList\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # num - num.floor\n    return num - num.floor()\n",
            "def below_zero(operations: List[int]) -> bool:\n    # var balance = 0\n    balance = 0\n    # for (op <- operations) {\n    for op in operations:\n        # balance += op\n        balance += op\n        # if (balance < 0) {\n        if balance < 0:\n            # return true\n            return True\n    # false\n    return False\n",
            "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # val mean = numbers.sum / numbers.length\n    mean = sum(numbers) / len(numbers)\n    # val deviation = numbers.map(x => (x - mean).abs).sum\n    deviation = sum(abs(x - mean) for x in numbers)\n    # deviation / numbers.length\n    deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # val result = mutable.ListBuffer[Int]()\n    result = []\n    # for (i <- 0 until numbers.length) {\n    for i in range(len(numbers)):\n        # if (i != 0) {\n        if i != 0:\n            # result += delimiter\n            result.append(delimiter)\n        # result += numbers(i)\n        result.append(numbers[i])\n    # result.toList\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # val result = mutable.ListBuffer[Int]()\n    result = []\n    # val parenGroups = parenString.split(\" \").filter(_.length > 0)\n    paren_groups = paren_string.split(\" \")\n    for paren_group in paren_groups:\n        # var maxDepth = 0\n        max_depth = 0\n        # var depth = 0\n        depth = 0\n        # for (ch <- parenGroup) {\n        for ch in paren_group:\n            # if (ch == '(') {\n            if ch == \"(\":\n                # depth += 1\n                depth += 1\n                # maxDepth = max(maxDepth, depth)\n                max_depth = max(max_depth, depth)\n            # } else if (ch == ')') {\n            elif ch == \")\":\n                # depth -= 1\n                depth -= 1\n        # result += maxDepth\n        result.append(max_depth)\n    # result.toList\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # strs.filter(_.contains(substring))\n    return [s for s in strs if substring in s]\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # val nSum = numbers.sum\n    n_sum = sum(numbers)\n    # val nProduct = numbers.product\n    n_product = 1\n    for n in numbers:\n        n_product *= n\n    # List(nSum, nProduct)\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # var maxSoFar = Int.MinValue\n    max_so_far = float('-inf')\n    # val result = mutable.ListBuffer[Int]()\n    result = []\n    # for (num <- numbers) {\n    for num in numbers:\n        # maxSoFar = max(maxSoFar, num)\n        max_so_far = max(max_so_far, num)\n        # result += maxSoFar\n        result.append(max_so_far)\n    # result.toList\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # s == s.reverse\n    return s == s[::-1]\ndef make_palindrome(s: str) -> str:\n    # if (isPalindrome(s)) {\n    if is_palindrome(s):\n        # s\n        return s\n    # else {\n    else:\n        # for (i <- 0 until s.length) {\n        for i in range(len(s)):\n            # if (isPalindrome(s.substring(i))) {\n            if is_palindrome(s[i:]):\n                # return s + s.substring(0, i).reverse\n                return s + s[:i][::-1]\n        # \"\"\n        return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # a.zip(b).map({case (x, y) => if (x == y) \"0\" else \"1\"}).mkString(\"\")\n    return \"\".join([\"0\" if x == y else \"1\" for x, y in zip(a, b)])\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if (strs.isEmpty) {\n    if not strs:\n        # None\n        return None\n    # } else {\n    #   var longestS = strs.head\n    longest_s = strs[0]\n    # for (s <- strs) {\n    for s in strs:\n        # if (s.length > longestS.length) {\n        if len(s) > len(longest_s):\n            # longestS = s\n            longest_s = s\n    # Some(longestS)\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if (b == 0) {\n    if b == 0:\n        # a\n        return a\n    # } else {\n    #     greatestCommonDivisor(b, a % b)\n    # }\n    return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # val result = mutable.ListBuffer[String]()\n    result = []\n    # for (i <- 1 to s.length) {\n    for i in range(1, len(s) + 1):\n        # result += s.substring(0, i)\n        result.append(s[:i])\n    # result.toList\n    return result\n",
            "def string_sequence(n: int) -> str:\n    # (0 to n).mkString(\" \")\n    return \" \".join(map(str, range(n + 1)))\n",
            "def count_distinct_characters(s: str) -> int:\n    # s.toLowerCase.distinct.length\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # val durations = Map(\"o\" -> 4, \"o|\" -> 2, \".|\" -> 1)\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    # val notes = musicString.split(\" \").filter(_.length > 0)\n    notes = [note for note in music_string.split(\" \") if len(note) > 0]\n    # notes.map(note => durations(note)).toList\n    return [durations[note] for note in notes]\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # var times = 0\n    times = 0\n    # for (i <- 0 to s.length - substring.length) {\n    for i in range(0, s.length - substring.length + 1):\n        # if (s.substring(i, i + substring.length) == substring) {\n        if s[i:i + substring.length] == substring:\n            # times += 1\n            times += 1\n    # times\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # val numDict = Map(\n    #   \"zero\" -> 0,\n    #   \"one\" -> 1,\n    #   \"two\" -> 2,\n    #   \"three\" -> 3,\n    #   \"four\" -> 4,\n    #   \"five\" -> 5,\n    #   \"six\" -> 6,\n    #   \"seven\" -> 7,\n    #   \"eight\" -> 8,\n    #   \"nine\" -> 9\n    # )\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    # val numList = numbers.split(\" \").filter(numDict.contains(_))\n    num_list = [num for num in numbers.split(\" \") if num in num_dict]\n    # val sortedList = numList.sortBy(numDict)\n    sorted_list = sorted(num_list, key=lambda num: num_dict[num])\n    # sortedList.mkString(\" \")\n    return \" \".join(sorted_list)\n",
            "def find_closest_elements(numbers: List[float]) -> List[float]:\n    # val sortedNumbers = numbers.sorted\n    sorted_numbers = sorted(numbers)\n    # var minDiff = Double.PositiveInfinity\n    min_diff = float('inf')\n    # var closestPair = List[Double]()\n    closest_pair = []\n    # for (i <- 1 until sortedNumbers.length) {\n    for i in range(1, len(sorted_numbers)):\n        # val diff = sortedNumbers(i) - sortedNumbers(i - 1)\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if (diff < minDiff) {\n        if diff < min_diff:\n            # minDiff = diff\n            min_diff = diff\n            # closestPair = List(sortedNumbers(i - 1), sortedNumbers(i))\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # closestPair\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # val minNum = numbers.min\n    min_num = min(numbers)\n    # val maxNum = numbers.max\n    max_num = max(numbers)\n    # if (minNum == maxNum) {\n    if min_num == max_num:\n        # List.fill(numbers.length)(0.0)\n        return [0.0] * len(numbers)\n    # else {\n    else:\n        # numbers.map(num => (num - minNum) / (maxNum - minNum))\n        return [\n            (num - min_num) / (max_num - min_num)\n            for num in numbers\n        ]\n",
            "def filter_integers(values: List[Any]) -> List[int]:\n    # values.collect { case x: Int => x }\n    return [x for x in values if isinstance(x, int)]\n",
            "def str_length(s: str) -> int:\n    # s.length\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for (i <- 2 until n) {\n    for i in range(2, n):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return n / i\n            return n / i\n    # 1\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # val factors = mutable.ListBuffer[Int]()\n    factors = []\n    # @tailrec\n    # def factorizeAcc(n: Int, i: Int): Unit = {\n    #   if (i > n) ()\n    #    else if (n % i == 0) {\n    #      factors += i\n    #      factorizeAcc(n / i, i)\n    #    } else {\n    #      factorizeAcc(n, i + 1)\n    #    }\n    # }\n    def factorize_acc(n: int, i: int):\n        if i > n:\n            return\n        elif n % i == 0:\n            factors.append(i)\n            factorize_acc(n // i, i)\n        else:\n            factorize_acc(n, i + 1)\n    factorize_acc(n, 2)\n    # factors.toList\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # val counts = mutable.Map[Int, Int]()\n    counts = {}\n    # for (num <- numbers) {\n    for num in numbers:\n        # counts(num) = counts.getOrElse(num, 0) + 1\n        counts[num] = counts.get(num, 0) + 1\n    # val res = numbers.filter(num => counts(num) == 1)\n    res = [num for num in numbers if counts[num] == 1]\n    res\n",
            "def flip_case(s: str) -> str:\n    # val flipped = StringBuilder()\n    flipped = []\n    # for (ch <- s) {\n    for ch in s:\n        # if (!ch.isLetter) {\n        if not ch.isalpha():\n            # flipped += ch\n            flipped.append(ch)\n        # } else if (ch.isLower) {\n        elif ch.islower():\n            # flipped += ch.toUpper\n            flipped.append(ch.upper())\n        # } else if (ch.isUpper) {\n        elif ch.isupper():\n            # flipped += ch.toLower\n            flipped.append(ch.lower())\n    # flipped.toString\n    return ''.join(flipped)\n",
            "def concatenate(strs: List[str]) -> str:\n    # strs.mkString(\"\")\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # strs.filter(_.startsWith(prefixStr))\n    return [s for s in strs if s.startswith(prefix_str)]\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # l.filter(_ > 0)\n    return [e for e in l if e > 0]\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false\n        return False\n    # for (i <- 2 to sqrt(n).floor.toInt) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\n",
            "def poly(xs: List[int], x: float) -> float:\n    # var res = 0.0\n    res = 0.0\n    # for (i <- 0 until xs.length) {\n    for i in range(len(xs)):\n        # res += xs(i) * pow(x, i)\n        res += xs[i] * pow(x, i)\n    # res\n    return res\ndef find_zero(xs: List[int]) -> float:\n    # var (x1, x2) = (1.0, -1.0)\n    x1, x2 = 1.0, -1.0\n    # while (poly(xs, x1) * poly(xs, x2) > 0) {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2\n        x1 *= 2\n        # x2 *= 2\n        x2 *= 2\n    # while ((x1 - x2).abs > 1e-10) {\n    while abs(x1 - x2) > 1e-10:\n        # val mid = (x1 + x2) / 2\n        mid = (x1 + x2) / 2\n        # if (poly(xs, mid) == 0) {\n        if poly(xs, mid) == 0:\n            # return mid\n            return mid\n        # else if (poly(xs, mid) * poly(xs, x1) < 0) {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid\n            x1 = mid\n    # (x1 + x2) / 2\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # val sortedThird = l.zipWithIndex.filter((x, i) => i % 3 == 0).map(x => x._1).sorted\n    sorted_third = sorted([x for x, i in zip(l, range(len(l))) if i % 3 == 0])\n    # l.zipWithIndex.map((x, i) => if (i % 3 == 0) sortedThird(i / 3) else x)\n    return [sorted_third[i // 3] if i % 3 == 0 else x for x, i in zip(l, range(len(l)))]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # l.toSet.toList.sorted\n    return sorted(set(l))\n",
            "def max_element(l: List[int]) -> int:\n    # if (l.isEmpty) {\n    if not l:\n        # 0\n        return 0\n    # } else {\n    #   l.max\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # var cnt = 0\n    cnt = 0\n    # for (i <- 0 until n) {\n    for i in range(n):\n        # if (i % 11 == 0 || i % 13 == 0) {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += i.toString.count(_ == '7')\n            cnt += i.toString().count('7')\n    # cnt\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # val sortedEven = l.zipWithIndex.filter((x, i) => i % 2 == 0).map(x => x._1).sorted\n    sorted_even = sorted([x for x, i in zip(l, range(len(l))) if i % 2 == 0])\n    # l.zipWithIndex.map((x, i) => if (i % 2 == 0) sortedEven(i / 2) else x)\n    return [sorted_even[i // 2] if i % 2 == 0 else x for x, i in zip(l, range(len(l)))]\n",
            "def encode_cyclic(s: str) -> str:\n    # val result = new StringBuilder()\n    result = ''\n    # for (i <- 0 until s.length by 3) {\n    for i in range(0, len(s), 3):\n        # if (i + 3 > s.length) {\n        if i + 3 > len(s):\n            # result ++= s.substring(i)\n            result += s[i:]\n        else:\n            # result ++= s.substring(i + 1, i + 3)\n            result += s[i + 1:i + 3]\n            # result += s(i)\n            result += s[i]\n    # result.toString()\n    return result\ndef decode_cyclic(s: str) -> str:\n    # encodeCyclic(encodeCyclic(s))\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    #   return false\n    if n < 2:\n        return False\n    # for (i <- 2 to sqrt(n).floor.toInt) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        #   return false\n        if n % i == 0:\n            return False\n    # true\n    return True\ndef prime_fib(n: int) -> int:\n    # var f = List(0, 1)\n    f = [0, 1]\n    # var cnt = 0\n    cnt = 0\n    # while (cnt < n) {\n    while cnt < n:\n        # f = List(f(1), f(0) + f(1))\n        f = [f[1], f[0] + f[1]]\n        # if (isPrime(f(1))) {\n        if is_prime(f[1]):\n            # cnt += 1\n            cnt += 1\n    # f(1)\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for (i <- 0 until l.length) {\n    for i in range(len(l)):\n        # for (j <- i + 1 until l.length) {\n        for j in range(i + 1, len(l)):\n            # for (k <- j + 1 until l.length) {\n            for k in range(j + 1, len(l)):\n                # if (l(i) + l(j) + l(k) == 0) {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true\n                    return True\n    # false\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # pow(n, 2).toInt\n    return int(pow(n, 2))\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # l.map(_ + 1)\n    return [e + 1 for e in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # val seen = mutable.Set[Int]()\n    seen = set()\n    # for (num <- l) {\n    for num in l:\n        # if (seen.contains(-num)) {\n        if -num in seen:\n            # return true\n            return True\n        # seen.add(num)\n        seen.add(num)\n    # false\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if (x == 0) {\n    #   return \"0\"\n    if x == 0:\n        return \"0\"\n    # val digits = mutable.ListBuffer[String]()\n    digits = []\n    # @tailrec\n    # def acc(x0: Int): Unit = {\n    #   if (x0 > 0) {\n    #     digits.append((x0 % bas).toString)\n    #     acc(x0 / bas)\n    #   }\n    # }\n    def acc(x0: int):\n        if x0 > 0:\n            digits.append(str(x0 % bas))\n            acc(x0 // bas)\n    # acc(x)\n    acc(x)\n    # digits.reverse.mkString(\"\")\n    return \"\".join(reversed(digits))\n",
            "def triangle_area(a: int, h: int) -> float:\n    # (a * h).toDouble / 2\n    return (a * h) / 2\n",
            "def fib4(n: int) -> int:\n    # var fib = mutable.ListBuffer(0, 0, 2, 0)\n    fib = [0, 0, 2, 0]\n    # for (i <- 4 to n) {\n    for i in range(4, n + 1):\n        # fib(i % 4) = fib.sum\n        fib[i % 4] = sum(fib)\n    # fib(n % 4)\n    return fib[n % 4]\n",
            "def median(l: List[float]) -> float:\n    # val sl = l.sorted\n    sl = sorted(l)\n    # if (l.length % 2 != 0) {\n    if len(l) % 2 != 0:\n        # sl(l.length / 2)\n        return sl[len(l) // 2]\n    # } else {\n    else:\n        # (sl(l.length / 2) + sl(l.length / 2 - 1)) / 2\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # txt == txt.reverse\n    return txt == txt[::-1]\n",
            "def modp(n: int, p: int) -> int:\n    # var ret = 1\n    ret = 1\n    # for (i <- 0 until n) {\n    for i in range(n):\n        # ret = (ret * 2) % p\n        ret = (ret * 2) % p\n    # ret\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # val result = s.map(ch => (((ch - 97 + 5) % 26) + 97).toChar).mkString\n    result = ''.join(chr(((ord(ch) - 97 + 5) % 26) + 97) for ch in s)\n    # result\n    return result\ndef decode_shift(s: str) -> str:\n    # val result = s.map(ch => (((ch - 97 + 21) % 26) + 97).toChar).mkString\n    result = ''.join(chr(((ord(ch) - 97 + 21) % 26) + 97) for ch in s)\n    # result\n    return result\n",
            "def remove_vowels(txt: str) -> str:\n    # val vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # txt.filterNot(vowels.contains)\n    return \"\".join(c for c in txt if c not in vowels)\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # l.forall(_ < t)\n    return all(e < t for e in l)\n",
            "def add(x: int, y: int) -> int:\n    # x + y\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # s0.toSet == s1.toSet\n    return set(s0) == set(s1)\n",
            "def fib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # n\n        return n\n    # } else {\n    else:\n        # fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # var depth = 0\n    depth = 0\n    # for (b <- brackets) {\n    for b in brackets:\n        # if (b == '<') {\n        if b == '<':\n            # depth += 1\n            depth += 1\n        # } else if (b == '>') {\n        elif b == '>':\n            # depth -= 1\n            depth -= 1\n        # }\n        # if (depth < 0) {\n        if depth < 0:\n            # return false\n            return False\n    # depth == 0\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # val diff = l.zip(l.drop(1)).map { case (a, b) => b - a }\n    diff = [b - a for a, b in zip(l, l[1:])]\n    # diff.forall(_ <= 0) || diff.forall(_ >= 0)\n    return all(d <= 0 for d in diff) or all(d >= 0 for d in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # (l1.toSet intersect l2.toSet).toList.sorted\n    return sorted(list(set(l1) & set(l2)))\n",
            "def largest_prime_factor(n: int) -> int:\n    # var i = 2\n    i = 2\n    # @tailrec\n    # def acc(n0: Int): Int = {\n    #   if (i * i > n0) {\n    #     n0\n    #   } else if (n0 % i != 0) {\n    #     i += 1\n    #     acc(n0)\n    #   } else {\n    #     acc(n0 / i)\n    #   }\n    # }\n    def acc(n0: int) -> int:\n        if i * i > n0:\n            return n0\n        elif n0 % i != 0:\n            i += 1\n            return acc(n0)\n        else:\n            return acc(n0 // i)\n    # acc(n)\n    return acc(n)\n",
            "def sum_to_n(n: int) -> int:\n    # (0 to n).sum\n    return sum(range(n + 1))\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # var depth = 0\n    depth = 0\n    # for (b <- brackets) {\n    for b in brackets:\n        # if (b == '(') {\n        if b == '(':\n            # depth += 1\n            depth += 1\n        # } else if (b == ')') {\n        elif b == ')':\n            # depth -= 1\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false\n            return False\n    # depth == 0\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # xs.zipWithIndex.tail.map { case (x, i) => x * i }\n    return [x * i for x, i in zip(xs, range(1, len(xs)))]\n",
            "def fibfib(n: int) -> int:\n    # if (n <= 1) {\n    #   return 0\n    # }\n    if n <= 1:\n        return 0\n    # var (a, b, c) = (0, 0, 1)\n    a, b, c = 0, 0, 1\n    # @tailrec\n    # def acc(n: Int): Int = {\n    #   if (n <= 2) {\n    #     return c\n    #   }\n    #   (b, c, a + b + c).match { case (_a, _b, _c) => a = _a; b = _b; c = _c } \n    #   acc(n - 1)\n    # }\n    def acc(n: int) -> int:\n        # if (n <= 2) {\n        #   return c\n        # }\n        if n <= 2:\n            return c\n        # (b, c, a + b + c).match { case (_a, _b, _c) => a = _a; b = _b; c = _c } \n        b, c, a = c, a + b + c, b\n        # acc(n - 1)\n        acc(n - 1)\n    # acc(n)\n    acc(n)\n",
            "def vowels_count(s: str) -> int:\n    # val vowels = \"aeiou\"\n    vowels = \"aeiou\"\n    # var cnt = 0\n    cnt = 0\n    # for (i <- 0 until s.length) {\n    for i in range(s.length):\n        # if (vowels.contains(s(i).toLower) || (i == s.length - 1 && s(i).toLower == 'y')) {\n        if s[i].lower() in vowels or (i == s.length - 1 and s[i].lower() == 'y'):\n            # cnt += 1\n            cnt += 1\n    # cnt\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # val xStr = x.toString\n    x_str = str(x)\n    # if (shift > xStr.length) {\n    if shift > len(x_str):\n        # return xStr.reverse\n        return x_str[::-1]\n    else:\n        # return xStr.substring(xStr.length - shift) + xStr.substring(0, xStr.length - shift)\n        return x_str[len(x_str) - shift:] + x_str[:len(x_str) - shift]\n",
            "def digit_sum(s: str) -> int:\n    # s.filter(_.isUpper).map(_.toInt).sum\n    return sum(map(int, filter(lambda x: x.isupper(), s)))\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # val words = s.split(' ')\n    words = s.split(' ')\n    # val apples = words(words.indexOf(\"apples\") - 1).toInt\n    apples = int(words[words.index(\"apples\") - 1])\n    # val oranges = words(words.indexOf(\"oranges\") - 1).toInt\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # n - apples - oranges\n    n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # val evens = arr.filter(_ % 2 == 0)\n    evens = [e for e in arr if e % 2 == 0]\n    # if (evens.length == 0) {\n    if len(evens) == 0:\n        # return List()\n        return []\n    # val minEven = evens.min\n    min_even = min(evens)\n    # List(minEven, arr.indexOf(minEven))\n    return [min_even, arr.index(min_even)]\n",
            "def search(lst: List[int]) -> int:\n    # var freqs = mutable.Map[Int, Int]()\n    freqs = {}\n    # for (n <- lst) {\n    for n in lst:\n        # freqs(n) = freqs.getOrElse(n, 0) + 1\n        freqs[n] = freqs.get(n, 0) + 1\n    # val good_vals = freqs.filter((k, v) => v >= k).keys\n    good_vals = [k for k, v in freqs.items() if v >= k]\n    # good_vals.maxOption.getOrElse(-1)\n    return max(good_vals) if good_vals else -1\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # val sl = lst.sorted\n    sl = sorted(lst)\n    # val result = mutable.ListBuffer[Int]()\n    result = []\n    # var (left, right) = (0, sl.length - 1)\n    left, right = 0, len(sl) - 1\n    # while (left <= right) {\n    while left <= right:\n        # result += sl(left)\n        result.append(sl[left])\n        left += 1\n        # if (left <= right) {\n        if left <= right:\n            # result += sl(right)\n            result.append(sl[right])\n            right -= 1\n    # result.toList\n    return result\n",
            "def triangle_area(a: int, b: int, c: int) -> float:\n    # if (a + b > c && a + c > b && b + c > a) {\n    if a + b > c and a + c > b and b + c > a:\n        # val s = (a + b + c) / 2.0\n        s = (a + b + c) / 2.0\n        # sqrt(s * (s - a) * (s - b) * (s - c))\n        return sqrt(s * (s - a) * (s - b) * (s - c))\n    # } else {\n    else:\n        # -1.0\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if (q.length == 0) {\n    if len(q) == 0:\n        # return false\n        return False\n    # val isPalin = (0 until q.length).forall(i => q(i) == q(q.length - i - 1))\n    is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    # val total = q.sum\n    total = sum(q)\n    # isPalin && total <= w\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # var ans = 0\n    ans = 0\n    # for (i <- 0 until arr.length / 2) {\n    for i in range(0, len(arr) // 2):\n        # if (arr(i) != arr(arr.length - i - 1)) {\n        if arr[i] != arr[len(arr) - i - 1]:\n            # ans += 1\n            ans += 1\n    # ans\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # val cnt1 = lst1.map(_.length).sum\n    cnt1 = sum(len(s) for s in lst1)\n    # val cnt2 = lst2.map(_.length).sum\n    cnt2 = sum(len(s) for s in lst2)\n    # if (cnt1 <= cnt2) lst1 else lst2\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    #   return false\n    # }\n    if n < 2:\n        return False\n    # for (i <- 2 to sqrt(n).floor.toInt) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        #   return false\n        # }\n        if n % i == 0:\n            return False\n    # true\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # var cnt = 0\n    cnt = 0\n    # for (i <- 2 to a) {\n    for i in range(2, a + 1):\n        # if (isPrime(i)) {\n        if is_prime(i):\n            # @tailrec\n            # def loop(a: Int): Int = {\n            #   if (a % i == 0) {\n            #     cnt += 1\n            #     loop(a / i)\n            #   } else {\n            #     a\n            #   }\n            # }\n            # loop(a)\n            while a % i == 0:\n                cnt += 1\n                a //= i\n    # cnt == 3\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if (n < 2) {\n    #   return x == n\n    if n < 2:\n        return x == n\n    # var tmp = 1\n    tmp = 1\n    # while (tmp < x) {\n    while tmp < x:\n        # tmp *= n\n        tmp *= n\n    # tmp == x\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # val a0 = a.abs\n    a0 = abs(a)\n    # val root = round(pow(a0, 1.0 / 3.0)).toInt\n    root = round(pow(a0, 1.0 / 3.0))\n    # root * root * root == a0\n    return root * root * root == a0\n",
            "def hex_key(num: str) -> int:\n    # num.count(\"2357BD\".contains(_))\n    return num.count(\"2357BD\".__contains__(_))\n",
            "def decimal_to_binary(dec: int) -> str:\n    # val binary = dec.toBinaryString\n    binary = bin(dec)\n    # s\"db${binary}db\"\n    return f\"db{binary}db\"\n",
            "def is_happy(s: str) -> bool:\n    # if (s.length < 3) {\n    if len(s) < 3:\n        # false\n        return False\n    # } else {\n    #   for (i <- 0 until s.length - 2) {\n    for i in range(len(s) - 2):\n        # if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false\n            return False\n    # true\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # val result = mutable.ListBuffer[String]()\n    result = []\n    # for (g <- grades) {\n    for g in grades:\n        # () match {\n        # case _ if g == 4.0 =>\n        if g == 4.0:\n            # result += \"A+\"\n            result.append(\"A+\")\n        # case _ if g > 3.7 =>\n        elif g > 3.7:\n            # result += \"A\"\n            result.append(\"A\")\n        # case _ if g > 3.3 =>\n        elif g > 3.3:\n            # result += \"A-\"\n            result.append(\"A-\")\n        # case _ if g > 3.0 =>\n        elif g > 3.0:\n            # result += \"B+\"\n            result.append(\"B+\")\n        # case _ if g > 2.7 =>\n        elif g > 2.7:\n            # result += \"B\"\n            result.append(\"B\")\n        # case _ if g > 2.3 =>\n        elif g > 2.3:\n            # result += \"B-\"\n            result.append(\"B-\")\n        # case _ if g > 2.0 =>\n        elif g > 2.0:\n            # result += \"C+\"\n            result.append(\"C+\")\n        # case _ if g > 1.7 =>\n        elif g > 1.7:\n            # result += \"C\"\n            result.append(\"C\")\n        # case _ if g > 1.3 =>\n        elif g > 1.3:\n            # result += \"C-\"\n            result.append(\"C-\")\n        # case _ if g > 1.0 =>\n        elif g > 1.0:\n            # result += \"D+\"\n            result.append(\"D+\")\n        # case _ if g > 0.7 =>\n        elif g > 0.7:\n            # result += \"D\"\n            result.append(\"D\")\n        # case _ if g > 0.0 =>\n        elif g > 0.0:\n            # result += \"D-\"\n            result.append(\"D-\")\n        # case _ =>\n        else:\n            # result += \"E\"\n            result.append(\"E\")\n    # result.toList\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # val length = s.length\n    length = len(s)\n    # if (length < 2) {\n    if length < 2:\n        # return false\n        return False\n    # for (i <- 2 to sqrt(length).floor.toInt) {\n    for i in range(2, int(sqrt(length)) + 1):\n        # if (length % i == 0) {\n        if length % i == 0:\n            # return false\n            return False\n    # true\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if (n == 1) {\n    if n == 1:\n        # return 1\n        return 1\n    # 2 * 9 * pow(10, n - 2).toInt\n    return 2 * 9 * pow(10, n - 2)\n",
            "def solve(n: int) -> str:\n    # val digitsSum = n.toString.map(_.asDigit).sum\n    digits_sum = sum(map(int, str(n)))\n    # digitsSum.toBinaryString\n    return bin(digits_sum)\n",
            "def add(lst: List[int]) -> int:\n    # lst.zipWithIndex.filter{(x, i) => i % 2 == 1 && x % 2 == 0}.map{(x, i) => x}.sum\n    return sum(x for x, i in zip(lst, range(len(lst))) if i % 2 == 1 and x % 2 == 0)\n",
            "def anti_shuffle(s: str) -> str:\n    # val words = s.split(\" \").map{word => word.sorted}\n    words = [word.sorted() for word in s.split(\" \")]\n    # return words.mkString(\" \")\n    return \" \".join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # val coords = mutable.ListBuffer[List[Int]]()\n    coords = []\n    # for (i <- lst.indices) {\n    for i in range(len(lst)):\n        # for (j <- lst(i).indices) {\n        for j in range(len(lst(i))):\n            # if (lst(i)(j) == x) {\n            if lst(i)(j) == x:\n                # coords += List(i, j)\n                coords.append([i, j])\n    # coords.sortBy(a => (a(0), -a(1))).toList\n    coords.sort(key=lambda a: (a[0], -a[1]))\n    return coords\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if (arr.length == 0) {\n    if len(arr) == 0:\n        # return List()\n        return []\n    # if ((arr(0) + arr(arr.length - 1)) % 2 == 0) {\n    if (arr[0] + arr[-1]) % 2 == 0:\n        # return arr.sorted.reverse\n        return sorted(arr, reverse=True)\n    # else {\n    else:\n        # return arr.sorted\n        return sorted(arr)\n",
            "def encrypt(s: str) -> str:\n    # val result = StringBuilder()\n    result = []\n    # for (ch <- s) {\n    for ch in s:\n        # var shifted = ch.toInt + 4\n        shifted = ord(ch) + 4\n        # if (shifted > 'z'.toInt) {\n        if shifted > ord('z'):\n            # shifted -= 26\n            shifted -= 26\n        # result += shifted.toChar\n        result.append(chr(shifted))\n    # result.toString\n    return ''.join(result)\n",
            "def next_smallest(lst: List[int]) -> Optional[int]:\n    # val sl = lst.toSet.toList.sorted\n    sl = sorted(set(lst))\n    # if (sl.length < 2) {\n    if len(sl) < 2:\n        # return None\n        return None\n    # Some(sl(1))\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # val sentences = s.split(\"[.!?]\\\\s*\")\n    sentences = s.split(\"[.!?]\\\\s*\")\n    # return sentences.filter{sentence => sentence.length >= 2 && sentence.substring(0, 2) == \"I \"}.length\n    return len([sentence for sentence in sentences if len(sentence) >= 2 and sentence.startswith(\"I \")])\n",
            "def any_int(x: Any, y: Any, z: Any) -> bool:\n    # if (x.isInstanceOf[Int] && y.isInstanceOf[Int] && z.isInstanceOf[Int]) {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # val a = x.asInstanceOf[Int]\n        a = x\n        # val b = y.asInstanceOf[Int]\n        b = y\n        # val c = z.asInstanceOf[Int]\n        c = z\n        # if ((a + b == c) || (a + c == b) || (b + c == a)) {\n        if a + b == c or a + c == b or b + c == a:\n            # return true\n            return True\n    # }\n    # false\n    return False\n",
            "def encode(message: str) -> str:\n    # val vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # val result = new StringBuilder()\n    result = \"\"\n    # for (ch <- message) {\n    for ch in message:\n        # if (ch.isLetter) {\n        if ch.isalpha():\n            # var ch1 = if (ch.isLower) ch.toUpper else ch.toUpper\n            ch1 = ch.upper() if ch.islower() else ch.lower()\n            # if (vowels.contains(ch1)) {\n            if ch1 in vowels:\n                # ch1 = (ch1.toInt + 2).toChar\n                ch1 = chr(ord(ch1) + 2)\n            # result += ch1\n            result += ch1\n        else:\n            # result += ch\n            result += ch\n    # result.toString\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false\n        return False\n    # for (i <- 2 to sqrt(n).floor.toInt) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # val primes = lst.filter(isPrime)\n    primes = [e for e in lst if is_prime(e)]\n    # if (primes.length == 0) {\n    if len(primes) == 0:\n        # return 0\n        return 0\n    # val largest = primes.max.toString\n    largest = str(max(primes))\n    # largest.map(_.asDigit).sum\n    return sum(map(int, largest))\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if (d.isEmpty) {\n    if not d:\n        # return false\n        return False\n    # d.keys.forall(_.forall(_.isLower)) || d.keys.forall(_.forall(_.isUpper))\n    return all(k.islower() for k in d.keys()) or all(k.isupper() for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # val primes = mutable.ListBuffer[Int]()\n    primes = []\n    # for (num <- 2 until n) {\n    for num in range(2, n):\n        # if (primes.forall(p => num % p != 0)) {\n        if all(num % p != 0 for p in primes):\n            # primes += num\n            primes.append(num)\n    # primes.toList\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # (a.abs % 10) * (b.abs % 10)\n    return (abs(a) % 10) * (abs(b) % 10)\n",
            "def count_upper(s: str) -> int:\n    # val vowels = \"AEIOU\"\n    vowels = \"AEIOU\"\n    # s.zipWithIndex.filter { case (c, i) => i % 2 == 0 && vowels.contains(c) }.length\n    return sum(1 for i, c in enumerate(s) if i % 2 == 0 and c in vowels)\n",
            "def closest_integer(value: str) -> int:\n    # val num = value.toFloat\n    num = float(value)\n    # if (num >= 0) {\n    if num >= 0:\n        # (num + 0.5).toInt\n        return int(num + 0.5)\n    # } else {\n    else:\n        # (num - 0.5).toInt\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # (0 until n).map(i => n + 2 * i)\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # s.split(\"[, ]\").filter(_.length > 0).toList\n    return [w for w in s.split(\", \") if len(w) > 0]\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    #   return -1\n    # }\n    if x > y:\n        return -1\n    # if (y % 2 == 0) {\n    #   return y\n    # }\n    if y % 2 == 0:\n        return y\n    # if (y != x) y - 1 else -1\n    if y != x:\n        return y - 1\n    return -1\n",
            "def rounded_avg(n: int, m: int) -> Optional[str]:\n    # if (n > m) {\n    if n > m:\n        # return None\n        return None\n    # val rAvg = ((n + m).toDouble / 2 + 0.5).toInt\n    r_avg = int((n + m) / 2 + 0.5)\n    # Some(rAvg.toBinaryString)\n    return str(r_avg)\n",
            "def all_digits_odd(s: str) -> bool:\n    # s.forall(_.toInt % 2 != 0)\n    return all(int(c) % 2 != 0 for c in s)\ndef unique_digits(x: List[int]) -> List[int]:\n    # x.filter(x => allDigitsOdd(x.toString)).sorted\n    return sorted(filter(lambda x: all_digits_odd(str(x)), x))\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # val digitNames = List(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # val sortedArr = arr.filter(x => 1 <= x && x <= 9).sorted.reverse\n    sorted_arr = sorted(filter(lambda x: 1 <= x and x <= 9, arr), reverse=True)\n    # sortedArr.map(x => digitNames(x - 1))\n    return [digit_names[x - 1] for x in sorted_arr]\n",
            "def f(n: int) -> List[int]:\n    # val nums = (1 to n).toList\n    nums = list(range(1, n + 1))\n    # nums.map(i => if (i % 2 != 0) nums.take(i).sum else nums.take(i).product)\n    return [nums.take(i).sum() if i % 2 != 0 else nums.take(i).product() for i in nums]\n",
            "def is_palindrome(s: str) -> bool:\n    # s == s.reverse\n    return s == s[::-1]\ndef even_odd_palindrome(n: int) -> List[int]:\n    # var cnt = List(0, 0)\n    cnt = [0, 0]\n    # for (i <- 1 to n) {\n    for i in range(1, n + 1):\n        # if (isPalindrome(i.toString)) {\n        if is_palindrome(str(i)):\n            # cnt = cnt.updated(i % 2, cnt(i % 2) + 1)\n            cnt[i % 2] += 1\n    # cnt\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # val nStr = n.toString\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # nStr.map(_.asDigit).sum\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # nStr.take(2).toInt * 2 + digitsSum(n.abs)\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# def countNums(arr: Seq[Int]): Int = {\ndef count_nums(arr: List[int]) -> int:\n    # arr.count(digitsSum(_) > 0)\n    return sum(map(lambda x: 1 if digits_sum(x) > 0 else 0, arr))\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if (arr.isEmpty) {\n    if not arr:\n        # return true\n        return True\n    # val sortedArr = arr.sorted\n    sorted_arr = sorted(arr)\n    # for (i <- 0 until arr.length) {\n    for i in range(len(arr)):\n        # if (arr.slice(i, arr.length) == sortedArr.slice(0, arr.length - i) && arr.slice(0, i) == sortedArr.slice(arr.length - i, arr.length)) {\n        if arr[i:] == sorted_arr[0:len(arr) - i] and arr[0:i] == sorted_arr[len(arr) - i:len(arr)]:\n            # return true\n            return True\n    # false\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # val oddCnt = lst1.count(_ % 2 != 0)\n    odd_cnt = sum(1 for e in lst1 if e % 2 != 0)\n    # val evenCnt = lst2.count(_ % 2 == 0)\n    even_cnt = sum(1 for e in lst2 if e % 2 == 0)\n    # if (evenCnt >= oddCnt) {\n    if even_cnt >= odd_cnt:\n        # \"YES\"\n        return \"YES\"\n    # } else {\n    #   \"NO\"\n    # }\n    return \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # val freq = mutable.Map[String, Int]()\n    freq = {}\n    # val words = test.split(\" \").filter(_.length > 0)\n    words = test.split(\" \")\n    for w in words:\n        # freq(w) = freq.getOrElse(w, 0) + 1\n        freq[w] = freq.get(w, 0) + 1\n    # val result = mutable.Map[String, Int]()\n    result = {}\n    # if (freq.size > 0) {\n    if freq:\n        # val maxFreq = freq.values.max\n        max_freq = max(freq.values())\n        # for ((k, v) <- freq) {\n        for k, v in freq.items():\n            # if (v == maxFreq) {\n            if v == max_freq:\n                # result(k) = v\n                result[k] = v\n    # }\n    # result.toMap\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # s == s.reverse\n    return s == s[::-1]\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # val s1 = s.filterNot(c.contains(_))\n    s1 = ''.join(filter(lambda x: x not in c, s))\n    # List(s1, if (isPalindrome(s1)) \"yes\" else \"no\")\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # val result = mutable.ListBuffer[String]()\n    result = []\n    # for (num <- lst) {\n    for num in lst:\n        # val n = num.filter(_.toInt % 2 == 1).length\n        n = sum(1 for c in num if int(c) % 2 == 1)\n        # val rs = \"the number of odd elements in the string i of the input.\"\n        rs = \"the number of odd elements in the string {} of the input.\".format(n)\n        # result += rs.replaceAll(\"i\", n.toString())\n        result.append(rs.replace(\"i\", str(n)))\n    # result.toList\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # var minSum = 0\n    min_sum = 0\n    # var curSum = 0\n    cur_sum = 0\n    # for (n <- nums) {\n    for n in nums:\n        # curSum = Math.min(curSum + n, 0)\n        cur_sum = min(cur_sum + n, 0)\n        # minSum = Math.min(curSum, minSum)\n        min_sum = min(cur_sum, min_sum)\n    # if (minSum == 0) {\n    if min_sum == 0:\n        # minSum = nums.min\n        min_sum = min(nums)\n    # minSum\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # grid.map(arr => ceil(arr.sum / capacity.toDouble).toInt).sum\n    return sum(ceil(sum(arr) / capacity) for arr in grid)\n",
            "def count_ones(num: int) -> int:\n    # num.toBinaryString.count(_ == '1')\n    return num.to_bytes(1, 'big').count(b'1')\ndef sort_array(arr: List[int]) -> List[int]:\n    # arr.sortBy(x => (countOnes(x), x))\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # val consonants = \"bcdfghjklmnpqrstvwxyz\";\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # val words = s.split(\" \").filter(_.length > 0);\n    words = [w for w in s.split(\" \") if len(w) > 0]\n    # words.filter(w => w.count(c => consonants.contains(c.toLower)) == n);\n    return [w for w in words if w.count(lambda c: c.lower() in consonants) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # val vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # for (i <- word.length - 2 to 1 by -1) {\n    for i in range(word.length - 2, 1, -1):\n        # if (vowels.contains(word(i)) && !vowels.contains(word(i - 1)) && !vowels.contains(word(i + 1))) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return word(i).toString;\n            return word[i]\n    # return \"\";\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # var depth = 0\n    depth = 0\n    # for (ch <- s) {\n    for ch in s:\n        # if (ch == '(') {\n        if ch == '(':\n            # depth += 1\n            depth += 1\n        # } else {\n        else:\n            # depth -= 1\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false\n            return False\n    # depth == 0\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # val s1 = lst(0) + lst(1)\n    s1 = lst[0] + lst[1]\n    # val s2 = lst(1) + lst(0)\n    s2 = lst[1] + lst[0]\n    # if (check(s1) || check(s2)) \"Yes\" else \"No\"\n    if check(s1) or check(s2):\n        return \"Yes\"\n    else:\n        return \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if (k == 0) {\n    if k == 0:\n        # return List()\n        return []\n    # arr.sorted.takeRight(k)\n    return sorted(arr)[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # lst.zipWithIndex.filter{(x, i) => i % 2 == 0 && x % 2 != 0}.map{(x, i) => x}.sum\n    return sum(x for x, i in zip(lst, range(len(lst))) if i % 2 == 0 and x % 2 != 0)\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # arr.take(k).filter(num => num.toString.length <= 2).sum\n    return sum(filter(lambda num: len(str(num)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # var collatz = mutable.ListBuffer[Int](1)\n    collatz = [1]\n    # var num = n\n    num = n\n    # while (num != 1) {\n    while num != 1:\n        # if (num % 2 != 0) {\n        if num % 2 != 0:\n            # collatz += num\n            collatz.append(num)\n            # num = 3 * num + 1\n            num = 3 * num + 1\n        else:\n            # num = num / 2\n            num = num / 2\n    # collatz.toList.sorted\n    return sorted(collatz)\n",
            "def valid_date(date: str) -> bool:\n    # if (date.length != 10 || date(2) != '-' || date(5) != '-') {\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        # return false\n        return False\n    # val m = date.substring(0, 2).toInt\n    m = int(date[0:2])\n    # val d = date.substring(3, 5).toInt\n    d = int(date[3:5])\n    # if (List(1, 3, 5, 7, 8, 10, 12).contains(m) && d >= 1 && d <= 31) {\n    if m in [1, 3, 5, 7, 8, 10, 12] and d >= 1 and d <= 31:\n        # return true\n        return True\n    # if (List(4, 6, 9, 11).contains(m) && d >= 1 && d <= 30) {\n    if m in [4, 6, 9, 11] and d >= 1 and d <= 30:\n        # return true\n        return True\n    # if (m == 2 && d >= 1 && d <= 29) {\n    if m == 2 and d >= 1 and d <= 29:\n        # return true\n        return True\n    # false\n    False\n",
            "def split_words(txt: str) -> List[str]:\n    # if (txt.contains(\" \")) {\n    if \" \" in txt:\n        # txt.split(\" \").toList\n        return txt.split(\" \")\n    # } else if (txt.contains(\",\")) {\n    elif \",\" in txt:\n        # txt.split(\",\").toList\n        return txt.split(\",\")\n    # } else {\n    else:\n        # List(txt.filter(c => c.isLower && c.toInt % 2 == 0).length.toString)\n        return [str(len(txt.lower().replace(\" \", \"\").replace(\",\", \"\").replace(\"'\", \"\").replace(\"\\\"\", \"\").replace(\":\", \"\").replace(\";\", \"\").replace(\"!\", \"\").replace(\"?\", \"\").replace(\"-\", \"\").replace(\"(\", \"\").replace(\")\", \"\").replace(\"[\", \"\").replace(\"]\", \"\").replace(\"{\", \"\").replace(\"}\", \"\").replace(\"*\", \"\").replace(\"&\", \"\").replace(\"^\", \"\").replace(\"$\", \"\").replace(\"#\", \"\").replace(\"%\", \"\").replace(\"@\", \"\").replace(\"~\", \"\").replace(\"`\", \"\").replace(\"+\", \"\").replace(\"=\", \"\").replace(\"_\", \"\").replace(\"\\\\\", \"\").replace(\"|\", \"\").replace(\"\\\"\", \"\").replace(\"'\", \"\").replace(\">\", \"\").replace(\"<\", \"\").replace(\"0\", \"\").replace(\"1\", \"\").replace(\"2\", \"\").replace(\"3\", \"\").replace(\"4\", \"\").replace(\"5\", \"\").replace(\"6\", \"\").replace(\"7\", \"\").replace(\"8\", \"\").replace(\"9\", \"\")))\n        return [str(len(txt.lower().replace(\" \", \"\").replace(\",\", \"\").replace(\"'\", \"\").replace(\"\\\"\", \"\").replace(\":\", \"\").replace(\";\", \"\").replace(\"!\", \"\").replace(\"?\", \"\").replace(\"-\", \"\").replace(\"(\", \"\").replace(\")\", \"\").replace(\"[\", \"\").replace(\"]\", \"\").replace(\"{\", \"\").replace(\"}\", \"\").replace(\"*\", \"\").replace(\"&\", \"\").replace(\"^\", \"\").replace(\"$\", \"\").replace(\"#\", \"\").replace(\"%\", \"\").replace(\"@\", \"\").replace(\"~\", \"\").replace(\"`\", \"\").replace(\"+\", \"\").replace(\"=\", \"\").replace(\"_\", \"\").replace(\"\\\\\", \"\").replace(\"|\", \"\").replace(\"\\\"\", \"\").replace(\"'\", \"\").replace(\">\", \"\").replace(\"<\", \"\").replace(\"0\", \"\").replace(\"1\", \"\").replace(\"2\", \"\").replace(\"3\", \"\").replace(\"4\", \"\").replace(\"5\", \"\").replace(\"6\", \"\").replace(\"7\", \"\").replace(\"8\", \"\").replace(\"9\", \"\")))\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if (!lst.sliding(2).filter(_.size == 2).forall(x => x(0) <= x(1))) {\n    if not all(x[0] <= x[1] for x in zip(lst, lst[1:])):\n        return False\n    # val freq = mutable.Map[Int, Int]()\n    freq = {}\n    # for (i <- lst) {\n    for i in lst:\n        # freq(i) = freq.getOrElse(i, 0) + 1\n        freq[i] = freq.get(i, 0) + 1\n    # freq.values.maxOption.getOrElse(0) <= 2\n    return max(freq.values(), default=0) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false\n        return False\n    # for (i <- 2 to sqrt(n).floor.toInt) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # val l = max(interval1(0), interval2(0))\n    l = max(interval1[0], interval2[0])\n    # val r = min(interval1(1), interval2(1))\n    r = min(interval1[1], interval2[1])\n    # val length = r - l\n    length = r - l\n    # if (length > 0 && isPrime(length)) \"YES\" else \"NO\"\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if (arr.isEmpty) {\n    if not arr:\n        # return None\n        return None\n    # if (arr.contains(0)) {\n    if 0 in arr:\n        # return Some(0)\n        return 0\n    # val sign = if (arr.count(_ < 0) % 2 == 1) -1 else 1\n    sign = -1 if arr.count(lambda x: x < 0) % 2 == 1 else 1\n    # Some(sign * arr.map(_.abs).sum)\n    return sign * sum(map(abs, arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # val n = grid.length\n    n = len(grid)\n    # var minVal = n * n + 1\n    min_val = n * n + 1\n    # for (i <- 0 until n) {\n    for i in range(n):\n        # for (j <- 0 until n) {\n        for j in range(n):\n            # if (grid(i)(j) == 1) {\n            if grid[i][j] == 1:\n                # val temp = mutable.ListBuffer[Int]()\n                temp = []\n                # if (i != 0) {\n                if i != 0:\n                    # temp.append(grid(i - 1)(j))\n                    temp.append(grid[i - 1][j])\n                # if (j != 0) {\n                if j != 0:\n                    # temp.append(grid(i)(j - 1))\n                    temp.append(grid[i][j - 1])\n                # if (i != n - 1) {\n                if i != n - 1:\n                    # temp.append(grid(i + 1)(j))\n                    temp.append(grid[i + 1][j])\n                # if (j != n - 1) {\n                if j != n - 1:\n                    # temp.append(grid(i)(j + 1))\n                    temp.append(grid[i][j + 1])\n                # minVal = temp.min\n                min_val = min(temp)\n    # val result = mutable.ListBuffer[Int]()\n    result = []\n    # for (i <- 0 until k) {\n    for i in range(k):\n        # result.append(if (i % 2 == 0) 1 else minVal)\n        result.append(1 if i % 2 == 0 else min_val)\n    # result.toList\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if (n == 0) {\n    if n == 0:\n        # List(1)\n        return [1]\n    # } else {\n    else:\n        # var seq = mutable.ListBuffer(1, 3)\n        seq = [1, 3]\n        # for (i <- 2 to n) {\n        for i in range(2, n + 1):\n            # if (i % 2 == 0) {\n            if i % 2 == 0:\n                # seq += i / 2 + 1\n                seq.append(i // 2 + 1)\n            # } else {\n            else:\n                # seq += seq(i - 1) + seq(i - 2) + (i + 3) / 2\n                seq.append(seq[i - 1] + seq[i - 2] + (i + 3) // 2)\n        # seq.toList\n        return seq\n",
            "def digits(n: int) -> int:\n    # val odds = n.toString.filter(_.asDigit % 2 == 1).map(_.asDigit)\n    odds = [int(c) for c in str(n) if int(c) % 2 == 1]\n    # if (odds.isEmpty) 0 else odds.product\n    return 0 if len(odds) == 0 else functools.reduce(lambda x, y: x * y, odds)\n",
            "def is_nested(s: str) -> bool:\n    # var openIdx = mutable.ListBuffer[Int]()\n    open_idx = []\n    # var closeIdx = mutable.ListBuffer[Int]()\n    close_idx = []\n    # for ((ch, i) <- s.zipWithIndex) {\n    for ch, i in zip(s, range(len(s))):\n        # ch match {\n        #   case '[' => openIdx += i\n        #   case ']' => closeIdx += i\n        # }\n        if ch == '[':\n            open_idx.append(i)\n        elif ch == ']':\n            close_idx.append(i)\n    # closeIdx = closeIdx.reverse\n    close_idx.reverse()\n    # var cnt = 0\n    cnt = 0\n    # var i = 0\n    i = 0\n    # val l = closeIdx.length\n    l = len(close_idx)\n    # for (idx <- openIdx) {\n    for idx in open_idx:\n        # if (i < l && idx < closeIdx(i)) {\n        if i < l and idx < close_idx[i]:\n            # cnt += 1\n            cnt += 1\n            # i += 1\n            i += 1\n    # cnt >= 2\n    return cnt >= 2\n",
            "def sum_squares(lst: List[float]) -> int:\n    # lst.map(n => pow(ceil(n), 2).toInt).sum\n    return sum(pow(ceil(n), 2) for n in lst)\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if (txt.isEmpty) {\n    #   return false\n    # }\n    if not txt:\n        return False\n    # val last = txt.substring(txt.lastIndexOf(' ') + 1)\n    last = txt.split()[-1]\n    # last.length == 1 && last(0).isLetter\n    return len(last) == 1 and last[0].isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if (arr.length <= 1) {\n    if len(arr) <= 1:\n        # return -1\n        return -1\n    # val idx = (1 until arr.length).filter(i => arr(i) < arr(i - 1))\n    idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    # idx.maxOption.getOrElse(-1)\n    return max(idx) if idx else -1\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # val neg = lst.filter(_ < 0)\n    neg = [e for e in lst if e < 0]\n    # val pos = lst.filter(_ > 0)\n    pos = [e for e in lst if e > 0]\n    # val maxNeg = neg.maxOption\n    max_neg = max(neg) if neg else None\n    # val minPos = pos.minOption\n    min_pos = min(pos) if pos else None\n    # List(maxNeg, minPos)\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if (o.isInstanceOf[String]) {\n    if isinstance(o, str):\n        # return o.asInstanceOf[String].replace(\",\", \".\").toDouble\n        return float(o.replace(\",\", \".\"))\n    # } else if (o.isInstanceOf[Int]) {\n    elif isinstance(o, int):\n        # return o.asInstanceOf[Int].toDouble\n        return float(o)\n    # } else if (o.isInstanceOf[Double]) {\n    elif isinstance(o, float):\n        # return o.asInstanceOf[Double]\n        return o\n    # }\n    # throw new Exception(\"Type Error\")\n    raise Exception(\"Type Error\")\ndef compare_one(a: Any, b: Any) -> Optional[float]:\n    # val a1 = anyToReal(a)\n    a1 = any_to_real(a)\n    # val b1 = anyToReal(b)\n    b1 = any_to_real(b)\n    # if (a1 == b1) {\n    if a1 == b1:\n        # None\n        return None\n    # } else if (a1 > b1) {\n    elif a1 > b1:\n        # Some(a1)\n        return a1\n    # } else {\n    else:\n        # Some(b1)\n        return b1\n    # }\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # n % 2 == 0 && n >= 8\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # var fact = 1\n    fact = 1\n    # var result = 1\n    result = 1\n    # for (i <- 1 to n) {\n    for i in range(1, n + 1):\n        # fact *= i\n        fact *= i\n        # result *= fact\n        result *= fact\n    # result\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return txt.replaceAll(\"\\\\s{3,}\", \"-\").replaceAll(\" \", \"_\")\n    return txt.replace(\"   \", \"-\").replace(\" \", \"_\")\n",
            "def file_name_check(file_name: str) -> str:\n    # val suf = List(\"txt\", \"exe\", \"dll\")\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # val lst = fileName.split(\"\\\\.\")\n    lst = file_name.split(\".\")\n    # if (lst.size != 2 || !suf.contains(lst(1)) || lst(0).isEmpty || !lst(0)(0).isLetter || lst(0).count(_.isDigit) > 3) {\n    if len(lst) != 2 or lst[1] not in suf or lst[0] == \"\" or lst[0][0].isdigit() or lst[0].count(str.isdigit) > 3:\n        # return \"No\"\n        return \"No\"\n    # return \"Yes\"\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # var result = 0\n    result = 0\n    # for (i <- 0 until lst.length) {\n    for i in range(len(lst)):\n        # if (i % 3 == 0) {\n        if i % 3 == 0:\n            # result += pow(lst(i), 2).toInt\n            result += pow(lst[i], 2)\n        # } else if (i % 4 == 0) {\n        elif i % 4 == 0:\n            # result += pow(lst(i), 3).toInt\n            result += pow(lst[i], 3)\n        # } else {\n        else:\n            # result += lst(i)\n            result += lst[i]\n    # result\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false\n        return False\n    # for (i <- 2 to sqrt(n).floor.toInt) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return false\n            return False\n    # true\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # val words = sentence.split(\" \")\n    words = sentence.split(\" \")\n    # words.filter(w => isPrime(w.length)).mkString(\" \")\n    return \" \".join([w for w in words if is_prime(len(w))])\n",
            "def simplify(x: str, n: str) -> bool:\n    # val xs = x.split('/')\n    xs = x.split('/')\n    # val ns = n.split('/')\n    ns = n.split('/')\n    # val num = xs(0).toInt * ns(0).toInt\n    num = int(xs[0]) * int(ns[0])\n    # val den = xs(1).toInt * ns(1).toInt\n    den = int(xs[1]) * int(ns[1])\n    # num % den == 0\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # val nStr = n.toString\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # nStr.map(_.asDigit).sum\n        return sum(map(int, n_str))\n    # else {\n    else:\n        # nStr.take(2).toInt * 2 + digitsSum(n.abs)\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\ndef order_by_points(nums: List[int]) -> List[int]:\n    # nums.sortBy(digitsSum)\n    return sorted(nums, key=digits_sum)\n",
            "def special_filter(nums: List[int]) -> int:\n    # val odds = \"13579\"\n    odds = \"13579\"\n    # nums.filter(n => n > 10 && n % 2 == 1 && odds.contains(n.toString()(0))).length\n    return len([n for n in nums if n > 10 and n % 2 == 1 and odds[0] in str(n)])\n",
            "def get_max_triples(n: int) -> int:\n    # val c = Array(0, 0, 0)\n    c = [0, 0, 0]\n    # for (i <- 1 to n) {\n    for i in range(1, n + 1):\n        # val a = i * i - i + 1\n        a = i * i - i + 1\n        # c(a % 3) += 1\n        c[a % 3] += 1\n    # c(0) * c(1) * c(2) + (c(0) * (c(0) - 1) * (c(0) - 2) + c(1) * (c(1) - 1) * (c(1) - 2) + c(2) * (c(2) - 1) * (c(2) - 2)) / 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # val names = List(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if (!names.contains(planet1) || !names.contains(planet2)) {\n    if planet1 not in names or planet2 not in names:\n        # return List()\n        return []\n    # var l = names.indexOf(planet1)\n    l = names.index(planet1)\n    # var r = names.indexOf(planet2)\n    r = names.index(planet2)\n    # if (l > r) {\n    if l > r:\n        # (l, r).match { case (_l, _r) => r = _l; l = _r}\n        r, l = l, r\n    # if (l == r) {\n    if l == r:\n        # return List()\n        return []\n    # names.slice(l + 1, r)\n    return names[l + 1:r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # val result = lst.filter(_.length % 2 == 0)\n    result = [s for s in lst if len(s) % 2 == 0]\n    # result.sortBy(s => (s.length, s))\n    result.sort(key=lambda s: (len(s), s))\n    return result\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if (n < 2) {\n    if n < 2:\n        # return y\n        return y\n    # for (i <- 2 to sqrt(n).floor.toInt) {\n    for i in range(2, int(sqrt(n)) + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return y\n            return y\n    # return x\n    return x\n",
            "def double_the_difference(lst: List[float]) -> int:\n    # lst.filter(n => n >= 0 && n % 2 == 1).map(n => (n * n).toInt).sum\n    return sum(map(lambda n: int(n * n), filter(lambda n: n >= 0 and n % 2 == 1, lst)))\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # game.zip(guess).map { case (x, y) => (x - y).abs }\n    return [abs(x - y) for x, y in zip(game, guess)]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # var maxS = Int.MinValue\n    max_s = -2147483648\n    # var maxExt = \"\"\n    max_ext = \"\"\n    # for (ext <- extensions) {\n    for ext in extensions:\n        # val upper = ext.count(_.isUpper)\n        upper = sum(1 for c in ext if c.isupper())\n        # val lower = ext.count(_.isLower)\n        lower = sum(1 for c in ext if c.islower())\n        # val s = upper - lower\n        s = upper - lower\n        # if (s > maxS) {\n        if s > max_s:\n            # maxS = s\n            max_s = s\n            # maxExt = ext\n            max_ext = ext\n    # s\"$className.$maxExt\"\n    return f\"{class_name}.{max_ext}\"\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if (a.length < b.length) {\n    if len(a) < len(b):\n        # false\n        return False\n    # } else {\n    #   for (i <- 0 until b.length) {\n    for i in range(len(b)):\n        # if (a.contains(b.substring(i) + b.substring(0, i))) {\n        if a.find(b[i:] + b[:i]) != -1:\n            # return true\n            return True\n    # false\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # val ds = num.abs.toString\n    ds = str(abs(num))\n    # val even = ds.count(d => d.toInt % 2 == 0)\n    even = ds.count(lambda d: int(d) % 2 == 0)\n    # List(even, ds.length - even)\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # val values = List(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 ,5, 4, 1)\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 ,5, 4, 1]\n    # val numerals = List(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # var res = StringBuilder()\n    res = \"\"\n    # @tailrec\n    # def loop(num: Int, i: Int): Unit = {\n    #   if (num == 0) ()\n    #   else if (num >= values(i)) {\n    #     res ++= numerals(i)\n    #     loop(num - values(i), i)\n    #   }\n    #   else loop(num, i + 1)\n    # }\n    def loop(num: int, i: int):\n        if num == 0:\n            return\n        elif num >= values[i]:\n            res += numerals[i]\n            loop(num - values[i], i)\n        else:\n            loop(num, i + 1)\n    loop(num, 0)\n    # res.toString\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # val s = List(a, b, c).sorted\n    s = sorted([a, b, c])\n    # s(0) * s(0) + s(1) * s(1) == s(2) * s(2)\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # var maxCnt = 0\n    max_cnt = 0\n    # var maxW = \"\"\n    max_w = \"\"\n    # for (w <- words) {\n    for w in words:\n        # val cnt = w.toSet.size\n        cnt = len(set(w))\n        # if (cnt > maxCnt) {\n        if cnt > max_cnt:\n            # maxCnt = cnt\n            max_cnt = cnt\n            # maxW = w\n            max_w = w\n        # else if (cnt == maxCnt) {\n        elif cnt == max_cnt:\n            # maxW = List(w, maxW).min\n            max_w = min(w, max_w)\n    # maxW\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if (need <= remaining) {\n    if need <= remaining:\n        # List(num + need, remaining - need)\n        return [num + need, remaining - need]\n    # } else {\n    else:\n        # List(num + remaining, 0)\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # var ops = operators.toBuffer\n    ops = operators.copy()\n    # var nums = operands.toBuffer\n    nums = operands.copy()\n    # var i = ops.length - 1\n    i = len(ops) - 1\n    # while (i >= 0) {\n    while i >= 0:\n        # if (ops(i) == \"**\") {\n        if ops[i] == \"**\":\n            # nums(i) = pow(nums(i), nums(i + 1)).toInt\n            nums[i] = int(pow(nums[i], nums[i + 1]))\n            # nums.remove(i + 1)\n            del nums[i + 1]\n            # ops.remove(i)\n            del ops[i]\n        # }\n        i -= 1\n    # i = 0\n    i = 0\n    # while (i < ops.length) {\n    while i < len(ops):\n        # if (ops(i) == \"*\") {\n        if ops[i] == \"*\":\n            # nums(i) = nums(i) * nums(i + 1)\n            nums[i] *= nums[i + 1]\n            # nums.remove(i + 1)\n            del nums[i + 1]\n            # ops.remove(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # } else if (ops(i) == \"//\") {\n        elif ops[i] == \"//\":\n            # nums(i) = nums(i) / nums(i + 1)\n            nums[i] //= nums[i + 1]\n            # nums.remove(i + 1)\n            del nums[i + 1]\n            # ops.remove(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # }\n        i += 1\n    # i = 0\n    i = 0\n    # while (i < ops.length) {\n    while i < len(ops):\n        # if (ops(i) == \"+\") {\n        if ops[i] == \"+\":\n            # nums(i) = nums(i) + nums(i + 1)\n            nums[i] += nums[i + 1]\n            # nums.remove(i + 1)\n            del nums[i + 1]\n            # ops.remove(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # } else if (ops(i) == \"-\") {\n        elif ops[i] == \"-\":\n            # nums(i) = nums(i) - nums(i + 1)\n            nums[i] -= nums[i + 1]\n            # nums.remove(i + 1)\n            del nums[i + 1]\n            # ops.remove(i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # }\n        i += 1\n    # nums(0)\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if (!s.exists(_.isLetter)) {\n    if not any(ch.isalpha() for ch in s):\n        # return s.reverse\n        return s[::-1]\n    # val result = StringBuilder()\n    result = []\n    # for (ch <- s) {\n    for ch in s:\n        # if (!ch.isLetter) {\n        if not ch.isalpha():\n            # result += ch\n            result.append(ch)\n        # else if (ch.isUpper) {\n        elif ch.isupper():\n            # result += ch.toLower\n            result.append(ch.lower())\n        # else if (ch.isLower) {\n        elif ch.islower():\n            # result += ch.toUpper\n            result.append(ch.upper())\n    # result.toString\n    return ''.join(result)\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if (txt.isEmpty) {\n    if not txt:\n        # return None\n        return None\n    # val md5Hash = MessageDigest.getInstance(\"MD5\")\n    md5_hash = hashlib.md5()\n    # val txtBytes = txt.getBytes()\n    txt_bytes = txt.encode()\n    # md5Hash.update(txtBytes)\n    md5_hash.update(txt_bytes)\n    # val md5Encoded = md5Hash.digest().map(\"%02x\".format(_)).mkString\n    md5_encoded = md5_hash.hexdigest()\n    # Some(md5Encoded)\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # val lower = max(2, min(a, b))\n    lower = max(2, min(a, b))\n    # val upper = min(8, max(a, b))\n    upper = min(8, max(a, b))\n    # (lower to upper).filter(_ % 2 == 0)\n    return list(filter(lambda x: x % 2 == 0, range(lower, upper + 1)))\n"
        ]
    },
    "swift": {
        "python": [
            "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # for i in 0..<numbers.count {\n    for i in range(len(numbers)):\n        # for j in (i + 1)..<numbers.count {\n        for j in range(i + 1, len(numbers)):\n            # if abs(numbers[i] - numbers[j]) < threshold {\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true\n                return True\n    # return false\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # var groups = [String]()\n    groups = []\n    # var stk = [Character]()\n    stk = []\n    # var currentGroup = \"\"\n    current_group = \"\"\n    # let parens = parenString.replacingOccurrences(of: \" \", with: \"\")\n    parens = paren_string.replace(\" \", \"\")\n    # for ch in parens {\n    for ch in parens:\n        # if ch == \"(\" {\n        if ch == \"(\":\n            # stk.append(ch)\n            stk.append(ch)\n            # currentGroup += String(ch)\n            current_group += ch\n        # } else if ch == \")\" {\n        elif ch == \")\":\n            # stk.popLast()\n            stk.pop()\n            # currentGroup += String(ch)\n            current_group += ch\n            # if stk.isEmpty {\n            if not stk:\n                # groups.append(currentGroup)\n                groups.append(current_group)\n                # currentGroup = \"\"\n                current_group = \"\"\n    # return groups\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return num - floor(num)\n    return num - math.floor(num)\n",
            "def below_zero(operations: List[int]) -> bool:\n    # var balance = 0\n    balance = 0\n    # for op in operations {\n    for op in operations:\n        # balance += op\n        balance += op\n        # if balance < 0 {\n        if balance < 0:\n            # return true\n            return True\n    # return false\n    return False\n",
            "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # let mean = numbers.reduce(0, +) / Double(numbers.count)\n    mean = sum(numbers) / len(numbers)\n    # let deviation = numbers.reduce(0) { $0 + abs($1 - mean) }\n    deviation = sum(abs(n - mean) for n in numbers)\n    # return deviation / Double(numbers.count)\n    return deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # var result = [Int]()\n    result = []\n    # for i in 0..<numbers.count {\n    for i in range(len(numbers)):\n        # if i != 0 {\n        if i != 0:\n            # result.append(delimiter)\n            result.append(delimiter)\n        # result.append(numbers[i])\n        result.append(numbers[i])\n    # return result\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # var result = [Int]()\n    result = []\n    # let parenGroups = parenString.split(separator: \" \")\n    paren_groups = paren_string.split(\" \")\n    # for group in parenGroups {\n    for group in paren_groups:\n        # var maxDepth = 0\n        max_depth = 0\n        # var depth = 0\n        depth = 0\n        # for ch in group {\n        for ch in group:\n            # if ch == \"(\" {\n            if ch == \"(\":\n                # depth += 1\n                depth += 1\n                # maxDepth = max(maxDepth, depth)\n                max_depth = max(max_depth, depth)\n            # } else if ch == \")\" {\n            elif ch == \")\":\n                # depth -= 1\n                depth -= 1\n        # result.append(maxDepth)\n        result.append(max_depth)\n    # return result\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # return strs.filter { $0.contains(substring) }\n    return list(filter(lambda s: substring in s, strs))\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # var nSum = numbers.reduce(0, +)\n    nSum = sum(numbers)\n    # var nProduct = numbers.reduce(1, *)\n    nProduct = reduce(lambda x, y: x * y, numbers)\n    # return [nSum, nProduct]\n    return [nSum, nProduct]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # var maxSoFar = Int.min\n    max_so_far = float('-inf')\n    # var result = [Int]()\n    result = []\n    # for num in numbers {\n    for num in numbers:\n        # maxSoFar = max(maxSoFar, num)\n        max_so_far = max(max_so_far, num)\n        # result.append(maxSoFar)\n        result.append(max_so_far)\n    # return result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == String(s.reversed())\n    return s == s[::-1]\ndef make_palindrome(s: str) -> str:\n    # if isPalindrome(s) {\n    if is_palindrome(s):\n        # return s\n        return s\n    # for i in 0..<s.count {\n    for i in range(len(s)):\n        # let index = s.index(s.startIndex, offsetBy: i)\n        index = s.index(s.startIndex, offsetBy=i)\n        # if isPalindrome(String(s[index...])) {\n        if is_palindrome(s[index:]):\n            # return s + String(s[..<index].reversed())\n            return s + s[:index][::-1]\n    # return \"\"\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # return String(zip(a, b).map { $0 == $1 ? \"0\" : \"1\" })\n    return ''.join(['0' if x == y else '1' for x, y in zip(a, b)])\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if strs.isEmpty {\n    if not strs:\n        # return nil\n        return None\n    # var longestS = strs[0]\n    longest_s = strs[0]\n    # for s in strs {\n    for s in strs:\n        # if s.count > longestS.count {\n        if len(s) > len(longest_s):\n            # longestS = s\n            longest_s = s\n    # return longestS\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if b == 0 {\n    if b == 0:\n        # return a\n        return a\n    # } else {\n    else:\n        # return greatestCommonDivisor(b, a % b)\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # var prefixes = [String]()\n    prefixes = []\n    # for i in 0..<s.count {\n    for i in range(len(s)):\n        # let index = s.index(s.startIndex, offsetBy: i+1)\n        index = s.index(i+1)\n        # let prefix = String(s[..<index])\n        prefix = s[:index]\n        # prefixes.append(prefix)\n        prefixes.append(prefix)\n    # return prefixes\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # return (0...n).map { String($0) }.joined(separator: \" \")\n    return \" \".join(map(str, range(n + 1)))\n",
            "def count_distinct_characters(s: str) -> int:\n    # return Set(s.lowercased()).count\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # let durations: [String: Int] = [\"o\": 4, \"o|\": 2, \".|\": 1]\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    # let notes = musicString.split(separator: \" \")\n    notes = music_string.split(\" \")\n    # return notes.map { durations[String($0)]! }\n    return [durations[note] for note in notes]\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # var times = 0\n    times = 0\n    # if substring.count > s.count {\n    if len(substring) > len(s):\n        # return 0\n        return 0\n    # for i in 0...s.count - substring.count {\n    for i in range(0, len(s) - len(substring)):\n        # if s[s.index(s.startIndex, offsetBy: i)..<s.index(s.startIndex, offsetBy: i + substring.count)] == substring {\n        if s[i:i + len(substring)] == substring:\n            # times += 1\n            times += 1\n    # return times\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # let numDict: [String: Int] = [\n    num_dict = {\n        # \"zero\": 0,\n        \"zero\": 0,\n        # \"one\": 1,\n        \"one\": 1,\n        # \"two\": 2,\n        \"two\": 2,\n        # \"three\": 3,\n        \"three\": 3,\n        # \"four\": 4,\n        \"four\": 4,\n        # \"five\": 5,\n        \"five\": 5,\n        # \"six\": 6,\n        \"six\": 6,\n        # \"seven\": 7,\n        \"seven\": 7,\n        # \"eight\": 8,\n        \"eight\": 8,\n        # \"nine\": 9\n        \"nine\": 9\n    }\n    # var numList = numbers.split(separator: \" \").map { String($0) }.filter { numDict[$0] != nil }\n    num_list = numbers.split(\" \")\n    num_list = list(map(lambda x: str(x), num_list))\n    num_list = list(filter(lambda x: num_dict[x] != None, num_list))\n    # numList.sort { numDict[$0]! < numDict[$1]! }\n    num_list.sort(key=lambda x: num_dict[x])\n    # return numList.joined(separator: \" \")\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[float]) -> List[float]:\n    # var sortedNumbers = numbers.sorted()\n    sorted_numbers = sorted(numbers)\n    # var minDiff = Double.infinity\n    min_diff = float('inf')\n    # var closestPair: [Double] = []\n    closest_pair = []\n    # for i in 1..<sortedNumbers.count {\n    for i in range(1, len(sorted_numbers)):\n        # let diff = sortedNumbers[i] - sortedNumbers[i - 1]\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if diff < minDiff {\n        if diff < min_diff:\n            # minDiff = diff\n            min_diff = diff\n            # closestPair = [sortedNumbers[i - 1], sortedNumbers[i]]\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return closestPair \n    return closest_pair \n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # let minNum = numbers.min() ?? 0.0\n    min_num = min(numbers) if numbers else 0.0\n    # let maxNum = numbers.max() ?? 0.0\n    max_num = max(numbers) if numbers else 0.0\n    # if minNum == maxNum {\n    if min_num == max_num:\n        # return Array(repeating: 0.0, count: numbers.count)\n        return [0.0] * len(numbers)\n    # } else {\n    else:\n        # return numbers.map { ($0 - minNum) / (maxNum - minNum) }\n        return [((n - min_num) / (max_num - min_num)) for n in numbers]\n",
            "def filter_integers(values: List[Any]) -> List[int]:\n    # return values.compactMap { $0 as? Int }\n    return [v for v in values if isinstance(v, int)]\n",
            "def str_length(s: str) -> int:\n    # return s.count\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # if n < 2 {\n    if n < 2:\n        # return 1\n        return 1\n    # for i in 2..<n {\n    for i in range(2, n):\n        # if n % i == 0 {\n        if n % i == 0:\n            # return n / i\n            return n / i\n    # return 1\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # var factors = [Int]()\n    factors = []\n    # var divisor = 2\n    divisor = 2\n    # var num = n\n    num = n\n    # while divisor <= num {\n    while divisor <= num:\n        # if num % divisor == 0 {\n        if num % divisor == 0:\n            # factors.append(divisor)\n            factors.append(divisor)\n            # num /= divisor\n            num //= divisor\n        # else {\n        else:\n            # divisor += 1\n            divisor += 1\n    # return factors\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # var counts: [Int: Int] = [:]\n    counts = {}\n    # for num in numbers {\n    for num in numbers:\n        # counts[num] = (counts[num] ?? 0) + 1\n        counts[num] = counts.get(num, 0) + 1\n    # var res = numbers.filter { counts[$0] == 1 }\n    res = [num for num in numbers if counts[num] == 1]\n    # return res\n    return res\n",
            "def flip_case(s: str) -> str:\n    # var flipped = \"\"\n    flipped = \"\"\n    # for ch in s {\n    for ch in s:\n        # if !ch.isLetter {\n        if not ch.isalpha():\n            # flipped.append(ch)\n            flipped += ch\n        # } else if ch.isLowercase {\n        elif ch.islower():\n            # flipped.append(ch.uppercased())\n            flipped += ch.upper()\n        # } else if ch.isUppercase {\n        elif ch.isupper():\n            # flipped.append(ch.lowercased())\n            flipped += ch.lower()\n    # return flipped\n    return flipped\n",
            "def concatenate(strs: List[str]) -> str:\n    # return strs.joined(separator: \"\")\n    return ''.join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # return strs.filter { $0.hasPrefix(prefixStr) }\n    return list(filter(lambda s: s.startswith(prefix_str), strs))\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # return l.filter { $0 > 0 }\n    return list(filter(lambda x: x > 0, l))\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return false\n        return False\n    # if 2 <= Int(floor(sqrt(Double(n)))) {\n    if 2 <= int(floor(sqrt(n))):\n        # for i in 2...Int(floor(sqrt(Double(n)))) {\n        for i in range(2, int(floor(sqrt(n)))):\n            # if n % i == 0 {\n            if n % i == 0:\n                # return false\n                return False\n    # return true\n    return True\n",
            "def poly(xs: List[int], x: float) -> float:\n    # var res = 0.0\n    res = 0.0\n    # for i in 0..<xs.count {\n    for i in range(len(xs)):\n        # res += Double(xs[i]) * pow(x, Double(i))\n        res += xs[i] * pow(x, i)\n    # return res\n    return res\ndef find_zero(xs: List[int]) -> float:\n    # var x1 = 1.0, x2 = -1.0\n    x1 = 1.0\n    x2 = -1.0\n    # while poly(xs, x1) * poly(xs, x2) > 0 {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2\n        x1 *= 2\n        # x2 *= 2\n        x2 *= 2\n    # while abs(x1 - x2) > 1e-10 {\n    while abs(x1 - x2) > 1e-10:\n        # let mid = (x1 + x2) / 2\n        mid = (x1 + x2) / 2\n        # if poly(xs, mid) == 0 {\n        if poly(xs, mid) == 0:\n            # return mid\n            return mid\n        # else if poly(xs, mid) * poly(xs, x1) < 0 {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid\n            x1 = mid\n    # return (x1 + x2) / 2\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # let sortedThird = l.enumerated().filter { $0.offset % 3 == 0 }.map { $0.element }.sorted()\n    sorted_third = sorted([e for i, e in enumerate(l) if i % 3 == 0])\n    # return l.enumerated().map { $0.offset % 3 == 0 ? sortedThird[$0.offset / 3] : $0.element }\n    return [sorted_third[i // 3] if i % 3 == 0 else e for i, e in enumerate(l)]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # return Array(Set(l)).sorted()\n    return sorted(set(l))\n",
            "def max_element(l: List[int]) -> int:\n    # if l.isEmpty {\n    if not l:\n        # return 0\n        return 0\n    # return l.max()!\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # var cnt = 0\n    cnt = 0\n    # for i in 0..<n {\n    for i in range(n):\n        # if i % 11 == 0 || i % 13 == 0 {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += String(i).filter { $0 == \"7\" }.count\n            cnt += len(list(filter(lambda x: x == \"7\", str(i))))\n    # return cnt\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # let sortedEven = l.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted()\n    sorted_even = [e for i, e in enumerate(l) if i % 2 == 0]\n    sorted_even.sort()\n    # return l.enumerated().map { $0.offset % 2 == 0 ? sortedEven[$0.offset / 2] : $0.element }\n    return [sorted_even[i // 2] if i % 2 == 0 else e for i, e in enumerate(l)]\n",
            "def encode_cyclic(s: str) -> str:\n    # var result = \"\"\n    result = \"\"\n    # for i in stride(from: 0, to: s.count, by: 3) {\n    for i in range(0, len(s), 3):\n        # if i + 3 > s.count {\n        if i + 3 > len(s):\n            # result += s[s.index(s.startIndex, offsetBy: i)...]\n            result += s[i:]\n        # } else {\n        else:\n            # result += s[s.index(s.startIndex, offsetBy: i + 1)..<s.index(s.startIndex, offsetBy: i + 3)]\n            result += s[i + 1:i + 3]\n            # result += String(s[s.index(s.startIndex, offsetBy: i)])\n            result += s[i]\n    # return result\n    return result\ndef decode_cyclic(s: str) -> str:\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(_n: int) -> bool:\n    # if n < 2 {\n    if _n < 2:\n        # return false\n        return False\n    # if 2 <= Int(floor(sqrt(Double(n)))) {\n    if 2 <= int(sqrt(_n)):\n        # for i in 2...Int(floor(sqrt(Double(n)))) {\n        for i in range(2, int(sqrt(_n)) + 1):\n            # if n % i == 0 {\n            if _n % i == 0:\n                # return false\n                return False\n    # return true\n    return True\ndef prime_fib(_n: int) -> int:\n    # var f = [0, 1]\n    f = [0, 1]\n    # var cnt = 0\n    cnt = 0\n    # while cnt < n {\n    while cnt < _n:\n        # f = [f[1], f[0] + f[1]]\n        f = [f[1], f[0] + f[1]]\n        # if isPrime(f[1]) {\n        if is_prime(f[1]):\n            # cnt += 1\n            cnt += 1\n    # return f[1]\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for i in 0..<l.count {\n    for i in range(len(l)):\n        # for j in (i + 1)..<l.count {\n        for j in range(i + 1, len(l)):\n            # for k in (j + 1)..<l.count {\n            for k in range(j + 1, len(l)):\n                # if l[i] + l[j] + l[k] == 0 {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true\n                    return True\n    # return false\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return Int(pow(Double(n), 2))\n    return int(pow(n, 2))\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # return l.map { $0 + 1 }\n    return [e + 1 for e in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # var seen = Set<Int>()\n    seen = set()\n    # for num in l {\n    for num in l:\n        # if seen.contains(-num) {\n        if -num in seen:\n            # return true\n            return True\n        # seen.insert(num)\n        seen.add(num)\n    # return false\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # var x = x\n    # if x == 0 {\n    if x == 0:\n        # return \"0\"\n        return \"0\"\n    # var digits = [String]()\n    digits = []\n    # while x > 0 {\n    while x > 0:\n        # digits.append(String(x % bas))\n        digits.append(str(x % bas))\n        # x /= bas\n        x //= bas\n    # return digits.reversed().joined()\n    return \"\".join(reversed(digits))\n",
            "def triangle_area(a: int, h: int) -> float:\n    # return Double(a * h) / 2\n    return float(a * h) / 2\n",
            "def fib4(n: int) -> int:\n    # var fib = [0, 0, 2, 0]\n    fib = [0, 0, 2, 0]\n    # for i in 4...n {\n    for i in range(4, n + 1):\n        # fib[i % 4] = fib.reduce(0, +)\n        fib[i % 4] = sum(fib)\n    # return fib[n % 4]\n    return fib[n % 4]\n",
            "def median(l: List[float]) -> float:\n    # let sl = l.sorted()\n    sl = sorted(l)\n    # if l.count % 2 != 0 {\n    if len(l) % 2 != 0:\n        # return sl[l.count / 2]\n        return sl[len(l) // 2]\n    # } else {\n    else:\n        # return (sl[l.count / 2] + sl[l.count / 2 - 1]) / 2\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt == String(txt.reversed())\n    return txt == txt[::-1]\n",
            "def modp(n: int, p: int) -> int:\n    # var ret = 1\n    ret = 1\n    # for _ in 0..<n {\n    for _ in range(n):\n        # ret = (ret * 2) % p\n        ret = (ret * 2) % p\n    # return ret\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # let result = s.unicodeScalars.map { Character(UnicodeScalar(($0.value - 97 + 5) % 26 + 97)!) }\n    result = [chr((ord(c) - 97 + 5) % 26 + 97) for c in s]\n    # return String(result)\n    return ''.join(result)\ndef decode_shift(s: str) -> str:\n    # let result = s.unicodeScalars.map { Character(UnicodeScalar(($0.value - 97 + 21) % 26 + 97)!) }\n    result = [chr((ord(c) - 97 + 21) % 26 + 97) for c in s]\n    # return String(result)\n    return ''.join(result)\n",
            "def remove_vowels(txt: str) -> str:\n    # let vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # return String(txt.filter { !vowels.contains($0) })\n    return ''.join(filter(lambda x: x not in vowels, txt))\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # return l.allSatisfy { $0 < t }\n    return all(e < t for e in l)\n",
            "def add(x: int, y: int) -> int:\n    # return x + y\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # return Set(s0) == Set(s1)\n    return set(s0) == set(s1)\n",
            "def fib(n: int) -> int:\n    # if n <= 1 {\n    if n <= 1:\n        # return n\n        return n\n    # } else {\n    else:\n        # return fib(n - 1) + fib(n - 2)\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # var depth = 0\n    depth = 0\n    # for b in brackets {\n    for b in brackets:\n        # if b == \"<\" {\n        if b == \"<\":\n            # depth += 1\n            depth += 1\n        # } else if b == \">\" {\n        elif b == \">\":\n            # depth -= 1\n            depth -= 1\n        # }\n        # if depth < 0 {\n        if depth < 0:\n            # return false\n            return False\n    # return depth == 0\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # let diff = zip(l, l.dropFirst()).map { $1 - $0 }\n    diff = [b - a for a, b in zip(l, l[1:])]\n    # return diff.allSatisfy { $0 <= 0 } || diff.allSatisfy { $0 >= 0 }\n    return all(d <= 0 for d in diff) or all(d >= 0 for d in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # return Array(Set(l1).intersection(Set(l2))).sorted()\n    return sorted(list(set(l1).intersection(set(l2))))\n",
            "def largest_prime_factor(n: int) -> int:\n    # var n = n\n    # var i = 2\n    i = 2\n    # while i * i <= n {\n    while i * i <= n:\n        # if n % i != 0 {\n        if n % i != 0:\n            # i += 1\n            i += 1\n        # else {\n        else:\n            # n /= i\n            n //= i\n    # return n\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # return (0...n).reduce(0, +)\n    return sum(range(0, n + 1))\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # var depth = 0\n    depth = 0\n    # for b in brackets {\n    for b in brackets:\n        # if b == \"(\" {\n        if b == \"(\":\n            # depth += 1\n            depth += 1\n        # } else if b == \")\" {\n        elif b == \")\":\n            # depth -= 1\n            depth -= 1\n        # if depth < 0 {\n        if depth < 0:\n            # return false\n            return False\n    # return depth == 0\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # return xs.enumerated().dropFirst().map { $0 * $1 }\n    return [x * y for x, y in enumerate(xs, 1)]\n",
            "def fibfib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return 0;\n        return 0\n    # var a = 0, b = 0, c = 1;\n    a = 0\n    b = 0\n    c = 1\n    # var n = n;\n    n = n\n    # while (n > 2) {\n    while n > 2:\n        # (a, b, c) = (b, c, a + b + c);\n        a, b, c = b, c, a + b + c\n        # n -= 1;\n        n -= 1\n    # return c;\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # var vowels = \"aeiou\"\n    vowels = \"aeiou\"\n    # var cnt = 0\n    cnt = 0\n    # for i in 0..<s.count {\n    for i in range(len(s)):\n        # let c = s[s.index(s.startIndex, offsetBy: i)]\n        c = s[i]\n        # if vowels.contains(c.lowercased()) || (i == s.count - 1 && c.lowercased() == \"y\") {\n        if c.lower() in vowels or (i == len(s) - 1 and c.lower() == \"y\"):\n            # cnt += 1\n            cnt += 1\n    # return cnt\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # let xStr = String(x)\n    x_str = str(x)\n    # if shift > xStr.count {\n    if shift > len(x_str):\n        # return String(xStr.reversed())\n        return str(x_str[::-1])\n    # } else {\n    #     return String(xStr.suffix(shift)) + String(xStr.prefix(xStr.count - shift))\n    # }\n    return x_str[shift:] + x_str[:-shift]\n",
            "def digit_sum(s: str) -> int:\n    # return s.filter { $0.isUppercase }.map { Int($0.asciiValue!) }.reduce(0, +)\n    return sum(map(int, filter(lambda x: x.isupper(), s)))\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # let words = s.split(separator: \" \")\n    words = s.split(\" \")\n    # let apples = Int(words[words.firstIndex(of: \"apples\")! - 1])!\n    apples = int(words[words.index(\"apples\") - 1])\n    # let oranges = Int(words[words.firstIndex(of: \"oranges\")! - 1])!\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # return n - apples - oranges\n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # let evens = arr.filter { $0 % 2 == 0 }\n    evens = [e for e in arr if e % 2 == 0]\n    # if evens.count == 0 {\n    if len(evens) == 0:\n        # return []\n        return []\n    # let minEven = evens.min()!\n    min_even = min(evens)\n    # return [minEven, arr.firstIndex(of: minEven)!]\n    return [min_even, arr.index(min_even)]\n",
            "def search(lst: List[int]) -> int:\n    # var freqs = [Int: Int]()\n    freqs = {}\n    # for n in lst {\n    for n in lst:\n        # freqs[n] = (freqs[n] ?? 0) + 1\n        freqs[n] = freqs.get(n, 0) + 1\n    # let good_vals = freqs.filter { $0.value >= $0.key }.map { $0.key }\n    good_vals = [k for k, v in freqs.items() if v >= k]\n    # return good_vals.max() ?? -1\n    return max(good_vals) if good_vals else -1\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # let sl = lst.sorted()\n    sl = sorted(lst)\n    # var result = [Int]()\n    result = []\n    # var left = 0, right = sl.count - 1\n    left = 0\n    right = len(sl) - 1\n    # while left <= right {\n    while left <= right:\n        # result.append(sl[left])\n        result.append(sl[left])\n        left += 1\n        # if left <= right {\n        if left <= right:\n            # result.append(sl[right])\n            result.append(sl[right])\n            right -= 1\n    # return result\n    return result\n",
            "def triangle_area(a: int, b: int, c: int) -> float:\n    # if a + b > c && a + c > b && b + c > a {\n    if a + b > c and a + c > b and b + c > a:\n        # let s = Double(a + b + c) / 2\n        s = (a + b + c) / 2\n        # return sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))\n        return sqrt(s * (s - a) * (s - b) * (s - c))\n    # } else {\n    else:\n        # return -1.0\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if q.count == 0 {\n    if len(q) == 0:\n        # return false\n        return False\n    # let isPalin = (0..<q.count).allSatisfy { q[$0] == q[q.count - $0 - 1] }\n    is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    # let total = q.reduce(0, +)\n    total = sum(q)\n    # return isPalin && total <= w\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # var ans = 0\n    ans = 0\n    # for i in 0..<arr.count / 2 {\n    for i in range(0, len(arr) // 2):\n        # if arr[i] != arr[arr.count - i - 1] {\n        if arr[i] != arr[len(arr) - i - 1]:\n            # ans += 1\n            ans += 1\n    # return ans\n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # let cnt1 = lst1.map { $0.count }.reduce(0, +)\n    cnt1 = sum(map(lambda x: len(x), lst1))\n    # let cnt2 = lst2.map { $0.count }.reduce(0, +)\n    cnt2 = sum(map(lambda x: len(x), lst2))\n    # return cnt1 <= cnt2 ? lst1 : lst2\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return false\n        return False\n    # if 2 <= Int(floor(sqrt(Double(n)))) {\n    if 2 <= int(sqrt(n)):\n        # for i in 2...Int(floor(sqrt(Double(n)))) {\n        for i in range(2, int(sqrt(n)) + 1):\n            # if n % i == 0 {\n            if n % i == 0:\n                # return false\n                return False\n    # return true\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # var cnt = 0\n    cnt = 0\n    # var a = a\n    # if a < 2 {\n    if a < 2:\n        # return false\n        return False\n    # for i in 2...a {\n    for i in range(2, a + 1):\n        # if isPrime(i) {\n        if is_prime(i):\n            # while a % i == 0 {\n            while a % i == 0:\n                # cnt += 1\n                cnt += 1\n                # a /= i\n                a //= i\n    # return cnt == 3\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return x == n\n        return x == n\n    # var tmp = 1\n    tmp = 1\n    # while tmp < x {\n    while tmp < x:\n        # tmp *= n\n        tmp *= n\n    # return tmp == x\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # let a = abs(a)\n    a = abs(a)\n    # let root = Int(round(pow(Double(a), 1.0 / 3.0)))\n    root = int(round(pow(a, 1.0 / 3.0)))\n    # return root * root * root == a\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # return num.filter { \"2357BD\".contains($0) }.count\n    return sum(1 for c in num if c in \"2357BD\")\n",
            "def decimal_to_binary(dec: int) -> str:\n    # let binary = String(dec, radix: 2)\n    binary = bin(dec)\n    # return \"db\\(binary)db\"\n    return \"db\" + binary + \"db\"\n",
            "def is_happy(s: str) -> bool:\n    # if s.count < 3 {\n    if len(s) < 3:\n        # return false\n        return False\n    # for i in 0..<(s.count - 2) {\n    for i in range(0, len(s) - 2):\n        # if s[s.index(s.startIndex, offsetBy: i)] == s[s.index(s.startIndex, offsetBy: i+1)] || s[s.index(s.startIndex, offsetBy: i)] == s[s.index(s.startIndex, offsetBy: i+2)] || s[s.index(s.startIndex, offsetBy: i+1)] == s[s.index(s.startIndex, offsetBy: i+2)] {\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            # return false\n            return False\n    # return true\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # var result = [String]()\n    result = []\n    # for g in grades {\n    for g in grades:\n        # switch () {\n        # case _ where g == 4.0:\n        if g == 4.0:\n            # result.append(\"A+\")\n            result.append(\"A+\")\n        # case _ where g > 3.7:\n        elif g > 3.7:\n            # result.append(\"A\")\n            result.append(\"A\")\n        # case _ where g > 3.3:\n        elif g > 3.3:\n            # result.append(\"A-\")\n            result.append(\"A-\")\n        # case _ where g > 3.0:\n        elif g > 3.0:\n            # result.append(\"B+\")\n            result.append(\"B+\")\n        # case _ where g > 2.7:\n        elif g > 2.7:\n            # result.append(\"B\")\n            result.append(\"B\")\n        # case _ where g > 2.3:\n        elif g > 2.3:\n            # result.append(\"B-\")\n            result.append(\"B-\")\n        # case _ where g > 2.0:\n        elif g > 2.0:\n            # result.append(\"C+\")\n            result.append(\"C+\")\n        # case _ where g > 1.7:\n        elif g > 1.7:\n            # result.append(\"C\")\n            result.append(\"C\")\n        # case _ where g > 1.3:\n        elif g > 1.3:\n            # result.append(\"C-\")\n            result.append(\"C-\")\n        # case _ where g > 1.0:\n        elif g > 1.0:\n            # result.append(\"D+\")\n            result.append(\"D+\")\n        # case _ where g > 0.7:\n        elif g > 0.7:\n            # result.append(\"D\")\n            result.append(\"D\")\n        # case _ where g > 0.0:\n        elif g > 0.0:\n            # result.append(\"D-\")\n            result.append(\"D-\")\n        # default:\n        else:\n            # result.append(\"E\")\n            result.append(\"E\")\n    # return result\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # let length = s.count\n    length = len(s)\n    # if length < 2 {\n    if length < 2:\n        # return false\n        return False\n    # if 2 <= Int(floor(sqrt(Double(length)))) {\n    if 2 <= int(floor(sqrt(length))):\n        # for i in 2...Int(floor(sqrt(Double(length)))) {\n        for i in range(2, int(floor(sqrt(length)))):\n            # if length % i == 0 {\n            if length % i == 0:\n                # return false\n                return False\n    # return true\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if n == 1 {\n    if n == 1:\n        # return 1\n        return 1\n    # return 2 * 9 * Int(pow(10, Double(n - 2)))\n    return 2 * 9 * int(pow(10, n - 2))\n",
            "def solve(n: int) -> str:\n    # let digitsSum = String(n).map { Int(String($0))! }.reduce(0, +)\n    digits_sum = sum(map(int, str(n)))\n    # return String(digitsSum, radix: 2)\n    return str(digits_sum, 2)\n",
            "def add(lst: List[int]) -> int:\n    # return lst.enumerated().filter { $0.offset % 2 == 1 && $0.element % 2 == 0 }.map { $0.element }.reduce(0, +)\n    return sum(filter(lambda x: x % 2 == 0, map(lambda x: x[1], filter(lambda x: x[0] % 2 == 1, enumerate(lst)))))\n",
            "def anti_shuffle(s: str) -> str:\n    # let words = s.split(separator: \" \").map { String($0.sorted()) }\n    words = [word.sorted() for word in s.split(\" \")]\n    # return words.joined(separator: \" \")\n    return \" \".join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # var coords = [[Int]]()\n    coords = []\n    # for i in 0..<lst.count {\n    for i in range(len(lst)):\n        # for j in 0..<lst[i].count {\n        for j in range(len(lst[i])):\n            # if lst[i][j] == x {\n            if lst[i][j] == x:\n                # coords.append([i, j])\n                coords.append([i, j])\n    # coords.sort { $0[0] == $1[0] ? $1[1] < $0[1] : $0[0] < $1[0] }\n    coords.sort(key=lambda x: x[0] == x[1][0] and x[1][1] < x[1][0] or x[0] < x[1][0])\n    # return coords\n    return coords\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # if arr.count == 0 {\n    if len(arr) == 0:\n        # return []\n        return []\n    # if (arr[0] + arr[arr.count - 1]) % 2 == 0 {\n    if (arr[0] + arr[-1]) % 2 == 0:\n        # return arr.sorted().reversed()\n        return sorted(arr, reverse=True)\n    # else {\n    else:\n        # return arr.sorted()\n        return sorted(arr)\n",
            "def encrypt(s: str) -> str:\n    # var result = \"\"\n    result = \"\"\n    # for ch in s {\n    for ch in s:\n        # var shifted = Int(ch.asciiValue!) + 4\n        shifted = ord(ch) + 4\n        # if shifted > Int(Character(\"z\").asciiValue!) {\n        if shifted > ord(\"z\"):\n            # shifted -= 26\n            shifted -= 26\n        # result += String(UnicodeScalar(shifted)!)\n        result += chr(shifted)\n    # return result\n    return result\n",
            "def next_smallest(lst: List[int]) -> Optional[int]:\n    # let sl = Set(lst).sorted()\n    sl = sorted(set(lst))\n    # if sl.count < 2 {\n    if len(sl) < 2:\n        # return nil\n        return None\n    # return sl[1]\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # let sentences = s.split(separator: #/[.!?]\\s*/#)\n    sentences = re.split(r'[.!?]\\s*', s)\n    # return sentences.filter { $0.count >= 2 && $0.prefix(2) == \"I \" }.count\n    return len([s for s in sentences if len(s) >= 2 and s[:2] == 'I '])\n",
            "def any_int(x: Any, y: Any, z: Any) -> bool:\n    # if let xInt = x as? Int, let yInt = y as? Int, let zInt = z as? Int {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        x_int = x\n        y_int = y\n        z_int = z\n        # if (xInt + yInt == zInt) || (xInt + zInt == yInt) || (yInt + zInt == xInt) {\n        if x_int + y_int == z_int or x_int + z_int == y_int or y_int + z_int == x_int:\n            # return true\n            return True\n    # }\n    # return false\n    return False\n",
            "def encode(message: str) -> str:\n    # let vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # var result = \"\"\n    result = \"\"\n    # for ch in message {\n    for ch in message:\n        # if ch.isLetter {\n        if ch.isalpha():\n            # var ch1 = ch.isLowercase ? Character(ch.uppercased()) : Character(ch.lowercased())\n            ch1 = ch.upper() if ch.islower() else ch.lower()\n            # if vowels.contains(ch1) {\n            if ch1 in vowels:\n                # ch1 = Character(UnicodeScalar(Int(ch1.asciiValue!) + 2)!)\n                ch1 = chr(ord(ch1) + 2)\n            # result.append(ch1)\n            result += ch1\n        # } else {\n        else:\n            # result.append(ch)\n            result += ch\n    # return result\n    return result\n",
            "def is_prime(_n: int) -> bool:\n    # if n < 2 {\n    if _n < 2:\n        # return false\n        return False\n    # if 2 <= Int(floor(sqrt(Double(n)))) {\n    if 2 <= int(sqrt(_n)):\n        # for i in 2...Int(floor(sqrt(Double(n)))) {\n        for i in range(2, int(sqrt(_n)) + 1):\n            # if n % i == 0 {\n            if _n % i == 0:\n                # return false\n                return False\n    # return true\n    return True\ndef skjkasdkd(_lst: List[int]) -> int:\n    # let primes = lst.filter { isPrime($0) }\n    primes = list(filter(is_prime, _lst))\n    # if primes.count == 0 {\n    if len(primes) == 0:\n        # return 0\n        return 0\n    # let largest = String(primes.max()!)\n    largest = str(max(primes))\n    # return largest.reduce(0) { $0 + $1.wholeNumberValue! }\n    return sum(map(int, largest))\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if d.isEmpty {\n    if not d:\n        # return false\n        return False\n    # return d.keys.allSatisfy { $0.allSatisfy { $0.isUppercase } } || d.keys.allSatisfy { $0.allSatisfy { $0.isLowercase } }\n    return all(k.isupper() for k in d.keys()) or all(k.islower() for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # var primes = [Int]()\n    primes = []\n    # if 2 <= n {\n    if 2 <= n:\n        # for num in 2..<n {\n        for num in range(2, n):\n            # if primes.allSatisfy({ num % $0 != 0 }) {\n            if all(num % p != 0 for p in primes):\n                # primes.append(num)\n                primes.append(num)\n    # return primes\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # (abs(a) % 10) * (abs(b) % 10)\n    return abs(a) % 10 * abs(b) % 10\n",
            "def count_upper(s: str) -> int:\n    # let vowels = \"AEIOU\"\n    vowels = \"AEIOU\"\n    # return s.enumerated().filter { $0.offset % 2 == 0 && vowels.contains($0.element) }.count\n    return sum(1 for i, c in enumerate(s) if i % 2 == 0 and c in vowels)\n",
            "def closest_integer(value: str) -> int:\n    # let num = Double(value)!\n    num = float(value)\n    # if num >= 0 {\n    if num >= 0:\n        # return Int(num + 0.5)\n        return int(num + 0.5)\n    # } else {\n    else:\n        # return Int(num - 0.5)\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # return (0..<n).map { i in n + 2 * i }\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # return s.split(separator: #/[, ]/#).filter { $0.count > 0 }.map { String($0) }\n    return list(filter(lambda x: len(x) > 0, s.split(#/[, ]/#)))\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    if x > y:\n        # return -1;\n        return -1\n    # if (y % 2 == 0) {\n    if y % 2 == 0:\n        # return y;\n        return y\n    # return y != x ? y - 1 : -1;\n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> str:\n    # if n > m {\n    if n > m:\n        # return nil\n        return None\n    # let rAvg = Int(Double(n + m) / 2 + 0.5)\n    r_avg = int(float(n + m) / 2 + 0.5)\n    # return String(rAvg, radix: 2)\n    return str(r_avg)\n",
            "def all_digits_odd(_ s: str) -> bool:\n    # return s.allSatisfy { $0.asciiValue! % 2 != 0 }\n    return all(map(lambda x: x.asciiValue() % 2 != 0, s))\ndef unique_digits(_ x: List[int]) -> List[int]:\n    # return x.filter { allDigitsOdd(String($0)) }.sorted()\n    return sorted(filter(lambda x: all_digits_odd(str(x)), x))\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # let digitNames = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # let sortedArr = arr.filter { 1 <= $0 && $0 <= 9 }.sorted(by: >)\n    sorted_arr = list(filter(lambda x: 1 <= x and x <= 9, arr))\n    sorted_arr.sort(reverse=True)\n    # return sortedArr.map { digitNames[$0 - 1] }\n    return list(map(lambda x: digit_names[x - 1], sorted_arr))\n",
            "def f(n: int) -> List[int]:\n    # let nums = Array(1...n)\n    nums = list(range(1, n + 1))\n    # return nums.map { $0 % 2 != 0 ? nums[0..<$0].reduce(0, +) : nums[0..<$0].reduce(1, *) }\n    return [nums[0..<i].__add__().__mul__(1) if i % 2 != 0 else nums[0..<i].__add__().__add__(0) for i in nums]\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == String(s.reversed())\n    return s == s[::-1]\ndef even_odd_palindrome(n: int) -> List[int]:\n    # var cnt = [0, 0]\n    cnt = [0, 0]\n    # for i in 1...n {\n    for i in range(1, n + 1):\n        # if isPalindrome(String(i)) {\n        if is_palindrome(str(i)):\n            # cnt[i % 2] += 1\n            cnt[i % 2] += 1\n    # return cnt\n    return cnt\n",
            "def digits_sum(_ n: int) -> int:\n    # let nStr = String(n)\n    n_str = str(n)\n    # if n >= 0 {\n    if n >= 0:\n        # return nStr.map { Int(String($0))! }.reduce(0, +)\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return Int(nStr.prefix(2))! * 2 + digitsSum(abs(n))\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# func countNums(_ arr: [Int]) -> Int {\ndef count_nums(arr: List[int]) -> int:\n    # return arr.filter { digitsSum($0) > 0 }.count\n    return len(list(filter(lambda x: digits_sum(x) > 0, arr)))\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if arr.isEmpty {\n    if not arr:\n        # return true\n        return True\n    # let sortedArr = arr.sorted()\n    sorted_arr = sorted(arr)\n    # for i in 0..<arr.count {\n    for i in range(len(arr)):\n        # if arr[i..<arr.count] == sortedArr[0..<arr.count - i] && arr[0..<i] == sortedArr[arr.count - i..<arr.count] {\n        if arr[i:] == sorted_arr[0:len(arr) - i] and arr[0:i] == sorted_arr[len(arr) - i:]:\n            # return true\n            return True\n    # return false\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # let oddCnt = lst1.filter { $0 % 2 != 0 }.count\n    odd_cnt = len(list(filter(lambda x: x % 2 != 0, lst1)))\n    # let evenCnt = lst2.filter { $0 % 2 == 0 }.count\n    even_cnt = len(list(filter(lambda x: x % 2 == 0, lst2)))\n    # return evenCnt >= oddCnt ? \"YES\" : \"NO\"\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # var freq = [String: Int]()\n    freq = {}\n    # let words = test.split(separator: \" \").map { String($0) }\n    words = test.split()\n    # for w in words {\n    for w in words:\n        # freq[w] = (freq[w] ?? 0) + 1\n        freq[w] = freq.get(w, 0) + 1\n    # var result = [String: Int]()\n    result = {}\n    # if !freq.isEmpty {\n    if freq:\n        # let maxFreq = freq.values.max()!\n        max_freq = max(freq.values())\n        # for (k, v) in freq {\n        for k, v in freq.items():\n            # if v == maxFreq {\n            if v == max_freq:\n                # result[k] = v\n                result[k] = v\n    # }\n    # return result\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s == String(s.reversed())\n    return s == s[::-1]\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # let s1 = s.filter { !c.contains($0) }\n    s1 = ''.join(filter(lambda x: x not in c, s))\n    # return [s1, isPalindrome(s1) ? \"yes\" : \"no\"]\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # var result = [String]()\n    result = []\n    # for num in lst {\n    for num in lst:\n        # let n = num.filter { $0.asciiValue! % 2 == 1 }.count\n        n = sum(1 for c in num if ord(c) % 2 == 1)\n        # let rs = \"the number of odd elements in the string i of the input.\"\n        rs = \"the number of odd elements in the string {} of the input.\".format(n)\n        # result.append(rs.replacingOccurrences(of: \"i\", with: String(n)))\n        result.append(rs.replace(\"i\", str(n)))\n    # return result\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # var minSum = 0\n    min_sum = 0\n    # var curSum = 0\n    cur_sum = 0\n    # for n in nums {\n    for n in nums:\n        # curSum = min(curSum + n, 0)\n        cur_sum = min(cur_sum + n, 0)\n        # minSum = min(curSum, minSum)\n        min_sum = min(cur_sum, min_sum)\n    # if minSum == 0 {\n    if min_sum == 0:\n        # minSum = nums.min()!\n        min_sum = min(nums)\n    # return minSum\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # return grid.map { Int(ceil(Double($0.reduce(0, +)) / Double(capacity))) }.reduce(0, +)\n    return sum(map(lambda x: int(ceil(sum(x) / capacity)), grid))\n",
            "def count_ones(_num: int) -> int:\n    # return String(num, radix: 2).filter { $0 == \"1\" }.count\n    return len(list(filter(lambda x: x == \"1\", str(bin(_num))[2:])))\ndef sort_array(_arr: List[int]) -> List[int]:\n    # return arr.sorted { countOnes($0) == countOnes($1) ? $0 < $1 : countOnes($0) < countOnes($1) }\n    return sorted(_arr, key=lambda x: (count_ones(x), x))\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # let words = s.split(separator: \" \").map { String($0) }.filter { $0.count > 0 }\n    words = [w for w in s.split() if len(w) > 0]\n    # return words.filter { $0.filter { consonants.contains($0.lowercased()) }.count == n }\n    return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # let vowels = \"aeiouAEIOU\"\n    vowels = \"aeiouAEIOU\"\n    # for i in stride(from: word.count - 2, through: 1, by: -1) {\n    for i in range(word.count - 2, 1, -1):\n        # let index = word.index(word.startIndex, offsetBy: i)\n        index = word.index(word.startIndex, offsetBy: i)\n        # if vowels.contains(word[index]) && !vowels.contains(word[word.index(before: index)]) && !vowels.contains(word[word.index(after: index)]) {\n        if word[index] in vowels and word[word.index(before: index)] not in vowels and word[word.index(after: index)] not in vowels:\n            # return String(word[index])\n            return word[index]\n    # return \"\"\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # var depth = 0\n    depth = 0\n    # for ch in s {\n    for ch in s:\n        # if ch == \"(\" {\n        if ch == \"(\":\n            # depth += 1\n            depth += 1\n        # } else {\n        else:\n            # depth -= 1\n            depth -= 1\n        # if depth < 0 {\n        if depth < 0:\n            # return false\n            return False\n    # return depth == 0 ? true : false\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # let s1 = lst[0] + lst[1]\n    s1 = lst[0] + lst[1]\n    # let s2 = lst[1] + lst[0]\n    s2 = lst[1] + lst[0]\n    # return check(s1) || check(s2) ? \"Yes\" : \"No\"\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if k == 0 {\n    if k == 0:\n        # return []\n        return []\n    # return arr.sorted().suffix(k)\n    return sorted(arr)[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # return lst.enumerated().filter { $0.offset % 2 == 0 && $0.element % 2 != 0 }.map { $0.element }.reduce(0, +)\n    return sum(filter(lambda x: x % 2 != 0, map(lambda x: x[1], filter(lambda x: x[0] % 2 == 0, enumerate(lst)))))\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # return arr.prefix(k).filter { String($0).count <= 2 }.reduce(0, +)\n    return sum(filter(lambda x: len(str(x)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # var collatz = [1]\n    collatz = [1]\n    # var n = n\n    # while n != 1 {\n    while n != 1:\n        # if n % 2 != 0 {\n        if n % 2 != 0:\n            # collatz.append(n)\n            collatz.append(n)\n            # n = 3 * n + 1\n            n = 3 * n + 1\n        # else {\n        else:\n            # n = n / 2\n            n = n / 2\n    # return collatz.sorted()\n    return sorted(collatz)\n",
            "def valid_date(date: str) -> bool:\n    # if date.count != 10 || date[date.index(date.startIndex, offsetBy: 2)] != \"-\" || date[date.index(date.startIndex, offsetBy: 5)] != \"-\" {\n    if len(date) != 10 or date[2] != \"-\" or date[5] != \"-\":\n        return False\n    # let m = Int(date.prefix(2))!\n    m = int(date[:2])\n    # let d = Int(date[date.index(date.startIndex, offsetBy: 3)..<date.index(date.startIndex, offsetBy: 5)])!\n    d = int(date[3:5])\n    # if [1, 3, 5, 7, 8, 10, 12].contains(m) && d >= 1 && d <= 31 {\n    if m in [1, 3, 5, 7, 8, 10, 12] and 1 <= d <= 31:\n        return True\n    # if [4, 6, 9, 11].contains(m) && d >= 1 && d <= 30 {\n    if m in [4, 6, 9, 11] and 1 <= d <= 30:\n        return True\n    # if m == 2 && d >= 1 && d <= 29 {\n    if m == 2 and 1 <= d <= 29:\n        return True\n    # return false\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if txt.contains(\" \") {\n    if \" \" in txt:\n        # return txt.components(separatedBy: \" \")\n        return txt.split(\" \")\n    # } else if txt.contains(\",\") {\n    elif \",\" in txt:\n        # return txt.components(separatedBy: \",\")\n        return txt.split(\",\")\n    # } else {\n    else:\n        # return [String(txt.filter { $0.isLowercase && $0.asciiValue! % 2 == 0 }.count)]\n        return [str(len(list(filter(lambda x: x.islower() and ord(x) % 2 == 0, txt))))]\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if !zip(lst, lst.dropFirst()).allSatisfy({ $0 <= $1 }) {\n    if not all(x <= y for x, y in zip(lst, lst[1:])):\n        # return false\n        return False\n    # var freq = [Int: Int]()\n    freq = {}\n    # for i in lst {\n    for i in lst:\n        # freq[i] = (freq[i] ?? 0) + 1\n        freq[i] = freq.get(i, 0) + 1\n    # return freq.values.max() ?? 0 <= 2\n    return max(freq.values()) <= 2\n",
            "def is_prime(_n: int) -> bool:\n    # if n < 2 {\n    if _n < 2:\n        # return false\n        return False\n    # if 2 <= Int(floor(sqrt(Double(n)))) {\n    if 2 <= int(floor(sqrt(float(_n)))):\n        # for i in 2...Int(floor(sqrt(Double(n)))) {\n        for i in range(2, int(floor(sqrt(float(_n)))) + 1):\n            # if n % i == 0 {\n            if _n % i == 0:\n                # return false\n                return False\n    # return true\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # let l = max(interval1[0], interval2[0])\n    l = max(interval1[0], interval2[0])\n    # let r = min(interval1[1], interval2[1])\n    r = min(interval1[1], interval2[1])\n    # let length = r - l\n    length = r - l\n    # return length > 0 && isPrime(length) ? \"YES\" : \"NO\"\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if arr.isEmpty {\n    if not arr:\n        # return nil\n        return None\n    # if arr.contains(0) {\n    if 0 in arr:\n        # return 0\n        return 0\n    # let sign = arr.filter { $0 < 0 }.count % 2 == 1 ? -1 : 1\n    sign = -1 if arr.count(lambda x: x < 0) % 2 == 1 else 1\n    # return sign * arr.map(abs).reduce(0, +)\n    return sign * sum(map(abs, arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # let n = grid.count\n    n = len(grid)\n    # var minVal = n * n + 1\n    min_val = n * n + 1\n    # for i in 0..<n {\n    for i in range(n):\n        # for j in 0..<n {\n        for j in range(n):\n            # if grid[i][j] == 1 {\n            if grid[i][j] == 1:\n                # var temp = [Int]()\n                temp = []\n                # if i != 0 {\n                if i != 0:\n                    # temp.append(grid[i - 1][j])\n                    temp.append(grid[i - 1][j])\n                # if j != 0 {\n                if j != 0:\n                    # temp.append(grid[i][j - 1])\n                    temp.append(grid[i][j - 1])\n                # if i != n - 1 {\n                if i != n - 1:\n                    # temp.append(grid[i + 1][j])\n                    temp.append(grid[i + 1][j])\n                # if j != n - 1 {\n                if j != n - 1:\n                    # temp.append(grid[i][j + 1])\n                    temp.append(grid[i][j + 1])\n                # minVal = temp.min()!\n                min_val = min(temp)\n    # var result = [Int]()\n    result = []\n    # for i in 0..<k {\n    for i in range(k):\n        # result.append(i % 2 == 0 ? 1 : minVal)\n        result.append(1 if i % 2 == 0 else min_val)\n    # return result\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if n == 0 {\n    if n == 0:\n        # return [1]\n        return [1]\n    # var seq = [1, 3]\n    seq = [1, 3]\n    # if 2 <= n {\n    if 2 <= n:\n        # for i in 2...n {\n        for i in range(2, n + 1):\n            # if i % 2 == 0 {\n            if i % 2 == 0:\n                # seq.append(i / 2 + 1)\n                seq.append(i // 2 + 1)\n            # } else {\n            else:\n                # seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n                seq.append(seq[i - 1] + seq[i - 2] + (i + 3) // 2)\n    # return seq\n    return seq\n",
            "def digits(n: int) -> int:\n    # let odds = String(n).filter { Int(String($0))! % 2 == 1 }.map { Int(String($0))! }\n    odds = list(filter(lambda x: int(str(x)) % 2 == 1, str(n)))\n    # return odds.isEmpty ? 0 : odds.reduce(1, *)\n    return 0 if len(odds) == 0 else reduce(lambda x, y: x * y, odds)\n",
            "def is_nested(s: str) -> bool:\n    # var openIdx = [Int]()\n    open_idx = []\n    # var closeIdx = [Int]()\n    close_idx = []\n    # for (i, ch) in s.enumerated() {\n    for i, ch in enumerate(s):\n        # switch (ch) {\n        #     case \"[\":\n        if ch == \"[\":\n            # openIdx.append(i)\n            open_idx.append(i)\n        #     case \"]\":\n        elif ch == \"]\":\n            # closeIdx.append(i)\n            close_idx.append(i)\n        #     default:\n        #         break\n        # }\n    # }\n    # closeIdx.reverse()\n    close_idx.reverse()\n    # var cnt = 0\n    cnt = 0\n    # var i = 0\n    i = 0\n    # let l = closeIdx.count\n    l = len(close_idx)\n    # for idx in openIdx {\n    for idx in open_idx:\n        # if i < l && idx < closeIdx[i] {\n        if i < l and idx < close_idx[i]:\n            # cnt += 1\n            cnt += 1\n            # i += 1\n            i += 1\n    # }\n    # return cnt >= 2\n    return cnt >= 2\n",
            "def sum_squares(lst: List[float]) -> int:\n    # return lst.map { Int(ceil($0)) * Int(ceil($0)) }.reduce(0, +)\n    return sum([int(ceil(e)) * int(ceil(e)) for e in lst])\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if txt.isEmpty {\n    if not txt:\n        # return false\n        return False\n    # let last = txt[(txt.lastIndex(of: \" \").map { txt.index(after: $0) } ?? txt.startIndex)...]\n    last = txt[(txt.rfind(\" \") + 1 if txt.rfind(\" \") != -1 else 0):]\n    # return last.count == 1 && last.first!.isLetter\n    return len(last) == 1 and last[0].isalpha()\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if arr.count <= 1 {\n    if len(arr) <= 1:\n        # return -1\n        return -1\n    # let idx = (1..<arr.count).filter { arr[$0] < arr[$0 - 1] }\n    idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    # return idx.max() ?? -1\n    return max(idx) if idx else -1\n",
            "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    # let neg = lst.filter { $0 < 0 }\n    neg = [e for e in lst if e < 0]\n    # let pos = lst.filter { $0 > 0 }\n    pos = [e for e in lst if e > 0]\n    # let maxNeg = neg.max()\n    max_neg = max(neg) if neg else None\n    # let minPos = pos.min()\n    min_pos = min(pos) if pos else None\n    # return [maxNeg, minPos]\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if let oStr = o as? String {\n    if isinstance(o, str):\n        # return Double(oStr.replacingOccurrences(of: \",\", with: \".\"))!\n        return float(o.replace(\",\", \".\"))\n    # } else if let oInt = o as? Int {\n    elif isinstance(o, int):\n        # return Double(oInt)\n        return float(o)\n    # } else if let oFloat = o as? Double {\n    elif isinstance(o, float):\n        # return oFloat\n        return o\n    # }\n    # fatalError(\"Type Error\")\n    raise TypeError(\"Type Error\")\ndef compare_one(a: Any, b: Any) -> Optional[float]:\n    # let a1 = anyToReal(a)\n    a1 = any_to_real(a)\n    # let b1 = anyToReal(b)\n    b1 = any_to_real(b)\n    # if a1 == b1 {\n    if a1 == b1:\n        # return nil\n        return None\n    # } else if a1 > b1 {\n    elif a1 > b1:\n        # return a1\n        return a1\n    # } else {\n    else:\n        # return b1\n        return b1\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return n % 2 == 0 && n >= 8\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # var fact = 1\n    fact = 1\n    # var result = 1\n    result = 1\n    # for i in 1...n {\n    for i in range(1, n + 1):\n        # fact *= i\n        fact *= i\n        # result *= fact\n        result *= fact\n    # return result\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return txt.replacing(#/\\s{3,}/#, with: \"-\").replacingOccurrences(of: \" \", with: \"_\")\n    return txt.replace(r'\\s{3,}', '-').replace(' ', '_')\n",
            "def file_name_check(file_name: str) -> str:\n    # let suf = [\"txt\", \"exe\", \"dll\"]\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # let lst = fileName.split(separator: \".\", omittingEmptySubsequences: false)\n    lst = file_name.split(\".\", maxsplit=1)\n    # if lst.count != 2 || !suf.contains(String(lst[1])) || lst[0].count == 0 || !lst[0].first!.isLetter || lst[0].filter({ $0.isNumber }).count > 3 {\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or lst[0][0].isdigit() or lst[0].isdigit():\n        # return \"No\"\n        return \"No\"\n    # return \"Yes\"\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # var result = 0\n    result = 0\n    # for i in 0..<lst.count {\n    for i in range(len(lst)):\n        # if i % 3 == 0 {\n        if i % 3 == 0:\n            # result += Int(pow(Double(lst[i]), 2))\n            result += int(pow(lst[i], 2))\n        # } else if i % 4 == 0 {\n        elif i % 4 == 0:\n            # result += Int(pow(Double(lst[i]), 3))\n            result += int(pow(lst[i], 3))\n        # } else {\n        else:\n            # result += lst[i]\n            result += lst[i]\n    # return result\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if n < 2 {\n    if n < 2:\n        # return false\n        return False\n    # if 2 <= Int(floor(sqrt(Double(n)))) {\n    if 2 <= int(sqrt(n)):\n        # for i in 2...Int(floor(sqrt(Double(n)))) {\n        for i in range(2, int(sqrt(n)) + 1):\n            # if n % i == 0 {\n            if n % i == 0:\n                # return false\n                return False\n    # return true\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # let words = sentence.split(separator: \" \")\n    words = sentence.split(\" \")\n    # return words.filter { isPrime($0.count) }.joined(separator: \" \")\n    return \" \".join(filter(lambda w: is_prime(len(w)), words))\n",
            "def simplify(x: str, n: str) -> bool:\n    # let xs = x.split(separator: \"/\")\n    xs = x.split(\"/\")\n    # let ns = n.split(separator: \"/\")\n    ns = n.split(\"/\")\n    # let num = Int(xs[0])! * Int(ns[0])!\n    num = int(xs[0]) * int(ns[0])\n    # let den = Int(xs[1])! * Int(ns[1])!\n    den = int(xs[1]) * int(ns[1])\n    # return num % den == 0\n    return num % den == 0\n",
            "def digits_sum(_ n: int) -> int:\n    # let nStr = String(n)\n    n_str = str(n)\n    # if n >= 0 {\n    if n >= 0:\n        # return nStr.map { Int(String($0))! }.reduce(0, +)\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return Int(nStr.prefix(2))! * 2 + digitsSum(abs(n))\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# func orderByPoints(_ nums: [Int]) -> [Int] {\ndef order_by_points(nums: List[int]) -> List[int]:\n    # return nums.sorted { digitsSum($0) < digitsSum($1) }\n    return sorted(nums, key=digits_sum)\n",
            "def special_filter(nums: List[int]) -> int:\n    # let odds = \"13579\"\n    odds = \"13579\"\n    # return nums.filter { $0 > 10 && $0 % 2 == 1 }.filter { odds.contains(String(String($0).first!)) }.count\n    return len([n for n in nums if n > 10 and n % 2 == 1 and str(n)[0] in odds])\n",
            "def get_max_triples(n: int) -> int:\n    # var c = [0, 0, 0]\n    c = [0, 0, 0]\n    # for i in 1...n {\n    for i in range(1, n + 1):\n        # let a = i * i - i + 1\n        a = i * i - i + 1\n        # c[a % 3] += 1\n        c[a % 3] += 1\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # let names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if !names.contains(planet1) || !names.contains(planet2) {\n    if planet1 not in names or planet2 not in names:\n        # return []\n        return []\n    # var l = names.firstIndex(of: planet1)!\n    l = names.index(planet1)\n    # var r = names.firstIndex(of: planet2)!\n    r = names.index(planet2)\n    # if l > r {\n    if l > r:\n        # (l, r) = (r, l)\n        l, r = r, l\n    # if l == r {\n    if l == r:\n        # return []\n        return []\n    # return Array(names[l + 1 ..< r])\n    return names[l + 1 : r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # let result = lst.filter { $0.count % 2 == 0 }\n    result = [e for e in lst if len(e) % 2 == 0]\n    # return result.sorted { $0.count < $1.count || $0 < $1 }\n    return sorted(result, key=lambda e: (len(e), e))\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if n < 2 {\n    if n < 2:\n        # return y\n        return y\n    # if 2 <= Int(floor(sqrt(Double(n)))) {\n    if 2 <= int(n ** 0.5):\n        # for i in 2...Int(floor(sqrt(Double(n)))) {\n        for i in range(2, int(n ** 0.5) + 1):\n            # if n % i == 0 {\n            if n % i == 0:\n                # return y\n                return y\n    # return x\n    return x\n",
            "def double_the_difference(lst: List[float]) -> int:\n    # return lst.filter { $0 >= 0 && $0.truncatingRemainder(dividingBy: 2) == 1 }.map { Int($0 * $0) }.reduce(0, +)\n    return sum(map(lambda x: int(x * x), filter(lambda x: x >= 0 and x % 2 == 1, lst)))\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # return zip(game, guess).map { abs($0 - $1) }\n    return [abs(g - g2) for g, g2 in zip(game, guess)]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # var maxS = Int.min\n    max_s = -1\n    # var maxExt = \"\"\n    max_ext = \"\"\n    # for ext in extensions {\n    for ext in extensions:\n        # let upper = ext.filter { $0.isUppercase }.count\n        upper = sum(1 for c in ext if c.isupper())\n        # let lower = ext.filter { $0.isLowercase }.count\n        lower = sum(1 for c in ext if c.islower())\n        # let s = upper - lower\n        s = upper - lower\n        # if s > maxS {\n        if s > max_s:\n            # maxS = s\n            max_s = s\n            # maxExt = ext\n            max_ext = ext\n    # return \"\\(className).\\(maxExt)\"\n    return f\"{class_name}.{max_ext}\"\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if a.count < b.count {\n    if len(a) < len(b):\n        # return false\n        return False\n    # for i in 0..<b.count {\n    for i in range(len(b)):\n        # if a.contains(b.suffix(b.count - i) + b.prefix(i)) {\n        if b.suffix(len(b) - i) + b.prefix(i) in a:\n            # return true\n            return True\n    # return false\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # let ds = String(abs(num))\n    ds = str(abs(num))\n    # let even = ds.filter { Int(String($0))! % 2 == 0 }.count\n    even = len([c for c in ds if int(c) % 2 == 0])\n    # return [even, ds.count - even]\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1]\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1]\n    # let numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    # var res = \"\"\n    res = \"\"\n    # var num = num\n    num = num\n    # for i in 0..<values.count {\n    for i in range(len(values)):\n        # while num >= values[i] {\n        while num >= values[i]:\n            # res += numerals[i]\n            res += numerals[i]\n            # num -= values[i]\n            num -= values[i]\n    # return res\n    return res\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # var s = [a, b, c].sorted()\n    s = sorted([a, b, c])\n    # return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # var maxCnt = 0\n    max_cnt = 0\n    # var maxW = \"\"\n    max_w = \"\"\n    # for w in words {\n    for w in words:\n        # let cnt = Set(w).count\n        cnt = len(set(w))\n        # if cnt > maxCnt {\n        if cnt > max_cnt:\n            # maxCnt = cnt\n            max_cnt = cnt\n            # maxW = w\n            max_w = w\n        # else if cnt == maxCnt {\n        elif cnt == max_cnt:\n            # maxW = min(maxW, w)\n            max_w = min(max_w, w)\n    # return maxW\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if need <= remaining {\n    if need <= remaining:\n        # return [num + need, remaining - need]\n        return [num + need, remaining - need]\n    # } else {\n    else:\n        # return [num + remaining, 0]\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # var ops = operators\n    ops = operators\n    # var nums = operands\n    nums = operands\n    # var i = ops.count - 1\n    i = len(ops) - 1\n    # while i >= 0 {\n    while i >= 0:\n        # if ops[i] == \"**\" {\n        if ops[i] == \"**\":\n            # nums[i] = Int(pow(Double(nums[i]), Double(nums[i + 1])))\n            nums[i] = int(pow(float(nums[i]), float(nums[i + 1])))\n            # nums.remove(at: i + 1)\n            del nums[i + 1]\n            # ops.remove(at: i)\n            del ops[i]\n        # }\n        i -= 1\n    # i = 0\n    i = 0\n    # while i < ops.count {\n    while i < len(ops):\n        # if ops[i] == \"*\" {\n        if ops[i] == \"*\":\n            # nums[i] = nums[i] * nums[i + 1]\n            nums[i] = nums[i] * nums[i + 1]\n            # nums.remove(at: i + 1)\n            del nums[i + 1]\n            # ops.remove(at: i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # } else if ops[i] == \"//\" {\n        elif ops[i] == \"//\":\n            # nums[i] = nums[i] / nums[i + 1]\n            nums[i] = nums[i] / nums[i + 1]\n            # nums.remove(at: i + 1)\n            del nums[i + 1]\n            # ops.remove(at: i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # }\n        i += 1\n    # i = 0\n    i = 0\n    # while i < ops.count {\n    while i < len(ops):\n        # if ops[i] == \"+\" {\n        if ops[i] == \"+\":\n            # nums[i] = nums[i] + nums[i + 1]\n            nums[i] = nums[i] + nums[i + 1]\n            # nums.remove(at: i + 1)\n            del nums[i + 1]\n            # ops.remove(at: i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # } else if ops[i] == \"-\" {\n        elif ops[i] == \"-\":\n            # nums[i] = nums[i] - nums[i + 1]\n            nums[i] = nums[i] - nums[i + 1]\n            # nums.remove(at: i + 1)\n            del nums[i + 1]\n            # ops.remove(at: i)\n            del ops[i]\n            # i -= 1\n            i -= 1\n        # }\n        i += 1\n    # return nums[0]\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if !s.contains(where: { $0.isLetter }) {\n    if not any(ch.isalpha() for ch in s):\n        # return String(s.reversed())\n        return ''.join(reversed(s))\n    # var result = \"\"\n    result = ''\n    # for ch in s {\n    for ch in s:\n        # if !ch.isLetter {\n        if not ch.isalpha():\n            # result.append(ch)\n            result += ch\n        # } else if ch.isUppercase {\n        elif ch.isupper():\n            # result.append(ch.lowercased())\n            result += ch.lower()\n        # } else if ch.isLowercase {\n        elif ch.islower():\n            # result.append(ch.uppercased())\n            result += ch.upper()\n    # return result\n    return result\n",
            "def string_to_md5(txt: str) -> Optional[str]:\n    # if txt.isEmpty {\n    if not txt:\n        # return nil\n        return None\n    # let txtBytes = Data(txt.utf8)\n    txt_bytes = txt.encode('utf-8')\n    # let md5Encoded = txtBytes.md5().map { String(format: \"%02hhx\", $0) }.joined()\n    md5_encoded = hashlib.md5(txt_bytes).hexdigest()\n    # return md5Encoded\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # let lower = max(2, min(a, b))\n    lower = max(2, min(a, b))\n    # let upper = min(8, max(a, b))\n    upper = min(8, max(a, b))\n    # if lower > upper {\n    if lower > upper:\n        # return []\n        return []\n    # return  Array(lower...upper).filter { $0 % 2 == 0 }\n    return  list(range(lower, upper + 1)).filter(lambda x: x % 2 == 0)\n"
        ]
    },
    "typescript": {
        "python": [
            "def has_close_elements(numbers: List[int], threshold: int) -> bool:\n    # for (let i = 0; i < numbers.length; i++) {\n    for i in range(len(numbers)):\n        # for (let j = i + 1; j < numbers.length; j++) {\n        for j in range(i + 1, len(numbers)):\n            # if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n            if abs(numbers[i] - numbers[j]) < threshold:\n                # return true;\n                return True\n    # return false;\n    return False\n",
            "def separate_paren_groups(paren_string: str) -> List[str]:\n    # const groups: Array<string> = [];\n    groups = []\n    # const stk: Array<string> = [];\n    stk = []\n    # let currentGroup: string = \"\";\n    current_group = \"\"\n    # const parens : string = parenString.replace(\" \", \"\");\n    parens = paren_string.replace(\" \", \"\")\n    # for (const ch of parens) {\n    for ch in parens:\n        # if (ch === \"(\") {\n        if ch == \"(\":\n            # stk.push(ch);\n            stk.append(ch)\n            # currentGroup += ch;\n            current_group += ch\n        # } else if (ch === \")\") {\n        elif ch == \")\":\n            # stk.pop();\n            stk.pop()\n            # currentGroup += ch;\n            current_group += ch\n            # if (stk.length === 0) {\n            if len(stk) == 0:\n                # groups.push(currentGroup);\n                groups.append(current_group)\n                # currentGroup = \"\";\n                current_group = \"\"\n    # return groups;\n    return groups\n",
            "def truncate_number(num: float) -> float:\n    # return num - Math.floor(num);\n    return num - math.floor(num)\n",
            "def below_zero(operations: List[int]) -> bool:\n    # let balance = 0;\n    balance = 0\n    # for (const op of operations) {\n    for op in operations:\n        # balance += op;\n        balance += op\n        # if (balance < 0) {\n        if balance < 0:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def mean_absolute_deviation(numbers: List[int]) -> float:\n    # const mean: number = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;\n    mean = sum(numbers) / len(numbers)\n    # const deviation: number = numbers.map(num => Math.abs(num - mean)).reduce((sum, num) => sum + num, 0);\n    deviation = sum(map(lambda num: abs(num - mean), numbers))\n    # return deviation / numbers.length;\n    return deviation / len(numbers)\n",
            "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    # const result: Array<number> = [];\n    result = []\n    # for (let i = 0; i < numbers.length; i++) {\n    for i in range(len(numbers)):\n        # if (i !== 0) {\n        if i != 0:\n            # result.push(delimiter);\n            result.append(delimiter)\n        # result.push(numbers[i]);\n        result.append(numbers[i])\n    # return result;\n    return result\n",
            "def parse_nested_parens(paren_string: str) -> List[int]:\n    # const result: Array<number> = [];\n    result = []\n    # const groups: Array<string> = parenString.split(\" \").filter((s) => s.length > 0);\n    groups = paren_string.split(\" \").filter(lambda s: len(s) > 0)\n    # for (const group of groups) {\n    for group in groups:\n        # let maxDepth = 0;\n        max_depth = 0\n        # let depth = 0;\n        depth = 0\n        # for (const ch of group) {\n        for ch in group:\n            # if (ch === \"(\") {\n            if ch == \"(\":\n                # depth += 1;\n                depth += 1\n                # maxDepth = Math.max(maxDepth, depth);\n                max_depth = max(max_depth, depth)\n            # } else if (ch === \")\") {\n            elif ch == \")\":\n                # depth -= 1;\n                depth -= 1\n        # result.push(maxDepth);\n        result.append(max_depth)\n    # return result;\n    return result\n",
            "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    # return strs.filter(s => s.includes(substring));\n    return list(filter(lambda s: substring in s, strs))\n",
            "def sum_product(numbers: List[int]) -> List[int]:\n    # let nSum = numbers.reduce((a, b) => a + b, 0);\n    n_sum = sum(numbers)\n    # let nProduct = numbers.reduce((a, b) => a * b, 1);\n    n_product = 1\n    for n in numbers:\n        n_product *= n\n    # return [nSum, nProduct];\n    return [n_sum, n_product]\n",
            "def rolling_max(numbers: List[int]) -> List[int]:\n    # let maxSoFar: number = Number.NEGATIVE_INFINITY;\n    max_so_far = float('-inf')\n    # const result: Array<number> = [];\n    result = []\n    # for (const num of numbers) {\n    for num in numbers:\n        # maxSoFar = Math.max(maxSoFar, num);\n        max_so_far = max(max_so_far, num)\n        # result.push(maxSoFar);\n        result.append(max_so_far)\n    # return result;\n    return result\n",
            "def is_palindrome(s: str) -> bool:\n    # return s === s.split('').reverse().join('');\n    return s == ''.join(reversed(s.split('')))\ndef make_palindrome(s: str) -> str:\n    # if (isPalindrome(s)) {\n    if is_palindrome(s):\n        # return s;\n        return s\n    # for (let i = 0; i < s.length; i++) {\n    for i in range(len(s)):\n        # if (isPalindrome(s.slice(i))) {\n        if is_palindrome(s[i:]):\n            # return s + s.slice(0, i).split('').reverse().join('');\n            return s + ''.join(reversed(s[:i].split('')))\n    # return \"\";\n    return \"\"\n",
            "def string_xor(a: str, b: str) -> str:\n    # return a.split('').map((c, i) => c === b[i] ? '0' : '1').join('');\n    return ''.join(['0' if c == b[i] else '1' for i, c in enumerate(a)])\n",
            "def longest(strs: List[str]) -> Optional[str]:\n    # if (!strs.length) {\n    if not strs:\n        # return null;\n        return None\n    # let longestS: string = strs[0];\n    longest_s = strs[0]\n    # for (const s of strs) {\n    for s in strs:\n        # if (s.length > longestS.length) {\n        if len(s) > len(longest_s):\n            # longestS = s;\n            longest_s = s\n    # return longestS;\n    return longest_s\n",
            "def greatest_common_divisor(a: int, b: int) -> int:\n    # if (b === 0) {\n    if b == 0:\n        # return a;\n        return a\n    # else {\n    else:\n        # return greatestCommonDivisor(b, a % b);\n        return greatest_common_divisor(b, a % b)\n",
            "def all_prefixes(s: str) -> List[str]:\n    # const prefixes: Array<string> = [];\n    prefixes = []\n    # for (let i = 0; i < s.length; i++) {\n    for i in range(len(s)):\n        # prefixes.push(s.slice(0, i + 1));\n        prefixes.append(s[:i + 1])\n    # return prefixes;\n    return prefixes\n",
            "def string_sequence(n: int) -> str:\n    # return Array.from({ length: n + 1 }, (_, i) => i).join(\" \");\n    return \" \".join(map(str, range(n + 1)))\n",
            "def count_distinct_characters(s: str) -> int:\n    # return new Set(s.toLowerCase()).size;\n    return len(set(s.lower()))\n",
            "def parse_music(music_string: str) -> List[int]:\n    # const durations: { [key: string]: number } = { \"o\": 4, \"o|\": 2, \".|\": 1 };\n    durations = { \"o\": 4, \"o|\": 2, \".|\": 1 }\n    # const notes: Array<string> = musicString.split(\" \").filter((s) => s.length > 0);\n    notes = music_string.split(\" \").filter(lambda s: len(s) > 0)\n    # return notes.map(note => durations[note]);\n    return list(map(lambda note: durations[note], notes))\n",
            "def how_many_times(s: str, substring: str) -> int:\n    # let times = 0;\n    times = 0\n    # for (let i = 0; i <= s.length - substring.length; i++) {\n    for i in range(s.length - substring.length + 1):\n        # if (s.slice(i, i + substring.length) === substring) {\n        if s[i:i + len(substring)] == substring:\n            # times += 1;\n            times += 1\n    # return times;\n    return times\n",
            "def sort_numbers(numbers: str) -> str:\n    # const numDict: { [key: string]: number } = {\n    num_dict = {\n        # \"zero\": 0,\n        \"zero\": 0,\n        # \"one\": 1,\n        \"one\": 1,\n        # \"two\": 2,\n        \"two\": 2,\n        # \"three\": 3,\n        \"three\": 3,\n        # \"four\": 4,\n        \"four\": 4,\n        # \"five\": 5,\n        \"five\": 5,\n        # \"six\": 6,\n        \"six\": 6,\n        # \"seven\": 7,\n        \"seven\": 7,\n        # \"eight\": 8,\n        \"eight\": 8,\n        # \"nine\": 9,\n        \"nine\": 9,\n    }\n    # const numList: Array<string> = numbers.split(\" \").filter(x => x in numDict);\n    num_list = [x for x in numbers.split(\" \") if x in num_dict]\n    # numList.sort((a, b) => numDict[a] - numDict[b]);\n    num_list.sort(key=lambda x: num_dict[x])\n    # return numList.join(\" \");\n    return \" \".join(num_list)\n",
            "def find_closest_elements(numbers: List[int]) -> List[int]:\n    # const sortedNumbers: Array<number> = [...numbers].sort((a, b) => a - b);\n    sorted_numbers = sorted(numbers)\n    # let minDiff: number = Infinity;\n    min_diff = float('inf')\n    # let closestPair: Array<number> = [];\n    closest_pair = []\n    # for (let i = 1; i < sortedNumbers.length; i++) {\n    for i in range(1, len(sorted_numbers)):\n        # const diff: number = sortedNumbers[i] - sortedNumbers[i - 1];\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        # if (diff < minDiff) {\n        if diff < min_diff:\n            # minDiff = diff;\n            min_diff = diff\n            # closestPair = [sortedNumbers[i - 1], sortedNumbers[i]];\n            closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n    # return closestPair;\n    return closest_pair\n",
            "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    # const minNum: number = Math.min(...numbers);\n    min_num = min(numbers)\n    # const maxNum: number = Math.max(...numbers);\n    max_num = max(numbers)\n    # if (minNum === maxNum) {\n    if min_num == max_num:\n        # return Array(numbers.length).fill(0.0);\n        return [0.0] * len(numbers)\n    # } else {\n    #     return numbers.map(num => (num - minNum) / (maxNum - minNum));\n    # }\n    return [ (num - min_num) / (max_num - min_num) for num in numbers ]\n",
            "def filter_integers(values: List[any]) -> List[int]:\n    # return values.filter((x) => typeof x === 'number' && Number.isInteger(x));\n    return list(filter(lambda x: type(x) == int, values))\n",
            "def str_length(s: str) -> int:\n    # return s.length;\n    return len(s)\n",
            "def largest_divisor(n: int) -> int:\n    # for (let i = 2; i <= n; i++) {\n    for i in range(2, n + 1):\n        # if (n % i == 0) {\n        if n % i == 0:\n            # return n / i;\n            return n / i\n    # return 1;\n    return 1\n",
            "def factorize(n: int) -> List[int]:\n    # const factors: Array<number> = [];\n    factors = []\n    # let divisor = 2;\n    divisor = 2\n    # while (divisor <= n) {\n    while divisor <= n:\n        # if (n % divisor === 0) {\n        if n % divisor == 0:\n            # factors.push(divisor);\n            factors.append(divisor)\n            # n /= divisor;\n            n //= divisor\n        else:\n            # divisor += 1;\n            divisor += 1\n    # return factors;\n    return factors\n",
            "def remove_duplicates(numbers: List[int]) -> List[int]:\n    # const counts: Map<number, number> = new Map();\n    counts = defaultdict(int)\n    # for (const num of numbers) {\n    for num in numbers:\n        # counts.set(num, (counts.get(num) || 0) + 1);\n        counts[num] += 1\n    # const res = numbers.filter(num => counts.get(num) === 1);\n    res = [num for num in numbers if counts[num] == 1]\n    # return res;\n    return res\n",
            "def flip_case(s: str) -> str:\n    # const flipped: string[] = [];\n    flipped = []\n    # for (const ch of s) {\n    for ch in s:\n        # if (ch.match(/[^a-zA-Z]/)) {\n        if ch.match(r'[^a-zA-Z]'):\n            # flipped.push(ch);\n            flipped.append(ch)\n        # } else if (ch.match(/[a-z]/)) {\n        elif ch.match(r'[a-z]'):\n            # flipped.push(ch.toUpperCase());\n            flipped.append(ch.upper())\n        # } else if (ch.match(/[A-Z]/)) {\n        elif ch.match(r'[A-Z]'):\n            # flipped.push(ch.toLowerCase());\n            flipped.append(ch.lower())\n    # return flipped.join('');\n    return ''.join(flipped)\n",
            "def concatenate(strs: List[str]) -> str:\n    # return strs.join(\"\");\n    return \"\".join(strs)\n",
            "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    # return strs.filter(s => s.startsWith(prefixStr));\n    return list(filter(lambda s: s.startswith(prefix_str), strs))\n",
            "def get_positive(l: List[int]) -> List[int]:\n    # return l.filter(num => num > 0);\n    return list(filter(lambda num: num > 0, l))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def poly(xs: List[float], x: float) -> float:\n    # let res = 0;\n    res = 0\n    # for (let i = 0; i < xs.length; i++) {\n    for i in range(len(xs)):\n        # res += xs[i] * Math.pow(x, i);\n        res += xs[i] * pow(x, i)\n    # return res;\n    return res\ndef find_zero(xs: List[float]) -> float:\n    # let [x1, x2] = [1.0, -1.0];\n    x1, x2 = 1.0, -1.0\n    # while (poly(xs, x1) * poly(xs, x2) > 0) {\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        # x1 *= 2;\n        x1 *= 2\n        # x2 *= 2;\n        x2 *= 2\n    # while (Math.abs(x1 - x2) > 1e-10) {\n    while abs(x1 - x2) > 1e-10:\n        # const mid = (x1 + x2) / 2;\n        mid = (x1 + x2) / 2\n        # if (poly(xs, mid) === 0) {\n        if poly(xs, mid) == 0:\n            # return mid;\n            return mid\n        # else if (poly(xs, mid) * poly(xs, x1) < 0) {\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            # x2 = mid;\n            x2 = mid\n        # else {\n        else:\n            # x1 = mid;\n            x1 = mid\n    # return (x1 + x2) / 2;\n    return (x1 + x2) / 2\n",
            "def sort_third(l: List[int]) -> List[int]:\n    # const sortedThird: Array<number> = l.filter((_, i) => i % 3 === 0).sort((a, b) => a - b);\n    sorted_third = sorted(filter(lambda x, i: i % 3 == 0, l))\n    # return l.map((x, i) => i % 3 === 0 ? sortedThird[i / 3] : x);\n    return [sorted_third[i / 3] if i % 3 == 0 else x for i, x in enumerate(l)]\n",
            "def list_unique(l: List[int]) -> List[int]:\n    # return [... new Set(l)].sort((a, b) => a - b);\n    return sorted(set(l))\n",
            "def max_element(l: List[int]) -> int:\n    # if (l.length === 0) {\n    if len(l) == 0:\n        # return 0;\n        return 0\n    # return Math.max(...l);\n    return max(l)\n",
            "def fizz_buzz(n: int) -> int:\n    # let cnt = 0;\n    cnt = 0\n    # for (let i = 0; i < n; i++) {\n    for i in range(n):\n        # if (i % 11 === 0 || i % 13 === 0) {\n        if i % 11 == 0 or i % 13 == 0:\n            # cnt += String(i).split(\"7\").length - 1;\n            cnt += len(str(i).split(\"7\")) - 1\n    # return cnt;\n    return cnt\n",
            "def sort_even(l: List[int]) -> List[int]:\n    # const sortedEven = l.filter((_, i) => (i & 1) === 0).sort((a, b) => a - b);\n    sorted_even = sorted([x for i, x in enumerate(l) if i & 1 == 0])\n    # return l.map((x, i) => (i & 1) === 0 ? sortedEven[i / 2] : x);\n    return [sorted_even[i / 2] if i & 1 == 0 else x for i, x in enumerate(l)]\n",
            "def encode_cyclic(s: str) -> str:\n    # const result: string[] = [];\n    result = []\n    # for (let i = 0; i < s.length; i += 3) {\n    for i in range(0, len(s), 3):\n        # if (i + 3 > s.length) {\n        if i + 3 > len(s):\n            # result.push(s.slice(i));\n            result.append(s[i:])\n        # } else {\n        else:\n            # result.push(s.slice(i+1, i+3));\n            result.append(s[i+1:i+3])\n            # result.push(s[i]);\n            result.append(s[i])\n    # return result.join(\"\");\n    return \"\".join(result)\ndef decode_cyclic(s: str) -> str:\n    return encode_cyclic(encode_cyclic(s))\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef prime_fib(n: int) -> int:\n    # let f = [0, 1];\n    f = [0, 1]\n    # let cnt = 0;\n    cnt = 0\n    # while (cnt < n) {\n    while cnt < n:\n        # f = [f[1], f[0] + f[1]];\n        f = [f[1], f[0] + f[1]]\n        # if (isPrime(f[1])) {\n        if is_prime(f[1]):\n            # cnt++;\n            cnt += 1\n    # return f[1];\n    return f[1]\n",
            "def triples_sum_to_zero(l: List[int]) -> bool:\n    # for (let i = 0; i < l.length; i++) {\n    for i in range(len(l)):\n        # for (let j = i + 1; j < l.length; j++) {\n        for j in range(i + 1, len(l)):\n            # for (let k = j + 1; k < l.length; k++) {\n            for k in range(j + 1, len(l)):\n                # if (l[i] + l[j] + l[k] === 0) {\n                if l[i] + l[j] + l[k] == 0:\n                    # return true;\n                    return True\n    # return false;\n    return False\n",
            "def car_race_collision(n: int) -> int:\n    # return Math.pow(n, 2);\n    return n ** 2\n",
            "def incr_list(l: List[int]) -> List[int]:\n    # return l.map(i => i + 1);\n    return [i + 1 for i in l]\n",
            "def pairs_sum_to_zero(l: List[int]) -> bool:\n    # const seen: Set<number> = new Set();\n    seen = set()\n    # for (const num of l) {\n    for num in l:\n        # if (seen.has(-num)) {\n        if -num in seen:\n            # return true;\n            return True\n        # seen.add(num);\n        seen.add(num)\n    # return false;\n    return False\n",
            "def change_base(x: int, bas: int) -> str:\n    # if (x === 0) {\n    if x == 0:\n        # return \"0\";\n        return \"0\"\n    # const digits: Array<string> = [];\n    digits = []\n    # while (x > 0) {\n    while x > 0:\n        # digits.push((x % bas).toString());\n        digits.append(str(x % bas))\n        # x = Math.trunc(x / bas);\n        x = x // bas\n    # return digits.reverse().join(\"\");\n    return \"\".join(digits[::-1])\n",
            "def triangle_area(a: float, h: float) -> float:\n    # return a * h / 2;\n    return a * h / 2\n",
            "def fib4(n: int) -> int:\n    # let fib = [0, 0, 2, 0];\n    fib = [0, 0, 2, 0]\n    # for (let i = 4; i <= n; i++) {\n    for i in range(4, n + 1):\n        # fib[i % 4] = fib.reduce((a, b) => a + b);\n        fib[i % 4] = sum(fib)\n    # return fib[n % 4];\n    return fib[n % 4]\n",
            "def median(l: List[int]) -> float:\n    # const sl: Array<number> = [...l].sort((a, b) => a - b);\n    sl = sorted(l)\n    # if (l.length % 2 !== 0) {\n    if len(l) % 2 != 0:\n        # return sl[Math.trunc(l.length / 2)];\n        return sl[len(l) // 2]\n    # else {\n    else:\n        # return (sl[Math.trunc(l.length / 2)] + sl[Math.trunc(l.length / 2) - 1]) / 2;\n        return (sl[len(l) // 2] + sl[len(l) // 2 - 1]) / 2\n",
            "def is_palindrome(txt: str) -> bool:\n    # return txt === txt.split('').reverse().join('');\n    return txt == txt[::-1]\n",
            "def modp(n: int, p: int) -> int:\n    # let ret = 1;\n    ret = 1\n    # for (let i = 0; i < n; i++) {\n    for i in range(n):\n        # ret = (ret * 2) % p;\n        ret = (ret * 2) % p\n    # return ret;\n    return ret\n",
            "def encode_shift(s: str) -> str:\n    # const result: Array<string> = [...s].map(ch => String.fromCharCode((ch.charCodeAt(0) - 97 + 5) % 26 + 97));\n    result = [String.fromCharCode((ch.charCodeAt(0) - 97 + 5) % 26 + 97) for ch in s]\n    # return result.join('');\n    return ''.join(result)\ndef decode_shift(s: str) -> str:\n    # const result: Array<string> = [...s].map(ch => String.fromCharCode((ch.charCodeAt(0) - 97 + 21) % 26 + 97));\n    result = [String.fromCharCode((ch.charCodeAt(0) - 97 + 21) % 26 + 97) for ch in s]\n    # return result.join('');\n    return ''.join(result)\n",
            "def remove_vowels(txt: str) -> str:\n    # const vowels: string = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # return txt.split('').filter(char => !vowels.includes(char)).join('');\n    return ''.join(filter(lambda char: char not in vowels, txt.split('')))\n",
            "def below_threshold(l: List[int], t: int) -> bool:\n    # return l.every(x => x < t);\n    return all(x < t for x in l)\n",
            "def add(x: int, y: int) -> int:\n    # return x + y;\n    return x + y\n",
            "def same_chars(s0: str, s1: str) -> bool:\n    # return _.isEqual(new Set([...s0]), new Set([...s1]));\n    return _.isEqual(set(s0), set(s1))\n",
            "def fib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return n;\n        return n\n    # } else {\n    else:\n        # return fib(n - 1) + fib(n - 2);\n        return fib(n - 1) + fib(n - 2)\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # let depth = 0;\n    depth = 0\n    # for (const b of brackets) {\n    for b in brackets:\n        # if (b == '<') {\n        if b == '<':\n            # depth += 1;\n            depth += 1\n        # } else if (b == '>') {\n        elif b == '>':\n            # depth -= 1;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth == 0;\n    return depth == 0\n",
            "def monotonic(l: List[int]) -> bool:\n    # const diff: Array<number> = l.slice(1).map((x, i) => x - l[i]);\n    diff = [x - l[i] for i, x in enumerate(l[1:])]\n    # return diff.every(x => x <= 0) || diff.every(x => x >= 0);\n    return all(x <= 0 for x in diff) or all(x >= 0 for x in diff)\n",
            "def common(l1: List[int], l2: List[int]) -> List[int]:\n    # return [...new Set(l1)].filter(element => l2.includes(element)).sort();\n    return sorted(set(l1).intersection(l2))\n",
            "def largest_prime_factor(n: int) -> int:\n    # let i = 2;\n    i = 2\n    # while (i * i <= n) {\n    while i * i <= n:\n        # if (n % i) {\n        if n % i:\n            # i += 1;\n            i += 1\n        else:\n            # n /= i;\n            n //= i\n    # return n;\n    return n\n",
            "def sum_to_n(n: int) -> int:\n    # return [...Array(n + 1).keys()].reduce((a, b) => a + b, 0);\n    return sum([*range(n + 1)])\n",
            "def correct_bracketing(brackets: str) -> bool:\n    # let depth = 0;\n    depth = 0\n    # for (const b of brackets) {\n    for b in brackets:\n        # if (b == '(') {\n        if b == '(':\n            # depth += 1;\n            depth += 1\n        # } else if (b == ')') {\n        elif b == ')':\n            # depth -= 1;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth == 0;\n    return depth == 0\n",
            "def derivative(xs: List[int]) -> List[int]:\n    # return xs.map((x, i) => x * i).slice(1);\n    return [x * i for i, x in enumerate(xs)][1:]\n",
            "def fibfib(n: int) -> int:\n    # if (n <= 1) {\n    if n <= 1:\n        # return 0;\n        return 0\n    # let a = 0, b = 0, c = 1;\n    a = 0\n    b = 0\n    c = 1\n    # while (n > 2) {\n    while n > 2:\n        # [a, b, c] = [b, c, a + b + c];\n        a, b, c = b, c, a + b + c\n        # n -= 1;\n        n -= 1\n    # return c;\n    return c\n",
            "def vowels_count(s: str) -> int:\n    # const vowels = \"aeiou\";\n    vowels = \"aeiou\"\n    # let cnt = 0;\n    cnt = 0\n    # for (let i = 0; i < s.length; i++) {\n    for i in range(len(s)):\n        # if (vowels.includes(s[i].toLowerCase()) || (i == s.length - 1 && s[i].toLowerCase() == \"y\")) {\n        if s[i].lower() in vowels or (i == len(s) - 1 and s[i].lower() == \"y\"):\n            # cnt += 1;\n            cnt += 1\n    # return cnt;\n    return cnt\n",
            "def circular_shift(x: int, shift: int) -> str:\n    # const xStr = x.toString();\n    x_str = str(x)\n    # if (shift > xStr.length) {\n    if shift > len(x_str):\n        # return xStr.split(\"\").reverse().join(\"\");\n        return \"\".join(reversed(x_str))\n    # } else {\n    #     return xStr.slice(-shift) + xStr.slice(0, -shift);\n    # }\n    return x_str[-shift:] + x_str[:-shift]\n",
            "def digit_sum(s: str) -> int:\n    # return s.split('').filter(c => c.match(/[A-Z]/)).map(c => c.charCodeAt(0)).reduce((a, b) => a + b, 0);\n    return sum(map(lambda c: ord(c), filter(lambda c: c.isupper(), s.split(''))))\n",
            "def fruit_distribution(s: str, n: int) -> int:\n    # const words = s.split(' ');\n    words = s.split(' ')\n    # const apples = parseInt(words[words.indexOf(\"apples\") - 1]);\n    apples = int(words[words.index(\"apples\") - 1])\n    # const oranges = parseInt(words[words.indexOf(\"oranges\") - 1]);\n    oranges = int(words[words.index(\"oranges\") - 1])\n    # return n - apples - oranges;\n    return n - apples - oranges\n",
            "def pluck(arr: List[int]) -> List[int]:\n    # const evens: Array<number> = arr.filter(n => n % 2 == 0);\n    evens = [n for n in arr if n % 2 == 0]\n    # if (evens.length == 0) {\n    if len(evens) == 0:\n        # return [];\n        return []\n    # const minEven = Math.min(...evens);\n    min_even = min(evens)\n    # return [minEven, arr.indexOf(minEven)];\n    return [min_even, arr.index(min_even)]\n",
            "def search(lst):\n    # const freqs: Map<number, number> = new Map();\n    freqs = {}\n    # for (let n of lst) {\n    for n in lst:\n        # freqs.set(n, (freqs.get(n) || 0) + 1);\n        freqs[n] = freqs.get(n, 0) + 1\n    # const goodVals: Array<number> = [...freqs.entries()].filter(p => p[1] >= p[0]).map(p => p[0]);\n    good_vals = [p[0] for p in freqs.items() if p[1] >= p[0]]\n    # return Math.max(...goodVals, -1);\n    return max(good_vals, default=-1)\n",
            "def strange_sort_list(lst: List[int]) -> List[int]:\n    # const sl: Array<number> = [...lst].sort((a, b) => a - b);\n    sl = sorted(lst)\n    # const result: Array<number> = [];\n    result = []\n    # let start = 0, right = sl.length - 1;\n    start = 0\n    right = len(sl) - 1\n    # while (start <= right) {\n    while start <= right:\n        # result.push(sl[start]);\n        result.append(sl[start])\n        # start += 1;\n        start += 1\n        # if (start <= right) {\n        if start <= right:\n            # result.push(sl[right]);\n            result.append(sl[right])\n            # right -= 1;\n            right -= 1\n    # return result;\n    return result\n",
            "def triangle_area(a: float, b: float, c: float) -> float:\n    # if (a + b > c && a + c > b && b + c > a) {\n    if a + b > c and a + c > b and b + c > a:\n        # const s = (a + b + c) / 2;\n        s = (a + b + c) / 2\n        # return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # else {\n    else:\n        # return -1.0;\n        return -1.0\n",
            "def will_it_fly(q: List[int], w: int) -> bool:\n    # if (q.length == 0) {\n    if len(q) == 0:\n        # return false;\n        return False\n    # const isPalin = Array.from(q.keys()).every(i => q[i] == q[q.length - i - 1]);\n    is_palin = all(q[i] == q[len(q) - i - 1] for i in range(len(q)))\n    # const total = q.reduce((a, b) => a + b);\n    total = sum(q)\n    # return isPalin && total <= w;\n    return is_palin and total <= w\n",
            "def smallest_change(arr: List[int]) -> int:\n    # let ans = 0;\n    ans = 0\n    # for (let i = 0; i < arr.length / 2; i++) {\n    for i in range(len(arr) // 2):\n        # if (arr[i] != arr[arr.length - i - 1]) {\n        if arr[i] != arr[len(arr) - i - 1]:\n            # ans += 1;\n            ans += 1\n    # return ans; \n    return ans\n",
            "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    # const cnt1 = lst1.reduce((a, b) => a + b.length, 0);\n    cnt1 = sum(map(len, lst1))\n    # const cnt2 = lst2.reduce((a, b) => a + b.length, 0);\n    cnt2 = sum(map(len, lst2))\n    # return cnt1 <= cnt2 ? lst1 : lst2;\n    return lst1 if cnt1 <= cnt2 else lst2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    # let cnt = 0;\n    cnt = 0\n    # for (let i = 2; i <= a; i++) {\n    for i in range(2, a + 1):\n        # if (isPrime(i)) {\n        if is_prime(i):\n            # while (a % i === 0) {\n            while a % i == 0:\n                # cnt += 1;\n                cnt += 1\n                # a /= i;\n                a //= i\n    # return cnt === 3;\n    return cnt == 3\n",
            "def is_simple_power(x: int, n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return x === n;\n        return x == n\n    # let tmp = 1;\n    tmp = 1\n    # while (tmp < x) {\n    while tmp < x:\n        # tmp *= n;\n        tmp *= n\n    # return tmp === x;\n    return tmp == x\n",
            "def is_cube(a: int) -> bool:\n    # a = Math.abs(a);\n    a = abs(a)\n    # const root = Math.round(Math.pow(a, 1.0 / 3.0));\n    root = round(pow(a, 1.0 / 3.0))\n    # return root * root * root === a;\n    return root * root * root == a\n",
            "def hex_key(num: str) -> int:\n    # return num.split('').filter((x) => \"2357BD\".includes(x)).length;\n    return len(list(filter(lambda x: x in \"2357BD\", num.split(''))))\n",
            "def decimal_to_binary(dec: int) -> str:\n    # const binary: string = dec.toString(2);\n    binary = bin(dec)\n    # return `db${binary}db`;\n    return f'db{binary}db'\n",
            "def is_happy(s: str) -> bool:\n    # if (s.length < 3) {\n    if len(s) < 3:\n        # return false;\n        return False\n    # for (let i = 0; i < s.length - 2; i++) {\n    for i in range(len(s) - 2):\n        # if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    # const result: Array<string> = [];\n    result = []\n    # for (const g of grades) {\n    for g in grades:\n        # switch (true) {\n        #     case g === 4.0:\n        #         result.push(\"A+\"); break;\n        if g == 4.0:\n            result.append(\"A+\")\n        #     case g > 3.7:\n        #         result.push(\"A\"); break;\n        elif g > 3.7:\n            result.append(\"A\")\n        #     case g > 3.3:\n        #         result.push(\"A-\"); break;\n        elif g > 3.3:\n            result.append(\"A-\")\n        #     case g > 3.0:\n        #         result.push(\"B+\"); break;\n        elif g > 3.0:\n            result.append(\"B+\")\n        #     case g > 2.7:\n        #         result.push(\"B\"); break;\n        elif g > 2.7:\n            result.append(\"B\")\n        #     case g > 2.3:\n        #         result.push(\"B-\"); break;\n        elif g > 2.3:\n            result.append(\"B-\")\n        #     case g > 2.0:\n        #         result.push(\"C+\"); break;\n        elif g > 2.0:\n            result.append(\"C+\")\n        #     case g > 1.7:\n        #         result.push(\"C\"); break;\n        elif g > 1.7:\n            result.append(\"C\")\n        #     case g > 1.3:\n        #         result.push(\"C-\"); break;\n        elif g > 1.3:\n            result.append(\"C-\")\n        #     case g > 1.0:\n        #         result.push(\"D+\"); break;\n        elif g > 1.0:\n            result.append(\"D+\")\n        #     case g > 0.7:\n        #         result.push(\"D\"); break;\n        elif g > 0.7:\n            result.append(\"D\")\n        #     case g > 0.0:\n        #         result.push(\"D-\"); break;\n        elif g > 0.0:\n            result.append(\"D-\")\n        #     default:\n        #         result.push(\"E\"); break;\n        else:\n            result.append(\"E\")\n    # return result;\n    return result\n",
            "def prime_length(s: str) -> bool:\n    # const length: number = s.length;\n    length = len(s)\n    # if (length < 2) {\n    if length < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(length)); i++) {\n    for i in range(2, int(math.floor(math.sqrt(length))) + 1):\n        # if (length % i === 0) {\n        if length % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\n",
            "def starts_one_ends(n: int) -> int:\n    # if (n === 1) {\n    if n == 1:\n        # return 1;\n        return 1\n    # return 2 * 9 * (10 ** (n - 2));\n    return 2 * 9 * (10 ** (n - 2))\n",
            "def solve(n: int) -> str:\n    # const digitsSum = Array.from(String(n), Number).reduce((a, b) => a + b);\n    digits_sum = sum(map(int, str(n)))\n    # return digitsSum.toString(2);\n    return bin(digits_sum)[2:]\n",
            "def add(lst: List[int]) -> int:\n    # return lst.filter((x, i) => i % 2 === 1 && x % 2 === 0).reduce((a, b) => a + b, 0);\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)\n",
            "def anti_shuffle(s: str) -> str:\n    # const words: Array<string> = s.split(' ').map(word => word.split('').sort().join(''));\n    words = [word.split('').sort().join('') for word in s.split(' ')]\n    # return words.join(' ');\n    return ' '.join(words)\n",
            "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    # const coords: Array<Array<number>> = [];\n    coords = []\n    # for (let i = 0; i < lst.length; i++) {\n    for i in range(len(lst)):\n        # for (let j = 0; j < lst[i].length; j++) {\n        for j in range(len(lst[i])):\n            # if (lst[i][j] === x) {\n            if lst[i][j] == x:\n                # coords.push([i, j]);\n                coords.append([i, j])\n    # return coords.sort((a, b) => a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n    return sorted(coords, key=lambda a: a[0] == b[0] and b[1] - a[1] or a[0] - b[0])\n",
            "def sort_array(arr: List[int]) -> List[int]:\n    # const sortedArr: Array<number> = [...arr];\n    sorted_arr = arr.copy()\n    # if (sortedArr.length <= 1) {\n    if len(sorted_arr) <= 1:\n        # return sortedArr;\n        return sorted_arr\n    # if ((sortedArr[0] + sortedArr[sortedArr.length - 1]) % 2 === 0) {\n    if (sorted_arr[0] + sorted_arr[-1]) % 2 == 0:\n        # sortedArr.sort((a, b) => b - a);\n        sorted_arr.sort(key=lambda x: -x)\n    else:\n        # sortedArr.sort((a, b) => a - b);\n        sorted_arr.sort(key=lambda x: x)\n    # return sortedArr;\n    return sorted_arr\n",
            "def encrypt(s):\n    # const result: Array<string> = [];\n    result = []\n    # for (const ch of s) {\n    for ch in s:\n        # let shifted = ch.charCodeAt(0) + 4;\n        shifted = ord(ch) + 4\n        # if (shifted > 'z'.charCodeAt(0)) {\n        if shifted > ord('z'):\n            # shifted -= 26;\n            shifted -= 26\n        # result.push(String.fromCharCode(shifted));\n        result.append(chr(shifted))\n    # return result.join('');\n    return ''.join(result)\n",
            "def next_smallest(lst: List[int]) -> int | None:\n    # const sl: Array<number> = [...new Set(lst)].sort((a, b) => a - b);\n    sl = sorted(set(lst))\n    # if (sl.length < 2) {\n    if len(sl) < 2:\n        # return null;\n        return None\n    # return sl[1];\n    return sl[1]\n",
            "def is_bored(s: str) -> int:\n    # const sentences: Array<string> = s.split(/[.!?]\\s*/);\n    sentences = s.split(r\"[.!?]\\s*\")\n    # return sentences.filter(sentence => sentence.length >= 2 && sentence.slice(0, 2) == \"I \").length;\n    return len([sentence for sentence in sentences if len(sentence) >= 2 and sentence[:2] == \"I \"])\n",
            "def any_int(x: any, y: any, z: any) -> bool:\n    # if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # if (x + y === z || x + z === y || y + z === x) {\n        if x + y == z or x + z == y or y + z == x:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def encode(message: str) -> str:\n    # const vowels: string = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # const result: Array<string> = [];\n    result = []\n    # for (const ch of message) {\n    for ch in message:\n        # if (ch.match(/[a-z]/i)) {\n        if ch.isalpha():\n            # let ch1: string = ch.toUpperCase() === ch ? ch.toLowerCase() : ch.toUpperCase();\n            ch1 = ch.lower() if ch.isupper() else ch.upper()\n            # if (vowels.includes(ch1)) {\n            if ch1 in vowels:\n                # ch1 = String.fromCharCode(ch1.charCodeAt(0) + 2);\n                ch1 = chr(ord(ch1) + 2)\n            # result.push(ch1);\n            result.append(ch1)\n        else:\n            # result.push(ch);\n            result.append(ch)\n    # return result.join(\"\");\n    return \"\".join(result)\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef skjkasdkd(lst: List[int]) -> int:\n    # const primes: Array<number> = lst.filter(n => isPrime(n));\n    primes = [n for n in lst if is_prime(n)]\n    # if (primes.length === 0) {\n    if len(primes) == 0:\n        # return 0;\n        return 0\n    # const largest: string = String(Math.max(...primes));\n    largest = str(max(primes))\n    # return [...largest].map(c => parseInt(c)).reduce((a, b) => a + b);\n    return sum([int(c) for c in largest])\n",
            "def check_dict_case(d: Dict[str, str]) -> bool:\n    # if (d.size === 0) {\n    if len(d) == 0:\n        # return false;\n        return False\n    # return [...d.keys()].every((k) => RegExp('^[A-Z]+$').test(k)) || [...d.keys()].every((k) => RegExp('^[a-z]+$').test(k));\n    return all(RegExp('^[A-Z]+$').test(k) for k in d.keys()) or all(RegExp('^[a-z]+$').test(k) for k in d.keys())\n",
            "def count_up_to(n: int) -> List[int]:\n    # const primes: Array<number> = [];\n    primes = []\n    # for (let num = 2; num < n; num++) {\n    for num in range(2, n):\n        # if (primes.every(p => num % p !== 0)) {\n        if all(num % p !== 0 for p in primes):\n            # primes.push(num);\n            primes.append(num)\n    # return primes;\n    return primes\n",
            "def multiply(a: int, b: int) -> int:\n    # return (Math.abs(a) % 10) * (Math.abs(b) % 10);\n    return abs(a) % 10 * abs(b) % 10\n",
            "def count_upper(s: str) -> int:\n    # const vowels = \"AEIOU\";\n    vowels = \"AEIOU\"\n    # return [...s].filter((c, i) => i % 2 === 0 && vowels.includes(c)).length;\n    return len([c for i, c in enumerate(s) if i % 2 == 0 and c in vowels])\n",
            "def closest_integer(value: str) -> int:\n    # const num: number = parseFloat(value);\n    num = float(value)\n    # if (num >= 0) {\n    if num >= 0:\n        # return Math.trunc(num + 0.5);\n        return int(num + 0.5)\n    # } else {\n    else:\n        # return Math.trunc(num - 0.5);\n        return int(num - 0.5)\n",
            "def make_a_pile(n: int) -> List[int]:\n    # return [...Array(n).keys()].map(i => n + 2 * i);\n    return [n + 2 * i for i in range(n)]\n",
            "def words_string(s: str) -> List[str]:\n    # return s.split(/[ ,]/).filter(w => w.length > 0);\n    return [w for w in s.split() if len(w) > 0]\n",
            "def choose_num(x: int, y: int) -> int:\n    # if (x > y) {\n    if x > y:\n        # return -1;\n        return -1\n    # if (y % 2 == 0) {\n    if y % 2 == 0:\n        # return y;\n        return y\n    # return y != x ? y - 1 : -1;\n    return y - 1 if y != x else -1\n",
            "def rounded_avg(n: int, m: int) -> str | None:\n    # if (n > m) {\n    if n > m:\n        # return null;\n        return None\n    # const rAvg = Math.trunc((n + m) / 2 + 0.5);\n    r_avg = int((n + m) / 2 + 0.5)\n    # return rAvg.toString(2);\n    return r_avg.to_bytes(1, 'big').hex()\n",
            "def all_digits_odd(s: str) -> bool:\n    # return [...s].every(digit => digit.codePointAt(0) % 2 !== 0);\n    return all(digit.codepoint_at(0) % 2 != 0 for digit in s)\ndef unique_digits(x: List[int]) -> List[int]:\n    # return x.filter(num => allDigitsOdd(String(num))).sort((a, b) => a - b);\n    return sorted(filter(lambda num: all_digits_odd(str(num)), x))\n",
            "def by_length(arr: List[int]) -> List[str]:\n    # const digitNames: Array<string> = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    # const sortedArr = arr.filter(x => 1 <= x && x <= 9).sort((a, b) => b - a);\n    sorted_arr = sorted(filter(lambda x: 1 <= x and x <= 9, arr), key=lambda x: -x)\n    # return sortedArr.map(x => digitNames[x - 1]);\n    return [digit_names[x - 1] for x in sorted_arr]\n",
            "def f(n: int) -> List[int]:\n    # const nums: Array<number> = [...Array(n).keys()].map(x => x + 1);\n    nums = [x + 1 for x in range(n)]\n    # return nums.map(i => i % 2 !== 0 ? nums.slice(0, i).reduce((x, y) => x + y) : nums.slice(0, i).reduce((x, y) => x * y));\n    return [i % 2 != 0 ? sum(nums[:i]) : reduce(lambda x, y: x * y, nums[:i]) for i in nums]\n",
            "def is_palindrome(s):\n    # return s === s.split('').reverse().join('');\n    return s == ''.join(reversed(s.split('')))\ndef even_odd_palindrome(n: int):\n    # const cnt = [0, 0];\n    cnt = [0, 0]\n    # for (let i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # if (isPalindrome(i.toString())) {\n        if is_palindrome(str(i)):\n            # cnt[i % 2]++;\n            cnt[i % 2] += 1\n    # return cnt\n    return cnt\n",
            "def digits_sum(n: int) -> int:\n    # const nStr = n.toString();\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return Array.from(nStr, Number).reduce((a, b) => a + b);\n        return sum(map(int, n_str))\n    # } else {\n    else:\n        # return parseInt(nStr.slice(0, 2)) * 2 + digitsSum(Math.abs(n));\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\n# }\ndef count_nums(arr: List[int]) -> int:\n    # return arr.filter(n => digitsSum(n) > 0).length;\n    return len(list(filter(lambda n: digits_sum(n) > 0, arr)))\n",
            "def move_one_ball(arr: List[int]) -> bool:\n    # if (arr.length === 0) {\n    if len(arr) == 0:\n        # return true;\n        return True\n    # const sortedArr: Array<number> = [...arr].sort((a, b) => a - b);\n    sorted_arr = sorted(arr)\n    # for (let i = 0; i < arr.length; i++) {\n    for i in range(len(arr)):\n        # if (_.isEqual(arr.slice(i), sortedArr.slice(0, arr.length - i)) && _.isEqual(arr.slice(0, i), sortedArr.slice(arr.length - i))) {\n        if _.isEqual(arr[i:], sorted_arr[0:len(arr) - i]) and _.isEqual(arr[0:i], sorted_arr[len(arr) - i:]):\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def can_exchange(lst1: List[int], lst2: List[int]) -> str:\n    # const oddCnt = lst1.filter(n => n % 2 !== 0).length;\n    odd_cnt = len([n for n in lst1 if n % 2 != 0])\n    # const evenCnt = lst2.filter(n => n % 2 === 0).length;\n    even_cnt = len([n for n in lst2 if n % 2 == 0])\n    # return evenCnt >= oddCnt ? \"YES\" : \"NO\";\n    return \"YES\" if even_cnt >= odd_cnt else \"NO\"\n",
            "def histogram(test: str) -> Dict[str, int]:\n    # const freq: Map<string, number> = new Map();\n    freq = {}\n    # const words: Array<string> = test.split(\" \").filter(w => w.length > 0);\n    words = [w for w in test.split(\" \") if len(w) > 0]\n    # for (let w of words) {\n    for w in words:\n        # freq.set(w, (freq.get(w) || 0) + 1);\n        freq[w] = freq.get(w, 0) + 1\n    # const result: Map<string, number> = new Map();\n    result = {}\n    # if (freq.size > 0) {\n    if freq:\n        # const maxFreq: number = Math.max(...freq.values());\n        max_freq = max(freq.values())\n        # for (let [k, v] of freq) {\n        for k, v in freq.items():\n            # if (v === maxFreq) {\n            if v == max_freq:\n                # result.set(k, v);\n                result[k] = v\n    # return result;\n    return result\n",
            "def is_palindrome(s):\n    # return s === s.split('').reverse().join('');\n    return s == ''.join(reversed(s.split('')))\ndef reverse_delete(s: str, c: str) -> List[str]:\n    # const s1 = s.split('').filter(ch => !c.includes(ch)).join('');\n    s1 = ''.join(ch for ch in s.split('') if ch not in c)\n    # return [s1, isPalindrome(s1) ? \"yes\" : \"no\"];\n    return [s1, \"yes\" if is_palindrome(s1) else \"no\"]\n",
            "def odd_count(lst: List[str]) -> List[str]:\n    # const result: Array<string> = [];\n    result = []\n    # for (const num of lst) {\n    for num in lst:\n        # const n = [...num].filter(d => d.charCodeAt(0) % 2 == 1).length;\n        n = len([d for d in num if ord(d) % 2 == 1])\n        # const rs = \"the number of odd elements in the string i of the input.\";\n        rs = \"the number of odd elements in the string i of the input.\"\n        # result.push(rs.replaceAll(\"i\", n.toString()));\n        result.append(rs.replace(\"i\", str(n)))\n    # return result;\n    return result\n",
            "def min_sub_array_sum(nums: List[int]) -> int:\n    # let minSum = 0;\n    min_sum = 0\n    # let curSum = 0;\n    cur_sum = 0\n    # for (const n of nums) {\n    for n in nums:\n        # curSum = Math.min(curSum + n, 0);\n        cur_sum = min(cur_sum + n, 0)\n        # minSum = Math.min(curSum, minSum);\n        min_sum = min(cur_sum, min_sum)\n    # if (minSum == 0) {\n    if min_sum == 0:\n        # minSum = Math.min(...nums);\n        min_sum = min(nums)\n    # return minSum;\n    return min_sum\n",
            "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    # return grid.reduce((acc, arr) => acc + Math.ceil(arr.reduce((acc, n) => acc + n, 0) / capacity), 0);\n    return sum(acc + int(ceil(sum(arr) / capacity)) for acc, arr in grid)\n",
            "def count_ones(num: int) -> int:\n    # return num.toString(2).split('1').length - 1;\n    return num.bit_length() - bin(num).count('1')\ndef sort_array(arr: List[int]) -> List[int]:\n    # return [...arr].sort((a, b) => countOnes(a) == countOnes(b) ? a - b : countOnes(a) - countOnes(b));\n    return sorted(arr, key=lambda x: count_ones(x), reverse=True)\n",
            "def select_words(s: str, n: int) -> List[str]:\n    # const consonants = \"bcdfghjklmnpqrstvwxyz\";\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    # const words = s.split(\" \").filter(w => w.length > 0);\n    words = [w for w in s.split(\" \") if len(w) > 0]\n    # return words.filter(w => [...w].filter(c => consonants.includes(c.toLowerCase())).length == n);\n    return [w for w in words if len([c for c in w if c.lower() in consonants]) == n]\n",
            "def get_closest_vowel(word: str) -> str:\n    # const vowels = \"aeiouAEIOU\";\n    vowels = \"aeiouAEIOU\"\n    # for (let i = word.length - 2; i > 0; i--) {\n    for i in range(word.length - 2, 0, -1):\n        # if (vowels.includes(word[i]) && !vowels.includes(word[i - 1]) && !vowels.includes(word[i + 1])) {\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            # return word[i];\n            return word[i]\n    # return \"\";\n    return \"\"\n",
            "def check(s: str) -> bool:\n    # let depth = 0;\n    depth = 0\n    # for (let ch of s) {\n    for ch in s:\n        # if (ch === \"(\") {\n        if ch == \"(\":\n            # depth++;\n            depth += 1\n        # } else {\n        else:\n            # depth--;\n            depth -= 1\n        # if (depth < 0) {\n        if depth < 0:\n            # return false;\n            return False\n    # return depth === 0;\n    return depth == 0\ndef match_parens(lst: List[str]) -> str:\n    # const s1 = lst[0] + lst[1];\n    s1 = lst[0] + lst[1]\n    # const s2 = lst[1] + lst[0];\n    s2 = lst[1] + lst[0]\n    # return check(s1) || check(s2) ? \"Yes\" : \"No\";\n    return \"Yes\" if check(s1) or check(s2) else \"No\"\n",
            "def maximum(arr: List[int], k: int) -> List[int]:\n    # if (k === 0) {\n    if k == 0:\n        # return [];\n        return []\n    # return [...arr].sort((a, b) => a - b).slice(-k);\n    return sorted(arr)[-k:]\n",
            "def solution(lst: List[int]) -> int:\n    # return lst.filter((x, i) => i % 2 === 0 && x % 2 !== 0).reduce((a, b) => a + b, 0);\n    return sum(filter(lambda x: x % 2 != 0 and i % 2 == 0, lst))\n",
            "def add_elements(arr: List[int], k: int) -> int:\n    # return arr.slice(0, k).filter(n => n.toString().length <= 2).reduce((a, b) => a + b, 0);\n    return sum(filter(lambda n: len(str(n)) <= 2, arr[:k]))\n",
            "def get_odd_collatz(n: int) -> List[int]:\n    # const collatz: Array<number> = [1];\n    collatz = [1]\n    # while (n !== 1) {\n    while n != 1:\n        # if (n % 2 !== 0) {\n        if n % 2 != 0:\n            # collatz.push(n);\n            collatz.append(n)\n            # n = 3 * n + 1;\n            n = 3 * n + 1\n        else:\n            # n = n / 2;\n            n = n / 2\n    # return collatz.sort((a, b) => a - b);\n    return sorted(collatz)\n",
            "def valid_date(date: str) -> bool:\n    # if (date.length !== 10 || date[2] !== \"-\" || date[5] !== \"-\") {\n    if len(date) != 10 or date[2] != \"-\" or date[5] != \"-\":\n        # return false;\n        return False\n    # const m = parseInt(date.slice(0, 2));\n    m = int(date[:2])\n    # const d = parseInt(date.slice(3, 5));\n    d = int(date[3:5])\n    # if ([1, 3, 5, 7, 8, 10, 12].includes(m) && d >= 1 && d <= 31) {\n    if m in [1, 3, 5, 7, 8, 10, 12] and 1 <= d <= 31:\n        # return true;\n        return True\n    # if ([4, 6, 9, 11].includes(m) && d >= 1 && d <= 30) {\n    if m in [4, 6, 9, 11] and 1 <= d <= 30:\n        # return true;\n        return True\n    # if (m === 2 && d >= 1 && d <= 29) {\n    if m == 2 and 1 <= d <= 29:\n        # return true;\n        return True\n    # return false;\n    return False\n",
            "def split_words(txt: str) -> List[str]:\n    # if (txt.includes(\" \")) {\n    if \" \" in txt:\n        # return txt.split(\" \");\n        return txt.split(\" \")\n    # } else if (txt.includes(\",\")) {\n    elif \",\" in txt:\n        # return txt.split(\",\");\n        return txt.split(\",\")\n    # } else {\n    else:\n        # return [[...txt].filter(c => /[a-z]/.test(c) && c.charCodeAt(0) % 2 === 0).length.toString()];\n        return [str(len([c for c in txt if c.isalpha() and ord(c) % 2 == 0]))]\n    # }\n",
            "def is_sorted(lst: List[int]) -> bool:\n    # if (!lst.slice(1).map((n, i) => lst[i] <= n).every(a => a)) {\n    if not lst[1:].map(lambda n, i: lst[i] <= n).every(lambda a: a):\n        # return false;\n        return False\n    # const freq: Map<number, number> = new Map();\n    freq = {}\n    # for (const i of lst) {\n    for i in lst:\n        # freq.set(i, (freq.get(i) || 0) + 1);\n        freq[i] = freq.get(i, 0) + 1\n    # return Math.max(...freq.values()) <= 2;\n    return max(freq.values()) <= 2\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef intersection(interval1: List[int], interval2: List[int]) -> str:\n    # const l = Math.max(interval1[0], interval2[0]);\n    l = max(interval1[0], interval2[0])\n    # const r = Math.min(interval1[1], interval2[1]);\n    r = min(interval1[1], interval2[1])\n    # const length = r - l;\n    length = r - l\n    # return length > 0 && isPrime(length) ? \"YES\" : \"NO\";\n    return \"YES\" if length > 0 and is_prime(length) else \"NO\"\n",
            "def prod_signs(arr: List[int]) -> Optional[int]:\n    # if (arr.length === 0) {\n    if len(arr) == 0:\n        # return null;\n        return None\n    # if (arr.includes(0)) {\n    if 0 in arr:\n        # return 0;\n        return 0\n    # const sign = arr.filter(n => n < 0).length % 2 === 1 ? -1 : 1;\n    sign = -1 if len(list(filter(lambda n: n < 0, arr))) % 2 == 1 else 1\n    # return sign * arr.map(n => Math.abs(n)).reduce((a, b) => a + b);\n    return sign * sum(map(lambda n: abs(n), arr))\n",
            "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    # const n = grid.length;\n    n = len(grid)\n    # let minVal = n * n + 1;\n    min_val = n * n + 1\n    # for (let i = 0; i < n; i++) {\n    for i in range(n):\n        # for (let j = 0; j < n; j++) {\n        for j in range(n):\n            # if (grid[i][j] === 1) {\n            if grid[i][j] == 1:\n                # const temp: Array<number> = [];\n                temp = []\n                # if (i !== 0) {\n                if i != 0:\n                    # temp.push(grid[i - 1][j]);\n                    temp.append(grid[i - 1][j])\n                # if (j !== 0) {\n                if j != 0:\n                    # temp.push(grid[i][j - 1]);\n                    temp.append(grid[i][j - 1])\n                # if (i !== n - 1) {\n                if i != n - 1:\n                    # temp.push(grid[i + 1][j]);\n                    temp.append(grid[i + 1][j])\n                # if (j !== n - 1) {\n                if j != n - 1:\n                    # temp.push(grid[i][j + 1]);\n                    temp.append(grid[i][j + 1])\n                # minVal = Math.min(...temp);\n                min_val = min(temp)\n    # const result: Array<number> = [];\n    result = []\n    # for (let i = 0; i < k; i++) {\n    for i in range(k):\n        # result.push(i % 2 === 0 ? 1 : minVal);\n        result.append(1 if i % 2 == 0 else min_val)\n    # return result;\n    return result\n",
            "def tri(n: int) -> List[int]:\n    # if (n === 0) {\n    if n == 0:\n        # return [1];\n        return [1]\n    # const seq: Array<number> = [1, 3];\n    seq = [1, 3]\n    # for (let i = 2; i <= n; i++) {\n    for i in range(2, n + 1):\n        # if (i % 2 === 0) {\n        if i % 2 == 0:\n            # seq.push(i / 2 + 1);\n            seq.append(i // 2 + 1)\n        # } else {\n        else:\n            # seq.push(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n    # return seq;\n    return seq\n",
            "def digits(n: int) -> int:\n    # const odds: Array<number> = [...n.toString()].filter(d => parseInt(d) % 2 === 1).map(d => parseInt(d));\n    odds = [int(d) for d in str(n) if int(d) % 2 == 1]\n    # return odds.length > 0 ? odds.reduce((a, b) => a * b) : 0;\n    return reduce(lambda a, b: a * b, odds) if odds else 0\n",
            "def is_nested(s: str) -> bool:\n    # const openIdx: Array<number> = [];\n    open_idx = []\n    # const closeIdx: Array<number> = [];\n    close_idx = []\n    # for (let [i, ch] of [...s].entries()) {\n    for i, ch in enumerate([*s]):\n        # switch (ch) {\n        #     case '[':\n        #         openIdx.push(i); break;\n        #     case ']':\n        #         closeIdx.push(i); break;\n        # }\n        if ch == '[':\n            open_idx.append(i)\n        elif ch == ']':\n            close_idx.append(i)\n    # closeIdx.reverse();\n    close_idx.reverse()\n    # let cnt = 0;\n    cnt = 0\n    # let i = 0;\n    i = 0\n    # const l = closeIdx.length;\n    l = len(close_idx)\n    # for (let idx of openIdx) {\n    for idx in open_idx:\n        # if (i < l && idx < closeIdx[i]) {\n        #     cnt += 1;\n        #     i += 1;\n        # }\n        if i < l and idx < close_idx[i]:\n            cnt += 1\n            i += 1\n    # return cnt >= 2;\n    return cnt >= 2\n",
            "def sum_squares(lst: List[int]) -> int:\n    # return lst.map(n => Math.pow(Math.ceil(n), 2)).reduce((a, b) => a + b, 0);\n    return sum(map(lambda n: pow(math.ceil(n), 2), lst))\n",
            "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    # if (!txt) {\n    if not txt:\n        # return false;\n        return False\n    # const last = txt.substring(txt.lastIndexOf(\" \") + 1);\n    last = txt[txt.rfind(\" \") + 1:]\n    # return last.length === 1 && /[a-z]/i.test(last[0]);\n    return len(last) == 1 and bool(re.match(r\"[a-z]\", last[0], re.IGNORECASE))\n",
            "def can_arrange(arr: List[int]) -> int:\n    # if (arr.length <= 1) {\n    if len(arr) <= 1:\n        # return -1;\n        return -1\n    # const idx: Array<number> = [...Array(arr.length).keys()].slice(1).filter(i => arr[i] < arr[i - 1])\n    idx = [i for i in range(1, len(arr)) if arr[i] < arr[i - 1]]\n    # return Math.max(...idx, -1);\n    return max(idx, default=-1)\n",
            "def largest_smallest_integers(lst: List[int]) -> List[int | None]:\n    # const neg: Array<number>  = lst.filter(i => i < 0);\n    neg = list(filter(lambda i: i < 0, lst))\n    # const pos: Array<number>  = lst.filter(i => i > 0);\n    pos = list(filter(lambda i: i > 0, lst))\n    # const maxNeg = neg.length > 0 ? Math.max(...neg) : null;\n    max_neg = max(neg) if len(neg) > 0 else None\n    # const minPos = pos.length > 0 ? Math.min(...pos) : null;\n    min_pos = min(pos) if len(pos) > 0 else None\n    # return [maxNeg, minPos];\n    return [max_neg, min_pos]\n",
            "def any_to_real(o: Any) -> float:\n    # if (typeof o === 'string') {\n    if isinstance(o, str):\n        # return parseFloat(o.replace(',', '.'));\n        return float(o.replace(',', '.'))\n    # } else if (typeof o === 'number') {\n    elif isinstance(o, (int, float)):\n        # return o;\n        return o\n    # }\n    # throw new Error('Type Error');\n    raise TypeError('Type Error')\ndef compare_one(a: Any, b: Any) -> float | None:\n    # let a1 = anyToReal(a);\n    a1 = any_to_real(a)\n    # let b1 = anyToReal(b);\n    b1 = any_to_real(b)\n    # if (a1 === b1) {\n    if a1 == b1:\n        # return null;\n        return None\n    # } else if (a1 > b1) {\n    elif a1 > b1:\n        # return a1;\n        return a1\n    # } else {\n    else:\n        # return b1;\n        return b1\n    # }\n",
            "def is_equal_to_sum_even(n: int) -> bool:\n    # return n % 2 === 0 && n >= 8;\n    return n % 2 == 0 and n >= 8\n",
            "def special_factorial(n: int) -> int:\n    # let fact = 1;\n    fact = 1\n    # let result = 1;\n    result = 1\n    # for (let i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # fact *= i;\n        fact *= i\n        # result *= fact;\n        result *= fact\n    # return result;\n    return result\n",
            "def fix_spaces(txt: str) -> str:\n    # return txt.replace(/\\s{3,}/g, \"-\").replace(/\\s/g, \"_\");\n    return txt.replace(\"   \", \"-\").replace(\" \", \"_\")\n",
            "def file_name_check(file_name: str) -> str:\n    # const suf: Array<string> = [\"txt\", \"exe\", \"dll\"];\n    suf = [\"txt\", \"exe\", \"dll\"]\n    # const lst: Array<string> = fileName.split('.');\n    lst = file_name.split('.')\n    # if (lst.length !== 2 || !suf.includes(lst[1]) || lst[0].length === 0 || !lst[0][0].match(/[a-z]/i) || [...lst[0]].filter(ch => ch.match(/\\d/)).length > 3) {\n    if len(lst) != 2 or lst[1] not in suf or len(lst[0]) == 0 or lst[0][0].isdigit() or len([ch for ch in lst[0] if ch.isdigit()]) > 3:\n        # return \"No\";\n        return \"No\"\n    # return \"Yes\";\n    return \"Yes\"\n",
            "def sum_squares(lst: List[int]) -> int:\n    # let result = 0;\n    result = 0\n    # for (let i = 0; i < lst.length; i++) {\n    for i in range(len(lst)):\n        # if (i % 3 === 0) {\n        if i % 3 == 0:\n            # result += Math.pow(lst[i], 2);\n            result += pow(lst[i], 2)\n        # } else if (i % 4 === 0) {\n        elif i % 4 == 0:\n            # result += Math.pow(lst[i], 3);\n            result += pow(lst[i], 3)\n        # } else {\n        else:\n            # result += lst[i];\n            result += lst[i]\n    # return result;\n    return result\n",
            "def is_prime(n: int) -> bool:\n    # if (n < 2) {\n    if n < 2:\n        # return false;\n        return False\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(n ** 0.5) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return false;\n            return False\n    # return true;\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    # const words = sentence.split(\" \");\n    words = sentence.split(\" \")\n    # return words.filter(w => isPrime(w.length)).join(\" \");\n    return \" \".join(filter(lambda w: is_prime(len(w)), words))\n",
            "def simplify(x: str, n: str) -> bool:\n    # const xs = x.split('/');\n    xs = x.split('/')\n    # const ns = n.split('/');\n    ns = n.split('/')\n    # const num = parseInt(xs[0]) * parseInt(ns[0]);\n    num = int(xs[0]) * int(ns[0])\n    # const den = parseInt(xs[1]) * parseInt(ns[1]);\n    den = int(xs[1]) * int(ns[1])\n    # return num % den === 0;\n    return num % den == 0\n",
            "def digits_sum(n: int) -> int:\n    # const nStr = n.toString();\n    n_str = str(n)\n    # if (n >= 0) {\n    if n >= 0:\n        # return Array.from(nStr, Number).reduce((a, b) => a + b);\n        return sum(map(int, n_str))\n    else:\n        # return parseInt(nStr.slice(0, 2)) * 2 + digitsSum(Math.abs(n));\n        return int(n_str[:2]) * 2 + digits_sum(abs(n))\ndef order_by_points(nums: List[int]) -> List[int]:\n    # return [...nums].sort((a, b) => digitsSum(a) - digitsSum(b));\n    return sorted(nums, key=lambda x: digits_sum(x))\n",
            "def special_filter(nums: List[int]) -> int:\n    # const odds = \"13579\";\n    odds = \"13579\"\n    # return nums.filter(n => n > 10 && n % 2 === 1 && odds.includes(n.toString()[0])).length;\n    return len([n for n in nums if n > 10 and n % 2 == 1 and odds[0] in str(n)])\n",
            "def get_max_triples(n: int) -> int:\n    # const c: Array<number> = [0, 0, 0];\n    c = [0, 0, 0]\n    # for (let i = 1; i <= n; i++) {\n    for i in range(1, n + 1):\n        # const a = i * i - i + 1;\n        a = i * i - i + 1\n        # c[a % 3]++;\n        c[a % 3] += 1\n    # return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6;\n    return c[0] * c[1] * c[2] + (c[0] * (c[0] - 1) * (c[0] - 2) + c[1] * (c[1] - 1) * (c[1] - 2) + c[2] * (c[2] - 1) * (c[2] - 2)) / 6\n",
            "def bf(planet1: str, planet2: str) -> List[str]:\n    # const names: Array<string> = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    # if (!names.includes(planet1) || !names.includes(planet2)) {\n    if planet1 not in names or planet2 not in names:\n        # return [];\n        return []\n    # let l = names.indexOf(planet1);\n    l = names.index(planet1)\n    # let r = names.indexOf(planet2);\n    r = names.index(planet2)\n    # if (l > r) {\n    if l > r:\n        # [l, r] = [r, l];\n        l, r = r, l\n    # if (l === r) {\n    if l == r:\n        # return [];\n        return []\n    # return names.slice(l + 1, r);\n    return names[l + 1:r]\n",
            "def sorted_list_sum(lst: List[str]) -> List[str]:\n    # const result = lst.filter(s => s.length % 2 === 0);\n    result = [s for s in lst if len(s) % 2 == 0]\n    # return result.sort((a, b) => {\n    #     if (a.length === b.length) {\n    #         return a.localeCompare(b, undefined, { sensitivity: 'base' });\n    #     }\n    #     return a.length - b.length;\n    # });\n    return sorted(result, key=lambda a, b: a.length - b.length if a.length == b.length else a.localeCompare(b, undefined, { 'sensitivity': 'base' }))\n",
            "def x_or_y(n: int, x: int, y: int) -> int:\n    # if (n < 2) {\n    if n < 2:\n        # return y;\n        return y\n    # for (let i = 2; i <= Math.floor(Math.sqrt(n)); i++) {\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # if (n % i === 0) {\n        if n % i == 0:\n            # return y;\n            return y\n    # return x;\n    return x\n",
            "def double_the_difference(lst: List[int]) -> int:\n    # return lst.filter(n => n >= 0 && n % 2 === 1).reduce((a, b) => a + b * b, 0);\n    return sum(n * n for n in lst if n >= 0 and n % 2 == 1)\n",
            "def compare(game: List[int], guess: List[int]) -> List[int]:\n    # return game.map((x, i) => Math.abs(x - guess[i]));\n    return [abs(x - guess[i]) for x in game]\n",
            "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    # let maxS = Number.MIN_SAFE_INTEGER;\n    max_s = float('-inf')\n    # let maxExt = \"\";\n    max_ext = \"\"\n    # for (const ext of extensions) {\n    for ext in extensions:\n        # const upper = [...ext].filter(c => c.toUpperCase() === c).length;\n        upper = sum(1 for c in ext if c.isupper())\n        # const lower = [...ext].filter(c => c.toLowerCase() === c).length;\n        lower = sum(1 for c in ext if c.islower())\n        # const s = upper - lower;\n        s = upper - lower\n        # if (s > maxS) {\n        if s > max_s:\n            # maxS = s;\n            max_s = s\n            # maxExt = ext;\n            max_ext = ext\n    # return `${className}.${maxExt}`;\n    return f\"{class_name}.{max_ext}\"\n",
            "def cycpattern_check(a: str, b: str) -> bool:\n    # if (a.length < b.length) {\n    if len(a) < len(b):\n        # return false;\n        return False\n    # for (let i = 0; i < b.length; i++) {\n    for i in range(len(b)):\n        # if (a.includes(b.slice(i) + b.slice(0, i))) {\n        if b[i:] + b[:i] in a:\n            # return true;\n            return True\n    # return false;\n    return False\n",
            "def even_odd_count(num: int) -> List[int]:\n    # const ds = Math.abs(num).toString();\n    ds = str(abs(num))\n    # const even = [...ds].filter(d => d.codePointAt(0) % 2 === 0).length;\n    even = len([d for d in ds if ord(d) % 2 == 0])\n    # return [even, ds.length - even];\n    return [even, len(ds) - even]\n",
            "def int_to_mini_roman(num: int) -> str:\n    # const values: Array<number> = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1];\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9 , 5, 4, 1]\n    # const numerals: Array<string> = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\" , \"v\", \"iv\", \"i\"];\n    numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\" , \"v\", \"iv\", \"i\"]\n    # let res: Array<string> = [];\n    res = []\n    # for (let i = 0; i < values.length; i++) {\n    for i in range(len(values)):\n        # while (num >= values[i]) {\n        while num >= values[i]:\n            # res.push(numerals[i]);\n            res.append(numerals[i])\n            # num -= values[i];\n            num -= values[i]\n    # return res.join(\"\");\n    return \"\".join(res)\n",
            "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    # const s = [a, b, c].sort((a, b) => a - b);\n    s = sorted([a, b, c])\n    # return s[0] * s[0] + s[1] * s[1] === s[2] * s[2];\n    return s[0] * s[0] + s[1] * s[1] == s[2] * s[2]\n",
            "def find_max(words: List[str]) -> str:\n    # let maxCnt = 0;\n    max_cnt = 0\n    # let maxW = \"\";\n    max_w = \"\"\n    # for (let w of words) {\n    for w in words:\n        # let cnt = new Set(w).size;\n        cnt = len(set(w))\n        # if (cnt > maxCnt) {\n        if cnt > max_cnt:\n            # maxCnt = cnt;\n            max_cnt = cnt\n            # maxW = w;\n            max_w = w\n        # } else if (cnt === maxCnt) {\n        elif cnt == max_cnt:\n            # maxW = maxW < w ? maxW : w;\n            max_w = max_w if max_w < w else w\n    # return maxW;\n    return max_w\n",
            "def eat(num: int, need: int, remaining: int) -> List[int]:\n    # if (need <= remaining) {\n    if need <= remaining:\n        # return [num + need, remaining - need];\n        return [num + need, remaining - need]\n    # } else {\n    else:\n        # return [num + remaining, 0];\n        return [num + remaining, 0]\n",
            "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    # const ops: Array<string> = [...operators];\n    ops = list(operators)\n    # const nums: Array<number> = [...operands];\n    nums = list(operands)\n    # let i = ops.length - 1;\n    i = len(ops) - 1\n    # while (i >= 0) {\n    while i >= 0:\n        # if (ops[i] === \"**\") {\n        if ops[i] == \"**\":\n            # nums[i] = Math.pow(nums[i], nums[i + 1]);\n            nums[i] = pow(nums[i], nums[i + 1])\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n        # i -= 1;\n        i -= 1\n    # i = 0;\n    i = 0\n    # while (i < ops.length) {\n    while i < len(ops):\n        # if (ops[i] === \"*\") {\n        if ops[i] == \"*\":\n            # nums[i] = nums[i] * nums[i + 1];\n            nums[i] = nums[i] * nums[i + 1]\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if (ops[i] === \"//\") {\n        elif ops[i] == \"//\":\n            # nums[i] = Math.trunc(nums[i] / nums[i + 1]);\n            nums[i] = int(nums[i] / nums[i + 1])\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # i = 0;\n    i = 0\n    # while (i < ops.length) {\n    while i < len(ops):\n        # if (ops[i] === \"+\") {\n        if ops[i] == \"+\":\n            # nums[i] = nums[i] + nums[i + 1];\n            nums[i] = nums[i] + nums[i + 1]\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # } else if (ops[i] === \"-\") {\n        elif ops[i] == \"-\":\n            # nums[i] = nums[i] - nums[i + 1];\n            nums[i] = nums[i] - nums[i + 1]\n            # nums.splice(i + 1, 1);\n            nums.pop(i + 1)\n            # ops.splice(i, 1);\n            ops.pop(i)\n            # i -= 1;\n            i -= 1\n        # i += 1;\n        i += 1\n    # return nums[0];\n    return nums[0]\n",
            "def solve(s: str) -> str:\n    # if (![...s].some(ch => ch.match(/[a-zA-Z]/))) {\n    if not any(ch.match(/[a-zA-Z]/) for ch in s):\n        # return s.split('').reverse().join('');\n        return ''.join(reversed(s.split('')))\n    # let result: string[] = [];\n    result = []\n    # for (const ch of s) {\n    for ch in s:\n        # if (!ch.match(/[a-zA-Z]/)) {\n        if not ch.match(/[a-zA-Z]/):\n            # result.push(ch);\n            result.append(ch)\n        # else if (ch.match(/[A-Z]/)) {\n        elif ch.match(/[A-Z]/):\n            # result.push(ch.toLowerCase());\n            result.append(ch.lower())\n        # else if (ch.match(/[a-z]/)) {\n        elif ch.match(/[a-z]/):\n            # result.push(ch.toUpperCase());\n            result.append(ch.upper())\n    # return result.join('');\n    return ''.join(result)\n",
            "def string_to_md5(txt: str) -> str | None:\n    # if (!txt) {\n    if not txt:\n        # return null;\n        return None\n    # const md5Hash = crypto.createHash('md5');\n    md5_hash = hashlib.md5()\n    # const txtBytes = Buffer.from(txt);\n    txt_bytes = txt.encode()\n    # md5Hash.update(txtBytes);\n    md5_hash.update(txt_bytes)\n    # const md5Encoded = md5Hash.digest('hex');\n    md5_encoded = md5_hash.hexdigest()\n    # return md5Encoded;\n    return md5_encoded\n",
            "def generate_integers(a: int, b: int) -> List[int]:\n    # const lower: number = Math.max(2, Math.min(a, b));\n    lower = max(2, min(a, b))\n    # const upper: number = Math.min(8, Math.max(a, b));\n    upper = min(8, max(a, b))\n    # if (lower > upper) {\n    if lower > upper:\n        # return [];\n        return []\n    # return Array.from({ length: upper - lower + 1}, (_, i) => i + lower).filter(n => n % 2 === 0);\n    return [i + lower for i in range(upper - lower + 1) if i % 2 == 0]\n"
        ]
    }
}